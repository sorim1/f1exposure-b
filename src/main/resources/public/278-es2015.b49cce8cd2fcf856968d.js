(self["webpackChunkpaper_dashboard_angular"] = self["webpackChunkpaper_dashboard_angular"] || []).push([[278],{

/***/ 6278:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AdminLayoutModule": function() { return /* binding */ AdminLayoutModule; }
});

// EXTERNAL MODULE: ./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js + 7 modules
var router = __webpack_require__(4655);
// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js
var common = __webpack_require__(8583);
// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js
var fesm2015_forms = __webpack_require__(3679);
// EXTERNAL MODULE: ./src/app/utility/rest.service.ts
var rest_service = __webpack_require__(7043);
// EXTERNAL MODULE: ./src/app/utility/utility.service.ts
var utility_service = __webpack_require__(2038);
// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js
var core = __webpack_require__(7716);
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sidenav.js + 1 modules
var sidenav = __webpack_require__(3017);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js
var platform = __webpack_require__(521);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js
var coercion = __webpack_require__(9490);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var empty = __webpack_require__(9193);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js + 1 modules
var auditTime = __webpack_require__(13);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(6782);
;// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/text-field.js









/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Options to pass to the animationstart listener. */


const listenerOptions = (0,platform/* normalizePassiveListenerOptions */.i$)({ passive: true });
/**
 * An injectable service that can be used to monitor the autofill state of an input.
 * Based on the following blog post:
 * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7
 */
class AutofillMonitor {
    constructor(_platform, _ngZone) {
        this._platform = _platform;
        this._ngZone = _ngZone;
        this._monitoredElements = new Map();
    }
    monitor(elementOrRef) {
        if (!this._platform.isBrowser) {
            return empty/* EMPTY */.E;
        }
        const element = (0,coercion/* coerceElement */.fI)(elementOrRef);
        const info = this._monitoredElements.get(element);
        if (info) {
            return info.subject;
        }
        const result = new Subject/* Subject */.xQ();
        const cssClass = 'cdk-text-field-autofilled';
        const listener = ((event) => {
            // Animation events fire on initial element render, we check for the presence of the autofill
            // CSS class to make sure this is a real change in state, not just the initial render before
            // we fire off events.
            if (event.animationName === 'cdk-text-field-autofill-start' &&
                !element.classList.contains(cssClass)) {
                element.classList.add(cssClass);
                this._ngZone.run(() => result.next({ target: event.target, isAutofilled: true }));
            }
            else if (event.animationName === 'cdk-text-field-autofill-end' &&
                element.classList.contains(cssClass)) {
                element.classList.remove(cssClass);
                this._ngZone.run(() => result.next({ target: event.target, isAutofilled: false }));
            }
        });
        this._ngZone.runOutsideAngular(() => {
            element.addEventListener('animationstart', listener, listenerOptions);
            element.classList.add('cdk-text-field-autofill-monitored');
        });
        this._monitoredElements.set(element, {
            subject: result,
            unlisten: () => {
                element.removeEventListener('animationstart', listener, listenerOptions);
            }
        });
        return result;
    }
    stopMonitoring(elementOrRef) {
        const element = (0,coercion/* coerceElement */.fI)(elementOrRef);
        const info = this._monitoredElements.get(element);
        if (info) {
            info.unlisten();
            info.subject.complete();
            element.classList.remove('cdk-text-field-autofill-monitored');
            element.classList.remove('cdk-text-field-autofilled');
            this._monitoredElements.delete(element);
        }
    }
    ngOnDestroy() {
        this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));
    }
}
AutofillMonitor.ɵfac = function AutofillMonitor_Factory(t) { return new (t || AutofillMonitor)(core/* ɵɵinject */.LFG(platform/* Platform */.t4), core/* ɵɵinject */.LFG(core/* NgZone */.R0b)); };
AutofillMonitor.ɵprov = core/* ɵɵdefineInjectable */.Yz7({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(core/* ɵɵinject */.LFG(platform/* Platform */.t4), core/* ɵɵinject */.LFG(core/* NgZone */.R0b)); }, token: AutofillMonitor, providedIn: "root" });
AutofillMonitor.ctorParameters = () => [
    { type: platform/* Platform */.t4 },
    { type: core/* NgZone */.R0b }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(AutofillMonitor, [{
        type: core/* Injectable */.GSi,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: platform/* Platform */.t4 }, { type: core/* NgZone */.R0b }]; }, null); })();
/** A directive that can be used to monitor the autofill state of an input. */
class CdkAutofill {
    constructor(_elementRef, _autofillMonitor) {
        this._elementRef = _elementRef;
        this._autofillMonitor = _autofillMonitor;
        /** Emits when the autofill state of the element changes. */
        this.cdkAutofill = new core/* EventEmitter */.vpe();
    }
    ngOnInit() {
        this._autofillMonitor
            .monitor(this._elementRef)
            .subscribe(event => this.cdkAutofill.emit(event));
    }
    ngOnDestroy() {
        this._autofillMonitor.stopMonitoring(this._elementRef);
    }
}
CdkAutofill.ɵfac = function CdkAutofill_Factory(t) { return new (t || CdkAutofill)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(AutofillMonitor)); };
CdkAutofill.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: CdkAutofill, selectors: [["", "cdkAutofill", ""]], outputs: { cdkAutofill: "cdkAutofill" } });
CdkAutofill.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: AutofillMonitor }
];
CdkAutofill.propDecorators = {
    cdkAutofill: [{ type: core/* Output */.r_U }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(CdkAutofill, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[cdkAutofill]'
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: AutofillMonitor }]; }, { cdkAutofill: [{
            type: core/* Output */.r_U
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Directive to automatically resize a textarea to fit its content. */
class CdkTextareaAutosize {
    constructor(_elementRef, _platform, _ngZone, 
    /** @breaking-change 11.0.0 make document required */
    document) {
        this._elementRef = _elementRef;
        this._platform = _platform;
        this._ngZone = _ngZone;
        this._destroyed = new Subject/* Subject */.xQ();
        this._enabled = true;
        /**
         * Value of minRows as of last resize. If the minRows has decreased, the
         * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight
         * does not have the same problem because it does not affect the textarea's scrollHeight.
         */
        this._previousMinRows = -1;
        this._isViewInited = false;
        this._document = document;
        this._textareaElement = this._elementRef.nativeElement;
        this._measuringClass = _platform.FIREFOX ?
            'cdk-textarea-autosize-measuring-firefox' :
            'cdk-textarea-autosize-measuring';
    }
    /** Minimum amount of rows in the textarea. */
    get minRows() { return this._minRows; }
    set minRows(value) {
        this._minRows = (0,coercion/* coerceNumberProperty */.su)(value);
        this._setMinHeight();
    }
    /** Maximum amount of rows in the textarea. */
    get maxRows() { return this._maxRows; }
    set maxRows(value) {
        this._maxRows = (0,coercion/* coerceNumberProperty */.su)(value);
        this._setMaxHeight();
    }
    /** Whether autosizing is enabled or not */
    get enabled() { return this._enabled; }
    set enabled(value) {
        value = (0,coercion/* coerceBooleanProperty */.Ig)(value);
        // Only act if the actual value changed. This specifically helps to not run
        // resizeToFitContent too early (i.e. before ngAfterViewInit)
        if (this._enabled !== value) {
            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();
        }
    }
    get placeholder() { return this._textareaElement.placeholder; }
    set placeholder(value) {
        this._cachedPlaceholderHeight = undefined;
        this._textareaElement.placeholder = value;
        this._cacheTextareaPlaceholderHeight();
    }
    /** Sets the minimum height of the textarea as determined by minRows. */
    _setMinHeight() {
        const minHeight = this.minRows && this._cachedLineHeight ?
            `${this.minRows * this._cachedLineHeight}px` : null;
        if (minHeight) {
            this._textareaElement.style.minHeight = minHeight;
        }
    }
    /** Sets the maximum height of the textarea as determined by maxRows. */
    _setMaxHeight() {
        const maxHeight = this.maxRows && this._cachedLineHeight ?
            `${this.maxRows * this._cachedLineHeight}px` : null;
        if (maxHeight) {
            this._textareaElement.style.maxHeight = maxHeight;
        }
    }
    ngAfterViewInit() {
        if (this._platform.isBrowser) {
            // Remember the height which we started with in case autosizing is disabled
            this._initialHeight = this._textareaElement.style.height;
            this.resizeToFitContent();
            this._ngZone.runOutsideAngular(() => {
                const window = this._getWindow();
                (0,fromEvent/* fromEvent */.R)(window, 'resize')
                    .pipe((0,auditTime/* auditTime */.e)(16), (0,takeUntil/* takeUntil */.R)(this._destroyed))
                    .subscribe(() => this.resizeToFitContent(true));
            });
            this._isViewInited = true;
            this.resizeToFitContent(true);
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * Cache the height of a single-row textarea if it has not already been cached.
     *
     * We need to know how large a single "row" of a textarea is in order to apply minRows and
     * maxRows. For the initial version, we will assume that the height of a single line in the
     * textarea does not ever change.
     */
    _cacheTextareaLineHeight() {
        if (this._cachedLineHeight) {
            return;
        }
        // Use a clone element because we have to override some styles.
        let textareaClone = this._textareaElement.cloneNode(false);
        textareaClone.rows = 1;
        // Use `position: absolute` so that this doesn't cause a browser layout and use
        // `visibility: hidden` so that nothing is rendered. Clear any other styles that
        // would affect the height.
        textareaClone.style.position = 'absolute';
        textareaClone.style.visibility = 'hidden';
        textareaClone.style.border = 'none';
        textareaClone.style.padding = '0';
        textareaClone.style.height = '';
        textareaClone.style.minHeight = '';
        textareaClone.style.maxHeight = '';
        // In Firefox it happens that textarea elements are always bigger than the specified amount
        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
        // As a workaround that removes the extra space for the scrollbar, we can just set overflow
        // to hidden. This ensures that there is no invalid calculation of the line height.
        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
        textareaClone.style.overflow = 'hidden';
        this._textareaElement.parentNode.appendChild(textareaClone);
        this._cachedLineHeight = textareaClone.clientHeight;
        this._textareaElement.parentNode.removeChild(textareaClone);
        // Min and max heights have to be re-calculated if the cached line height changes
        this._setMinHeight();
        this._setMaxHeight();
    }
    _measureScrollHeight() {
        // Reset the textarea height to auto in order to shrink back to its default size.
        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
        this._textareaElement.classList.add(this._measuringClass);
        // The measuring class includes a 2px padding to workaround an issue with Chrome,
        // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).
        const scrollHeight = this._textareaElement.scrollHeight - 4;
        this._textareaElement.classList.remove(this._measuringClass);
        return scrollHeight;
    }
    _cacheTextareaPlaceholderHeight() {
        if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {
            return;
        }
        if (!this.placeholder) {
            this._cachedPlaceholderHeight = 0;
            return;
        }
        const value = this._textareaElement.value;
        this._textareaElement.value = this._textareaElement.placeholder;
        this._cachedPlaceholderHeight = this._measureScrollHeight();
        this._textareaElement.value = value;
    }
    ngDoCheck() {
        if (this._platform.isBrowser) {
            this.resizeToFitContent();
        }
    }
    /**
     * Resize the textarea to fit its content.
     * @param force Whether to force a height recalculation. By default the height will be
     *    recalculated only if the value changed since the last call.
     */
    resizeToFitContent(force = false) {
        // If autosizing is disabled, just skip everything else
        if (!this._enabled) {
            return;
        }
        this._cacheTextareaLineHeight();
        this._cacheTextareaPlaceholderHeight();
        // If we haven't determined the line-height yet, we know we're still hidden and there's no point
        // in checking the height of the textarea.
        if (!this._cachedLineHeight) {
            return;
        }
        const textarea = this._elementRef.nativeElement;
        const value = textarea.value;
        // Only resize if the value or minRows have changed since these calculations can be expensive.
        if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {
            return;
        }
        const scrollHeight = this._measureScrollHeight();
        const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);
        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
        textarea.style.height = `${height}px`;
        this._ngZone.runOutsideAngular(() => {
            if (typeof requestAnimationFrame !== 'undefined') {
                requestAnimationFrame(() => this._scrollToCaretPosition(textarea));
            }
            else {
                setTimeout(() => this._scrollToCaretPosition(textarea));
            }
        });
        this._previousValue = value;
        this._previousMinRows = this._minRows;
    }
    /**
     * Resets the textarea to its original size
     */
    reset() {
        // Do not try to change the textarea, if the initialHeight has not been determined yet
        // This might potentially remove styles when reset() is called before ngAfterViewInit
        if (this._initialHeight !== undefined) {
            this._textareaElement.style.height = this._initialHeight;
        }
    }
    // In Ivy the `host` metadata will be merged, whereas in ViewEngine it is overridden. In order
    // to avoid double event listeners, we need to use `HostListener`. Once Ivy is the default, we
    // can move this back into `host`.
    // tslint:disable:no-host-decorator-in-concrete
    _noopInputHandler() {
        // no-op handler that ensures we're running change detection on input events.
    }
    /** Access injected document if available or fallback to global document reference */
    _getDocument() {
        return this._document || document;
    }
    /** Use defaultView of injected document if available or fallback to global window reference */
    _getWindow() {
        const doc = this._getDocument();
        return doc.defaultView || window;
    }
    /**
     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
     * prevent it from scrolling to the caret position. We need to re-set the selection
     * in order for it to scroll to the proper position.
     */
    _scrollToCaretPosition(textarea) {
        const { selectionStart, selectionEnd } = textarea;
        const document = this._getDocument();
        // IE will throw an "Unspecified error" if we try to set the selection range after the
        // element has been removed from the DOM. Assert that the directive hasn't been destroyed
        // between the time we requested the animation frame and when it was executed.
        // Also note that we have to assert that the textarea is focused before we set the
        // selection range. Setting the selection range on a non-focused textarea will cause
        // it to receive focus on IE and Edge.
        if (!this._destroyed.isStopped && document.activeElement === textarea) {
            textarea.setSelectionRange(selectionStart, selectionEnd);
        }
    }
}
CdkTextareaAutosize.ɵfac = function CdkTextareaAutosize_Factory(t) { return new (t || CdkTextareaAutosize)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0, 8)); };
CdkTextareaAutosize.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: CdkTextareaAutosize, selectors: [["textarea", "cdkTextareaAutosize", ""]], hostAttrs: ["rows", "1", 1, "cdk-textarea-autosize"], hostBindings: function CdkTextareaAutosize_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("input", function CdkTextareaAutosize_input_HostBindingHandler() { return ctx._noopInputHandler(); });
    } }, inputs: { minRows: ["cdkAutosizeMinRows", "minRows"], maxRows: ["cdkAutosizeMaxRows", "maxRows"], enabled: ["cdkTextareaAutosize", "enabled"], placeholder: "placeholder" }, exportAs: ["cdkTextareaAutosize"] });
CdkTextareaAutosize.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: platform/* Platform */.t4 },
    { type: core/* NgZone */.R0b },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] }
];
CdkTextareaAutosize.propDecorators = {
    minRows: [{ type: core/* Input */.IIB, args: ['cdkAutosizeMinRows',] }],
    maxRows: [{ type: core/* Input */.IIB, args: ['cdkAutosizeMaxRows',] }],
    enabled: [{ type: core/* Input */.IIB, args: ['cdkTextareaAutosize',] }],
    placeholder: [{ type: core/* Input */.IIB }],
    _noopInputHandler: [{ type: core/* HostListener */.L6J, args: ['input',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(CdkTextareaAutosize, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'textarea[cdkTextareaAutosize]',
                exportAs: 'cdkTextareaAutosize',
                host: {
                    'class': 'cdk-textarea-autosize',
                    // Textarea elements that have the directive applied should have a single row by default.
                    // Browsers normally show two rows by default and therefore this limits the minRows binding.
                    'rows': '1'
                }
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: platform/* Platform */.t4 }, { type: core/* NgZone */.R0b }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }]; }, { minRows: [{
            type: core/* Input */.IIB,
            args: ['cdkAutosizeMinRows']
        }], maxRows: [{
            type: core/* Input */.IIB,
            args: ['cdkAutosizeMaxRows']
        }], enabled: [{
            type: core/* Input */.IIB,
            args: ['cdkTextareaAutosize']
        }], placeholder: [{
            type: core/* Input */.IIB
        }], 
    // In Ivy the `host` metadata will be merged, whereas in ViewEngine it is overridden. In order
    // to avoid double event listeners, we need to use `HostListener`. Once Ivy is the default, we
    // can move this back into `host`.
    // tslint:disable:no-host-decorator-in-concrete
    _noopInputHandler: [{
            type: core/* HostListener */.L6J,
            args: ['input']
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TextFieldModule {
}
TextFieldModule.ɵfac = function TextFieldModule_Factory(t) { return new (t || TextFieldModule)(); };
TextFieldModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: TextFieldModule });
TextFieldModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[platform/* PlatformModule */.ud]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(TextFieldModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                declarations: [CdkAutofill, CdkTextareaAutosize],
                imports: [platform/* PlatformModule */.ud],
                exports: [CdkAutofill, CdkTextareaAutosize]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(TextFieldModule, { declarations: function () { return [CdkAutofill, CdkTextareaAutosize]; }, imports: function () { return [platform/* PlatformModule */.ud]; }, exports: function () { return [CdkAutofill, CdkTextareaAutosize]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=text-field.js.map
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js + 1 modules
var fesm2015_core = __webpack_require__(2458);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/observers.js
var observers = __webpack_require__(8553);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js
var bidi = __webpack_require__(946);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js
var animations = __webpack_require__(7238);
// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js + 1 modules
var fesm2015_animations = __webpack_require__(6237);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/form-field.js












/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */






const _c0 = ["underline"];
const _c1 = ["connectionContainer"];
const _c2 = ["inputContainer"];
const _c3 = ["label"];
function MatFormField_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "div", 14);
    core/* ɵɵelement */._UZ(2, "div", 15);
    core/* ɵɵelement */._UZ(3, "div", 16);
    core/* ɵɵelement */._UZ(4, "div", 17);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 18);
    core/* ɵɵelement */._UZ(6, "div", 15);
    core/* ɵɵelement */._UZ(7, "div", 16);
    core/* ɵɵelement */._UZ(8, "div", 17);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
} }
function MatFormField_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 19);
    core/* ɵɵprojection */.Hsn(1, 1);
    core/* ɵɵelementEnd */.qZA();
} }
function MatFormField_label_9_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵprojection */.Hsn(1, 2);
    core/* ɵɵelementStart */.TgZ(2, "span");
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r10._control.placeholder);
} }
function MatFormField_label_9_ng_content_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵprojection */.Hsn(0, 3, ["*ngSwitchCase", "true"]);
} }
function MatFormField_label_9_span_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span", 23);
    core/* ɵɵtext */._uU(1, " *");
    core/* ɵɵelementEnd */.qZA();
} }
function MatFormField_label_9_Template(rf, ctx) { if (rf & 1) {
    const _r14 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "label", 20, 21);
    core/* ɵɵlistener */.NdJ("cdkObserveContent", function MatFormField_label_9_Template_label_cdkObserveContent_0_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r13 = core/* ɵɵnextContext */.oxw(); return ctx_r13.updateOutlineGap(); });
    core/* ɵɵtemplate */.YNc(2, MatFormField_label_9_ng_container_2_Template, 4, 1, "ng-container", 12);
    core/* ɵɵtemplate */.YNc(3, MatFormField_label_9_ng_content_3_Template, 1, 0, "ng-content", 12);
    core/* ɵɵtemplate */.YNc(4, MatFormField_label_9_span_4_Template, 2, 0, "span", 22);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵclassProp */.ekj("mat-empty", ctx_r4._control.empty && !ctx_r4._shouldAlwaysFloat())("mat-form-field-empty", ctx_r4._control.empty && !ctx_r4._shouldAlwaysFloat())("mat-accent", ctx_r4.color == "accent")("mat-warn", ctx_r4.color == "warn");
    core/* ɵɵproperty */.Q6J("cdkObserveContentDisabled", ctx_r4.appearance != "outline")("id", ctx_r4._labelId)("ngSwitch", ctx_r4._hasLabel());
    core/* ɵɵattribute */.uIk("for", ctx_r4._control.id)("aria-owns", ctx_r4._control.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", false);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", true);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r4.hideRequiredMarker && ctx_r4._control.required && !ctx_r4._control.disabled);
} }
function MatFormField_div_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 24);
    core/* ɵɵprojection */.Hsn(1, 4);
    core/* ɵɵelementEnd */.qZA();
} }
function MatFormField_div_11_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 25, 26);
    core/* ɵɵelement */._UZ(2, "span", 27);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r6 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵclassProp */.ekj("mat-accent", ctx_r6.color == "accent")("mat-warn", ctx_r6.color == "warn");
} }
function MatFormField_div_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵprojection */.Hsn(1, 5);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("@transitionMessages", ctx_r7._subscriptAnimationState);
} }
function MatFormField_div_14_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r16 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("id", ctx_r16._hintLabelId);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r16.hintLabel);
} }
function MatFormField_div_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 28);
    core/* ɵɵtemplate */.YNc(1, MatFormField_div_14_div_1_Template, 2, 2, "div", 29);
    core/* ɵɵprojection */.Hsn(2, 6);
    core/* ɵɵelement */._UZ(3, "div", 30);
    core/* ɵɵprojection */.Hsn(4, 7);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("@transitionMessages", ctx_r8._subscriptAnimationState);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.hintLabel);
} }
const _c4 = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]];
const _c5 = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"];
let nextUniqueId$2 = 0;
/**
 * Injection token that can be used to reference instances of `MatError`. It serves as
 * alternative token to the actual `MatError` class which could cause unnecessary
 * retention of the class and its directive metadata.
 */
const MAT_ERROR = new core/* InjectionToken */.OlP('MatError');
/** Single error message to be shown underneath the form field. */
class MatError {
    constructor(ariaLive, elementRef) {
        this.id = `mat-error-${nextUniqueId$2++}`;
        // If no aria-live value is set add 'polite' as a default. This is preferred over setting
        // role='alert' so that screen readers do not interrupt the current task to read this aloud.
        if (!ariaLive) {
            elementRef.nativeElement.setAttribute('aria-live', 'polite');
        }
    }
}
MatError.ɵfac = function MatError_Factory(t) { return new (t || MatError)(core/* ɵɵinjectAttribute */.$8M('aria-live'), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq)); };
MatError.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatError, selectors: [["mat-error"]], hostAttrs: ["aria-atomic", "true", 1, "mat-error"], hostVars: 1, hostBindings: function MatError_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵattribute */.uIk("id", ctx.id);
    } }, inputs: { id: "id" }, features: [core/* ɵɵProvidersFeature */._Bn([{ provide: MAT_ERROR, useExisting: MatError }])] });
MatError.ctorParameters = () => [
    { type: String, decorators: [{ type: core/* Attribute */.ahi, args: ['aria-live',] }] },
    { type: core/* ElementRef */.SBq }
];
MatError.propDecorators = {
    id: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatError, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-error',
                host: {
                    'class': 'mat-error',
                    '[attr.id]': 'id',
                    'aria-atomic': 'true'
                },
                providers: [{ provide: MAT_ERROR, useExisting: MatError }]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: core/* Attribute */.ahi,
                args: ['aria-live']
            }] }, { type: core/* ElementRef */.SBq }]; }, { id: [{
            type: core/* Input */.IIB
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Animations used by the MatFormField.
 * @docs-private
 */
const matFormFieldAnimations = {
    /** Animation that transitions the form field's error and hint messages. */
    transitionMessages: (0,animations/* trigger */.X$)('transitionMessages', [
        // TODO(mmalerba): Use angular animations for label animation as well.
        (0,animations/* state */.SB)('enter', (0,animations/* style */.oB)({ opacity: 1, transform: 'translateY(0%)' })),
        (0,animations/* transition */.eR)('void => enter', [
            (0,animations/* style */.oB)({ opacity: 0, transform: 'translateY(-5px)' }),
            (0,animations/* animate */.jt)('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
        ]),
    ])
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** An interface which allows a control to work inside of a `MatFormField`. */
class MatFormFieldControl {
}
MatFormFieldControl.ɵfac = function MatFormFieldControl_Factory(t) { return new (t || MatFormFieldControl)(); };
MatFormFieldControl.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatFormFieldControl });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatFormFieldControl, [{
        type: core/* Directive */.Xek
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @docs-private */
function getMatFormFieldPlaceholderConflictError() {
    return Error('Placeholder attribute and child element were both specified.');
}
/** @docs-private */
function getMatFormFieldDuplicatedHintError(align) {
    return Error(`A hint was already declared for 'align="${align}"'.`);
}
/** @docs-private */
function getMatFormFieldMissingControlError() {
    return Error('mat-form-field must contain a MatFormFieldControl.');
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let nextUniqueId$1 = 0;
/**
 * Injection token that can be used to reference instances of `MatHint`. It serves as
 * alternative token to the actual `MatHint` class which could cause unnecessary
 * retention of the class and its directive metadata.
 *
 * *Note*: This is not part of the public API as the MDC-based form-field will not
 * need a lightweight token for `MatHint` and we want to reduce breaking changes.
 */
const _MAT_HINT = new core/* InjectionToken */.OlP('MatHint');
/** Hint text to be shown underneath the form field control. */
class MatHint {
    constructor() {
        /** Whether to align the hint label at the start or end of the line. */
        this.align = 'start';
        /** Unique ID for the hint. Used for the aria-describedby on the form field control. */
        this.id = `mat-hint-${nextUniqueId$1++}`;
    }
}
MatHint.ɵfac = function MatHint_Factory(t) { return new (t || MatHint)(); };
MatHint.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatHint, selectors: [["mat-hint"]], hostAttrs: [1, "mat-hint"], hostVars: 4, hostBindings: function MatHint_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵattribute */.uIk("id", ctx.id)("align", null);
        core/* ɵɵclassProp */.ekj("mat-form-field-hint-end", ctx.align === "end");
    } }, inputs: { align: "align", id: "id" }, features: [core/* ɵɵProvidersFeature */._Bn([{ provide: _MAT_HINT, useExisting: MatHint }])] });
MatHint.propDecorators = {
    align: [{ type: core/* Input */.IIB }],
    id: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatHint, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-hint',
                host: {
                    'class': 'mat-hint',
                    '[class.mat-form-field-hint-end]': 'align === "end"',
                    '[attr.id]': 'id',
                    // Remove align attribute to prevent it from interfering with layout.
                    '[attr.align]': 'null'
                },
                providers: [{ provide: _MAT_HINT, useExisting: MatHint }]
            }]
    }], function () { return []; }, { align: [{
            type: core/* Input */.IIB
        }], id: [{
            type: core/* Input */.IIB
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** The floating label for a `mat-form-field`. */
class MatLabel {
}
MatLabel.ɵfac = function MatLabel_Factory(t) { return new (t || MatLabel)(); };
MatLabel.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatLabel, selectors: [["mat-label"]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatLabel, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-label'
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The placeholder text for an `MatFormField`.
 * @deprecated Use `<mat-label>` to specify the label and the `placeholder` attribute to specify the
 *     placeholder.
 * @breaking-change 8.0.0
 */
class MatPlaceholder {
}
MatPlaceholder.ɵfac = function MatPlaceholder_Factory(t) { return new (t || MatPlaceholder)(); };
MatPlaceholder.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatPlaceholder, selectors: [["mat-placeholder"]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatPlaceholder, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-placeholder'
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection token that can be used to reference instances of `MatPrefix`. It serves as
 * alternative token to the actual `MatPrefix` class which could cause unnecessary
 * retention of the class and its directive metadata.
 */
const MAT_PREFIX = new core/* InjectionToken */.OlP('MatPrefix');
/** Prefix to be placed in front of the form field. */
class MatPrefix {
}
MatPrefix.ɵfac = function MatPrefix_Factory(t) { return new (t || MatPrefix)(); };
MatPrefix.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatPrefix, selectors: [["", "matPrefix", ""]], features: [core/* ɵɵProvidersFeature */._Bn([{ provide: MAT_PREFIX, useExisting: MatPrefix }])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatPrefix, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[matPrefix]',
                providers: [{ provide: MAT_PREFIX, useExisting: MatPrefix }]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection token that can be used to reference instances of `MatSuffix`. It serves as
 * alternative token to the actual `MatSuffix` class which could cause unnecessary
 * retention of the class and its directive metadata.
 */
const MAT_SUFFIX = new core/* InjectionToken */.OlP('MatSuffix');
/** Suffix to be placed at the end of the form field. */
class MatSuffix {
}
MatSuffix.ɵfac = function MatSuffix_Factory(t) { return new (t || MatSuffix)(); };
MatSuffix.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatSuffix, selectors: [["", "matSuffix", ""]], features: [core/* ɵɵProvidersFeature */._Bn([{ provide: MAT_SUFFIX, useExisting: MatSuffix }])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSuffix, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[matSuffix]',
                providers: [{ provide: MAT_SUFFIX, useExisting: MatSuffix }]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let nextUniqueId = 0;
const floatingLabelScale = 0.75;
const outlineGapPadding = 5;
/**
 * Boilerplate for applying mixins to MatFormField.
 * @docs-private
 */
const _MatFormFieldBase = (0,fesm2015_core/* mixinColor */.pj)(class {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}, 'primary');
/**
 * Injection token that can be used to configure the
 * default options for all form field within an app.
 */
const MAT_FORM_FIELD_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('MAT_FORM_FIELD_DEFAULT_OPTIONS');
/**
 * Injection token that can be used to inject an instances of `MatFormField`. It serves
 * as alternative token to the actual `MatFormField` class which would cause unnecessary
 * retention of the `MatFormField` class and its component metadata.
 */
const MAT_FORM_FIELD = new core/* InjectionToken */.OlP('MatFormField');
/** Container for form controls that applies Material Design styling and behavior. */
class MatFormField extends _MatFormFieldBase {
    constructor(elementRef, _changeDetectorRef, 
    /**
     * @deprecated `_labelOptions` parameter no longer being used. To be removed.
     * @breaking-change 12.0.0
     */
    // Use `ElementRef` here so Angular has something to inject.
    _labelOptions, _dir, _defaults, _platform, _ngZone, _animationMode) {
        super(elementRef);
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._defaults = _defaults;
        this._platform = _platform;
        this._ngZone = _ngZone;
        /**
         * Whether the outline gap needs to be calculated
         * immediately on the next change detection run.
         */
        this._outlineGapCalculationNeededImmediately = false;
        /** Whether the outline gap needs to be calculated next time the zone has stabilized. */
        this._outlineGapCalculationNeededOnStable = false;
        this._destroyed = new Subject/* Subject */.xQ();
        /** Override for the logic that disables the label animation in certain cases. */
        this._showAlwaysAnimate = false;
        /** State of the mat-hint and mat-error animations. */
        this._subscriptAnimationState = '';
        this._hintLabel = '';
        // Unique id for the hint label.
        this._hintLabelId = `mat-hint-${nextUniqueId++}`;
        // Unique id for the label element.
        this._labelId = `mat-form-field-label-${nextUniqueId++}`;
        this.floatLabel = this._getDefaultFloatLabelState();
        this._animationsEnabled = _animationMode !== 'NoopAnimations';
        // Set the default through here so we invoke the setter on the first run.
        this.appearance = (_defaults && _defaults.appearance) ? _defaults.appearance : 'legacy';
        this._hideRequiredMarker = (_defaults && _defaults.hideRequiredMarker != null) ?
            _defaults.hideRequiredMarker : false;
    }
    /** The form-field appearance style. */
    get appearance() { return this._appearance; }
    set appearance(value) {
        const oldValue = this._appearance;
        this._appearance = value || (this._defaults && this._defaults.appearance) || 'legacy';
        if (this._appearance === 'outline' && oldValue !== value) {
            this._outlineGapCalculationNeededOnStable = true;
        }
    }
    /** Whether the required marker should be hidden. */
    get hideRequiredMarker() { return this._hideRequiredMarker; }
    set hideRequiredMarker(value) {
        this._hideRequiredMarker = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /** Whether the floating label should always float or not. */
    _shouldAlwaysFloat() {
        return this.floatLabel === 'always' && !this._showAlwaysAnimate;
    }
    /** Whether the label can float or not. */
    _canLabelFloat() { return this.floatLabel !== 'never'; }
    /** Text for the form field hint. */
    get hintLabel() { return this._hintLabel; }
    set hintLabel(value) {
        this._hintLabel = value;
        this._processHints();
    }
    /**
     * Whether the label should always float, never float or float as the user types.
     *
     * Note: only the legacy appearance supports the `never` option. `never` was originally added as a
     * way to make the floating label emulate the behavior of a standard input placeholder. However
     * the form field now supports both floating labels and placeholders. Therefore in the non-legacy
     * appearances the `never` option has been disabled in favor of just using the placeholder.
     */
    get floatLabel() {
        return this.appearance !== 'legacy' && this._floatLabel === 'never' ? 'auto' : this._floatLabel;
    }
    set floatLabel(value) {
        if (value !== this._floatLabel) {
            this._floatLabel = value || this._getDefaultFloatLabelState();
            this._changeDetectorRef.markForCheck();
        }
    }
    get _control() {
        // TODO(crisbeto): we need this workaround in order to support both Ivy and ViewEngine.
        //  We should clean this up once Ivy is the default renderer.
        return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic;
    }
    set _control(value) {
        this._explicitFormFieldControl = value;
    }
    /**
     * Gets the id of the label element. If no label is present, returns `null`.
     */
    getLabelId() {
        return this._hasFloatingLabel() ? this._labelId : null;
    }
    /**
     * Gets an ElementRef for the element that a overlay attached to the form-field should be
     * positioned relative to.
     */
    getConnectedOverlayOrigin() {
        return this._connectionContainerRef || this._elementRef;
    }
    ngAfterContentInit() {
        this._validateControlChild();
        const control = this._control;
        if (control.controlType) {
            this._elementRef.nativeElement.classList.add(`mat-form-field-type-${control.controlType}`);
        }
        // Subscribe to changes in the child control state in order to update the form field UI.
        control.stateChanges.pipe((0,startWith/* startWith */.O)(null)).subscribe(() => {
            this._validatePlaceholders();
            this._syncDescribedByIds();
            this._changeDetectorRef.markForCheck();
        });
        // Run change detection if the value changes.
        if (control.ngControl && control.ngControl.valueChanges) {
            control.ngControl.valueChanges
                .pipe((0,takeUntil/* takeUntil */.R)(this._destroyed))
                .subscribe(() => this._changeDetectorRef.markForCheck());
        }
        // Note that we have to run outside of the `NgZone` explicitly,
        // in order to avoid throwing users into an infinite loop
        // if `zone-patch-rxjs` is included.
        this._ngZone.runOutsideAngular(() => {
            this._ngZone.onStable.pipe((0,takeUntil/* takeUntil */.R)(this._destroyed)).subscribe(() => {
                if (this._outlineGapCalculationNeededOnStable) {
                    this.updateOutlineGap();
                }
            });
        });
        // Run change detection and update the outline if the suffix or prefix changes.
        (0,merge/* merge */.T)(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {
            this._outlineGapCalculationNeededOnStable = true;
            this._changeDetectorRef.markForCheck();
        });
        // Re-validate when the number of hints changes.
        this._hintChildren.changes.pipe((0,startWith/* startWith */.O)(null)).subscribe(() => {
            this._processHints();
            this._changeDetectorRef.markForCheck();
        });
        // Update the aria-described by when the number of errors changes.
        this._errorChildren.changes.pipe((0,startWith/* startWith */.O)(null)).subscribe(() => {
            this._syncDescribedByIds();
            this._changeDetectorRef.markForCheck();
        });
        if (this._dir) {
            this._dir.change.pipe((0,takeUntil/* takeUntil */.R)(this._destroyed)).subscribe(() => {
                if (typeof requestAnimationFrame === 'function') {
                    this._ngZone.runOutsideAngular(() => {
                        requestAnimationFrame(() => this.updateOutlineGap());
                    });
                }
                else {
                    this.updateOutlineGap();
                }
            });
        }
    }
    ngAfterContentChecked() {
        this._validateControlChild();
        if (this._outlineGapCalculationNeededImmediately) {
            this.updateOutlineGap();
        }
    }
    ngAfterViewInit() {
        // Avoid animations on load.
        this._subscriptAnimationState = 'enter';
        this._changeDetectorRef.detectChanges();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /** Determines whether a class from the NgControl should be forwarded to the host element. */
    _shouldForward(prop) {
        const ngControl = this._control ? this._control.ngControl : null;
        return ngControl && ngControl[prop];
    }
    _hasPlaceholder() {
        return !!(this._control && this._control.placeholder || this._placeholderChild);
    }
    _hasLabel() {
        return !!(this._labelChildNonStatic || this._labelChildStatic);
    }
    _shouldLabelFloat() {
        return this._canLabelFloat() &&
            ((this._control && this._control.shouldLabelFloat) || this._shouldAlwaysFloat());
    }
    _hideControlPlaceholder() {
        // In the legacy appearance the placeholder is promoted to a label if no label is given.
        return this.appearance === 'legacy' && !this._hasLabel() ||
            this._hasLabel() && !this._shouldLabelFloat();
    }
    _hasFloatingLabel() {
        // In the legacy appearance the placeholder is promoted to a label if no label is given.
        return this._hasLabel() || this.appearance === 'legacy' && this._hasPlaceholder();
    }
    /** Determines whether to display hints or errors. */
    _getDisplayedMessages() {
        return (this._errorChildren && this._errorChildren.length > 0 &&
            this._control.errorState) ? 'error' : 'hint';
    }
    /** Animates the placeholder up and locks it in position. */
    _animateAndLockLabel() {
        if (this._hasFloatingLabel() && this._canLabelFloat()) {
            // If animations are disabled, we shouldn't go in here,
            // because the `transitionend` will never fire.
            if (this._animationsEnabled && this._label) {
                this._showAlwaysAnimate = true;
                (0,fromEvent/* fromEvent */.R)(this._label.nativeElement, 'transitionend').pipe((0,take/* take */.q)(1)).subscribe(() => {
                    this._showAlwaysAnimate = false;
                });
            }
            this.floatLabel = 'always';
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control
     * or child element with the `mat-placeholder` directive).
     */
    _validatePlaceholders() {
        if (this._control.placeholder && this._placeholderChild &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatFormFieldPlaceholderConflictError();
        }
    }
    /** Does any extra processing that is required when handling the hints. */
    _processHints() {
        this._validateHints();
        this._syncDescribedByIds();
    }
    /**
     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the
     * attribute being considered as `align="start"`.
     */
    _validateHints() {
        if (this._hintChildren && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            let startHint;
            let endHint;
            this._hintChildren.forEach((hint) => {
                if (hint.align === 'start') {
                    if (startHint || this.hintLabel) {
                        throw getMatFormFieldDuplicatedHintError('start');
                    }
                    startHint = hint;
                }
                else if (hint.align === 'end') {
                    if (endHint) {
                        throw getMatFormFieldDuplicatedHintError('end');
                    }
                    endHint = hint;
                }
            });
        }
    }
    /** Gets the default float label state. */
    _getDefaultFloatLabelState() {
        return (this._defaults && this._defaults.floatLabel) || 'auto';
    }
    /**
     * Sets the list of element IDs that describe the child control. This allows the control to update
     * its `aria-describedby` attribute accordingly.
     */
    _syncDescribedByIds() {
        if (this._control) {
            let ids = [];
            // TODO(wagnermaciel): Remove the type check when we find the root cause of this bug.
            if (this._control.userAriaDescribedBy &&
                typeof this._control.userAriaDescribedBy === 'string') {
                ids.push(...this._control.userAriaDescribedBy.split(' '));
            }
            if (this._getDisplayedMessages() === 'hint') {
                const startHint = this._hintChildren ?
                    this._hintChildren.find(hint => hint.align === 'start') : null;
                const endHint = this._hintChildren ?
                    this._hintChildren.find(hint => hint.align === 'end') : null;
                if (startHint) {
                    ids.push(startHint.id);
                }
                else if (this._hintLabel) {
                    ids.push(this._hintLabelId);
                }
                if (endHint) {
                    ids.push(endHint.id);
                }
            }
            else if (this._errorChildren) {
                ids.push(...this._errorChildren.map(error => error.id));
            }
            this._control.setDescribedByIds(ids);
        }
    }
    /** Throws an error if the form field's control is missing. */
    _validateControlChild() {
        if (!this._control && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatFormFieldMissingControlError();
        }
    }
    /**
     * Updates the width and position of the gap in the outline. Only relevant for the outline
     * appearance.
     */
    updateOutlineGap() {
        const labelEl = this._label ? this._label.nativeElement : null;
        if (this.appearance !== 'outline' || !labelEl || !labelEl.children.length ||
            !labelEl.textContent.trim()) {
            return;
        }
        if (!this._platform.isBrowser) {
            // getBoundingClientRect isn't available on the server.
            return;
        }
        // If the element is not present in the DOM, the outline gap will need to be calculated
        // the next time it is checked and in the DOM.
        if (!this._isAttachedToDOM()) {
            this._outlineGapCalculationNeededImmediately = true;
            return;
        }
        let startWidth = 0;
        let gapWidth = 0;
        const container = this._connectionContainerRef.nativeElement;
        const startEls = container.querySelectorAll('.mat-form-field-outline-start');
        const gapEls = container.querySelectorAll('.mat-form-field-outline-gap');
        if (this._label && this._label.nativeElement.children.length) {
            const containerRect = container.getBoundingClientRect();
            // If the container's width and height are zero, it means that the element is
            // invisible and we can't calculate the outline gap. Mark the element as needing
            // to be checked the next time the zone stabilizes. We can't do this immediately
            // on the next change detection, because even if the element becomes visible,
            // the `ClientRect` won't be reclaculated immediately. We reset the
            // `_outlineGapCalculationNeededImmediately` flag some we don't run the checks twice.
            if (containerRect.width === 0 && containerRect.height === 0) {
                this._outlineGapCalculationNeededOnStable = true;
                this._outlineGapCalculationNeededImmediately = false;
                return;
            }
            const containerStart = this._getStartEnd(containerRect);
            const labelChildren = labelEl.children;
            const labelStart = this._getStartEnd(labelChildren[0].getBoundingClientRect());
            let labelWidth = 0;
            for (let i = 0; i < labelChildren.length; i++) {
                labelWidth += labelChildren[i].offsetWidth;
            }
            startWidth = Math.abs(labelStart - containerStart) - outlineGapPadding;
            gapWidth = labelWidth > 0 ? labelWidth * floatingLabelScale + outlineGapPadding * 2 : 0;
        }
        for (let i = 0; i < startEls.length; i++) {
            startEls[i].style.width = `${startWidth}px`;
        }
        for (let i = 0; i < gapEls.length; i++) {
            gapEls[i].style.width = `${gapWidth}px`;
        }
        this._outlineGapCalculationNeededOnStable =
            this._outlineGapCalculationNeededImmediately = false;
    }
    /** Gets the start end of the rect considering the current directionality. */
    _getStartEnd(rect) {
        return (this._dir && this._dir.value === 'rtl') ? rect.right : rect.left;
    }
    /** Checks whether the form field is attached to the DOM. */
    _isAttachedToDOM() {
        const element = this._elementRef.nativeElement;
        if (element.getRootNode) {
            const rootNode = element.getRootNode();
            // If the element is inside the DOM the root node will be either the document
            // or the closest shadow root, otherwise it'll be the element itself.
            return rootNode && rootNode !== element;
        }
        // Otherwise fall back to checking if it's in the document. This doesn't account for
        // shadow DOM, however browser that support shadow DOM should support `getRootNode` as well.
        return document.documentElement.contains(element);
    }
}
MatFormField.ɵfac = function MatFormField_Factory(t) { return new (t || MatFormField)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8), core/* ɵɵdirectiveInject */.Y36(MAT_FORM_FIELD_DEFAULT_OPTIONS, 8), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb, 8)); };
MatFormField.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatFormField, selectors: [["mat-form-field"]], contentQueries: function MatFormField_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatFormFieldControl, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatFormFieldControl, 7);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatLabel, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatLabel, 7);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatPlaceholder, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MAT_ERROR, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, _MAT_HINT, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MAT_PREFIX, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, MAT_SUFFIX, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._controlNonStatic = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._controlStatic = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._labelChildNonStatic = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._labelChildStatic = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._placeholderChild = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._errorChildren = _t);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._hintChildren = _t);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._prefixChildren = _t);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._suffixChildren = _t);
    } }, viewQuery: function MatFormField_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(_c0, 5);
        core/* ɵɵviewQuery */.Gf(_c1, 7);
        core/* ɵɵviewQuery */.Gf(_c2, 5);
        core/* ɵɵviewQuery */.Gf(_c3, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.underlineRef = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._connectionContainerRef = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._inputContainerRef = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._label = _t.first);
    } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function MatFormField_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵclassProp */.ekj("mat-form-field-appearance-standard", ctx.appearance == "standard")("mat-form-field-appearance-fill", ctx.appearance == "fill")("mat-form-field-appearance-outline", ctx.appearance == "outline")("mat-form-field-appearance-legacy", ctx.appearance == "legacy")("mat-form-field-invalid", ctx._control.errorState)("mat-form-field-can-float", ctx._canLabelFloat())("mat-form-field-should-float", ctx._shouldLabelFloat())("mat-form-field-has-label", ctx._hasFloatingLabel())("mat-form-field-hide-placeholder", ctx._hideControlPlaceholder())("mat-form-field-disabled", ctx._control.disabled)("mat-form-field-autofilled", ctx._control.autofilled)("mat-focused", ctx._control.focused)("ng-untouched", ctx._shouldForward("untouched"))("ng-touched", ctx._shouldForward("touched"))("ng-pristine", ctx._shouldForward("pristine"))("ng-dirty", ctx._shouldForward("dirty"))("ng-valid", ctx._shouldForward("valid"))("ng-invalid", ctx._shouldForward("invalid"))("ng-pending", ctx._shouldForward("pending"))("_mat-animation-noopable", !ctx._animationsEnabled);
    } }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [core/* ɵɵProvidersFeature */._Bn([
            { provide: MAT_FORM_FIELD, useExisting: MatFormField },
        ]), core/* ɵɵInheritDefinitionFeature */.qOj], ngContentSelectors: _c5, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], ["underline", ""], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function MatFormField_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(_c4);
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1, 2);
        core/* ɵɵlistener */.NdJ("click", function MatFormField_Template_div_click_1_listener($event) { return ctx._control.onContainerClick && ctx._control.onContainerClick($event); });
        core/* ɵɵtemplate */.YNc(3, MatFormField_ng_container_3_Template, 9, 0, "ng-container", 3);
        core/* ɵɵtemplate */.YNc(4, MatFormField_div_4_Template, 2, 0, "div", 4);
        core/* ɵɵelementStart */.TgZ(5, "div", 5, 6);
        core/* ɵɵprojection */.Hsn(7);
        core/* ɵɵelementStart */.TgZ(8, "span", 7);
        core/* ɵɵtemplate */.YNc(9, MatFormField_label_9_Template, 5, 16, "label", 8);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(10, MatFormField_div_10_Template, 2, 0, "div", 9);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(11, MatFormField_div_11_Template, 3, 4, "div", 10);
        core/* ɵɵelementStart */.TgZ(12, "div", 11);
        core/* ɵɵtemplate */.YNc(13, MatFormField_div_13_Template, 2, 1, "div", 12);
        core/* ɵɵtemplate */.YNc(14, MatFormField_div_14_Template, 5, 2, "div", 13);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(3);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.appearance == "outline");
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx._prefixChildren.length);
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngIf", ctx._hasFloatingLabel());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx._suffixChildren.length);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.appearance != "outline");
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitch", ctx._getDisplayedMessages());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", "error");
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", "hint");
    } }, directives: [common/* NgIf */.O5, common/* NgSwitch */.RF, common/* NgSwitchCase */.n9, observers/* CdkObserveContent */.wD], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", ".mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:\"\";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n", ".mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:\" \";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:\"\";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n", ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [matFormFieldAnimations.transitionMessages] }, changeDetection: 0 });
MatFormField.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [core/* ElementRef */.SBq,] }] },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] },
    { type: platform/* Platform */.t4 },
    { type: core/* NgZone */.R0b },
    { type: String, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb,] }] }
];
MatFormField.propDecorators = {
    appearance: [{ type: core/* Input */.IIB }],
    hideRequiredMarker: [{ type: core/* Input */.IIB }],
    hintLabel: [{ type: core/* Input */.IIB }],
    floatLabel: [{ type: core/* Input */.IIB }],
    underlineRef: [{ type: core/* ViewChild */.i9L, args: ['underline',] }],
    _connectionContainerRef: [{ type: core/* ViewChild */.i9L, args: ['connectionContainer', { static: true },] }],
    _inputContainerRef: [{ type: core/* ViewChild */.i9L, args: ['inputContainer',] }],
    _label: [{ type: core/* ViewChild */.i9L, args: ['label',] }],
    _controlNonStatic: [{ type: core/* ContentChild */.aQ5, args: [MatFormFieldControl,] }],
    _controlStatic: [{ type: core/* ContentChild */.aQ5, args: [MatFormFieldControl, { static: true },] }],
    _labelChildNonStatic: [{ type: core/* ContentChild */.aQ5, args: [MatLabel,] }],
    _labelChildStatic: [{ type: core/* ContentChild */.aQ5, args: [MatLabel, { static: true },] }],
    _placeholderChild: [{ type: core/* ContentChild */.aQ5, args: [MatPlaceholder,] }],
    _errorChildren: [{ type: core/* ContentChildren */.AcB, args: [MAT_ERROR, { descendants: true },] }],
    _hintChildren: [{ type: core/* ContentChildren */.AcB, args: [_MAT_HINT, { descendants: true },] }],
    _prefixChildren: [{ type: core/* ContentChildren */.AcB, args: [MAT_PREFIX, { descendants: true },] }],
    _suffixChildren: [{ type: core/* ContentChildren */.AcB, args: [MAT_SUFFIX, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatFormField, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-form-field',
                exportAs: 'matFormField',
                template: "<div class=\"mat-form-field-wrapper\">\n  <div class=\"mat-form-field-flex\" #connectionContainer\n       (click)=\"_control.onContainerClick && _control.onContainerClick($event)\">\n\n    <!-- Outline used for outline appearance. -->\n    <ng-container *ngIf=\"appearance == 'outline'\">\n      <div class=\"mat-form-field-outline\">\n        <div class=\"mat-form-field-outline-start\"></div>\n        <div class=\"mat-form-field-outline-gap\"></div>\n        <div class=\"mat-form-field-outline-end\"></div>\n      </div>\n      <div class=\"mat-form-field-outline mat-form-field-outline-thick\">\n        <div class=\"mat-form-field-outline-start\"></div>\n        <div class=\"mat-form-field-outline-gap\"></div>\n        <div class=\"mat-form-field-outline-end\"></div>\n      </div>\n    </ng-container>\n\n    <div class=\"mat-form-field-prefix\" *ngIf=\"_prefixChildren.length\">\n      <ng-content select=\"[matPrefix]\"></ng-content>\n    </div>\n\n    <div class=\"mat-form-field-infix\" #inputContainer>\n      <ng-content></ng-content>\n\n      <span class=\"mat-form-field-label-wrapper\">\n        <!-- We add aria-owns as a workaround for an issue in JAWS & NVDA where the label isn't\n             read if it comes before the control in the DOM. -->\n        <label class=\"mat-form-field-label\"\n               (cdkObserveContent)=\"updateOutlineGap()\"\n               [cdkObserveContentDisabled]=\"appearance != 'outline'\"\n               [id]=\"_labelId\"\n               [attr.for]=\"_control.id\"\n               [attr.aria-owns]=\"_control.id\"\n               [class.mat-empty]=\"_control.empty && !_shouldAlwaysFloat()\"\n               [class.mat-form-field-empty]=\"_control.empty && !_shouldAlwaysFloat()\"\n               [class.mat-accent]=\"color == 'accent'\"\n               [class.mat-warn]=\"color == 'warn'\"\n               #label\n               *ngIf=\"_hasFloatingLabel()\"\n               [ngSwitch]=\"_hasLabel()\">\n\n          <!-- @breaking-change 8.0.0 remove in favor of mat-label element an placeholder attr. -->\n          <ng-container *ngSwitchCase=\"false\">\n            <ng-content select=\"mat-placeholder\"></ng-content>\n            <span>{{_control.placeholder}}</span>\n          </ng-container>\n\n          <ng-content select=\"mat-label\" *ngSwitchCase=\"true\"></ng-content>\n\n          <!-- @breaking-change 8.0.0 remove `mat-placeholder-required` class -->\n          <span\n            class=\"mat-placeholder-required mat-form-field-required-marker\"\n            aria-hidden=\"true\"\n            *ngIf=\"!hideRequiredMarker && _control.required && !_control.disabled\">&#32;*</span>\n        </label>\n      </span>\n    </div>\n\n    <div class=\"mat-form-field-suffix\" *ngIf=\"_suffixChildren.length\">\n      <ng-content select=\"[matSuffix]\"></ng-content>\n    </div>\n  </div>\n\n  <!-- Underline used for legacy, standard, and box appearances. -->\n  <div class=\"mat-form-field-underline\" #underline\n       *ngIf=\"appearance != 'outline'\">\n    <span class=\"mat-form-field-ripple\"\n          [class.mat-accent]=\"color == 'accent'\"\n          [class.mat-warn]=\"color == 'warn'\"></span>\n  </div>\n\n  <div class=\"mat-form-field-subscript-wrapper\"\n       [ngSwitch]=\"_getDisplayedMessages()\">\n    <div *ngSwitchCase=\"'error'\" [@transitionMessages]=\"_subscriptAnimationState\">\n      <ng-content select=\"mat-error\"></ng-content>\n    </div>\n\n    <div class=\"mat-form-field-hint-wrapper\" *ngSwitchCase=\"'hint'\"\n      [@transitionMessages]=\"_subscriptAnimationState\">\n      <!-- TODO(mmalerba): use an actual <mat-hint> once all selectors are switched to mat-* -->\n      <div *ngIf=\"hintLabel\" [id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div>\n      <ng-content select=\"mat-hint:not([align='end'])\"></ng-content>\n      <div class=\"mat-form-field-hint-spacer\"></div>\n      <ng-content select=\"mat-hint[align='end']\"></ng-content>\n    </div>\n  </div>\n</div>\n",
                animations: [matFormFieldAnimations.transitionMessages],
                host: {
                    'class': 'mat-form-field',
                    '[class.mat-form-field-appearance-standard]': 'appearance == "standard"',
                    '[class.mat-form-field-appearance-fill]': 'appearance == "fill"',
                    '[class.mat-form-field-appearance-outline]': 'appearance == "outline"',
                    '[class.mat-form-field-appearance-legacy]': 'appearance == "legacy"',
                    '[class.mat-form-field-invalid]': '_control.errorState',
                    '[class.mat-form-field-can-float]': '_canLabelFloat()',
                    '[class.mat-form-field-should-float]': '_shouldLabelFloat()',
                    '[class.mat-form-field-has-label]': '_hasFloatingLabel()',
                    '[class.mat-form-field-hide-placeholder]': '_hideControlPlaceholder()',
                    '[class.mat-form-field-disabled]': '_control.disabled',
                    '[class.mat-form-field-autofilled]': '_control.autofilled',
                    '[class.mat-focused]': '_control.focused',
                    '[class.ng-untouched]': '_shouldForward("untouched")',
                    '[class.ng-touched]': '_shouldForward("touched")',
                    '[class.ng-pristine]': '_shouldForward("pristine")',
                    '[class.ng-dirty]': '_shouldForward("dirty")',
                    '[class.ng-valid]': '_shouldForward("valid")',
                    '[class.ng-invalid]': '_shouldForward("invalid")',
                    '[class.ng-pending]': '_shouldForward("pending")',
                    '[class._mat-animation-noopable]': '!_animationsEnabled'
                },
                inputs: ['color'],
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                providers: [
                    { provide: MAT_FORM_FIELD, useExisting: MatFormField },
                ],
                styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", ".mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:\"\";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n", ".mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:\" \";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:\"\";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n", ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: core/* ChangeDetectorRef */.sBO }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [core/* ElementRef */.SBq]
            }] }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_FORM_FIELD_DEFAULT_OPTIONS]
            }] }, { type: platform/* Platform */.t4 }, { type: core/* NgZone */.R0b }, { type: String, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb]
            }] }]; }, { floatLabel: [{
            type: core/* Input */.IIB
        }], appearance: [{
            type: core/* Input */.IIB
        }], hideRequiredMarker: [{
            type: core/* Input */.IIB
        }], hintLabel: [{
            type: core/* Input */.IIB
        }], underlineRef: [{
            type: core/* ViewChild */.i9L,
            args: ['underline']
        }], _connectionContainerRef: [{
            type: core/* ViewChild */.i9L,
            args: ['connectionContainer', { static: true }]
        }], _inputContainerRef: [{
            type: core/* ViewChild */.i9L,
            args: ['inputContainer']
        }], _label: [{
            type: core/* ViewChild */.i9L,
            args: ['label']
        }], _controlNonStatic: [{
            type: core/* ContentChild */.aQ5,
            args: [MatFormFieldControl]
        }], _controlStatic: [{
            type: core/* ContentChild */.aQ5,
            args: [MatFormFieldControl, { static: true }]
        }], _labelChildNonStatic: [{
            type: core/* ContentChild */.aQ5,
            args: [MatLabel]
        }], _labelChildStatic: [{
            type: core/* ContentChild */.aQ5,
            args: [MatLabel, { static: true }]
        }], _placeholderChild: [{
            type: core/* ContentChild */.aQ5,
            args: [MatPlaceholder]
        }], _errorChildren: [{
            type: core/* ContentChildren */.AcB,
            args: [MAT_ERROR, { descendants: true }]
        }], _hintChildren: [{
            type: core/* ContentChildren */.AcB,
            args: [_MAT_HINT, { descendants: true }]
        }], _prefixChildren: [{
            type: core/* ContentChildren */.AcB,
            args: [MAT_PREFIX, { descendants: true }]
        }], _suffixChildren: [{
            type: core/* ContentChildren */.AcB,
            args: [MAT_SUFFIX, { descendants: true }]
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatFormFieldModule {
}
MatFormFieldModule.ɵfac = function MatFormFieldModule_Factory(t) { return new (t || MatFormFieldModule)(); };
MatFormFieldModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatFormFieldModule });
MatFormFieldModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[
            common/* CommonModule */.ez,
            fesm2015_core/* MatCommonModule */.BQ,
            observers/* ObserversModule */.Q8,
        ], fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatFormFieldModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                declarations: [
                    MatError,
                    MatFormField,
                    MatHint,
                    MatLabel,
                    MatPlaceholder,
                    MatPrefix,
                    MatSuffix,
                ],
                imports: [
                    common/* CommonModule */.ez,
                    fesm2015_core/* MatCommonModule */.BQ,
                    observers/* ObserversModule */.Q8,
                ],
                exports: [
                    fesm2015_core/* MatCommonModule */.BQ,
                    MatError,
                    MatFormField,
                    MatHint,
                    MatLabel,
                    MatPlaceholder,
                    MatPrefix,
                    MatSuffix,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatFormFieldModule, { declarations: function () { return [MatError, MatFormField, MatHint, MatLabel, MatPlaceholder, MatPrefix, MatSuffix]; }, imports: function () { return [common/* CommonModule */.ez,
        fesm2015_core/* MatCommonModule */.BQ,
        observers/* ObserversModule */.Q8]; }, exports: function () { return [fesm2015_core/* MatCommonModule */.BQ, MatError, MatFormField, MatHint, MatLabel, MatPlaceholder, MatPrefix, MatSuffix]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=form-field.js.map
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/input.js









/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Directive to automatically resize a textarea to fit its content.
 * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.
 * @breaking-change 8.0.0
 */






class MatTextareaAutosize extends CdkTextareaAutosize {
    get matAutosizeMinRows() { return this.minRows; }
    set matAutosizeMinRows(value) { this.minRows = value; }
    get matAutosizeMaxRows() { return this.maxRows; }
    set matAutosizeMaxRows(value) { this.maxRows = value; }
    get matAutosize() { return this.enabled; }
    set matAutosize(value) { this.enabled = value; }
    get matTextareaAutosize() { return this.enabled; }
    set matTextareaAutosize(value) { this.enabled = value; }
}
MatTextareaAutosize.ɵfac = /*@__PURE__*/ function () { let ɵMatTextareaAutosize_BaseFactory; return function MatTextareaAutosize_Factory(t) { return (ɵMatTextareaAutosize_BaseFactory || (ɵMatTextareaAutosize_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatTextareaAutosize)))(t || MatTextareaAutosize); }; }();
MatTextareaAutosize.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatTextareaAutosize, selectors: [["textarea", "mat-autosize", ""], ["textarea", "matTextareaAutosize", ""]], hostAttrs: ["rows", "1", 1, "cdk-textarea-autosize", "mat-autosize"], inputs: { cdkAutosizeMinRows: "cdkAutosizeMinRows", cdkAutosizeMaxRows: "cdkAutosizeMaxRows", matAutosizeMinRows: "matAutosizeMinRows", matAutosizeMaxRows: "matAutosizeMaxRows", matAutosize: ["mat-autosize", "matAutosize"], matTextareaAutosize: "matTextareaAutosize" }, exportAs: ["matTextareaAutosize"], features: [core/* ɵɵInheritDefinitionFeature */.qOj] });
MatTextareaAutosize.propDecorators = {
    matAutosizeMinRows: [{ type: core/* Input */.IIB }],
    matAutosizeMaxRows: [{ type: core/* Input */.IIB }],
    matAutosize: [{ type: core/* Input */.IIB, args: ['mat-autosize',] }],
    matTextareaAutosize: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatTextareaAutosize, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',
                exportAs: 'matTextareaAutosize',
                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],
                host: {
                    'class': 'cdk-textarea-autosize mat-autosize',
                    // Textarea elements that have the directive applied should have a single row by default.
                    // Browsers normally show two rows by default and therefore this limits the minRows binding.
                    'rows': '1'
                }
            }]
    }], null, { matAutosizeMinRows: [{
            type: core/* Input */.IIB
        }], matAutosizeMaxRows: [{
            type: core/* Input */.IIB
        }], matAutosize: [{
            type: core/* Input */.IIB,
            args: ['mat-autosize']
        }], matTextareaAutosize: [{
            type: core/* Input */.IIB
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @docs-private */
function getMatInputUnsupportedTypeError(type) {
    return Error(`Input type "${type}" isn't supported by matInput.`);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This token is used to inject the object whose value should be set into `MatInput`. If none is
 * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide
 * themselves for this token, in order to make `MatInput` delegate the getting and setting of the
 * value to them.
 */
const MAT_INPUT_VALUE_ACCESSOR = new core/* InjectionToken */.OlP('MAT_INPUT_VALUE_ACCESSOR');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.
const MAT_INPUT_INVALID_TYPES = [
    'button',
    'checkbox',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
let input_nextUniqueId = 0;
// Boilerplate for applying mixins to MatInput.
/** @docs-private */
const _MatInputBase = (0,fesm2015_core/* mixinErrorState */.FD)(class {
    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, 
    /** @docs-private */
    ngControl) {
        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.ngControl = ngControl;
    }
});
/** Directive that allows a native input to work inside a `MatFormField`. */
class MatInput extends _MatInputBase {
    constructor(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone, 
    // TODO: Remove this once the legacy appearance has been removed. We only need
    // to inject the form-field for determining whether the placeholder has been promoted.
    _formField) {
        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);
        this._elementRef = _elementRef;
        this._platform = _platform;
        this._autofillMonitor = _autofillMonitor;
        this._formField = _formField;
        this._uid = `mat-input-${input_nextUniqueId++}`;
        /**
         * Implemented as part of MatFormFieldControl.
         * @docs-private
         */
        this.focused = false;
        /**
         * Implemented as part of MatFormFieldControl.
         * @docs-private
         */
        this.stateChanges = new Subject/* Subject */.xQ();
        /**
         * Implemented as part of MatFormFieldControl.
         * @docs-private
         */
        this.controlType = 'mat-input';
        /**
         * Implemented as part of MatFormFieldControl.
         * @docs-private
         */
        this.autofilled = false;
        this._disabled = false;
        this._required = false;
        this._type = 'text';
        this._readonly = false;
        this._neverEmptyInputTypes = [
            'date',
            'datetime',
            'datetime-local',
            'month',
            'time',
            'week'
        ].filter(t => (0,platform/* getSupportedInputTypes */.qK)().has(t));
        const element = this._elementRef.nativeElement;
        const nodeName = element.nodeName.toLowerCase();
        // If no input value accessor was explicitly specified, use the element as the input value
        // accessor.
        this._inputValueAccessor = inputValueAccessor || element;
        this._previousNativeValue = this.value;
        // Force setter to be called in case id was not specified.
        this.id = this.id;
        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
        // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
        // exists on iOS, we only bother to install the listener on iOS.
        if (_platform.IOS) {
            ngZone.runOutsideAngular(() => {
                _elementRef.nativeElement.addEventListener('keyup', (event) => {
                    const el = event.target;
                    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two
                    // indicate different things. If the value is 0, it means that the caret is at the start
                    // of the input, whereas a value of `null` means that the input doesn't support
                    // manipulating the selection range. Inputs that don't support setting the selection range
                    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:
                    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply
                    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {
                        // Note: Just setting `0, 0` doesn't fix the issue. Setting
                        // `1, 1` fixes it for the first time that you type text and
                        // then hold delete. Toggling to `1, 1` and then back to
                        // `0, 0` seems to completely fix it.
                        el.setSelectionRange(1, 1);
                        el.setSelectionRange(0, 0);
                    }
                });
            });
        }
        this._isServer = !this._platform.isBrowser;
        this._isNativeSelect = nodeName === 'select';
        this._isTextarea = nodeName === 'textarea';
        this._isInFormField = !!_formField;
        if (this._isNativeSelect) {
            this.controlType = element.multiple ? 'mat-native-select-multiple' :
                'mat-native-select';
        }
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = (0,coercion/* coerceBooleanProperty */.Ig)(value);
        // Browsers may not fire the blur event if the input is disabled too quickly.
        // Reset from here to ensure that the element doesn't become stuck.
        if (this.focused) {
            this.focused = false;
            this.stateChanges.next();
        }
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get id() { return this._id; }
    set id(value) { this._id = value || this._uid; }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get required() { return this._required; }
    set required(value) { this._required = (0,coercion/* coerceBooleanProperty */.Ig)(value); }
    /** Input type of the element. */
    get type() { return this._type; }
    set type(value) {
        this._type = value || 'text';
        this._validateType();
        // When using Angular inputs, developers are no longer able to set the properties on the native
        // input element. To ensure that bindings for `type` work, we need to sync the setter
        // with the native property. Textarea elements don't support the type property or attribute.
        if (!this._isTextarea && (0,platform/* getSupportedInputTypes */.qK)().has(this._type)) {
            this._elementRef.nativeElement.type = this._type;
        }
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get value() { return this._inputValueAccessor.value; }
    set value(value) {
        if (value !== this.value) {
            this._inputValueAccessor.value = value;
            this.stateChanges.next();
        }
    }
    /** Whether the element is readonly. */
    get readonly() { return this._readonly; }
    set readonly(value) { this._readonly = (0,coercion/* coerceBooleanProperty */.Ig)(value); }
    ngAfterViewInit() {
        if (this._platform.isBrowser) {
            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {
                this.autofilled = event.isAutofilled;
                this.stateChanges.next();
            });
        }
    }
    ngOnChanges() {
        this.stateChanges.next();
    }
    ngOnDestroy() {
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
        }
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        // We need to dirty-check the native element's value, because there are some cases where
        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
        // updating the value using `emitEvent: false`).
        this._dirtyCheckNativeValue();
        // We need to dirty-check and set the placeholder attribute ourselves, because whether it's
        // present or not depends on a query which is prone to "changed after checked" errors.
        this._dirtyCheckPlaceholder();
    }
    /** Focuses the input. */
    focus(options) {
        this._elementRef.nativeElement.focus(options);
    }
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    /** Callback for the cases where the focused state of the input changes. */
    // tslint:disable:no-host-decorator-in-concrete
    // tslint:enable:no-host-decorator-in-concrete
    _focusChanged(isFocused) {
        if (isFocused !== this.focused) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    }
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    // tslint:disable-next-line:no-host-decorator-in-concrete
    _onInput() {
        // This is a noop function and is used to let Angular know whenever the value changes.
        // Angular will run a new change detection each time the `input` event has been dispatched.
        // It's necessary that Angular recognizes the value change, because when floatingLabel
        // is set to false and Angular forms aren't used, the placeholder won't recognize the
        // value changes and will not disappear.
        // Listening to the input event wouldn't be necessary when the input is using the
        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
    }
    /** Does some manual dirty checking on the native input `placeholder` attribute. */
    _dirtyCheckPlaceholder() {
        var _a, _b;
        // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise
        // screen readers will read it out twice: once from the label and once from the attribute.
        // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's
        // the only one that supports promoting the placeholder to a label.
        const placeholder = ((_b = (_a = this._formField) === null || _a === void 0 ? void 0 : _a._hideControlPlaceholder) === null || _b === void 0 ? void 0 : _b.call(_a)) ? null : this.placeholder;
        if (placeholder !== this._previousPlaceholder) {
            const element = this._elementRef.nativeElement;
            this._previousPlaceholder = placeholder;
            placeholder ?
                element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');
        }
    }
    /** Does some manual dirty checking on the native input `value` property. */
    _dirtyCheckNativeValue() {
        const newValue = this._elementRef.nativeElement.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    }
    /** Make sure the input is a supported type. */
    _validateType() {
        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatInputUnsupportedTypeError(this._type);
        }
    }
    /** Checks whether the input type is one of the types that are never empty. */
    _isNeverEmpty() {
        return this._neverEmptyInputTypes.indexOf(this._type) > -1;
    }
    /** Checks whether the input is invalid based on the native validation. */
    _isBadInput() {
        // The `validity` property won't be present on platform-server.
        let validity = this._elementRef.nativeElement.validity;
        return validity && validity.badInput;
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get empty() {
        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&
            !this.autofilled;
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get shouldLabelFloat() {
        if (this._isNativeSelect) {
            // For a single-selection `<select>`, the label should float when the selected option has
            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid
            // overlapping the label with the options.
            const selectElement = this._elementRef.nativeElement;
            const firstOption = selectElement.options[0];
            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be
            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.
            return this.focused || selectElement.multiple || !this.empty ||
                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
        }
        else {
            return this.focused || !this.empty;
        }
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    setDescribedByIds(ids) {
        if (ids.length) {
            this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));
        }
        else {
            this._elementRef.nativeElement.removeAttribute('aria-describedby');
        }
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    onContainerClick() {
        // Do not re-focus the input element if the element is already focused. Otherwise it can happen
        // that someone clicks on a time input and the cursor resets to the "hours" field while the
        // "minutes" field was actually clicked. See: https://github.com/angular/components/issues/12849
        if (!this.focused) {
            this.focus();
        }
    }
}
MatInput.ɵfac = function MatInput_Factory(t) { return new (t || MatInput)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* NgControl */.a5, 10), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* NgForm */.F, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* FormGroupDirective */.sg, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_core/* ErrorStateMatcher */.rD), core/* ɵɵdirectiveInject */.Y36(MAT_INPUT_VALUE_ACCESSOR, 10), core/* ɵɵdirectiveInject */.Y36(AutofillMonitor), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(MAT_FORM_FIELD, 8)); };
MatInput.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatInput, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 9, hostBindings: function MatInput_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("focus", function MatInput_focus_HostBindingHandler() { return ctx._focusChanged(true); })("blur", function MatInput_blur_HostBindingHandler() { return ctx._focusChanged(false); })("input", function MatInput_input_HostBindingHandler() { return ctx._onInput(); });
    } if (rf & 2) {
        core/* ɵɵhostProperty */.Ikx("disabled", ctx.disabled)("required", ctx.required);
        core/* ɵɵattribute */.uIk("id", ctx.id)("data-placeholder", ctx.placeholder)("readonly", ctx.readonly && !ctx._isNativeSelect || null)("aria-invalid", ctx.empty && ctx.required ? null : ctx.errorState)("aria-required", ctx.required);
        core/* ɵɵclassProp */.ekj("mat-input-server", ctx._isServer);
    } }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"] }, exportAs: ["matInput"], features: [core/* ɵɵProvidersFeature */._Bn([{ provide: MatFormFieldControl, useExisting: MatInput }]), core/* ɵɵInheritDefinitionFeature */.qOj, core/* ɵɵNgOnChangesFeature */.TTD] });
MatInput.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: platform/* Platform */.t4 },
    { type: fesm2015_forms/* NgControl */.a5, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Self */.PiD }] },
    { type: fesm2015_forms/* NgForm */.F, decorators: [{ type: core/* Optional */.FiY }] },
    { type: fesm2015_forms/* FormGroupDirective */.sg, decorators: [{ type: core/* Optional */.FiY }] },
    { type: fesm2015_core/* ErrorStateMatcher */.rD },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Self */.PiD }, { type: core/* Inject */.tBr, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },
    { type: AutofillMonitor },
    { type: core/* NgZone */.R0b },
    { type: MatFormField, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_FORM_FIELD,] }] }
];
MatInput.propDecorators = {
    disabled: [{ type: core/* Input */.IIB }],
    id: [{ type: core/* Input */.IIB }],
    placeholder: [{ type: core/* Input */.IIB }],
    required: [{ type: core/* Input */.IIB }],
    type: [{ type: core/* Input */.IIB }],
    errorStateMatcher: [{ type: core/* Input */.IIB }],
    userAriaDescribedBy: [{ type: core/* Input */.IIB, args: ['aria-describedby',] }],
    value: [{ type: core/* Input */.IIB }],
    readonly: [{ type: core/* Input */.IIB }],
    _focusChanged: [{ type: core/* HostListener */.L6J, args: ['focus', ['true'],] }, { type: core/* HostListener */.L6J, args: ['blur', ['false'],] }],
    _onInput: [{ type: core/* HostListener */.L6J, args: ['input',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatInput, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `input[matInput], textarea[matInput], select[matNativeControl],
      input[matNativeControl], textarea[matNativeControl]`,
                exportAs: 'matInput',
                host: {
                    /**
                     * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                     */
                    'class': 'mat-input-element mat-form-field-autofill-control',
                    '[class.mat-input-server]': '_isServer',
                    // Native input properties that are overwritten by Angular inputs need to be synced with
                    // the native input element. Otherwise property bindings for those don't work.
                    '[attr.id]': 'id',
                    // At the time of writing, we have a lot of customer tests that look up the input based on its
                    // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen
                    // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.
                    '[attr.data-placeholder]': 'placeholder',
                    '[disabled]': 'disabled',
                    '[required]': 'required',
                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',
                    // Only mark the input as invalid for assistive technology if it has a value since the
                    // state usually overlaps with `aria-required` when the input is empty and can be redundant.
                    '[attr.aria-invalid]': '(empty && required) ? null : errorState',
                    '[attr.aria-required]': 'required'
                },
                providers: [{ provide: MatFormFieldControl, useExisting: MatInput }]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: platform/* Platform */.t4 }, { type: fesm2015_forms/* NgControl */.a5, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Self */.PiD
            }] }, { type: fesm2015_forms/* NgForm */.F, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: fesm2015_forms/* FormGroupDirective */.sg, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: fesm2015_core/* ErrorStateMatcher */.rD }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Self */.PiD
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_INPUT_VALUE_ACCESSOR]
            }] }, { type: AutofillMonitor }, { type: core/* NgZone */.R0b }, { type: MatFormField, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_FORM_FIELD]
            }] }]; }, { id: [{
            type: core/* Input */.IIB
        }], disabled: [{
            type: core/* Input */.IIB
        }], required: [{
            type: core/* Input */.IIB
        }], type: [{
            type: core/* Input */.IIB
        }], value: [{
            type: core/* Input */.IIB
        }], readonly: [{
            type: core/* Input */.IIB
        }], 
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    /** Callback for the cases where the focused state of the input changes. */
    // tslint:disable:no-host-decorator-in-concrete
    // tslint:enable:no-host-decorator-in-concrete
    _focusChanged: [{
            type: core/* HostListener */.L6J,
            args: ['focus', ['true']]
        }, {
            type: core/* HostListener */.L6J,
            args: ['blur', ['false']]
        }], 
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    // tslint:disable-next-line:no-host-decorator-in-concrete
    _onInput: [{
            type: core/* HostListener */.L6J,
            args: ['input']
        }], placeholder: [{
            type: core/* Input */.IIB
        }], errorStateMatcher: [{
            type: core/* Input */.IIB
        }], userAriaDescribedBy: [{
            type: core/* Input */.IIB,
            args: ['aria-describedby']
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatInputModule {
}
MatInputModule.ɵfac = function MatInputModule_Factory(t) { return new (t || MatInputModule)(); };
MatInputModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatInputModule });
MatInputModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [fesm2015_core/* ErrorStateMatcher */.rD], imports: [[
            TextFieldModule,
            MatFormFieldModule,
            fesm2015_core/* MatCommonModule */.BQ,
        ], TextFieldModule,
        // We re-export the `MatFormFieldModule` since `MatInput` will almost always
        // be used together with `MatFormField`.
        MatFormFieldModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatInputModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                declarations: [MatInput, MatTextareaAutosize],
                imports: [
                    TextFieldModule,
                    MatFormFieldModule,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                exports: [
                    TextFieldModule,
                    // We re-export the `MatFormFieldModule` since `MatInput` will almost always
                    // be used together with `MatFormField`.
                    MatFormFieldModule,
                    MatInput,
                    MatTextareaAutosize,
                ],
                providers: [fesm2015_core/* ErrorStateMatcher */.rD]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatInputModule, { declarations: function () { return [MatInput, MatTextareaAutosize]; }, imports: function () { return [TextFieldModule,
        MatFormFieldModule,
        fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [TextFieldModule,
        // We re-export the `MatFormFieldModule` since `MatInput` will almost always
        // be used together with `MatFormField`.
        MatFormFieldModule, MatInput, MatTextareaAutosize]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=input.js.map
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/button.js
var fesm2015_button = __webpack_require__(1095);
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/expansion.js + 1 modules
var expansion = __webpack_require__(171);
;// CONCATENATED MODULE: ./src/app/pages/contact-info/contact-info.component.ts











function ContactInfoComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r4 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 40);
    core/* ɵɵelementStart */.TgZ(2, "div", 41);
    core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r4); const comment_r2 = restoredCtx.$implicit; const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3.utilityService.replyingTo(comment_r2.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 42);
    core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r4); const comment_r2 = restoredCtx.$implicit; const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.utilityService.replyingTo(comment_r2.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 43);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.comment);
} }
class ContactInfoComponent {
    constructor(restService, utilityService) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.email = '';
        this.messageText = '';
        this.utilityService.setTitle(11, 'About');
    }
    sendMessage() {
        if (this.messageText === '') {
        }
        else {
            const message = {
                id: null,
                page: null,
                nickname: localStorage.getItem('f1-chosen-nickname') + ' - ' + this.email,
                comment: this.messageText,
                timestamp: null
            };
            this.restService.sendMessage(message).subscribe({
                next: data => {
                    this.email = '';
                    this.messageText = '';
                    this.utilityService.pushToastrMessage('Message sent.');
                    return data;
                },
                error: error => {
                    this.utilityService.pushToastrMessage('ERROR OCCURED. Message wasn\'t sent.');
                    console.error('There was an error!', error);
                }
            });
        }
    }
}
ContactInfoComponent.ɵfac = function ContactInfoComponent_Factory(t) { return new (t || ContactInfoComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t)); };
ContactInfoComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ContactInfoComponent, selectors: [["app-contact-info-cmp"]], decls: 89, vars: 5, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [1, "col-lg-6", "col-md-6", "pt-2", "pl-4", "col-sm-6"], [1, "card", "card-stats"], [1, "card-header"], [1, "implying"], [1, "card-body"], [1, "col-12", "col-lg-12"], ["list-style-type", "circle"], [1, "col-12", "col-lg-2", "no-right-padding"], [1, "icon-big", "text-center", "icon-warning"], [1, "nc-icon", "nc-minimal-up", "text-warning"], [1, "col-12", "col-lg-10"], [1, "div-padded-mobile"], [1, "pt-2", "col-lg-6", "col-md-6", "col-sm-6"], [1, "nc-icon", "nc-money-coins", "text-warning"], [1, "px-2"], ["hideToggle", ""], ["href", "https://ko-fi.com/sorim", "target", "_blank", 1, "postLinks"], [1, "text-right"], [1, "col-lg-12", "col-md-6", "col-sm-6"], [1, "bg-secondary", "row"], [1, "col-7", "col-md-9"], [1, "text-white"], ["placeholder", "e-mail", "type", "text", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "form-group"], ["matInput", "", "placeholder", "type a message", 1, "form-control", "message-text-area-150", 3, "ngModel", "ngModelChange"], [1, "col-md-2", "no-right-padding"], [1, "nc-icon", "nc-email-85", "text-warning"], ["mat-raised-button", "", 1, "bg-success", "text-white", "height-5-rem", 3, "click"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"]], template: function ContactInfoComponent_Template(rf, ctx) { if (rf & 1) {
        const _r6 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function ContactInfoComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function ContactInfoComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(8); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(8); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, ContactInfoComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r6); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r6); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(20, "div", 3);
        core/* ɵɵelementStart */.TgZ(21, "div", 12);
        core/* ɵɵelementStart */.TgZ(22, "div", 13);
        core/* ɵɵelementStart */.TgZ(23, "div", 14);
        core/* ɵɵelementStart */.TgZ(24, "span", 15);
        core/* ɵɵtext */._uU(25, ">I have a suggestion/complaint");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(26, "hr");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(27, "div", 16);
        core/* ɵɵelementStart */.TgZ(28, "div", 3);
        core/* ɵɵelementStart */.TgZ(29, "div", 17);
        core/* ɵɵelementStart */.TgZ(30, "div");
        core/* ɵɵelementStart */.TgZ(31, "ul", 18);
        core/* ɵɵtext */._uU(32, " - post it in the comments anywhere ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(33, "ul");
        core/* ɵɵtext */._uU(34, " - or send private message below. ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(35, "ul");
        core/* ɵɵtext */._uU(36, " - or e-mail admin@f1exposure.com ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(37, "div", 13);
        core/* ɵɵelementStart */.TgZ(38, "div", 14);
        core/* ɵɵelementStart */.TgZ(39, "span", 15);
        core/* ɵɵtext */._uU(40, "> Is there jigsaw puzzle functionality? ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(41, "hr");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(42, "div", 16);
        core/* ɵɵelementStart */.TgZ(43, "div", 3);
        core/* ɵɵelementStart */.TgZ(44, "div", 19);
        core/* ɵɵelementStart */.TgZ(45, "div", 20);
        core/* ɵɵelement */._UZ(46, "i", 21);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(47, "div", 22);
        core/* ɵɵelementStart */.TgZ(48, "div", 23);
        core/* ɵɵelementStart */.TgZ(49, "p", 16);
        core/* ɵɵtext */._uU(50, "there is no jigsaw puzzle functionality ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(51, "div", 24);
        core/* ɵɵelementStart */.TgZ(52, "div", 13);
        core/* ɵɵelementStart */.TgZ(53, "div", 16);
        core/* ɵɵelementStart */.TgZ(54, "div", 3);
        core/* ɵɵelementStart */.TgZ(55, "div", 19);
        core/* ɵɵelementStart */.TgZ(56, "div", 20);
        core/* ɵɵelement */._UZ(57, "i", 25);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(58, "div", 17);
        core/* ɵɵelementStart */.TgZ(59, "div", 26);
        core/* ɵɵelementStart */.TgZ(60, "mat-accordion");
        core/* ɵɵelementStart */.TgZ(61, "mat-expansion-panel", 27);
        core/* ɵɵelementStart */.TgZ(62, "mat-expansion-panel-header");
        core/* ɵɵelementStart */.TgZ(63, "mat-panel-title");
        core/* ɵɵtext */._uU(64, " Buy me coffee ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(65, "a", 28);
        core/* ɵɵelementStart */.TgZ(66, "div");
        core/* ɵɵtext */._uU(67, "https://ko-fi.com/sorim");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(68, "div", 29);
        core/* ɵɵtext */._uU(69, "DISCLAIMER: I do not drink coffee. I drink tea.");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(70, "div", 30);
        core/* ɵɵelementStart */.TgZ(71, "div", 13);
        core/* ɵɵelementStart */.TgZ(72, "div", 16);
        core/* ɵɵelementStart */.TgZ(73, "div", 31);
        core/* ɵɵelementStart */.TgZ(74, "div", 32);
        core/* ɵɵelementStart */.TgZ(75, "div", 4);
        core/* ɵɵelementStart */.TgZ(76, "label", 33);
        core/* ɵɵtext */._uU(77, "Your contact e-mail (not required)");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(78, "input", 34);
        core/* ɵɵlistener */.NdJ("ngModelChange", function ContactInfoComponent_Template_input_ngModelChange_78_listener($event) { return ctx.email = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(79, "div", 35);
        core/* ɵɵelementStart */.TgZ(80, "label", 33);
        core/* ɵɵtext */._uU(81, "Message");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(82, "textarea", 36);
        core/* ɵɵlistener */.NdJ("ngModelChange", function ContactInfoComponent_Template_textarea_ngModelChange_82_listener($event) { return ctx.messageText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(83, "div", 37);
        core/* ɵɵelementStart */.TgZ(84, "div", 20);
        core/* ɵɵelement */._UZ(85, "i", 38);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(86, "div", 3);
        core/* ɵɵelementStart */.TgZ(87, "button", 39);
        core/* ɵɵlistener */.NdJ("click", function ContactInfoComponent_Template_button_click_87_listener() { return ctx.sendMessage(); });
        core/* ɵɵtext */._uU(88, " Send message ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(65);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.email);
        core/* ɵɵadvance */.xp6(4);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.messageText);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, expansion/* MatAccordion */.pp, expansion/* MatExpansionPanel */.ib, expansion/* MatExpansionPanelHeader */.yz, expansion/* MatExpansionPanelTitle */.yK], encapsulation: 2 });

;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var tslib_es6_assign = function() {
    tslib_es6_assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return tslib_es6_assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js

/**
 * ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Searches `array` for `value`.
 *
 * Returns -1 if not found.
 *
 * @param array  Source array
 * @param value  Value to search
 * @returns Index
 */
function indexOf(array, value) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        // TODO handle NaN
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
}
/**
 * Calls `test` for each element in `array`.
 *
 * If `test` returns `true` then it immediately returns `true`.
 *
 * If `test` returns `false` for all of the elements in `array` then it returns `false`.
 *
 * @param array  Source array
 * @param test   Function which is called on each element
 * @returns Whether `test` returned true or not
 */
function any(array, test) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (test(array[i])) {
            return true;
        }
    }
    return false;
}
/**
 * Calls `fn` function for every member of array and returns a new array out
 * of all outputs.
 *
 * @param array  Source array
 * @param fn     Callback function
 * @returns New array
 */
function map(array, fn) {
    var length = array.length;
    var output = new Array(length);
    for (var i = 0; i < length; ++i) {
        output[i] = fn(array[i], i);
    }
    return output;
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function each(array, fn) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array in reverse order and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachReverse(array, fn) {
    var i = array.length;
    while (i > 0) {
        --i;
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * If `fn` call evaluates to `false`, further iteration is cancelled.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachContinue(array, fn) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (!fn(array[i], i)) {
            break;
        }
    }
}
/**
 * Shifts an item at `index` towards beginning of the array.
 *
 * @param array  Source array
 * @param index  Target element index
 */
function shiftLeft(array, index) {
    var length = array.length;
    for (var i = index; i < length; ++i) {
        array[i - index] = array[i];
    }
    array.length = length - index;
}
/**
 * Returns the last item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function last(array) {
    var length = array.length;
    return length ? array[length - 1] : undefined;
}
/**
 * Returns the first item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function first(array) {
    return array[0];
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * Caps `index` to be between `0` and `array.length`
 *
 * @param array    Source array
 * @param element  Item to insert
 * @param array    Index to insert item at
 */
function insert(array, element, index) {
    //if (array) {
    index = Math.max(0, Math.min(index, array.length));
    array.splice(index, 0, element);
    //}
}
/**
 * Removes all copies of `element` from `array` (if they exist) and then
 * inserts `element` at `index`.
 *
 * @param array    Source array
 * @param element  Item
 * @param array    Index to move item to
 */
function setIndex(array, element, index) {
    remove(array, element);
    insert(array, element, index);
}
/**
 * Pushes all of the elements from `input` into `array`.
 *
 * @param array  Output array
 * @param input  Input array
 */
function pushAll(array, input) {
    var length = input.length;
    for (var i = 0; i < length; ++i) {
        array.push(input[i]);
    }
}
/**
 * Removes `element` from `array`.
 *
 * If there are multiple copies of `element`, they are all removed.
 *
 * @param array    Source array
 * @param element  Item to remove
 */
function remove(array, element) {
    var found = false;
    var index = 0;
    for (;;) {
        index = array.indexOf(element, index);
        if (index === -1) {
            return found;
        }
        else {
            found = true;
            array.splice(index, 1);
        }
    }
}
function removeFirst(array, element) {
    var index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Adds an `element` to `array`.
 *
 * If array already contains and item like this, it is removed before adding
 * it again.
 *
 * Optionally `toIndex` can be specified to add element at specific index.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to move item to
 */
function move(array, element, toIndex) {
    // @todo this implementation must be the same as the List.moveValue method
    // @todo don't do anything if the desired index is the same as the current index
    var index = indexOf(array, element);
    // @todo remove all old values rather than only the first ?
    if (index !== -1) {
        removeIndex(array, index);
    }
    if (toIndex == null) {
        array.push(element);
    }
    else {
        insertIndex(array, toIndex, element);
    }
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to add item at
 */
function add(array, element, index) {
    // Append to the end if index is not set
    if (!$type.isNumber(index)) {
        array.push(element);
    }
    // Add to the beginning of array if index is 0
    else if (index === 0) {
        array.unshift(element);
    }
    // Add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Pushes `element` into `array` if it doesn't already exist.
 *
 * @param array    Source array
 * @param element  Item to add
 */
function pushOne(array, element) {
    if (array.indexOf(element) === -1) {
        array.push(element);
    }
}
/**
 * Removes `element` from `array` (if it exists) and then inserts `element` at
 * `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to remove
 * @param array    Index to move item to
 */
function replace(array, element, index) {
    // check if exists
    var ind = array.indexOf(element);
    // remove if exists
    if (ind !== -1) {
        array.splice(ind, 1);
    }
    // add to end if index is not set
    if (!$type.isNumber(index)) {
        array.push(element);
    }
    // add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Wraps `input` in an array, if it isn't already an array.
 *
 * @param input  Source value
 * @return An array
 */
function toArray(input) {
    if (Array.isArray(input)) {
        return input;
    }
    else {
        return [input];
    }
}
/**
 * Returns `true` if `element` exists in `array`.
 *
 * @param array    Source array
 * @param element  Item to search for
 * @returns Item in array?
 */
function has(array, element) {
    return indexOf(array, element) !== -1;
}
/**
 * Returns a shallow copy of `array`.
 *
 * @param array  Source array
 * @returns Copy of the array
 */
function copy(array) {
    var length = array.length;
    // It's faster to create the array with a pre-defined length
    var output = new Array(length);
    for (var i = 0; i < length; ++i) {
        // Because the array has a pre-defined length, we have to assign rather than push
        // This is also faster than pushing
        output[i] = array[i];
    }
    return output;
}
/**
 * Returns a copy of `array` which contains all the elements between `start`
 * and `end`. (including `start` and excluding `end`)
 *
 * If `end` is not provided, it defaults to `array.length`.
 *
 * @param array  Source array
 * @param start  Start index
 * @param end    End index
 * @returns Part of the array
 */
function slice(array, start, end) {
    if (end === void 0) { end = array.length; }
    var output = new Array(end - start);
    for (var i = start; i < end; ++i) {
        output[i - start] = array[i];
    }
    return output;
}
/**
 * Inserts a value into array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 * @param value  Value to insert
 */
function insertIndex(array, index, value) {
    array.splice(index, 0, value);
}
/**
 * Removes a value from array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 */
function removeIndex(array, index) {
    array.splice(index, 1);
}
/**
 * Searches the array using custom function and returns index of the item if
 * found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns -1.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndex(array, matches) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * This is the same as `findIndex` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndexReverse(array, matches) {
    var i = array.length;
    while (i > 0) {
        --i;
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function find(array, matches) {
    var index = findIndex(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * This is the same as `find` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findReverse(array, matches) {
    var index = findIndexReverse(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If value
 * is not `undefined`, it returns it.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findMap(array, matches) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        var value = matches(array[i], i);
        if (value !== undefined) {
            return value;
        }
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/449477
    var currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}
/**
 * Orders an array using specific `ordering` function and returns right-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getSortedIndex(array, ordering) {
    var start = 0;
    var end = array.length;
    var found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        var pivot = (start + end) >> 1;
        var order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            start = pivot + 1;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: (found ? start - 1 : start)
    };
}
/**
 * Orders an array using specific `ordering` function and returns left-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getFirstSortedIndex(array, ordering) {
    var start = 0;
    var end = array.length;
    var found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        var pivot = (start + end) >> 1;
        var order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            end = pivot;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: start
    };
}
function keepIf(array, keep) {
    var i = array.length;
    while (i > 0) {
        --i;
        if (!keep(array[i])) {
            array.splice(i, 1);
        }
    }
}
//# sourceMappingURL=Array.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * A base class for disposable objects.
 *
 * @ignore Exclude from docs
 */
var DisposerClass = /** @class */ (function () {
    /**
     * Constructor.
     */
    function DisposerClass() {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    Object.defineProperty(DisposerClass.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    /**
     * Disposes the object.
     */
    Object.defineProperty(DisposerClass.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    });
    return DisposerClass;
}());

/**
 * A class for creating an IDisposer.
 *
 * @ignore Exclude from docs
 */
var Disposer = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param dispose  Function that disposes object
     */
    function Disposer(dispose) {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Method that disposes the object.
         */
        Object.defineProperty(this, "_dispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
        this._dispose = dispose;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    Object.defineProperty(Disposer.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    /**
     * Disposes the object.
     */
    Object.defineProperty(Disposer.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    });
    return Disposer;
}());

/**
 * This can be extended by other classes to add a `_disposers` property.
 *
 * @ignore Exclude from docs
 */
var ArrayDisposer = /** @class */ (function (_super) {
    __extends(ArrayDisposer, _super);
    function ArrayDisposer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        return _this;
    }
    Object.defineProperty(ArrayDisposer.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            each(this._disposers, function (x) {
                x.dispose();
            });
        }
    });
    return ArrayDisposer;
}(DisposerClass));

/**
 * A collection of related disposers that can be disposed in one go.
 *
 * @ignore Exclude from docs
 */
var MultiDisposer = /** @class */ (function (_super) {
    __extends(MultiDisposer, _super);
    function MultiDisposer(disposers) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this._disposers = disposers;
        return _this;
    }
    Object.defineProperty(MultiDisposer.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            each(this._disposers, function (x) {
                x.dispose();
            });
        }
    });
    return MultiDisposer;
}(DisposerClass));

/**
 * A special kind of Disposer that has attached value set.
 *
 * If a new value is set using `set()` method, the old disposer value is
 * disposed.
 *
 * @ignore Exclude from docs
 * @todo Description
 */
var MutableValueDisposer = /** @class */ (function (_super) {
    __extends(MutableValueDisposer, _super);
    function MutableValueDisposer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Current disposer.
         */
        Object.defineProperty(_this, "_disposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Current value.
         */
        Object.defineProperty(_this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(MutableValueDisposer.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._disposer != null) {
                this._disposer.dispose();
                this._disposer = undefined;
            }
        }
    });
    /**
     * Returns current value.
     *
     * @return Value
     */
    Object.defineProperty(MutableValueDisposer.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._value;
        }
    });
    /**
     * Sets value and disposes previous disposer if it was set.
     *
     * @param value     New value
     * @param disposer  Disposer
     */
    Object.defineProperty(MutableValueDisposer.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, disposer) {
            if (this._disposer != null) {
                this._disposer.dispose();
            }
            this._disposer = disposer;
            this._value = value;
        }
    });
    /**
     * Resets the disposer value.
     */
    Object.defineProperty(MutableValueDisposer.prototype, "reset", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.set(undefined, undefined);
        }
    });
    return MutableValueDisposer;
}(DisposerClass));

/**
 * @ignore Exclude from docs
 * @todo Description
 */
var CounterDisposer = /** @class */ (function (_super) {
    __extends(CounterDisposer, _super);
    function CounterDisposer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * [_counter description]
         *
         * @todo Description
         */
        Object.defineProperty(_this, "_counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        return _this;
    }
    /**
     * [increment description]
     *
     * @todo Description
     */
    Object.defineProperty(CounterDisposer.prototype, "increment", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            // TODO throw an error if it is disposed
            ++this._counter;
            // TODO make this more efficient
            return new Disposer(function () {
                --_this._counter;
                if (_this._counter === 0) {
                    _this.dispose();
                }
            });
        }
    });
    return CounterDisposer;
}(Disposer));

//# sourceMappingURL=Disposer.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js
/**
 * A collection of utility functions for various type checks and conversion
 * @hidden
 */
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Returns `true` if value is not a number (NaN).
 *
 * @param value Input value
 * @return Is NaN?
 */
function Type_isNaN(value) {
    return Number(value) !== value;
}
/**
 * Returns a type of the value.
 *
 * @param value  Input value
 * @return Type of the value
 * @ignore
 */
function getType(value) {
    return ({}).toString.call(value);
}
/**
 * ============================================================================
 * QUICK CONVERSION
 * ============================================================================
 * @hidden
 */
/**
 * Converts any value into a `number`.
 *
 * @param value  Source value
 * @return Number representation of value
 */
function toNumber(value) {
    if (value != null && !isNumber(value)) {
        var converted = Number(value);
        if (Type_isNaN(converted) && isString(value) && value != "") {
            return toNumber(value.replace(/[^0-9.\-]+/g, ''));
        }
        return converted;
    }
    return value;
}
/**
 * Converts anything to Date object.
 *
 * @param value  A value of any type
 * @return Date object representing a value
 */
function toDate(value) {
    if (isDate(value)) {
        // TODO maybe don't create a new Date ?
        return new Date(value);
    }
    else if (isNumber(value)) {
        return new Date(value);
    }
    else {
        // Try converting to number (assuming timestamp)
        var num = Number(value);
        if (!isNumber(num)) {
            return new Date(value);
        }
        else {
            return new Date(num);
        }
    }
}
/**
 * Converts numeric value into string. Deals with large or small numbers that
 * would otherwise use exponents.
 *
 * @param value  Numeric value
 * @return Numeric value as string
 */
function numberToString(value) {
    // TODO handle Infinity and -Infinity
    if (Type_isNaN(value)) {
        return "NaN";
    }
    if (value === Infinity) {
        return "Infinity";
    }
    if (value === -Infinity) {
        return "-Infinity";
    }
    // Negative 0
    if ((value === 0) && (1 / value === -Infinity)) {
        return "-0";
    }
    // Preserve negative and deal with absoute values
    var negative = value < 0;
    value = Math.abs(value);
    // TODO test this
    var parsed = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value);
    var digits = parsed[1];
    var decimals = parsed[2] || "";
    var res;
    // Leave the nummber as it is if it does not use exponents
    if (parsed[3] === undefined) {
        res = (decimals === "" ? digits : digits + "." + decimals);
    }
    else {
        var exponent = +parsed[3];
        // Deal with decimals
        if (value < 1) {
            var zeros = exponent - 1;
            res = "0." + repeat("0", zeros) + digits + decimals;
            // Deal with integers
        }
        else {
            var zeros = exponent - decimals.length;
            if (zeros === 0) {
                res = digits + decimals;
            }
            else if (zeros < 0) {
                res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
            }
            else {
                res = digits + decimals + repeat("0", zeros);
            }
        }
    }
    return negative ? "-" + res : res;
}
/**
 * Repeats a `string` number of times as set in `amount`.
 *
 * @ignore Exclude from docs
 * @todo Make this faster
 * @param string  Source string
 * @param amount  Number of times to repeat string
 * @return New string
 */
function repeat(string, amount) {
    return new Array(amount + 1).join(string);
}
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Checks if parameter is `Date`.
 *
 * @param value  Input value
 * @return Is Date?
 */
function isDate(value) {
    return getType(value) === "[object Date]";
}
/**
 * Checks if parameter is `string`.
 *
 * @param value  Input value
 * @return Is string?
 */
function isString(value) {
    return typeof value === "string";
}
/**
 * Checks if parameter is `number`.
 *
 * @param value  Input value
 * @return Is number?
 */
function isNumber(value) {
    return typeof value === "number" && Number(value) == value;
}
/**
 * Checks if parameter is `object`.
 *
 * @param value  Input value
 * @return Is object?
 */
function isObject(value) {
    return typeof value === "object" && value !== null;
}
/**
 * Checks if parameter is `Array`.
 *
 * @param value  Input value
 * @return Is Array?
 */
function isArray(value) {
    return Array.isArray(value);
}
/**
 * ============================================================================
 * STATIC CONSTANTS
 * ============================================================================
 * @hidden
 */
/**
 * @ignore Exclude from docs
 */
var PLACEHOLDER = "__§§§__";
/**
 * @ignore Exclude from docs
 */
var PLACEHOLDER2 = "__§§§§__";
//# sourceMappingURL=Type.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js
/**
 * Event Dispatcher module is used for registering listeners and dispatching
 * events across amCharts system.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * Universal Event Dispatcher.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
var EventDispatcher = /** @class */ (function () {
    /**
     * Constructor
     */
    function EventDispatcher() {
        Object.defineProperty(this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_killed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_iterating", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_enabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._listeners = [];
        this._killed = [];
        this._disabled = {};
        this._iterating = 0;
        this._enabled = true;
        this._disposed = false;
    }
    /**
     * Returns if this object has been already disposed.
     *
     * @return Disposed?
     */
    Object.defineProperty(EventDispatcher.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    /**
     * Dispose (destroy) this object.
     */
    Object.defineProperty(EventDispatcher.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                var a = this._listeners;
                this._iterating = 1;
                this._listeners = null;
                this._disabled = null;
                try {
                    each(a, function (x) {
                        x.disposer.dispose();
                    });
                }
                finally {
                    this._killed = null;
                    this._iterating = null;
                }
            }
        }
    });
    /**
     * Checks if this particular event dispatcher has any listeners set.
     *
     * @return Has listeners?
     */
    Object.defineProperty(EventDispatcher.prototype, "hasListeners", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._listeners.length !== 0;
        }
    });
    /**
     * Checks if this particular event dispatcher has any particular listeners set.
     *
     * @return Has particular event listeners?
     */
    Object.defineProperty(EventDispatcher.prototype, "hasListenersByType", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type) {
            return any(this._listeners, function (x) { return (x.type === null || x.type === type) && !x.killed; });
        }
    });
    /**
     * Enable dispatching of events if they were previously disabled by
     * `disable()`.
     */
    Object.defineProperty(EventDispatcher.prototype, "enable", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._enabled = true;
        }
    });
    /**
     * Disable dispatching of events until re-enabled by `enable()`.
     */
    Object.defineProperty(EventDispatcher.prototype, "disable", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._enabled = false;
        }
    });
    /**
     * Enable dispatching particular event, if it was disabled before by
     * `disableType()`.
     *
     * @param type Event type
     */
    Object.defineProperty(EventDispatcher.prototype, "enableType", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type) {
            delete this._disabled[type];
        }
    });
    /**
     * Disable dispatching of events for a certain event type.
     *
     * Optionally, can set how many dispatches to skip before automatically
     * re-enabling the dispatching.
     *
     * @param type    Event type
     * @param amount  Number of event dispatches to skip
     */
    Object.defineProperty(EventDispatcher.prototype, "disableType", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, amount) {
            if (amount === void 0) { amount = Infinity; }
            this._disabled[type] = amount;
        }
    });
    /**
     * Removes listener from dispatcher.
     *
     * Will throw an exception if such listener does not exists.
     *
     * @param listener Listener to remove
     */
    Object.defineProperty(EventDispatcher.prototype, "_removeListener", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (listener) {
            if (this._iterating === 0) {
                var index = this._listeners.indexOf(listener);
                if (index === -1) {
                    throw new Error("Invalid state: could not remove listener");
                }
                this._listeners.splice(index, 1);
            }
            else {
                this._killed.push(listener);
            }
        }
    });
    /**
     * Removes existing listener by certain parameters.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    Object.defineProperty(EventDispatcher.prototype, "_removeExistingListener", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (once, type, callback, context) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            this._eachListener(function (info) {
                if (info.once === once && // TODO is this correct ?
                    info.type === type &&
                    (callback === undefined || info.callback === callback) &&
                    info.context === context) {
                    info.disposer.dispose();
                }
            });
        }
    });
    /**
     * Checks if dispatching for particular event type is enabled.
     *
     * @param type  Event type
     * @return Enabled?
     */
    Object.defineProperty(EventDispatcher.prototype, "isEnabled", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            // TODO is this check correct ?
            return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;
        }
    });
    /**
     * Checks if there's already a listener with specific parameters.
     *
     * @param type      Listener's type
     * @param callback  Callback function
     * @param context   Callback context
     * @return Has listener?
     */
    Object.defineProperty(EventDispatcher.prototype, "has", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, callback, context) {
            var index = findIndex(this._listeners, function (info) {
                return info.once !== true && // Ignoring "once" listeners
                    info.type === type &&
                    (callback === undefined || info.callback === callback) &&
                    info.context === context;
            });
            return index !== -1;
        }
    });
    /**
     * Checks whether event of the particular type should be dispatched.
     *
     * @param type  Event type
     * @return Dispatch?
     */
    Object.defineProperty(EventDispatcher.prototype, "_shouldDispatch", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            var count = this._disabled[type];
            if (!isNumber(count)) {
                return this._enabled;
            }
            else {
                if (count <= 1) {
                    delete this._disabled[type];
                }
                else {
                    --this._disabled[type];
                }
                return false;
            }
        }
    });
    /**
     * [_eachListener description]
     *
     * All of this extra code is needed when a listener is removed while iterating
     *
     * @todo Description
     * @param fn [description]
     */
    Object.defineProperty(EventDispatcher.prototype, "_eachListener", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fn) {
            var _this = this;
            ++this._iterating;
            try {
                each(this._listeners, fn);
            }
            finally {
                --this._iterating;
                // TODO should this be inside or outside the finally ?
                if (this._iterating === 0 && this._killed.length !== 0) {
                    // Remove killed listeners
                    each(this._killed, function (killed) {
                        _this._removeListener(killed);
                    });
                    this._killed.length = 0;
                }
            }
        }
    });
    /**
     * Dispatches an event immediately without waiting for next cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    Object.defineProperty(EventDispatcher.prototype, "dispatch", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, event) {
            if (this._shouldDispatch(type)) {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                // TODO if the function throws, maybe it should keep going ?
                this._eachListener(function (listener) {
                    if (!listener.killed && (listener.type === null || listener.type === type)) {
                        listener.dispatch(type, event);
                    }
                });
            }
        }
    });
    /**
     * Shelves the event to be dispatched within next update cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
        if (this._shouldDispatch(type)) {
            this._eachListener((listener) => {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    // TODO if the function throws, maybe it should keep going ?
                    // TODO dispatch during the update cycle, rather than using whenIdle
                    $async.whenIdle(() => {
                        if (!listener.killed) {
                            listener.dispatch(type, event);
                        }
                    });
                }
            });
        }
    }*/
    /**
     * Creates, catalogs and returns an [[EventListener]].
     *
     * Event listener can be disposed.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @param dispatch
     * @returns An event listener
     */
    Object.defineProperty(EventDispatcher.prototype, "_on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (once, type, callback, context, shouldClone, dispatch) {
            var _this = this;
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            this._removeExistingListener(once, type, callback, context);
            var info = {
                type: type,
                callback: callback,
                context: context,
                shouldClone: shouldClone,
                dispatch: dispatch,
                killed: false,
                once: once,
                disposer: new Disposer(function () {
                    info.killed = true;
                    _this._removeListener(info);
                })
            };
            this._listeners.push(info);
            return info;
        }
    });
    /**
     * Creates an event listener to be invoked on **any** event.
     *
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    Object.defineProperty(EventDispatcher.prototype, "onAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (callback, context, shouldClone) {
            if (shouldClone === void 0) { shouldClone = true; }
            return this._on(false, null, callback, context, shouldClone, function (_type, event) { return callback.call(context, event); }).disposer;
        }
    });
    /**
     * Creates an event listener to be invoked on a specific event type.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler whenever series we put
     * event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    Object.defineProperty(EventDispatcher.prototype, "on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, callback, context, shouldClone) {
            if (shouldClone === void 0) { shouldClone = true; }
            return this._on(false, type, callback, context, shouldClone, function (_type, event) { return callback.call(context, event); }).disposer;
        }
    });
    /**
     * Creates an event listener to be invoked on a specific event type once.
     *
     * Once the event listener is invoked, it is automatically disposed.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler the first time series we
     * put event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    Object.defineProperty(EventDispatcher.prototype, "once", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, callback, context, shouldClone) {
            if (shouldClone === void 0) { shouldClone = true; }
            var x = this._on(true, type, callback, context, shouldClone, function (_type, event) {
                x.disposer.dispose();
                callback.call(context, event);
            });
            // TODO maybe this should return a different Disposer ?
            return x.disposer;
        }
    });
    /**
     * Removes the event listener with specific parameters.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    Object.defineProperty(EventDispatcher.prototype, "off", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, callback, context) {
            this._removeExistingListener(false, type, callback, context);
        }
    });
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    Object.defineProperty(EventDispatcher.prototype, "copyFrom", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (source) {
            var _this = this;
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            if (source === this) {
                throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
            }
            var disposers = [];
            each(source._listeners, function (x) {
                // TODO is this correct ?
                if (!x.killed && x.shouldClone) {
                    if (x.type === null) {
                        disposers.push(_this.onAll(x.callback, x.context));
                    }
                    else if (x.once) {
                        disposers.push(_this.once(x.type, x.callback, x.context));
                    }
                    else {
                        disposers.push(_this.on(x.type, x.callback, x.context));
                    }
                }
            });
            return new MultiDisposer(disposers);
        }
    });
    return EventDispatcher;
}());

/**
 * A version of the [[EventDispatcher]] that dispatches events for a specific
 * target object.
 *
 * @ignore
 */
var TargetedEventDispatcher = /** @class */ (function (_super) {
    __extends(TargetedEventDispatcher, _super);
    /**
     * Constructor
     *
     * @param target Event dispatcher target
     */
    function TargetedEventDispatcher(target) {
        var _this = _super.call(this) || this;
        /**
         * A target object which is originating events using this dispatcher.
         */
        Object.defineProperty(_this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this.target = target;
        return _this;
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    Object.defineProperty(TargetedEventDispatcher.prototype, "copyFrom", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (source) {
            var _this = this;
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            if (source === this) {
                throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
            }
            var disposers = [];
            each(source._listeners, function (x) {
                // TODO very hacky
                if (x.context === source.target) {
                    return;
                }
                // TODO is this correct ?
                if (!x.killed && x.shouldClone) {
                    if (x.type === null) {
                        disposers.push(_this.onAll(x.callback, x.context));
                    }
                    else if (x.once) {
                        disposers.push(_this.once(x.type, x.callback, x.context));
                    }
                    else {
                        disposers.push(_this.on(x.type, x.callback, x.context));
                    }
                }
            });
            return new MultiDisposer(disposers);
        }
    });
    return TargetedEventDispatcher;
}(EventDispatcher));

//# sourceMappingURL=EventDispatcher.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/List.js



/**
 * Checks if specific index fits into length.
 *
 * @param index  Index
 * @param len    Length
 * @ignore
 */
function checkBounds(index, len) {
    if (!(index >= 0 && index < len)) {
        throw new Error("Index out of bounds: " + index);
    }
}
/**
 * A List class is used to hold a number of indexed items of the same type.
 */
var List = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param initial  Inital list of values to add to list
     */
    function List(initial) {
        if (initial === void 0) { initial = []; }
        /**
         * List values.
         */
        Object.defineProperty(this, "_values", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventDispatcher()
        });
        this._values = initial;
    }
    Object.defineProperty(List.prototype, "values", {
        /**
         * An array of values in the list.
         *
         * Do not use this property to add values. Rather use dedicated methods, like
         * `push()`, `removeIndex()`, etc.
         *
         * @readonly
         * @return List values
         */
        get: function () {
            return this._values;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Checks if list contains specific item reference.
     *
     * @param item  Item to search for
     * @return `true` if found, `false` if not found
     */
    Object.defineProperty(List.prototype, "contains", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            return this._values.indexOf(value) !== -1;
        }
    });
    /**
     * Removes specific item from the list.
     *
     * @param item An item to remove
     */
    Object.defineProperty(List.prototype, "removeValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var i = 0;
            var length = this._values.length;
            while (i < length) {
                // TODO handle NaN
                if (this._values[i] === value) {
                    this.removeIndex(i);
                    --length;
                }
                else {
                    ++i;
                }
            }
        }
    });
    /**
     * Searches the list for specific item and returns its index.
     *
     * @param item  An item to search for
     * @return Index or -1 if not found
     */
    Object.defineProperty(List.prototype, "indexOf", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            return indexOf(this._values, value);
        }
    });
    Object.defineProperty(List.prototype, "length", {
        /**
         * Number of items in list.
         *
         * @readonly
         * @return Number of items
         */
        get: function () {
            return this._values.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Checks if there's a value at specific index.
     *
     * @param index  Index
     * @return Value exists?
     */
    Object.defineProperty(List.prototype, "hasIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return index >= 0 && index < this._values.length;
        }
    });
    /**
     * Returns an item at specified index.
     *
     * @param index  Index
     * @return List item
     */
    Object.defineProperty(List.prototype, "getIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return this._values[index];
        }
    });
    Object.defineProperty(List.prototype, "_onPush", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (newValue) {
            if (this.events.isEnabled("push")) {
                this.events.dispatch("push", {
                    type: "push",
                    target: this,
                    newValue: newValue
                });
            }
        }
    });
    Object.defineProperty(List.prototype, "_onInsertIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, newValue) {
            if (this.events.isEnabled("insertIndex")) {
                this.events.dispatch("insertIndex", {
                    type: "insertIndex",
                    target: this,
                    index: index,
                    newValue: newValue
                });
            }
        }
    });
    Object.defineProperty(List.prototype, "_onSetIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, oldValue, newValue) {
            if (this.events.isEnabled("setIndex")) {
                this.events.dispatch("setIndex", {
                    type: "setIndex",
                    target: this,
                    index: index,
                    oldValue: oldValue,
                    newValue: newValue
                });
            }
        }
    });
    Object.defineProperty(List.prototype, "_onRemoveIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, oldValue) {
            if (this.events.isEnabled("removeIndex")) {
                this.events.dispatch("removeIndex", {
                    type: "removeIndex",
                    target: this,
                    index: index,
                    oldValue: oldValue
                });
            }
        }
    });
    Object.defineProperty(List.prototype, "_onMoveIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (oldIndex, newIndex, value) {
            if (this.events.isEnabled("moveIndex")) {
                this.events.dispatch("moveIndex", {
                    type: "moveIndex",
                    target: this,
                    oldIndex: oldIndex,
                    newIndex: newIndex,
                    value: value,
                });
            }
        }
    });
    Object.defineProperty(List.prototype, "_onClear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (oldValues) {
            if (this.events.isEnabled("clear")) {
                this.events.dispatch("clear", {
                    type: "clear",
                    target: this,
                    oldValues: oldValues
                });
            }
        }
    });
    /**
     * Sets value at specific index.
     *
     * If there's already a value at the index, it is overwritten.
     *
     * @param index  Index
     * @param value  New value
     * @return New value
     */
    Object.defineProperty(List.prototype, "setIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, value) {
            checkBounds(index, this._values.length);
            var oldValue = this._values[index];
            // Do nothing if the old value and the new value are the same
            if (oldValue !== value) {
                this._values[index] = value;
                this._onSetIndex(index, oldValue, value);
            }
            return oldValue;
        }
    });
    /**
     * Adds an item to the list at a specific index, which pushes all the other
     * items further down the list.
     *
     * @param index Index
     * @param item  An item to add
     */
    Object.defineProperty(List.prototype, "insertIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, value) {
            checkBounds(index, this._values.length + 1);
            insertIndex(this._values, index, value);
            this._onInsertIndex(index, value);
            return value;
        }
    });
    /**
     * Swaps indexes of two items in the list.
     *
     * @param a  Item 1
     * @param b  Item 2
     */
    Object.defineProperty(List.prototype, "swap", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (a, b) {
            var len = this._values.length;
            checkBounds(a, len);
            checkBounds(b, len);
            if (a !== b) {
                var value_a = this._values[a];
                var value_b = this._values[b];
                this._values[a] = value_b;
                this._onSetIndex(a, value_a, value_b);
                this._values[b] = value_a;
                this._onSetIndex(b, value_b, value_a);
            }
        }
    });
    /**
     * Removes a value at specific index.
     *
     * @param index  Index of value to remove
     * @return Removed value
     */
    Object.defineProperty(List.prototype, "removeIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            checkBounds(index, this._values.length);
            var oldValue = this._values[index];
            removeIndex(this._values, index);
            this._onRemoveIndex(index, oldValue);
            return oldValue;
        }
    });
    /**
     * Moves an item to a specific index within the list.
     *
     * If the index is not specified it will move the item to the end of the
     * list.
     *
     * @param value  Item to move
     * @param index  Index to place item at
     */
    Object.defineProperty(List.prototype, "moveValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, toIndex) {
            // TODO don't do anything if the desired index is the same as the current index
            var index = this.indexOf(value);
            // TODO remove all old values rather than only the first ?
            if (index !== -1) {
                removeIndex(this._values, index);
                if (toIndex == null) {
                    var toIndex_1 = this._values.length;
                    this._values.push(value);
                    this._onMoveIndex(index, toIndex_1, value);
                }
                else {
                    insertIndex(this._values, toIndex, value);
                    this._onMoveIndex(index, toIndex, value);
                }
            }
            else if (toIndex == null) {
                this._values.push(value);
                this._onPush(value);
            }
            else {
                insertIndex(this._values, toIndex, value);
                this._onInsertIndex(toIndex, value);
            }
            return value;
        }
    });
    /**
     * Adds an item to the end of the list.
     *
     * @param item  An item to add
     */
    Object.defineProperty(List.prototype, "push", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            this._values.push(value);
            this._onPush(value);
            return value;
        }
    });
    /**
     * Adds an item as a first item in the list.
     *
     * @param item  An item to add
     */
    Object.defineProperty(List.prototype, "unshift", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            this.insertIndex(0, value);
            return value;
        }
    });
    /**
     * Adds multiple items to the list.
     *
     * @param items  An Array of items to add
     */
    Object.defineProperty(List.prototype, "pushAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (values) {
            var _this = this;
            each(values, function (value) {
                _this.push(value);
            });
        }
    });
    /**
     * Copies and adds items from abother list.
     *
     * @param source  A list top copy items from
     */
    Object.defineProperty(List.prototype, "copyFrom", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (source) {
            this.pushAll(source._values);
        }
    });
    /**
     * Returns the last item from the list, and removes it.
     *
     * @return Item
     */
    Object.defineProperty(List.prototype, "pop", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var index = this._values.length - 1;
            return index < 0 ? undefined : this.removeIndex(this._values.length - 1);
        }
    });
    /**
     * Returns the first item from the list, and removes it.
     *
     * @return Item
     */
    Object.defineProperty(List.prototype, "shift", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._values.length ? this.removeIndex(0) : undefined;
        }
    });
    /**
     * Sets multiple items to the list.
     *
     * All current items are removed.
     *
     * @param newArray  New items
     */
    Object.defineProperty(List.prototype, "setAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (newArray) {
            var _this = this;
            var old = this._values;
            this._values = [];
            this._onClear(old);
            each(newArray, function (value) {
                _this._values.push(value);
                _this._onPush(value);
            });
        }
    });
    /**
     * Removes all items from the list.
     */
    Object.defineProperty(List.prototype, "clear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setAll([]);
        }
    });
    /**
     * Returns an ES6 iterator for the list.
     */
    Object.defineProperty(List.prototype, Symbol.iterator, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var length, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        length = this._values.length;
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._values[i]];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        ++i;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }
    });
    /**
     * Calls `f` for each element in the list.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    Object.defineProperty(List.prototype, "each", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            each(this._values, f);
        }
    });
    /**
     * Calls `f` for each element in the list, from right to left.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    Object.defineProperty(List.prototype, "eachReverse", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            eachReverse(this._values, f);
        }
    });
    return List;
}());

/**
 * A version of a [[List]] where the elements are disposed automatically when
 * removed from the list, unless `autoDispose` is set to `false`.
 */
var ListAutoDispose = /** @class */ (function (_super) {
    __extends(ListAutoDispose, _super);
    function ListAutoDispose() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Automatically disposes elements that are removed from the list.
         *
         * @default true
         */
        Object.defineProperty(_this, "autoDispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(ListAutoDispose.prototype, "_onSetIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, oldValue, newValue) {
            if (this.autoDispose) {
                oldValue.dispose();
            }
            _super.prototype._onSetIndex.call(this, index, oldValue, newValue);
        }
    });
    Object.defineProperty(ListAutoDispose.prototype, "_onRemoveIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, oldValue) {
            if (this.autoDispose) {
                oldValue.dispose();
            }
            _super.prototype._onRemoveIndex.call(this, index, oldValue);
        }
    });
    Object.defineProperty(ListAutoDispose.prototype, "_onClear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (oldValues) {
            if (this.autoDispose) {
                each(oldValues, function (x) {
                    x.dispose();
                });
            }
            _super.prototype._onClear.call(this, oldValues);
        }
    });
    Object.defineProperty(ListAutoDispose.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    Object.defineProperty(ListAutoDispose.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                if (this.autoDispose) {
                    each(this._values, function (x) {
                        x.dispose();
                    });
                }
            }
        }
    });
    return ListAutoDispose;
}(List));

/**
 * A version of a [[List]] that is able to create new elements as well as
 * apply additional settings to newly created items.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info
 */
var ListTemplate = /** @class */ (function (_super) {
    __extends(ListTemplate, _super);
    function ListTemplate(template, make) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "make", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this.template = template;
        _this.make = make;
        return _this;
    }
    return ListTemplate;
}(ListAutoDispose));

//# sourceMappingURL=List.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js



/**
 * A version of [[List]] to hold children of the [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 */
var Children = /** @class */ (function (_super) {
    __extends(Children, _super);
    function Children(container) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this._container = container;
        _this._events = _this.events.onAll(function (change) {
            if (change.type === "clear") {
                each(change.oldValues, function (x) {
                    _this._onRemoved(x);
                });
            }
            else if (change.type === "push") {
                _this._onInserted(change.newValue);
            }
            else if (change.type === "setIndex") {
                _this._onRemoved(change.oldValue);
                _this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "insertIndex") {
                _this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "removeIndex") {
                _this._onRemoved(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                _this._onRemoved(change.value);
                _this._onInserted(change.value, change.newIndex);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        });
        return _this;
    }
    Object.defineProperty(Children.prototype, "_onInserted", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child, index) {
            child._setParent(this._container, true);
            var childrenDisplay = this._container._childrenDisplay;
            if (index === undefined) {
                childrenDisplay.addChild(child._display);
            }
            else {
                childrenDisplay.addChildAt(child._display, index);
            }
        }
    });
    Object.defineProperty(Children.prototype, "_onRemoved", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child) {
            this._container._childrenDisplay.removeChild(child._display);
            this._container.markDirtyBounds();
            this._container.markDirty();
        }
    });
    /**
     * Returns `true` if obejct is disposed.
     */
    Object.defineProperty(Children.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    /**
     * Permanently dispose this object.
     */
    Object.defineProperty(Children.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                this._events.dispose();
                each(this.values, function (child) {
                    child.dispose();
                });
            }
        }
    });
    return Children;
}(List));

//# sourceMappingURL=Children.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a relative value (percent).
 *
 * The Percent object, can be instantiated using two ways:
 *
 * * Via `new Percent(X)`.
 * * Via `am5.percent(X)`.
 *
 * You can also use shortcut functions for `0%`, `50%`, and `100%`:
 * * `am5.p0`
 * * `am5.p50`
 * * `am5.p1000`
 */
var Percent = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param percent  Percent value
     */
    function Percent(percent) {
        /**
         * Value in percent.
         */
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = percent;
    }
    Object.defineProperty(Percent.prototype, "value", {
        /**
         * Relative value.
         *
         * E.g. 100% is 1, 50% is 0.5, etc.
         *
         * This is useful to apply transformations to other values. E.g.:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = new am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = new am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * Alternatively, you can use `am5.percent()` helper function:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * @readonly
         * @return Relative value
         */
        get: function () {
            return this._value / 100;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Percent.prototype, "percent", {
        /**
         * Value in percent.
         *
         * @return Percent
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Percent.prototype, "toString", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return "" + this._value + "%";
        }
    });
    Object.defineProperty(Percent.prototype, "interpolate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (min, max) {
            return min + (this.value * (max - min));
        }
    });
    Object.defineProperty(Percent, "normalize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (percent, min, max) {
            if (percent instanceof Percent) {
                return percent;
            }
            else {
                if (min === max) {
                    return new Percent(0);
                }
                else {
                    return new Percent(Math.min(Math.max((percent - min) * (1 / (max - min)), 0), 1) * 100);
                }
            }
        }
    });
    return Percent;
}());

/**
 * Converts numeric percent value to a proper [[Percent]] object.
 *
 * ```TypeScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 * ```JavaScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 *
 * @param value  Percent
 * @return Percent object
 */
function percent(value) {
    return new Percent(value);
}
/**
 * A shortcut function to `am5.percent(0)`.
 */
var p0 = percent(0);
/**
 * A shortcut function to `am5.percent(100)`.
 */
var p100 = percent(100);
/**
 * A shortcut function to `am5.percent(50)`.
 */
var p50 = percent(50);
/**
 * Checks if value is a [[Percent]] object.
 *
 * @ignore Exclude from docs
 * @param value  Input value
 * @return Is percent?
 */
function isPercent(value) {
    return value instanceof Percent;
}
//# sourceMappingURL=Percent.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js

function keys(object) {
    return Object.keys(object);
}
/**
 * Returns an array of object's property names ordered using specific ordering
 * function.
 *
 * @param object  Source object
 * @param order   Ordering function
 * @returns Object property names
 */
function keysOrdered(object, order) {
    return keys(object).sort(order);
}
function Object_copy(object) {
    return Object.assign({}, object);
}
function Object_each(object, f) {
    keys(object).forEach(function (key) {
        f(key, object[key]);
    });
}
/**
 * Iterates through all properties of the object calling `fn` for each of them.
 *
 * If return value of the function evaluates to `false` further iteration is
 * cancelled.
 *
 * @param object  Source object
 * @param fn      Callback function
 */
function Object_eachContinue(object, fn) {
    for (var key in object) {
        if (hasKey(object, key)) {
            if (!fn(key, object[key])) {
                break;
            }
        }
    }
}
/**
 * Orders object properties using custom `ord` function and iterates through
 * them calling `fn` for each of them.
 *
 * @param object  Source object
 * @param fn      Callback function
 * @param order   Ordering function
 */
function eachOrdered(object, fn, ord) {
    $array.each(keysOrdered(object, ord), function (key) {
        fn(key, object[key]);
    });
}
/**
 * Checks if `object` has a specific `key`.
 *
 * @param object  Source object
 * @param key     Property name
 * @returns Has key?
 */
function hasKey(object, key) {
    return {}.hasOwnProperty.call(object, key);
}
/**
 * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.
 *
 * @param fromObject  Source object
 * @param toObject    Target object
 * @return Updated target object
 * @todo Maybe consolidate with utils.copy?
 */
function softCopyProperties(source, target) {
    Object_each(source, function (key, value) {
        // only if value is set
        //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {
        if (value != null && target[key] == null) {
            target[key] = value;
        }
    });
    return target;
}
//# sourceMappingURL=Object.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js





/**
 * ============================================================================
 * DOM FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Execute a function when DOM is ready.
 *
 * @since 5.0.2
 * @param  f  Callback
 */
function ready(f) {
    if (document.readyState !== "loading") {
        f();
    }
    else {
        var listener_1 = function () {
            if (document.readyState !== "loading") {
                document.removeEventListener("readystatechange", listener_1);
                f();
            }
        };
        document.addEventListener("readystatechange", listener_1);
    }
}
/**
 * Removes a DOM element.
 * @param  el  Target element
 */
function removeElement(el) {
    if (el.parentNode) {
        el.parentNode.removeChild(el);
    }
}
/**
 * Function that adds a disposable event listener directly to a DOM element.
 *
 * @ignore Exclude from docs
 * @param dom       A DOM element to add event to
 * @param type      Event type
 * @param listener  Event listener
 * @returns Disposable event
 */
function addEventListener(dom, type, listener, options) {
    //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)
    //console.log(type, dom);
    dom.addEventListener(type, listener, options || false);
    return new Disposer(function () {
        dom.removeEventListener(type, listener, options || false);
    });
}
/**
 * @ignore
 */
function supports(cap) {
    switch (cap) {
        case "touchevents":
            //return "ontouchstart" in document.documentElement;
            return window.hasOwnProperty("TouchEvent");
        case "pointerevents":
            return window.hasOwnProperty("PointerEvent");
        case "mouseevents":
            return window.hasOwnProperty("MouseEvent");
        case "wheelevents":
            return window.hasOwnProperty("WheelEvent");
        case "keyboardevents":
            return window.hasOwnProperty("KeyboardEvent");
    }
    return false;
}
/**
 * @ignore
 */
function getPointerId(event) {
    var id = event.pointerId || 0;
    //console.log(event);
    return id;
}
/**
 * Removes focus from any element by shifting focus to body.
 *
 * @ignore
 */
function Utils_blur() {
    if (document.activeElement && document.activeElement != document.body) {
        if (document.activeElement.blur) {
            document.activeElement.blur();
        }
        else {
            var input = document.createElement("button");
            input.style.position = "fixed";
            input.style.top = "0px";
            input.style.left = "-10000px";
            document.body.appendChild(input);
            input.focus();
            input.blur();
            document.body.removeChild(input);
        }
    }
}
/**
 * Focuses element.
 *
 * @ignore
 */
function Utils_focus(el) {
    if (el) {
        el.focus();
    }
}
/**
 * @ignore
 */
function getRendererEvent(key) {
    if (supports("pointerevents")) {
        return key;
    }
    else if (supports("touchevents")) {
        switch (key) {
            case "pointerover": return "touchstart";
            case "pointerout": return "touchend";
            case "pointerdown": return "touchstart";
            case "pointermove": return "touchmove";
            case "pointerup": return "touchend";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    else if (supports("mouseevents")) {
        switch (key) {
            case "pointerover": return "mouseover";
            case "pointerout": return "mouseout";
            case "pointerdown": return "mousedown";
            case "pointermove": return "mousemove";
            case "pointerup": return "mouseup";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    return key;
}
/**
 * Determines if pointer event originated from a touch pointer or mouse.
 *
 * @param ev  Original event
 * @return Touch pointer?
 */
function isTouchEvent(ev) {
    if (typeof Touch !== "undefined" && ev instanceof Touch) {
        return true;
    }
    else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && ev.pointerType != null) {
        switch (ev.pointerType) {
            case "touch":
            case "pen":
            case 2:
                return true;
            case "mouse":
            case 4:
                return false;
            default:
                return !(ev instanceof MouseEvent);
        }
    }
    else if (ev.type != null) {
        if (ev.type.match(/^mouse/)) {
            return false;
        }
    }
    return true;
}
/**
 * Sets style property on DOM element.
 *
 * @ignore Exclude from docs
 */
function setStyle(dom, property, value) {
    dom.style[property] = value;
}
function getStyle(dom, property) {
    return dom.style[property];
}
/**
 * Checks of element `a` contains element `b`.
 *
 * @param a  Aleged ascendant
 * @param b  Aleged descendant
 * @return Contains?
 */
function contains(a, b) {
    var cursor = b;
    while (true) {
        if (a === cursor) {
            return true;
        }
        else if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host == null) {
                return false;
            }
            else {
                cursor = cursor.host;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Disables or enables interactivity of a DOM element.
 *
 * @param  target       Target element
 * @param  interactive  Interactive?
 */
function setInteractive(target, interactive) {
    if (interactive) {
        target.style.pointerEvents = "";
    }
    else {
        target.style.pointerEvents = "none";
    }
}
/**
 * Returns the shadow root of the element or null
 *
 * @param a  Node
 * @return Root
 */
function getShadowRoot(a) {
    var cursor = a;
    while (true) {
        if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host != null) {
                return cursor;
            }
            else {
                return null;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * [rootStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
var rootStylesheet;
/**
 * @ignore Exclude from docs
 */
function createStylesheet(element, text, nonce) {
    if (nonce === void 0) { nonce = ""; }
    // TODO use createElementNS ?
    var e = document.createElement("style");
    e.type = "text/css";
    if (nonce != "") {
        e.setAttribute("nonce", nonce);
    }
    e.textContent = text;
    if (element === null) {
        document.head.appendChild(e);
    }
    else {
        element.appendChild(e);
    }
    return e;
}
/**
 * [getStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @return [description]
 */
function getStylesheet(element, nonce) {
    if (nonce === void 0) { nonce = ""; }
    if (element === null) {
        if (rootStylesheet == null) {
            // TODO use createElementNS ?
            var e = document.createElement("style");
            e.type = "text/css";
            if (nonce != "") {
                e.setAttribute("nonce", nonce);
            }
            document.head.appendChild(e);
            rootStylesheet = e.sheet;
        }
        return rootStylesheet;
    }
    else {
        // TODO use createElementNS ?
        var e = document.createElement("style");
        e.type = "text/css";
        if (nonce != "") {
            e.setAttribute("nonce", nonce);
        }
        element.appendChild(e);
        return e.sheet;
    }
}
/**
 * [makeStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param selector  [description]
 * @return [description]
 */
function appendStylesheet(root, selector) {
    var index = root.cssRules.length;
    root.insertRule(selector + "{}", index);
    return root.cssRules[index];
}
/**
 * Defines a class for a CSS rule.
 *
 * Can be used to dynamically add CSS to the document.
 */
var StyleRule = /** @class */ (function (_super) {
    __extends(StyleRule, _super);
    /**
     * Constructor.
     *
     * @param selector  CSS selector
     * @param styles    An object of style attribute - value pairs
     */
    function StyleRule(element, selector, styles, nonce) {
        if (nonce === void 0) { nonce = ""; }
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * CSS rule.
         */
        Object.defineProperty(_this, "_rule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this._root = getStylesheet(element, nonce);
        _this._rule = appendStylesheet(_this._root, selector);
        Object_each(styles, function (key, value) {
            _this.setStyle(key, value);
        });
        return _this;
    }
    Object.defineProperty(StyleRule.prototype, "selector", {
        /**
         * @return CSS selector
         */
        get: function () {
            return this._rule.selectorText;
        },
        /**
         * A CSS selector text.
         *
         * E.g.: `.myClass p`
         *
         * @param selector  CSS selector
         */
        set: function (selector) {
            this._rule.selectorText = selector;
        },
        enumerable: false,
        configurable: true
    });
    // TODO test this
    Object.defineProperty(StyleRule.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // TODO a bit hacky
            var index = indexOf(this._root.cssRules, this._rule);
            if (index === -1) {
                throw new Error("Could not dispose StyleRule");
            }
            else {
                // TODO if it's empty remove it from the DOM ?
                this._root.deleteRule(index);
            }
        }
    });
    /**
     * Sets the same style properties with browser-specific prefixes.
     *
     * @param name   Attribute name
     * @param value  Attribute value
     */
    Object.defineProperty(StyleRule.prototype, "_setVendorPrefixName", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, value) {
            var style = this._rule.style;
            style.setProperty("-webkit-" + name, value, "");
            style.setProperty("-moz-" + name, value, "");
            style.setProperty("-ms-" + name, value, "");
            style.setProperty("-o-" + name, value, "");
            style.setProperty(name, value, "");
        }
    });
    /**
     * Sets a value for specific style attribute.
     *
     * @param name   Attribute
     * @param value  Value
     */
    Object.defineProperty(StyleRule.prototype, "setStyle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, value) {
            if (name === "transition") {
                this._setVendorPrefixName(name, value);
            }
            else {
                this._rule.style.setProperty(name, value, "");
            }
        }
    });
    return StyleRule;
}(DisposerClass));

/**
 * Defines a class for an entire CSS style sheet.
 *
 * Can be used to dynamically add CSS to the document.
 */
var StyleSheet = /** @class */ (function (_super) {
    __extends(StyleSheet, _super);
    /**
     * Constructor.
     *
     * @param text  CSS stylesheet
     */
    function StyleSheet(element, text, nonce) {
        if (nonce === void 0) { nonce = ""; }
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this._element = createStylesheet(element, text, nonce);
        return _this;
    }
    Object.defineProperty(StyleSheet.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._element.parentNode) {
                this._element.parentNode.removeChild(this._element);
            }
        }
    });
    return StyleSheet;
}(DisposerClass));

// /**
//  * Applies a set of styles to an element. Stores the original styles so they
//  * can be restored later.
//  *
//  * @ignore
//  * @param io      Element
//   */
// export function prepElementForDrag(dom: HTMLElement): void {
// 	// @todo: save current values
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "none");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "rgba(0, 0, 0, 0)");
// }
// /**
//  * Restores replaced styles
//  *
//  * @ignore
//  * @param  io  Element
//  */
// export function unprepElementForDrag(dom: HTMLElement): void {
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "");
// }
function iOS() {
    return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function getSafeResolution() {
    return iOS() ? 1 : undefined;
}
function relativeToValue(percent, full) {
    if (isNumber(percent)) {
        return percent;
    }
    else if (percent != null && isNumber(percent.value) && isNumber(full)) {
        return full * percent.value;
    }
    else {
        return 0;
    }
}
/**
 * Returns number of decimals
 *
 * @ignore Exclude from docs
 * @param number  Input number
 * @return Number of decimals
 */
function decimalPlaces(number) {
    var match = ('' + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match) {
        return 0;
    }
    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
}
/**
 * ============================================================================
 * STRING FORMATTING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Pads a string with additional characters to certain length.
 *
 * @param value  A numeric value
 * @param len    Result string length in characters
 * @param char   A character to use for padding
 * @return Padded value as string
 */
function padString(value, len, char) {
    if (len === void 0) { len = 0; }
    if (char === void 0) { char = "0"; }
    if (typeof value !== "string") {
        value = value.toString();
    }
    return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
}
function trimLeft(text) {
    return text.replace(/^[\s]*/, "");
}
function trimRight(text) {
    return text.replace(/[\s]*$/, "");
}
function trim(text) {
    return trimLeft(trimRight(text));
}
/**
 * Tries to determine format type.
 *
 * @ignore Exclude from docs
 * @param format  Format string
 * @return Format type ("string" | "number" | "date" | "duration")
 */
function getFormat(format) {
    // Undefined?
    if (typeof format === "undefined") {
        return "string";
    }
    // Cleanup and lowercase format
    format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
    // Remove style tags
    format = format.replace(/\[[^\]]+\]/, "");
    // Trim
    format = format.trim();
    // Check for any explicit format hints (i.e. /Date)
    var hints = format.match(/\/(date|number|duration)$/);
    if (hints) {
        return hints[1];
    }
    // Check for explicit hints
    if (format === "number") {
        return "number";
    }
    if (format === "date") {
        return "date";
    }
    if (format === "duration") {
        return "duration";
    }
    // Detect number formatting symbols
    if (format.match(/[#0]/)) {
        return "number";
    }
    // Detect date formatting symbols
    if (format.match(/[ymwdhnsqaxkzgtei]/)) {
        return "date";
    }
    // Nothing? Let's display as string
    return "string";
}
/**
 * Cleans up format:
 * * Strips out formatter hints
 *
 * @ignore Exclude from docs
 * @param format  Format
 * @return Cleaned format
 */
function cleanFormat(format) {
    return format.replace(/\/(date|number|duration)$/i, "");
}
/**
 * Strips all tags from the string.
 *
 * @param text  Source string
 * @return String without tags
 */
function stripTags(text) {
    return text ? text.replace(/<[^>]*>/g, "") : text;
}
/**
 * Removes new lines and tags from a string.
 *
 * @param text  String to conver
 * @return Converted string
 */
function plainText(text) {
    return text ? stripTags(("" + text).replace(/[\n\r]+/g, ". ")) : text;
}
/**
 * Escapes string so it can safely be used in a Regex.
 *
 * @param value  Unsescaped string
 * @return Escaped string
 */
function escapeForRgex(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/**
 * ============================================================================
 * DATE-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns a year day.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year day
 * @todo Account for UTC
 */
function getYearDay(date, utc) {
    if (utc === void 0) { utc = false; }
    // TODO: utc needed?
    utc;
    var start = new Date(date.getFullYear(), 0, 0);
    var diff = (date.getTime() - start.getTime()) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
    var oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
}
/**
 * Returns week number for a given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Week number
 * @todo Account for UTC
 */
function getWeek(date, utc) {
    if (utc === void 0) { utc = false; }
    var day = getYearDay(date, utc) - 1;
    var week = Math.floor((day - (date.getDay() || 7) + 10) / 7);
    if (week === 0) {
        week = 53;
    }
    else if (week === 53) {
        week = 1;
    }
    return week;
}
/**
 * Returns a week number in the month.
 *
 * @param date  Source Date
 * @param utc   Assume UTC dates?
 * @return Week number in month
 */
function getMonthWeek(date, utc) {
    if (utc === void 0) { utc = false; }
    var firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
    var currentWeek = getWeek(date, utc);
    if (currentWeek == 1) {
        currentWeek = 53;
    }
    return currentWeek - firstWeek + 1;
}
/**
 * Returns a year day out of the given week number.
 *
 * @param week     Week
 * @param year     Year
 * @param weekday  Weekday
 * @param utc      Assume UTC dates
 * @return Day in a year
 */
function getDayFromWeek(week, year, weekday, utc) {
    if (weekday === void 0) { weekday = 1; }
    if (utc === void 0) { utc = false; }
    var date = new Date(year, 0, 4, 0, 0, 0, 0);
    if (utc) {
        date.setUTCFullYear(year);
    }
    var day = week * 7 + weekday - ((date.getDay() || 7) + 3);
    return day;
}
/**
 * Returns 12-hour representation out of the 24-hour hours.
 *
 * @param hours  24-hour number
 * @return 12-hour number
 */
function get12Hours(hours, base) {
    if (hours > 12) {
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    return base != null ? hours + (base - 1) : hours;
}
/**
 * Returns a string name of the time zone.
 *
 * @param date     Date object
 * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")
 * @param savings  Include information if it's in daylight savings mode
 * @param utc      Assume UTC dates
 * @return Time zone name
 */
function getTimeZone(date, long, savings, utc) {
    if (long === void 0) { long = false; }
    if (savings === void 0) { savings = false; }
    if (utc === void 0) { utc = false; }
    if (utc) {
        return long ? "Coordinated Universal Time" : "UTC";
    }
    var wotz = date.toLocaleString("UTC");
    var wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
    //wtz = wtz.replace(/[+-]+[0-9]+$/, "");
    if (savings === false) {
        wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
    }
    return wtz;
}
function capitalizeFirst(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}
/**
 * The functions below are taken and adapted from Garry Tan's blog post:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * The further attributions go mjijackson.com, which now seems to be defunct.
 */
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param h       The hue
 * @param s       The saturation
 * @param l       The lightness
 * @return The RGB representation
 */
function hslToRgb(color) {
    var r, g, b;
    var h = color.h;
    var s = color.s;
    var l = color.l;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param r       The red color value
 * @param g       The green color value
 * @param b       The blue color value
 * @return The HSL representation
 */
function rgbToHsl(color) {
    var r = color.r / 255;
    var g = color.g / 255;
    var b = color.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var l = (max + min) / 2;
    if (max === min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        l: l
    };
}
/**
 * Returns a color that is `percent` brighter than the reference color.
 *
 * @ignore Exclude from docs
 * @param color    Reference color
 * @param percent  Brightness percent
 * @return Hex code of the new color
 */
function lighten(rgb, percent) {
    if (rgb) {
        return {
            r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),
            g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),
            b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Gets lightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getLightnessStep(value, percent) {
    var base = percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns a color that is `percent` brighter than the source `color`.
 *
 * @ignore Exclude from docs
 * @param color    Source color
 * @param percent  Brightness percent
 * @return New color
 */
function brighten(rgb, percent) {
    if (rgb) {
        var base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);
        //let base = Math.max(rgb.r, rgb.g, rgb.b);
        var step = getLightnessStep(base, percent);
        return {
            r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),
            g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),
            b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Returns brightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getBrightnessStep(_value, percent) {
    var base = 255; //percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns `true` if color is "light". Useful indetermining which contrasting
 * color to use for elements over this color. E.g.: you would want to use
 * black text over light background, and vice versa.
 *
 * @ignore Exclude from docs
 * @param color  Source color
 * @return Light?
 */
function isLight(color) {
    return ((color.r * 299) + (color.g * 587) + (color.b * 114)) / 1000 >= 128;
}
/**
 * Returns a new [[iRGB]] object based on `rgb` parameter with specific
 * saturation applied.
 *
 * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
 * saturated).
 *
 * @ignore Exclude from docs
 * @param color       Base color
 * @param saturation  Saturation (0-1)
 * @return New color
 */
function saturate(rgb, saturation) {
    if (rgb === undefined || saturation == 1) {
        return rgb;
    }
    var hsl = rgbToHsl(rgb);
    hsl.s = saturation;
    return hslToRgb(hsl);
}
function alternativeColor(color, lightAlternative, darkAlternative) {
    if (lightAlternative === void 0) { lightAlternative = { r: 255, g: 255, b: 255 }; }
    if (darkAlternative === void 0) { darkAlternative = { r: 255, g: 255, b: 255 }; }
    var light = lightAlternative;
    var dark = darkAlternative;
    if (isLight(darkAlternative)) {
        light = darkAlternative;
        dark = lightAlternative;
    }
    return isLight(color) ? dark : light;
}
/**
 * @ignore
 * @deprecated
 */
// export function unshiftThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.unshift(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 * @deprecated
 */
// export function pushThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.push(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 */
function mergeTags(tags1, tags2) {
    if (!tags1) {
        tags1 = [];
    }
    return __spreadArray(__spreadArray([], __read(tags1)), __read(tags2)).filter(function (value, index, self) {
        return self.indexOf(value) === index;
    });
}
/**
 * @ignore
 */
function sameBounds(a, b) {
    if (!b) {
        return false;
    }
    if (a.left != b.left) {
        return false;
    }
    if (a.right != b.right) {
        return false;
    }
    if (a.top != b.top) {
        return false;
    }
    if (a.bottom != b.bottom) {
        return false;
    }
    return true;
}
//# sourceMappingURL=Utils.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js



/**
 * @ignore
 */
function string2hex(string) {
    //string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
        string = string.substr(1);
    }
    if (string.length == 3) {
        string = string[0].repeat(2) + string[1].repeat(2) + string[2].repeat(2);
    }
    return parseInt(string, 16);
}
/**
 * @ignore
 */
function rgba2hex(color) {
    color = color.replace(/[ ]/g, "");
    // Init
    var matches = color.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
    // Try rgb() format
    if (matches) {
        matches.push("1");
    }
    else {
        matches = color.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
        if (!matches) {
            return 0x000000;
        }
    }
    var hex = "";
    for (var i = 1; i <= 3; i++) {
        var val = parseInt(matches[i]).toString(16);
        if (val.length == 1) {
            val = "0" + val;
        }
        hex += val;
    }
    return string2hex(hex);
}
/**
 * Returns a new [[Color]] object base on input.
 *
 * Accepts parameters in CSS hex or rgb/rtba strings, or hex numbers.
 *
 * * `"#f00"`
 * * `"#ff0000"`
 * * `"rgb(255, 0, 0)"`
 * * `"rgba(255, 0, 0, 1)"`
 * * `0xff0000`
 *
 * @param   input  Input color
 * @return         Color
 */
function color(input) {
    return Color.fromAny(input);
}
/**
 * Wherever color needs to be specified in amCharts 5, `Color` object needs to
 * be used.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more info
 * @important
 */
var Color = /** @class */ (function () {
    function Color(hex) {
        Object.defineProperty(this, "_hex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._hex = hex | 0;
    }
    Object.defineProperty(Color.prototype, "hex", {
        /**
         * Color numeric value.
         */
        get: function () {
            return this._hex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "r", {
        /**
         * Value of color's R channel.
         * @return R value
         */
        get: function () {
            return this._hex >>> 16;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        /**
         * Value of color's G channel.
         * @return G value
         */
        get: function () {
            return (this._hex >> 8) & 0xFF;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        /**
         * Value of color's B channel.
         * @return B value
         */
        get: function () {
            return this._hex & 0xFF;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
     *
     * @param   alpha  Opacity
     * @return         CSS string
     */
    Object.defineProperty(Color.prototype, "toCSS", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (alpha) {
            if (alpha === void 0) { alpha = 1; }
            return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";
        }
    });
    /**
     * Returns color CSS representation in form of `#rgb` string.
     *
     * @return         CSS string
     */
    Object.defineProperty(Color.prototype, "toCSSHex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return "#" + padString(this.r.toString(16), 2) + padString(this.g.toString(16), 2) + padString(this.b.toString(16), 2);
        }
    });
    /**
     * Returns color's HSL info.
     * @param   alpha Opacity
     * @return        HSL info
     */
    Object.defineProperty(Color.prototype, "toHSL", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (alpha) {
            if (alpha === void 0) { alpha = 1; }
            return rgbToHsl({
                r: this.r,
                g: this.g,
                b: this.b,
                a: alpha
            });
        }
    });
    /**
     * Converts HSL values into a new [[Color]] object.
     *
     * @param   h H value
     * @param   s S value
     * @param   l L value
     * @return    Color object
     */
    Object.defineProperty(Color, "fromHSL", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (h, s, l) {
            var rgb = hslToRgb({
                h: h,
                s: s,
                l: l
            });
            return this.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    });
    Object.defineProperty(Color.prototype, "toString", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.toCSSHex();
        }
    });
    /**
     * Converts hex number into a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromHex(0xff0000) // red
     * ```
     * ```JavaScript
     * Color.fromHex(0xff0000) // red
     * ```
     *
     * @param   hex  Hex color
     * @return       Color
     */
    Object.defineProperty(Color, "fromHex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (hex) {
            return new Color(hex);
        }
    });
    /**
     * Converts RGB values to a new [[Color]] object.
     *
     * @param   r  R value
     * @param   g  G value
     * @param   b  B value
     * @return     Color
     */
    Object.defineProperty(Color, "fromRGB", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (r, g, b) {
            return new Color((b | 0) + (g << 8) + (r << 16));
        }
    });
    /**
     * Converts RGB string to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromString("#ff0000") // red
     * ```
     * ```JavaScript
     * Color.fromString("#ff0000") // red
     * ```
     *
     * @param   s  RGB string
     * @return     Color
     */
    Object.defineProperty(Color, "fromString", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (s) {
            return new Color(string2hex(s));
        }
    });
    /**
     * Converts CSS rgba() syntax to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     * ```JavaScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     *
     * @param  {string} s [description]
     * @return {Color}    [description]
     */
    Object.defineProperty(Color, "fromCSS", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (s) {
            return new Color(rgba2hex(s));
        }
    });
    /**
     * Convert to color from virtually anything.
     *
     * Will throw an exception if unable to resolve the color.
     *
     * @param   s  Source
     * @return     Color
     */
    Object.defineProperty(Color, "fromAny", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (s) {
            if (isString(s)) {
                if (s[0] == "#") {
                    return Color.fromString(s);
                }
                else if (s.substr(0, 3) == "rgb") {
                    return Color.fromCSS(s);
                }
            }
            else if (isNumber(s)) {
                return Color.fromHex(s);
            }
            else if (s instanceof Color) {
                return Color.fromHex(s.hex);
            }
            throw new Error("Unknown color syntax: " + s);
        }
    });
    /**
     * Returns a new [[Color]] object based on either `lightAlternative` or
     * `darkAlternative` depending on which one is more contrasting with
     * the `color`.
     *
     * @param   color             Reference color
     * @param   lightAlternative  Light color
     * @param   darkAlternative   Dark color
     * @return                    Alternative color
     */
    Object.defineProperty(Color, "alternative", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, lightAlternative, darkAlternative) {
            var rgb = alternativeColor({ r: color.r, g: color.g, b: color.b }, lightAlternative ? { r: lightAlternative.r, g: lightAlternative.g, b: lightAlternative.b } : undefined, darkAlternative ? { r: darkAlternative.r, g: darkAlternative.g, b: darkAlternative.b } : undefined);
            return this.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    });
    /**
     * Returns an intermediate Color between two reference colors depending on
     * the progress (`diff`) between the two.
     *
     * @param   diff  Progress
     * @param   from  Source color
     * @param   to    Target color
     * @param   mode  Interpolation mode
     * @return        Color
     */
    Object.defineProperty(Color, "interpolate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (diff, from, to, mode) {
            if (mode === void 0) { mode = "rgb"; }
            if (mode == "hsl") {
                var fromHSL = from.toHSL();
                var toHSL = to.toHSL();
                return Color.fromHSL(range(diff, fromHSL.h, toHSL.h), range(diff, fromHSL.s, toHSL.s), range(diff, fromHSL.l, toHSL.l));
            }
            else {
                return Color.fromRGB(range(diff, from.r, to.r), range(diff, from.g, to.g), range(diff, from.b, to.b));
            }
        }
    });
    /**
     * Returns a new [[Color]] lightened by `percent` value.
     *
     * Use negative value to darken the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    Object.defineProperty(Color, "lighten", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, percent) {
            var rgb = lighten({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    });
    /**
     * Returns a new [[Color]] brightened by `percent` value.
     *
     * Use negative value to dim the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    Object.defineProperty(Color, "brighten", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, percent) {
            var rgb = brighten({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    });
    /**
     * Returns a new [[Color]] saturated by `percent` value.
     *
     * Use negative value to desaturate the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    Object.defineProperty(Color, "saturate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, percent) {
            var rgb = saturate({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    });
    return Color;
}());

//# sourceMappingURL=Color.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js





/**
 * @ignore
 */
function waitForAnimations(animations) {
    return __awaiter(this, void 0, void 0, function () {
        var promises_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(animations !== undefined)) return [3 /*break*/, 2];
                    promises_1 = [];
                    Object_each(animations, function (_, animation) {
                        promises_1.push(animation.waitForStop());
                    });
                    return [4 /*yield*/, Promise.all(promises_1)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
/**
 * @ignore
 */
function normalize(value, min, max) {
    if (min === max) {
        return 0;
    }
    else {
        return Math.min(Math.max((value - min) * (1 / (max - min)), 0), 1);
    }
}
/**
 * @ignore
 */
function range(diff, from, to) {
    return from + (diff * (to - from));
}
/**
 * @ignore
 */
function defaultInterpolate(diff, from, to) {
    if (diff >= 1) {
        return to;
    }
    else {
        return from;
    }
}
/**
 * @ignore
 */
function percentInterpolate(diff, from, to) {
    return new Percent(range(diff, from.percent, to.percent));
}
/**
 * @ignore
 */
function colorInterpolate(diff, from, to) {
    return Color.interpolate(diff, from, to);
}
/**
 * @ignore
 */
function getInterpolate(from, to) {
    if (typeof from === "number" && typeof to === "number") {
        return range;
    }
    if (from instanceof Percent && to instanceof Percent) {
        return percentInterpolate;
    }
    if (from instanceof Color && to instanceof Color) {
        return colorInterpolate;
    }
    return defaultInterpolate;
}
/**
 * @ignore
 */
var AnimationTime = /** @class */ (function () {
    function AnimationTime(entity, duration) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_playingDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_startingTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_current", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventDispatcher()
        });
        Object.defineProperty(this, "easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
        this._duration = duration;
    }
    Object.defineProperty(AnimationTime.prototype, "_stopEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var type = "stopped";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this });
            }
        }
    });
    Object.defineProperty(AnimationTime.prototype, "_runAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            if (this._playingDuration !== null) {
                if (this._startingTime === null) {
                    this._startingTime = currentTime;
                    return false;
                }
                else {
                    var diff = (currentTime - this._startingTime) / this._playingDuration;
                    if (diff >= 1) {
                        this._playingDuration = null;
                        this._startingTime = null;
                        this._from = this._to;
                        this._current = this._to;
                        this._entity.markDirty();
                        this._stopEvent();
                        var type = "ended";
                        if (this.events.isEnabled(type)) {
                            this.events.dispatch(type, { type: type, target: this });
                        }
                        return true;
                    }
                    else {
                        this._current = range(diff, this._from, this._to);
                        this._entity.markDirty();
                        var type = "progress";
                        if (this.events.isEnabled(type)) {
                            this.events.dispatch(type, { type: type, target: this, progress: diff });
                        }
                        return false;
                    }
                }
            }
            else {
                return true;
            }
        }
    });
    Object.defineProperty(AnimationTime.prototype, "_play", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._from = this._current;
            if (this._playingDuration === null) {
                this._entity._root._addAnimation(this);
                var type = "started";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
            else {
                this._startingTime = null;
            }
            this._playingDuration = Math.abs(this._to - this._from) * this._duration;
        }
    });
    Object.defineProperty(AnimationTime.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        set: function (value) {
            if (this._duration !== value) {
                this._duration = value;
                if (value === 0) {
                    this.jumpTo(this._to);
                }
                else if (this._current !== this._to) {
                    this._play();
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationTime.prototype, "current", {
        get: function () {
            if (this.easing) {
                return this.easing(this._current);
            }
            else {
                return this._current;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationTime.prototype, "stop", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.jumpTo(this._current);
        }
    });
    Object.defineProperty(AnimationTime.prototype, "jumpTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            if (this._current !== value) {
                this._entity.markDirty();
            }
            if (this._playingDuration !== null) {
                this._stopEvent();
            }
            this._playingDuration = null;
            this._startingTime = null;
            this._current = value;
            this._from = value;
            this._to = value;
        }
    });
    Object.defineProperty(AnimationTime.prototype, "tweenTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            if (this._current === value || this._duration === 0) {
                this.jumpTo(value);
            }
            else {
                if (this._to !== value) {
                    this._to = value;
                    this._play();
                }
            }
        }
    });
    return AnimationTime;
}());

/*export class AnimationValue extends AnimationTime {
    public _min: number;
    public _max: number;

    constructor(entity: Entity, duration: number, min: number, max: number) {
        super(entity, duration);
        this._min = min;
        this._max = max;
    }

    public get min(): number {
        return this._min;
    }

    public set min(value: number) {
        if (this._min !== value) {
            this._min = value;
            this._entity.markDirty();
        }
    }

    public get max(): number {
        return this._max;
    }

    public set max(value: number) {
        if (this._max !== value) {
            this._max = value;
            this._entity.markDirty();
        }
    }

    public currentValue(): number {
        return range(super.currentTime(), this._min, this._max);
    }

    public jumpToValue(value: number) {
        super.jumpToTime(normalize(value, this._min, this._max));
    }

    public tweenToValue(value: number) {
        super.tweenToTime(normalize(value, this._min, this._max));
    }
}
*/
//# sourceMappingURL=Animation.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js
/**
 * A collection of easing functions
 *
 * Parts of this collection are taken from D3.js library (https://d3js.org/)
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * The functions below are from D3.js library (https://d3js.org/)
 *
 * ----------------------------------------------------------------------------
 * Copyright 2017 Mike Bostock
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	this list of conditions and the following disclaimer in the documentation
 *	and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *	contributors may be used to endorse or promote products derived from this
 *	software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 * @hidden
 */
/**
 */
function linear(t) {
    return t;
}
function quad(t) {
    return t * t;
}
function cubic(t) {
    return t * t * t;
}
function pow(t, e) {
    return Math.pow(t, e);
}
function exp(t) {
    return Math.pow(2, 10 * t - 10);
}
function sine(t) {
    return 1 - Math.cos(t * $math.HALFPI);
}
function circle(t) {
    return 1 - Math.sqrt(1 - t * t);
}
/**
 * ============================================================================
 * TRANSFORMERS
 * ============================================================================
 * @hidden
 */
/**
 */
function yoyo(ease) {
    return function (t) {
        if (t < 0.5) {
            return ease(t * 2.0);
        }
        else {
            return ease((1.0 - t) * 2.0);
        }
    };
}
function out(ease) {
    return function (t) {
        return 1.0 - ease(1.0 - t);
    };
}
function inOut(ease) {
    return function (t) {
        if (t <= 0.5) {
            return ease(t * 2.0) / 2.0;
        }
        else {
            return 1.0 - (ease((1.0 - t) * 2.0) / 2.0);
        }
    };
}
/**
 * ============================================================================
 * BOUNCE
 * ============================================================================
 * @hidden
 */
var b1 = 4 / 11, b2 = (/* unused pure expression or super */ null && (6 / 11)), b3 = (/* unused pure expression or super */ null && (8 / 11)), b4 = (/* unused pure expression or super */ null && (3 / 4)), b5 = (/* unused pure expression or super */ null && (9 / 11)), b6 = (/* unused pure expression or super */ null && (10 / 11)), b7 = (/* unused pure expression or super */ null && (15 / 16)), b8 = (/* unused pure expression or super */ null && (21 / 22)), b9 = (/* unused pure expression or super */ null && (63 / 64)), b0 = 1 / b1 / b1;
function bounce(t) {
    return 1 - bounceOut(1 - t);
}
/**
 * @ignore
 */
function bounceOut(t) {
    t = t;
    if (t < b1) {
        return b0 * t * t;
    }
    else if (t < b3) {
        return b0 * (t -= b2) * t + b4;
    }
    else if (t < b6) {
        return b0 * (t -= b5) * t + b7;
    }
    else {
        return b0 * (t -= b8) * t + b9;
    }
}
/**
 * ============================================================================
 * ELASTIC
 * ============================================================================
 * @hidden
 */
/**
 * @ignore
 */
var tau = 2 * Math.PI;
/**
 * @ignore
 */
var amplitude = 1;
/**
 * @ignore
 */
var period = 0.3 / tau;
/**
 * @ignore
 */
var s = Math.asin(1 / amplitude) * period;
function elastic(t) {
    var v = t;
    return amplitude * Math.pow(2, 10 * --v) * Math.sin((s - v) / period);
}
//# sourceMappingURL=Ease.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/States.js


/**
 * An object representing a collection of setting values to apply as required.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
var State = /** @class */ (function () {
    function State(entity, settings) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
        this._settings = settings;
    }
    Object.defineProperty(State.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(State.prototype, "setRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._settings[key] = value;
        }
    });
    /**
     * Sets a setting `value` for the specified `key` to be set when the state
     * is applied.
     *
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    Object.defineProperty(State.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._userSettings[key] = true;
            this.setRaw(key, value);
        }
    });
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    Object.defineProperty(State.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            delete this._userSettings[key];
            delete this._settings[key];
        }
    });
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    Object.defineProperty(State.prototype, "setAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (settings) {
            var _this = this;
            keys(settings).forEach(function (key) {
                _this.set(key, settings[key]);
            });
        }
    });
    Object.defineProperty(State.prototype, "_eachSetting", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            Object_each(this._settings, f);
        }
    });
    /**
     * Applies the state to the target element.
     *
     * All setting values are set immediately.
     */
    Object.defineProperty(State.prototype, "apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var seen = {};
            seen["stateAnimationEasing"] = true;
            seen["stateAnimationDuration"] = true;
            var defaultState = this._entity.states.lookup("default");
            this._eachSetting(function (key, value) {
                if (!seen[key]) {
                    seen[key] = true;
                    // save values to default state
                    if (_this !== defaultState) {
                        if (!(key in defaultState._settings)) {
                            defaultState._settings[key] = _this._entity.get(key);
                        }
                    }
                    _this._entity.set(key, value);
                }
            });
        }
    });
    /**
     * Applies the state to the target element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @return           Animations
     */
    Object.defineProperty(State.prototype, "applyAnimate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            var _this = this;
            if (duration == null) {
                duration = this._settings.stateAnimationDuration;
            }
            if (duration == null) {
                duration = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0));
            }
            var easing = this._settings.stateAnimationEasing;
            if (easing == null) {
                easing = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", cubic));
            }
            var defaultState = this._entity.states.lookup("default");
            var seen = {};
            seen["stateAnimationEasing"] = true;
            seen["stateAnimationDuration"] = true;
            var animations = {};
            this._eachSetting(function (key, value) {
                if (!seen[key]) {
                    seen[key] = true;
                    // save values to default state
                    if (_this != defaultState) {
                        if (!(key in defaultState._settings)) {
                            defaultState._settings[key] = _this._entity.get(key);
                        }
                    }
                    var animation = _this._entity.animate({
                        key: key,
                        to: value,
                        duration: duration,
                        easing: easing
                    });
                    if (animation) {
                        animations[key] = animation;
                    }
                }
            });
            return animations;
        }
    });
    return State;
}());

/**
 * Collection of [[State]] objects for an element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
var States = /** @class */ (function () {
    function States(entity) {
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
    }
    /**
     * Checks if a state by `name` exists. Returns it there is one.
     *
     * @param  name  State name
     * @return       State
     */
    Object.defineProperty(States.prototype, "lookup", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            return this._states[name];
        }
    });
    /**
     * Sets supplied `settings` on a state by the `name`.
     *
     * If such state does not yet exists, it is created.
     *
     * @param   name      State name
     * @param   settings  Settings
     * @return            New State
     */
    Object.defineProperty(States.prototype, "create", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, settings) {
            var state = this._states[name];
            if (state) {
                state.setAll(settings);
                return state;
            }
            else {
                var state_1 = new State(this._entity, settings);
                this._states[name] = state_1;
                return state_1;
            }
        }
    });
    /**
     * Removes the state called `name`.
     *
     * @param   name      State name
     */
    Object.defineProperty(States.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            delete this._states[name];
        }
    });
    /**
     * Applies a named state to the target element.
     *
     * @param  newState  State name
     */
    Object.defineProperty(States.prototype, "apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (newState) {
            var state = this._states[newState];
            if (state) {
                state.apply();
            }
            this._entity._applyState(newState);
        }
    });
    /**
     * Applies a named state to the element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @param   newState  State name
     * @return            Animations
     */
    Object.defineProperty(States.prototype, "applyAnimate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (newState, duration) {
            var animations;
            var state = this._states[newState];
            if (state) {
                animations = state.applyAnimate(duration);
            }
            this._entity._applyStateAnimated(newState, duration);
            return animations;
        }
    });
    return States;
}());

//# sourceMappingURL=States.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Registry.js
/**
 * @ignore
 */
var Registry = /** @class */ (function () {
    function Registry() {
        /**
         * List of applied licenses.
         * @ignore
         */
        Object.defineProperty(this, "licenses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * Entities that have their `id` setting set.
         */
        Object.defineProperty(this, "entitiesById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        /**
         * All created [[Root]] elements.
         */
        Object.defineProperty(this, "rootElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    return Registry;
}());

/**
    * @ignore
 */
var registry = new Registry();
/**
 * Adds a license, e.g.:
 *
 * ```TypeScript
 * am5.addLicense("xxxxxxxx");
 * ```
 * ```JavaScript
 * am5.addLicense("xxxxxxxx");
 * ```
 *
 * Multiple licenses can be added to cover for multiple products.
 *
 * @param  license  License key
 */
function addLicense(license) {
    registry.licenses.push(license);
}
/**
 * Disposes all [[Root]] elements.
 */
function disposeAllRootElements() {
    var root;
    while (root = registry.rootElements.pop()) {
        root.dispose();
    }
}
//# sourceMappingURL=Registry.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js
/**
 * @ignore
 */
function compare(left, right) {
    if (left === right) {
        return 0;
    }
    else if (left < right) {
        return -1;
    }
    else {
        return 1;
    }
}
/**
 * @ignore
 */
function compareArray(left, right, f) {
    var leftLength = left.length;
    var rightLength = right.length;
    var length = Math.min(leftLength, rightLength);
    for (var i = 0; i < length; ++i) {
        var order = f(left[i], right[i]);
        if (order !== 0) {
            return order;
        }
    }
    return compare(leftLength, rightLength);
}
/**
 * @ignore
 */
function reverse(order) {
    if (order < 0) {
        return 1;
    }
    else if (order > 0) {
        return -1;
    }
    else {
        return 0;
    }
}
/**
 * @ignore
 */
function compareNumber(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=Order.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js










/**
 * Allows to dynamically modify setting value of its target element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
 */
var Adapters = /** @class */ (function () {
    function Adapters(entity) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
    }
    /**
     * Add a function (`callback`) that will modify value for setting `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
     */
    Object.defineProperty(Adapters.prototype, "add", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var callbacks = this._callbacks[key];
            if (callbacks === undefined) {
                callbacks = this._callbacks[key] = [];
            }
            callbacks.push(callback);
            this._entity._markDirtyKey(key);
            return new Disposer(function () {
                if (removeFirst(callbacks, callback)) {
                    _this._entity._markDirtyKey(key);
                }
            });
        }
    });
    /**
     * Removes all adapters for the specific key.
     *
     * @since 5.1.0
     */
    Object.defineProperty(Adapters.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                delete this._callbacks[key];
                if (callbacks.length !== 0) {
                    this._entity._markDirtyKey(key);
                }
            }
        }
    });
    /**
     * Enables (previously disabled) adapters for specific key.
     *
     * @since 5.1.0
     */
    Object.defineProperty(Adapters.prototype, "enable", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (this._disabled[key]) {
                delete this._disabled[key];
                this._entity._markDirtyKey(key);
            }
        }
    });
    /**
     * Disables all adapters for specific key.
     *
     * @since 5.1.0
     */
    Object.defineProperty(Adapters.prototype, "disable", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (!this._disabled[key]) {
                this._disabled[key] = true;
                this._entity._markDirtyKey(key);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Adapters.prototype, "fold", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            if (!this._disabled[key]) {
                var callbacks = this._callbacks[key];
                if (callbacks !== undefined) {
                    for (var i = 0, len = callbacks.length; i < len; ++i) {
                        value = callbacks[i](value, this._entity, key);
                    }
                }
            }
            return value;
        }
    });
    return Adapters;
}());

/**
 * Animation object.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/} for more info
 */
var Animation = /** @class */ (function () {
    function Animation(from, to, duration, easing, loops, startingTime) {
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_loops", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_interpolate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_oldTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_time", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_stopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_playing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventDispatcher()
        });
        this._from = from;
        this._to = to;
        this._duration = duration;
        this._easing = easing;
        this._loops = loops;
        this._interpolate = getInterpolate(from, to);
        this._oldTime = startingTime;
    }
    Object.defineProperty(Animation.prototype, "to", {
        get: function () {
            return this._to;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "from", {
        get: function () {
            return this._from;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "playing", {
        get: function () {
            return this._playing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "stopped", {
        get: function () {
            return this._stopped;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "stop", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._stopped) {
                this._stopped = true;
                this._playing = false;
                if (this.events.isEnabled("stopped")) {
                    this.events.dispatch("stopped", {
                        type: "stopped",
                        target: this,
                    });
                }
            }
        }
    });
    Object.defineProperty(Animation.prototype, "pause", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._playing = false;
            this._oldTime = null;
        }
    });
    Object.defineProperty(Animation.prototype, "play", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._stopped) {
                this._playing = true;
            }
        }
    });
    Object.defineProperty(Animation.prototype, "percentage", {
        get: function () {
            return this._time / this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "waitForStop", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            return new Promise(function (resolve, _reject) {
                if (_this._stopped) {
                    resolve();
                }
                else {
                    var listener = function () {
                        stopped_1.dispose();
                        resolve();
                    };
                    var stopped_1 = _this.events.on("stopped", listener);
                }
            });
        }
    });
    Object.defineProperty(Animation.prototype, "_checkEnded", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._loops > 1) {
                --this._loops;
                return false;
            }
            else {
                return true;
            }
        }
    });
    Object.defineProperty(Animation.prototype, "_run", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            if (this._oldTime !== null) {
                this._time += currentTime - this._oldTime;
                if (this._time > this._duration) {
                    this._time = this._duration;
                }
            }
            this._oldTime = currentTime;
        }
    });
    Object.defineProperty(Animation.prototype, "_reset", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            this._oldTime = currentTime;
            this._time = 0;
        }
    });
    Object.defineProperty(Animation.prototype, "_value", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (diff) {
            return this._interpolate(this._easing(diff), this._from, this._to);
        }
    });
    return Animation;
}());

/**
 * @ignore
 */
var counter = 0;
/**
 * Base class for [[Entity]] objects that support Settings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
 */
var Settings = /** @class */ (function () {
    function Settings(settings) {
        /**
         * Unique ID.
         */
        Object.defineProperty(this, "uid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ++counter
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO move this into Entity
        Object.defineProperty(this, "_userProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._settings = settings;
    }
    Object.defineProperty(Settings.prototype, "_checkDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            keys(this._settings).forEach(function (key) {
                _this._userProperties[key] = true;
                _this._markDirtyKey(key);
            });
        }
    });
    Object.defineProperty(Settings.prototype, "_runAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            var _this = this;
            if (!this.isDisposed()) {
                Object_each(this._animatingSettings, function (key, animation) {
                    if (animation._stopped) {
                        _this._stopAnimation(key);
                    }
                    else if (animation._playing) {
                        animation._run(currentTime);
                        var diff = animation.percentage;
                        if (diff >= 1) {
                            if (animation._checkEnded()) {
                                _this.set(key, animation._value(1));
                            }
                            else {
                                animation._reset(currentTime);
                                _this._set(key, animation._value(1));
                            }
                        }
                        else {
                            _this._set(key, animation._value(diff));
                        }
                    }
                });
                Object_each(this._animatingPrivateSettings, function (key, animation) {
                    if (animation._stopped) {
                        _this._stopAnimationPrivate(key);
                    }
                    else if (animation._playing) {
                        animation._run(currentTime);
                        var diff = animation.percentage;
                        if (diff >= 1) {
                            if (animation._checkEnded()) {
                                _this.setPrivate(key, animation._value(1));
                            }
                            else {
                                animation._reset(currentTime);
                                _this._setPrivate(key, animation._value(1));
                            }
                        }
                        else {
                            _this._setPrivate(key, animation._value(diff));
                        }
                    }
                });
                if (this._animatingCount < 0) {
                    throw new Error("Invalid animation count");
                }
                return this._animatingCount === 0;
            }
            else {
                return true;
            }
        }
    });
    Object.defineProperty(Settings.prototype, "_markDirtyKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_key) {
            this.markDirty();
        }
    });
    Object.defineProperty(Settings.prototype, "_markDirtyPrivateKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_key) {
            this.markDirty();
        }
    });
    /**
     * Sets a callback function to invoke when specific key of settings changes
     * or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @param   key       Settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    Object.defineProperty(Settings.prototype, "on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var events = this._settingEvents[key];
            if (events === undefined) {
                events = this._settingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(function () {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete _this._settingEvents[key];
                }
            });
        }
    });
    /**
     * Sets a callback function to invoke when specific key of private settings
     * changes or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @ignore
     * @param   key       Private settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    Object.defineProperty(Settings.prototype, "onPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var events = this._privateSettingEvents[key];
            if (events === undefined) {
                events = this._privateSettingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(function () {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete _this._privateSettingEvents[key];
                }
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "getRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    Object.defineProperty(Settings.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            return this.getRaw(key, fallback);
        }
    });
    Object.defineProperty(Settings.prototype, "_sendKeyEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var _this = this;
            var events = this._settingEvents[key];
            if (events !== undefined) {
                each(events, function (callback) {
                    callback(value, _this, key);
                });
            }
        }
    });
    Object.defineProperty(Settings.prototype, "_sendPrivateKeyEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var _this = this;
            var events = this._privateSettingEvents[key];
            if (events !== undefined) {
                each(events, function (callback) {
                    callback(value, _this, key);
                });
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "_setRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, old, value) {
            this._prevSettings[key] = old;
            this._sendKeyEvent(key, value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "setRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var old = this._settings[key];
            this._settings[key] = value;
            if (old !== value) {
                this._setRaw(key, old, value);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "_set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var old = this._settings[key];
            this._settings[key] = value;
            if (old !== value) {
                this._setRaw(key, old, value);
                this._markDirtyKey(key);
            }
        }
    });
    Object.defineProperty(Settings.prototype, "_stopAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var animation = this._animatingSettings[key];
            if (animation) {
                delete this._animatingSettings[key];
                --this._animatingCount;
                animation.stop();
            }
        }
    });
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    Object.defineProperty(Settings.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._set(key, value);
            this._stopAnimation(key);
            return value;
        }
    });
    /**
     * Removes a setting value for the specified `key`;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    Object.defineProperty(Settings.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (key in this._settings) {
                this._prevSettings[key] = this._settings[key];
                delete this._settings[key];
                this._sendKeyEvent(key, undefined);
                this._markDirtyKey(key);
            }
            this._stopAnimation(key);
        }
    });
    /**
     * Removes all keys;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     */
    Object.defineProperty(Settings.prototype, "removeAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            each(keys(this._settings), function (key) {
                _this.remove(key);
            });
        }
    });
    /**
     * Returns a value of a private setting.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
     */
    Object.defineProperty(Settings.prototype, "getPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._privateSettings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "_setPrivateRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, old, value) {
            this._prevPrivateSettings[key] = old;
            this._sendPrivateKeyEvent(key, value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "setPrivateRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var old = this._privateSettings[key];
            this._privateSettings[key] = value;
            if (old !== value) {
                this._setPrivateRaw(key, old, value);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "_setPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var old = this._privateSettings[key];
            this._privateSettings[key] = value;
            if (old !== value) {
                this._setPrivateRaw(key, old, value);
                this._markDirtyPrivateKey(key);
            }
        }
    });
    Object.defineProperty(Settings.prototype, "_stopAnimationPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var animation = this._animatingPrivateSettings[key];
            if (animation) {
                animation.stop();
                delete this._animatingPrivateSettings[key];
                --this._animatingCount;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "setPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._setPrivate(key, value);
            this._stopAnimationPrivate(key);
            return value;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "removePrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (key in this._privateSettings) {
                this._prevPrivateSettings[key] = this._privateSettings[key];
                delete this._privateSettings[key];
                this._markDirtyPrivateKey(key);
            }
            this._stopAnimationPrivate(key);
        }
    });
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    Object.defineProperty(Settings.prototype, "setAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (settings) {
            var _this = this;
            Object_each(settings, function (key, value) {
                _this.set(key, value);
            });
        }
    });
    /**
     * Animates setting values from current/start values to new ones.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
     * @param   options  Animation options
     * @return           Animation object
     */
    Object.defineProperty(Settings.prototype, "animate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (options) {
            var key = options.key;
            var to = options.to;
            var duration = options.duration || 0;
            var loops = options.loops || 1;
            var from = (options.from === undefined ? this.get(key) : options.from);
            var easing = (options.easing === undefined ? linear : options.easing);
            if (duration === 0) {
                this.set(key, to);
            }
            else {
                if (from === undefined || from === to) {
                    this.set(key, to);
                }
                else {
                    ++this._animatingCount;
                    this.set(key, from);
                    var animation_1 = this._animatingSettings[key] = new Animation(from, to, duration, easing, loops, this._animationTime());
                    this._startAnimation();
                    return animation_1;
                }
            }
            var animation = new Animation(from, to, duration, easing, loops, null);
            animation.stop();
            return animation;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Settings.prototype, "animatePrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (options) {
            var key = options.key;
            var to = options.to;
            var duration = options.duration || 0;
            var loops = options.loops || 1;
            var from = (options.from === undefined ? this.getPrivate(key) : options.from);
            var easing = (options.easing === undefined ? linear : options.easing);
            if (duration === 0) {
                this.setPrivate(key, to);
            }
            else {
                if (from === undefined || from === to) {
                    this.setPrivate(key, to);
                }
                else {
                    ++this._animatingCount;
                    this.setPrivate(key, from);
                    var animation_2 = this._animatingPrivateSettings[key] = new Animation(from, to, duration, easing, loops, this._animationTime());
                    this._startAnimation();
                    return animation_2;
                }
            }
            var animation = new Animation(from, to, duration, easing, loops, null);
            animation.stop();
            return animation;
        }
    });
    Object.defineProperty(Settings.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    /**
     * Returns `true` if this element is disposed.
     *
     * @return Disposed
     */
    Object.defineProperty(Settings.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    /**
     * Disposes this object.
     */
    Object.defineProperty(Settings.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    });
    return Settings;
}());

/**
 * Base class.
 *
 * @important
 */
var Entity = /** @class */ (function (_super) {
    __extends(Entity, _super);
    /**
     * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
     *
     * Use static method `Class.new()` instead.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @ignore
     */
    function Entity(root, settings, isReal, templates) {
        if (templates === void 0) { templates = []; }
        var _this = _super.call(this, settings) || this;
        Object.defineProperty(_this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_user_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }); // for testing purposes
        Object.defineProperty(_this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new States(_this)
        });
        Object.defineProperty(_this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Adapters(_this)
        });
        Object.defineProperty(_this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._createEvents()
        });
        Object.defineProperty(_this, "_userPrivateProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_dirtyPrivate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Templates for the themes
        Object.defineProperty(_this, "_templates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Internal templates which can be overridden by the user's templates
        Object.defineProperty(_this, "_internalTemplates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Default themes which can be overridden by the user's themes
        Object.defineProperty(_this, "_defaultThemes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Disposers for all of the templates
        Object.defineProperty(_this, "_templateDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Whether the template setup function should be run
        Object.defineProperty(_this, "_runSetup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "_disposerProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        _this._root = root;
        _this._internalTemplates = templates;
        return _this;
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    Object.defineProperty(Entity, "new", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root, settings, template) {
            var x = (new this(root, settings, true));
            x._template = template;
            x._afterNew();
            return x;
        }
    });
    Object.defineProperty(Entity, "_new", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root, settings, templates) {
            if (templates === void 0) { templates = []; }
            var x = (new this(root, settings, true, templates));
            x._afterNew();
            return x;
        }
    });
    Object.defineProperty(Entity.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this._checkDirty();
            var shouldApply = false;
            var template = this._template;
            if (template) {
                shouldApply = true;
                template._setObjectTemplate(this);
            }
            each(this._internalTemplates, function (template) {
                shouldApply = true;
                template._setObjectTemplate(_this);
            });
            if (shouldApply) {
                this._applyTemplates(false);
            }
            this.states.create("default", {});
            this._setDefaults();
        }
    });
    // This is the same as _afterNew, except it also applies the themes.
    // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
    Object.defineProperty(Entity.prototype, "_afterNewApplyThemes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this._checkDirty();
            var template = this._template;
            if (template) {
                template._setObjectTemplate(this);
            }
            each(this._internalTemplates, function (template) {
                template._setObjectTemplate(_this);
            });
            this.states.create("default", {});
            this._setDefaults();
            this._applyThemes();
        }
    });
    Object.defineProperty(Entity.prototype, "_createEvents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return new EventDispatcher();
        }
    });
    Object.defineProperty(Entity.prototype, "classNames", {
        /**
         * @ignore
         */
        get: function () {
            return this.constructor.classNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Entity.prototype, "className", {
        /**
         * @ignore
         */
        get: function () {
            return this.constructor.className;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Entity.prototype, "_setDefaults", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Entity.prototype, "_setDefault", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            if (!(key in this._settings)) {
                _super.prototype.set.call(this, key, value);
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_setRawDefault", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            if (!(key in this._settings)) {
                _super.prototype.setRaw.call(this, key, value);
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            keys(this._dirty).forEach(function (key) {
                _this._dirty[key] = false;
            });
            keys(this._dirtyPrivate).forEach(function (key) {
                _this._dirtyPrivate[key] = false;
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "isDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            return !!this._dirty[key];
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "isPrivateDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            return !!this._dirtyPrivate[key];
        }
    });
    Object.defineProperty(Entity.prototype, "_markDirtyKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            this._dirty[key] = true;
            _super.prototype._markDirtyKey.call(this, key);
        }
    });
    Object.defineProperty(Entity.prototype, "_markDirtyPrivateKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            this._dirtyPrivate[key] = true;
            _super.prototype._markDirtyKey.call(this, key);
        }
    });
    /**
     * Checks if element is of certain class (or inherits one).
     *
     * @param   type  Class name to check
     * @return {boolean} Is of class?
     */
    Object.defineProperty(Entity.prototype, "isType", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type) {
            return this.classNames.indexOf(type) !== -1;
        }
    });
    Object.defineProperty(Entity.prototype, "_pushPropertyDisposer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, disposer) {
            var disposers = this._disposerProperties[key];
            if (disposers === undefined) {
                disposers = this._disposerProperties[key] = [];
            }
            disposers.push(disposer);
            return disposer;
        }
    });
    Object.defineProperty(Entity.prototype, "_disposeProperty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var disposers = this._disposerProperties[key];
            if (disposers !== undefined) {
                each(disposers, function (disposer) {
                    disposer.dispose();
                });
                delete this._disposerProperties[key];
            }
        }
    });
    Object.defineProperty(Entity.prototype, "template", {
        get: function () {
            return this._template;
        },
        /**
         * @todo needs description
         * @param  value  Template
         */
        set: function (value) {
            var template = this._template;
            if (template !== value) {
                this._template = value;
                if (template) {
                    template._removeObjectTemplate(this);
                }
                if (value) {
                    value._setObjectTemplate(this);
                }
                this._applyTemplates();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "markDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._root._addDirtyEntity(this);
        }
    });
    Object.defineProperty(Entity.prototype, "_startAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._root._addAnimation(this);
        }
    });
    Object.defineProperty(Entity.prototype, "_animationTime", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._root.animationTime;
        }
    });
    Object.defineProperty(Entity.prototype, "_applyState", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_name) { }
    });
    Object.defineProperty(Entity.prototype, "_applyStateAnimated", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_name, _duration) { }
    });
    Object.defineProperty(Entity.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this.adapters.fold(key, this._settings[key]);
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    Object.defineProperty(Entity.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._userProperties[key] = true;
            return _super.prototype.set.call(this, key, value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "setRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._userProperties[key] = true;
            _super.prototype.setRaw.call(this, key, value);
        }
    });
    /**
     * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    Object.defineProperty(Entity.prototype, "_setSoft", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            if (!this._userProperties[key]) {
                return _super.prototype.set.call(this, key, value);
            }
            return value;
        }
    });
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    Object.defineProperty(Entity.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            delete this._userProperties[key];
            this._removeTemplateProperty(key);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "setPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._userPrivateProperties[key] = true;
            return _super.prototype.setPrivate.call(this, key, value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "setPrivateRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._userPrivateProperties[key] = true;
            _super.prototype.setPrivateRaw.call(this, key, value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "removePrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            delete this._userPrivateProperties[key];
            this._removeTemplatePrivateProperty(key);
        }
    });
    Object.defineProperty(Entity.prototype, "_setTemplateProperty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (template, key, value) {
            if (!this._userProperties[key]) {
                var match = this._findTemplateByKey(key);
                if (template === match) {
                    _super.prototype.set.call(this, key, value);
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_setTemplatePrivateProperty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (template, key, value) {
            if (!this._userPrivateProperties[key]) {
                var match = this._findTemplateByPrivateKey(key);
                if (template === match) {
                    _super.prototype.setPrivate.call(this, key, value);
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_removeTemplateProperty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (!this._userProperties[key]) {
                var match = this._findTemplateByKey(key);
                if (match) {
                    // TODO don't stop the animation if the property didn't change
                    _super.prototype.set.call(this, key, match._settings[key]);
                }
                else {
                    _super.prototype.remove.call(this, key);
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_removeTemplatePrivateProperty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (!this._userPrivateProperties[key]) {
                var match = this._findTemplateByPrivateKey(key);
                if (match) {
                    // TODO don't stop the animation if the property didn't change
                    _super.prototype.setPrivate.call(this, key, match._privateSettings[key]);
                }
                else {
                    _super.prototype.removePrivate.call(this, key);
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_walkParents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            f(this._root._rootContainer);
            f(this);
        }
    });
    // TODO faster version of this method which is specialized to just 1 key
    Object.defineProperty(Entity.prototype, "_applyStateByKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            var other = this.states.create(name, {});
            var seen = {};
            this._eachTemplate(function (template) {
                var state = template.states.lookup(name);
                if (state) {
                    state._apply(other, seen);
                }
            });
            Object_each(other._settings, function (key) {
                if (!seen[key] && !other._userSettings[key]) {
                    other.remove(key);
                }
            });
        }
    });
    Object.defineProperty(Entity.prototype, "_applyTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (template, state) {
            var _this = this;
            this._templateDisposers.push(template._apply(this, state));
            Object_each(template._settings, function (key, value) {
                if (!state.settings[key] && !_this._userProperties[key]) {
                    state.settings[key] = true;
                    _super.prototype.set.call(_this, key, value);
                }
            });
            Object_each(template._privateSettings, function (key, value) {
                if (!state.privateSettings[key] && !_this._userPrivateProperties[key]) {
                    state.privateSettings[key] = true;
                    _super.prototype.setPrivate.call(_this, key, value);
                }
            });
            if (this._runSetup && template.setup) {
                this._runSetup = false;
                template.setup(this);
            }
        }
    });
    /**
     * Calls the closure with each template and returns the first template which is true
     */
    Object.defineProperty(Entity.prototype, "_findStaticTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            if (this._template) {
                if (f(this._template)) {
                    return this._template;
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_eachTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            this._findStaticTemplate(function (template) {
                f(template);
                return false;
            });
            // _internalTemplates is sorted with most specific to the right
            eachReverse(this._internalTemplates, f);
            // _templates is sorted with most specific to the left
            each(this._templates, f);
        }
    });
    Object.defineProperty(Entity.prototype, "_applyTemplates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (remove) {
            var _this = this;
            if (remove === void 0) { remove = true; }
            if (remove) {
                this._disposeTemplates();
            }
            var state = {
                settings: {},
                privateSettings: {},
                states: {},
            };
            this._eachTemplate(function (template) {
                _this._applyTemplate(template, state);
            });
            if (remove) {
                Object_each(this._settings, function (key) {
                    if (!_this._userProperties[key] && !state.settings[key]) {
                        _super.prototype.remove.call(_this, key);
                    }
                });
                Object_each(this._privateSettings, function (key) {
                    if (!_this._userPrivateProperties[key] && !state.privateSettings[key]) {
                        _super.prototype.removePrivate.call(_this, key);
                    }
                });
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_findTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            var value = this._findStaticTemplate(f);
            if (value === undefined) {
                // _internalTemplates is sorted with most specific to the right
                var value_1 = findReverse(this._internalTemplates, f);
                if (value_1 === undefined) {
                    // _templates is sorted with most specific to the left
                    return find(this._templates, f);
                }
                else {
                    return value_1;
                }
            }
            else {
                return value;
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_findTemplateByKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            return this._findTemplate(function (template) {
                return key in template._settings;
            });
        }
    });
    Object.defineProperty(Entity.prototype, "_findTemplateByPrivateKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            return this._findTemplate(function (template) {
                return key in template._privateSettings;
            });
        }
    });
    Object.defineProperty(Entity.prototype, "_disposeTemplates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            each(this._templateDisposers, function (disposer) {
                disposer.dispose();
            });
            this._templateDisposers.length = 0;
        }
    });
    Object.defineProperty(Entity.prototype, "_removeTemplates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            each(this._templates, function (template) {
                template._removeObjectTemplate(_this);
            });
            this._templates.length = 0;
        }
    });
    Object.defineProperty(Entity.prototype, "_applyThemes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var isConnected = false;
            var defaults = [];
            var themes = [];
            var themeTags = new Set();
            var tags = this.get("themeTagsSelf");
            if (tags) {
                each(tags, function (tag) {
                    themeTags.add(tag);
                });
            }
            this._walkParents(function (entity) {
                if (entity === _this._root._rootContainer) {
                    isConnected = true;
                }
                if (entity._defaultThemes.length > 0) {
                    defaults.push(entity._defaultThemes);
                }
                var theme = entity.get("themes");
                if (theme) {
                    themes.push(theme);
                }
                var tags = entity.get("themeTags");
                if (tags) {
                    each(tags, function (tag) {
                        themeTags.add(tag);
                    });
                }
            });
            themes = defaults.concat(themes);
            this._removeTemplates();
            if (isConnected) {
                eachReverse(this.classNames, function (name) {
                    var allRules = [];
                    each(themes, function (themes) {
                        each(themes, function (theme) {
                            var rules = theme._lookupRules(name);
                            if (rules) {
                                eachReverse(rules, function (rule) {
                                    var matches = rule.tags.every(function (tag) {
                                        return themeTags.has(tag);
                                    });
                                    if (matches) {
                                        var result = getFirstSortedIndex(allRules, function (x) {
                                            var order = compare(rule.tags.length, x.tags.length);
                                            if (order === 0) {
                                                return compareArray(rule.tags, x.tags, compare);
                                            }
                                            else {
                                                return order;
                                            }
                                        });
                                        allRules.splice(result.index, 0, rule);
                                    }
                                });
                            }
                        });
                    });
                    each(allRules, function (rule) {
                        _this._templates.push(rule.template);
                        rule.template._setObjectTemplate(_this);
                    });
                });
            }
            this._applyTemplates();
            if (isConnected) {
                // This causes it to only run the setup function the first time that the themes are applied
                this._runSetup = false;
            }
            return isConnected;
        }
    });
    Object.defineProperty(Entity.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    Object.defineProperty(Entity.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.isDirty("id")) {
                var id = this.get("id");
                if (id) {
                    if (registry.entitiesById[id]) {
                        throw new Error("An entity with id \"" + id + "\" already exists.");
                    }
                    registry.entitiesById[id] = this;
                }
                var prevId = this._prevSettings.id;
                if (prevId) {
                    delete registry.entitiesById[prevId];
                }
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_afterChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "addDisposer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (disposer) {
            this._disposers.push(disposer);
            return disposer;
        }
    });
    Object.defineProperty(Entity.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._dispose.call(this);
            var template = this._template;
            if (template) {
                template._removeObjectTemplate(this);
            }
            each(this._internalTemplates, function (template) {
                template._removeObjectTemplate(_this);
            });
            this._removeTemplates();
            this._disposeTemplates();
            this.events.dispose();
            this._disposers.forEach(function (x) {
                x.dispose();
            });
            Object_each(this._disposerProperties, function (_, disposers) {
                each(disposers, function (disposer) {
                    disposer.dispose();
                });
            });
            var id = this.get("id");
            if (id) {
                delete registry.entitiesById[id];
            }
        }
    });
    /**
     * Creates and returns a "disposable" timeout.
     *
     * @param   fn     Callback
     * @param   delay  Delay in milliseconds
     * @return         Timeout disposer
     */
    Object.defineProperty(Entity.prototype, "setTimeout", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fn, delay) {
            var _this = this;
            var id = setTimeout(function () {
                _this.removeDispose(disposer);
                fn();
            }, delay);
            var disposer = new Disposer(function () {
                clearTimeout(id);
            });
            this._disposers.push(disposer);
            return disposer;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "removeDispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            if (!this.isDisposed()) {
                var index = indexOf(this._disposers, target);
                if (index > -1) {
                    this._disposers.splice(index, 1);
                }
            }
            target.dispose();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "hasTag", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tag) {
            return indexOf(this.get("themeTags", []), tag) !== -1;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "addTag", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tag) {
            if (!this.hasTag(tag)) {
                var tags = this.get("themeTags", []);
                tags.push(tag);
                this.set("themeTags", tags);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Entity.prototype, "removeTag", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tag) {
            if (this.hasTag(tag)) {
                var tags = this.get("themeTags", []);
                remove(tags, tag);
                this.set("themeTags", tags);
            }
        }
    });
    Object.defineProperty(Entity.prototype, "_t", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text, locale) {
            var _a;
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            return (_a = this._root.language).translate.apply(_a, __spreadArray([text, locale], __read(rest)));
        }
    });
    Object.defineProperty(Entity.prototype, "root", {
        /**
         * An instance of [[Root]] object.
         *
         * @readonly
         * @since 5.0.6
         * @return Root object
         */
        get: function () {
            return this._root;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Entity, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Entity"
    });
    Object.defineProperty(Entity, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["Entity"]
    });
    return Entity;
}(Settings));

//# sourceMappingURL=Entity.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js




var TemplateState = /** @class */ (function () {
    function TemplateState(name, template, settings) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._name = name;
        this._template = template;
        this._settings = settings;
    }
    Object.defineProperty(TemplateState.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    Object.defineProperty(TemplateState.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._settings[key] = value;
            // TODO maybe only do this if the value changed ?
            this._template._stateChanged(this._name);
        }
    });
    Object.defineProperty(TemplateState.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            delete this._settings[key];
            // TODO maybe only do this if the value changed ?
            this._template._stateChanged(this._name);
        }
    });
    Object.defineProperty(TemplateState.prototype, "setAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (settings) {
            var _this = this;
            keys(settings).forEach(function (key) {
                _this._settings[key] = settings[key];
            });
            this._template._stateChanged(this._name);
        }
    });
    Object.defineProperty(TemplateState.prototype, "_apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (other, seen) {
            Object_each(this._settings, function (key, value) {
                if (!seen[key] && !other._userSettings[key]) {
                    seen[key] = true;
                    other.setRaw(key, value);
                }
            });
        }
    });
    return TemplateState;
}());

var TemplateStates = /** @class */ (function () {
    function TemplateStates(template) {
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._template = template;
    }
    Object.defineProperty(TemplateStates.prototype, "lookup", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            return this._states[name];
        }
    });
    Object.defineProperty(TemplateStates.prototype, "create", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, settings) {
            var state = this._states[name];
            if (state) {
                state.setAll(settings);
                return state;
            }
            else {
                var state_1 = new TemplateState(name, this._template, settings);
                this._states[name] = state_1;
                this._template._stateChanged(name);
                return state_1;
            }
        }
    });
    Object.defineProperty(TemplateStates.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            delete this._states[name];
            this._template._stateChanged(name);
        }
    });
    Object.defineProperty(TemplateStates.prototype, "_apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity, state) {
            Object_each(this._states, function (key, value) {
                var seen = state.states[key];
                if (seen == null) {
                    seen = state.states[key] = {};
                }
                var other = entity.states.create(key, {});
                value._apply(other, seen);
            });
        }
    });
    return TemplateStates;
}());

var TemplateAdapters = /** @class */ (function () {
    function TemplateAdapters() {
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    Object.defineProperty(TemplateAdapters.prototype, "add", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var callbacks = this._callbacks[key];
            if (callbacks === undefined) {
                callbacks = this._callbacks[key] = [];
            }
            callbacks.push(callback);
            return new Disposer(function () {
                removeFirst(callbacks, callback);
                if (callbacks.length === 0) {
                    delete _this._callbacks[key];
                }
            });
        }
    });
    Object.defineProperty(TemplateAdapters.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                delete this._callbacks[key];
            }
        }
    });
    Object.defineProperty(TemplateAdapters.prototype, "_apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity) {
            var disposers = [];
            Object_each(this._callbacks, function (key, callbacks) {
                each(callbacks, function (callback) {
                    disposers.push(entity.adapters.add(key, callback));
                });
            });
            return new MultiDisposer(disposers);
        }
    });
    return TemplateAdapters;
}());

// TODO maybe extend from Properties ?
var Template = /** @class */ (function () {
    function Template(settings, isReal) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        // TODO code duplication with Properties
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entities", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateStates(this)
        });
        Object.defineProperty(this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateAdapters()
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventDispatcher()
        });
        Object.defineProperty(this, "setup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._settings = settings;
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    Object.defineProperty(Template, "new", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (settings) {
            return new Template(settings, true);
        }
    });
    Object.defineProperty(Template.prototype, "get", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    Object.defineProperty(Template.prototype, "setRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._settings[key] = value;
        }
    });
    Object.defineProperty(Template.prototype, "set", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var _this = this;
            if (this._settings[key] !== value) {
                this.setRaw(key, value);
                this._entities.forEach(function (entity) {
                    entity._setTemplateProperty(_this, key, value);
                });
            }
        }
    });
    Object.defineProperty(Template.prototype, "remove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (key in this._settings) {
                delete this._settings[key];
                this._entities.forEach(function (entity) {
                    entity._removeTemplateProperty(key);
                });
            }
        }
    });
    Object.defineProperty(Template.prototype, "removeAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            Object_each(this._settings, function (key, _value) {
                _this.remove(key);
            });
        }
    });
    Object.defineProperty(Template.prototype, "getPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, fallback) {
            var value = this._privateSettings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
    });
    Object.defineProperty(Template.prototype, "setPrivateRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            this._privateSettings[key] = value;
            return value;
        }
    });
    Object.defineProperty(Template.prototype, "setPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var _this = this;
            if (this._privateSettings[key] !== value) {
                this.setPrivateRaw(key, value);
                this._entities.forEach(function (entity) {
                    entity._setTemplatePrivateProperty(_this, key, value);
                });
            }
            return value;
        }
    });
    Object.defineProperty(Template.prototype, "removePrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            if (key in this._privateSettings) {
                delete this._privateSettings[key];
                this._entities.forEach(function (entity) {
                    entity._removeTemplatePrivateProperty(key);
                });
            }
        }
    });
    Object.defineProperty(Template.prototype, "setAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var _this = this;
            Object_each(value, function (key, value) {
                _this.set(key, value);
            });
        }
    });
    // TODO code duplication with Properties
    Object.defineProperty(Template.prototype, "on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var events = this._settingEvents[key];
            if (events === undefined) {
                events = this._settingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(function () {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete _this._settingEvents[key];
                }
            });
        }
    });
    // TODO code duplication with Properties
    Object.defineProperty(Template.prototype, "onPrivate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback) {
            var _this = this;
            var events = this._privateSettingEvents[key];
            if (events === undefined) {
                events = this._privateSettingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(function () {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete _this._privateSettingEvents[key];
                }
            });
        }
    });
    Object.defineProperty(Template.prototype, "_apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity, state) {
            var disposers = [];
            Object_each(this._settingEvents, function (key, events) {
                each(events, function (event) {
                    disposers.push(entity.on(key, event));
                });
            });
            Object_each(this._privateSettingEvents, function (key, events) {
                each(events, function (event) {
                    disposers.push(entity.onPrivate(key, event));
                });
            });
            this.states._apply(entity, state);
            disposers.push(this.adapters._apply(entity));
            disposers.push(entity.events.copyFrom(this.events));
            return new MultiDisposer(disposers);
        }
    });
    Object.defineProperty(Template.prototype, "_setObjectTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity) {
            this._entities.push(entity);
        }
    });
    Object.defineProperty(Template.prototype, "_removeObjectTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity) {
            remove(this._entities, entity);
        }
    });
    Object.defineProperty(Template.prototype, "_stateChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            this._entities.forEach(function (entity) {
                entity._applyStateByKey(name);
            });
        }
    });
    return Template;
}());

//# sourceMappingURL=Template.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js

/**
 * ============================================================================
 * CONSTANTS
 * ============================================================================
 * @hidden
 */
var PI = Math.PI;
var HALFPI = PI / 2;
var RADIANS = PI / 180;
var DEGREES = 180 / PI;
/**
 * Rounds the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.
 * @return Rounded value
 */
function round(value, precision, floor) {
    if (!isNumber(precision) || precision <= 0) {
        var rounded = Math.round(value);
        if (floor) {
            if (rounded - value == 0.5) {
                rounded--;
            }
        }
        return rounded;
    }
    else {
        var d = Math.pow(10, precision);
        return Math.round(value * d) / d;
    }
}
/**
 * Ceils the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @return Rounded value
 */
function ceil(value, precision) {
    if (!isNumber(precision) || precision <= 0) {
        return Math.ceil(value);
    }
    else {
        var d = Math.pow(10, precision);
        return Math.ceil(value * d) / d;
    }
}
/**
 * [getCubicControlPointA description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {
    return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };
}
/**
 * [getCubicControlPointB description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {
    return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };
}
function fitToRange(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * Returns sine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function sin(angle) {
    return Math.sin(RADIANS * angle);
}
/**
 * Returns tan of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function tan(angle) {
    return Math.tan(RADIANS * angle);
}
/**
 * Returns cosine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Cosine
 */
function cos(angle) {
    return Math.cos(RADIANS * angle);
}
// 0 to 360
function normalizeAngle(value) {
    value = value % 360;
    if (value < 0) {
        value += 360;
    }
    return value;
}
// TODO this doesn't work properly for skewing, and it's probably broken for rotation too
function getArcBounds(cx, cy, startAngle, endAngle, radius) {
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = -Number.MAX_VALUE;
    var maxY = -Number.MAX_VALUE;
    var bpoints = [];
    bpoints.push(getArcPoint(radius, startAngle));
    bpoints.push(getArcPoint(radius, endAngle));
    var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);
    var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);
    for (var angle = fromAngle; angle <= toAngle; angle += 90) {
        if (angle >= startAngle && angle <= endAngle) {
            bpoints.push(getArcPoint(radius, angle));
        }
    }
    for (var i = 0; i < bpoints.length; i++) {
        var pt = bpoints[i];
        if (pt.x < minX) {
            minX = pt.x;
        }
        if (pt.y < minY) {
            minY = pt.y;
        }
        if (pt.x > maxX) {
            maxX = pt.x;
        }
        if (pt.y > maxY) {
            maxY = pt.y;
        }
    }
    return ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });
}
/**
 * Returns point on arc
 *
 * @param center point
 * @param radius
 * @param arc
 * @return {boolean}
 */
function getArcPoint(radius, arc) {
    return ({ x: radius * cos(arc), y: radius * sin(arc) });
}
function mergeBounds(bounds) {
    var len = bounds.length;
    if (len > 0) {
        var bound = bounds[0];
        var left = bound.left;
        var top_1 = bound.top;
        var right = bound.right;
        var bottom = bound.bottom;
        if (len > 1) {
            for (var i = 1; i < len; i++) {
                bound = bounds[i];
                left = Math.min(bound.left, left);
                right = Math.max(bound.right, right);
                top_1 = Math.min(bound.top, top_1);
                bottom = Math.max(bound.bottom, bottom);
            }
        }
        return { left: left, right: right, top: top_1, bottom: bottom };
    }
    return { left: 0, right: 0, top: 0, bottom: 0 };
}
function fitAngleToRange(value, startAngle, endAngle) {
    if (startAngle > endAngle) {
        var temp = startAngle;
        startAngle = endAngle;
        endAngle = temp;
    }
    value = normalizeAngle(value);
    var count = (startAngle - normalizeAngle(startAngle)) / 360;
    if (value < startAngle) {
        value += 360 * (count + 1);
    }
    var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;
    var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;
    if (value > endAngle) {
        if (value - 360 > startAngle) {
            value -= 360;
        }
        else {
            if (value < maxEnd) {
                value = endAngle;
            }
            else {
                value = startAngle;
            }
        }
    }
    if (value < startAngle) {
        if (value > maxStart) {
            value = startAngle;
        }
        else {
            value = endAngle;
        }
    }
    return value;
}
function inBounds(point, bounds) {
    if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {
        return true;
    }
    return false;
}
function getAngle(point1, point2) {
    if (!point2) {
        point2 = { x: point1.x * 2, y: point1.y * 2 };
    }
    var diffX = point2.x - point1.x;
    var diffY = point2.y - point1.y;
    var angle = Math.atan2(diffY, diffX) * DEGREES;
    if (angle < 0) {
        angle += 360;
    }
    return normalizeAngle(angle);
}
/**
 * [getPointOnQuadraticCurve description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param pointA        [description]
 * @param pointB        [description]
 * @param controlPoint  [description]
 * @param position      [description]
 * @return [description]
 */
function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {
    var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;
    var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;
    return { x: x, y: y };
}
function getPointOnLine(pointA, pointB, position) {
    return { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };
}
/**
 * Returns the closest value from the array of values to the reference value.
 *
 * @param values  Array of values
 * @param value   Reference value
 * @return Closes value from the array
 */
function closest(values, referenceValue) {
    return values.reduce(function (prev, curr) {
        return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);
    });
}
function boundsOverlap(bounds1, bounds2) {
    return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);
}
//# sourceMappingURL=Math.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js












//import { populateString } from "../util/PopulateString";
/**
 * An [[EventDispatcher]] for [[Sprite]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
var SpriteEventDispatcher = /** @class */ (function (_super) {
    __extends(SpriteEventDispatcher, _super);
    function SpriteEventDispatcher(sprite) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_sprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_rendererDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_dispatchParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        _this._sprite = sprite;
        return _this;
    }
    Object.defineProperty(SpriteEventDispatcher.prototype, "_makePointerEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, event) {
            return {
                type: key,
                originalEvent: event.event,
                point: event.point,
                simulated: event.simulated,
                native: event.native,
                target: this._sprite
            };
        }
    });
    Object.defineProperty(SpriteEventDispatcher.prototype, "_onRenderer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, dispatch) {
            var _this = this;
            // TODO: is this OK? it'd be good not to require to set this on each individual element
            this._sprite.set("interactive", true);
            this._sprite._display.interactive = true;
            var events = this._rendererDisposers[key];
            if (events === undefined) {
                var disposer_1 = this._sprite._display.on(key, function (e) {
                    dispatch.call(_this, e);
                });
                events = this._rendererDisposers[key] = new CounterDisposer(function () {
                    delete _this._rendererDisposers[key];
                    disposer_1.dispose();
                });
            }
            return events.increment();
        }
    });
    Object.defineProperty(SpriteEventDispatcher.prototype, "_on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (once, type, callback, context, shouldClone, dispatch) {
            var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);
            var rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];
            if (rendererEvent !== undefined) {
                info.disposer = new MultiDisposer([
                    info.disposer,
                    this._onRenderer(type, rendererEvent),
                ]);
            }
            return info;
        }
    });
    /**
     * Will stop any bubbling up of the event to element's parents.
     *
     * Should be called in an event handler, e.g.:
     *
     * ```TypeScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     * ```JavaScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     */
    Object.defineProperty(SpriteEventDispatcher.prototype, "stopParentDispatch", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._dispatchParents = false;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(SpriteEventDispatcher.prototype, "dispatchParents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (type, event) {
            var old = this._dispatchParents;
            this._dispatchParents = true;
            try {
                this.dispatch(type, event);
                if (this._dispatchParents && this._sprite.parent) {
                    this._sprite.parent.events.dispatchParents(type, event);
                }
            }
            finally {
                this._dispatchParents = old;
            }
        }
    });
    Object.defineProperty(SpriteEventDispatcher, "RENDERER_EVENTS", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {
            "click": function (event) {
                if (this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", event))) {
                    this.dispatch("click", this._makePointerEvent("click", event));
                }
            },
            "rightclick": function (event) {
                if (this.isEnabled("rightclick")) {
                    this.dispatch("rightclick", this._makePointerEvent("rightclick", event));
                }
            },
            "middleclick": function (event) {
                if (this.isEnabled("middleclick")) {
                    this.dispatch("middleclick", this._makePointerEvent("middleclick", event));
                }
            },
            "dblclick": function (event) {
                this.dispatchParents("dblclick", this._makePointerEvent("dblclick", event));
            },
            "pointerover": function (event) {
                if (this.isEnabled("pointerover")) {
                    this.dispatch("pointerover", this._makePointerEvent("pointerover", event));
                }
            },
            "pointerout": function (event) {
                if (this.isEnabled("pointerout")) {
                    this.dispatch("pointerout", this._makePointerEvent("pointerout", event));
                }
            },
            "pointerdown": function (event) {
                this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", event));
            },
            "pointerup": function (event) {
                if (this.isEnabled("pointerup")) {
                    this.dispatch("pointerup", this._makePointerEvent("pointerup", event));
                }
            },
            "globalpointerup": function (event) {
                if (this.isEnabled("globalpointerup")) {
                    this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", event));
                }
            },
            "globalpointermove": function (event) {
                if (this.isEnabled("globalpointermove")) {
                    this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", event));
                }
            },
            "wheel": function (event) {
                if (this.isEnabled("wheel")) {
                    this.dispatch("wheel", {
                        type: "wheel",
                        target: this._sprite,
                        originalEvent: event.event,
                        point: event.point,
                    });
                }
            },
        }
    });
    return SpriteEventDispatcher;
}(EventDispatcher));
/**
 * A base class for all visual elements.
 *
 * @important
 */
var Sprite = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    function Sprite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_adjustedLocalBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(_this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(_this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_dataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_templateField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_sizeDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // Will be true only when dragging
        Object.defineProperty(_this, "_isDragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // The event when the dragging starts
        Object.defineProperty(_this, "_dragEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The position when dragging starts
        Object.defineProperty(_this, "_dragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_isHidden", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_isShowing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_isHiding", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_isDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_downPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_downPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_toggleDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_dragDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_tooltipDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_hoverDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_focusDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_tooltipMoveDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_tooltipPointerDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_statesHandled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(Sprite.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setPrivateRaw("visible", true);
            _super.prototype._afterNew.call(this);
        }
    });
    Object.defineProperty(Sprite.prototype, "_markDirtyKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            _super.prototype._markDirtyKey.call(this, key);
            if (key == "x" || key == "y" || key == "dx" || key == "dy") {
                this.markDirtyBounds();
                this._addPercentagePositionChildren();
                this.markDirtyPosition();
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_markDirtyPrivateKey", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            _super.prototype._markDirtyPrivateKey.call(this, key);
            if (key == "x" || key == "y") {
                this.markDirtyPosition();
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_removeTemplateField", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._templateField) {
                this._templateField._removeObjectTemplate(this);
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_createEvents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return new SpriteEventDispatcher(this);
        }
    });
    Object.defineProperty(Sprite.prototype, "_processTemplateField", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var template;
            var field = this.get("templateField");
            if (field) {
                var dataItem = this.dataItem;
                if (dataItem) {
                    var context = dataItem.dataContext;
                    if (context) {
                        template = context[field];
                        if (!(template instanceof Template) && template) {
                            template = Template.new(template);
                        }
                    }
                }
            }
            if (this._templateField !== template) {
                this._removeTemplateField();
                this._templateField = template;
                if (template) {
                    template._setObjectTemplate(this);
                }
                this._applyTemplates();
            }
        }
    });
    // TODO change this to run before the element is added to the parent, so that way
    //      it doesn't need to apply the themes twice
    Object.defineProperty(Sprite.prototype, "_setDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var oldDataItem = this._dataItem;
            this._dataItem = dataItem;
            this._processTemplateField();
            var eventType = "dataitemchanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, {
                    type: eventType,
                    target: this,
                    oldDataItem: oldDataItem,
                    newDataItem: dataItem
                });
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "dataItem", {
        /**
         * @return DataItem
         */
        get: function () {
            if (this._dataItem) {
                return this._dataItem;
            }
            else {
                var parent_1 = this._parent;
                while (parent_1) {
                    if (parent_1._dataItem) {
                        return parent_1._dataItem;
                    }
                    else {
                        parent_1 = parent_1._parent;
                    }
                }
            }
        },
        /**
         * A [[DataItem]] used for this element.
         *
         * NOTE: data item is being assigned automatically in most cases where it
         * matters. Use this accessor to set data item only if you know what you're
         * doing.
         *
         * @param  value  Data item
         */
        set: function (value) {
            this._setDataItem(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "_addPercentageSizeChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var parent = this.parent;
            if (parent) {
                if (this.get("width") instanceof Percent || this.get("height") instanceof Percent) {
                    pushOne(parent._percentageSizeChildren, this);
                }
                else {
                    removeFirst(parent._percentageSizeChildren, this);
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_addPercentagePositionChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var parent = this.parent;
            if (parent) {
                if (this.get("x") instanceof Percent || this.get("y") instanceof Percent) {
                    pushOne(parent._percentagePositionChildren, this);
                }
                else {
                    removeFirst(parent._percentagePositionChildren, this);
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirtyPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._root._addDirtyPosition(this);
        }
    });
    Object.defineProperty(Sprite.prototype, "updatePivotPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var bounds = this._localBounds;
            if (bounds) {
                var centerX = this.get("centerX");
                if (centerX != null) {
                    this._display.pivot.x = bounds.left + relativeToValue(centerX, bounds.right - bounds.left);
                }
                var centerY = this.get("centerY");
                if (centerY != null) {
                    this._display.pivot.y = bounds.top + relativeToValue(centerY, bounds.bottom - bounds.top);
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("tooltip")) {
                var previous = this._prevSettings.tooltip;
                if (previous) {
                    previous.dispose();
                }
            }
            if (this.isDirty("layer")) {
                this._display.setLayer(this.get("layer"));
                this.markDirtyLayer();
            }
            if (this.isDirty("tooltipPosition")) {
                var tooltipMoveDp = this._tooltipMoveDp;
                if (tooltipMoveDp) {
                    tooltipMoveDp.dispose();
                    this._tooltipMoveDp = undefined;
                }
                var tooltipPointerDp = this._tooltipPointerDp;
                if (tooltipPointerDp) {
                    tooltipPointerDp.dispose();
                    this._tooltipPointerDp = undefined;
                }
                if (this.get("tooltipPosition") == "pointer") {
                    this._tooltipPointerDp = new MultiDisposer([
                        this.events.on("pointerover", function () {
                            _this._tooltipMoveDp = _this.events.on("globalpointermove", function (e) {
                                _this.showTooltip(e.point);
                            });
                        }),
                        this.events.on("pointerout", function () {
                            var tooltipMoveDp = _this._tooltipMoveDp;
                            if (tooltipMoveDp) {
                                tooltipMoveDp.dispose();
                                _this._tooltipMoveDp = undefined;
                            }
                        })
                    ]);
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_handleStates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._statesHandled) {
                if (this.isDirty("active")) {
                    if (this.get("active")) {
                        this.states.applyAnimate("active");
                        this.set("ariaChecked", true);
                    }
                    else {
                        if (!this.isHidden()) {
                            this.states.applyAnimate("default");
                        }
                        this.set("ariaChecked", false);
                    }
                    this.markDirtyAccessibility();
                }
                if (this.isDirty("disabled")) {
                    if (this.get("disabled")) {
                        this.states.applyAnimate("disabled");
                        this.set("ariaChecked", false);
                    }
                    else {
                        if (!this.isHidden()) {
                            this.states.applyAnimate("default");
                        }
                        this.set("ariaChecked", true);
                    }
                    this.markDirtyAccessibility();
                }
                this._statesHandled = true;
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._changed.call(this);
            var display = this._display;
            var events = this.events;
            if (this.isDirty("draggable")) {
                var draggable = this.get("draggable");
                if (draggable) {
                    this.set("interactive", true);
                    this._dragDp = new MultiDisposer([
                        events.on("pointerdown", function (ev) {
                            _this.dragStart(ev);
                        }),
                        events.on("globalpointermove", function (ev) {
                            _this.dragMove(ev);
                        }),
                        events.on("globalpointerup", function (ev) {
                            _this.dragStop(ev);
                        })
                    ]);
                }
                else {
                    if (this._dragDp) {
                        this._dragDp.dispose();
                        this._dragDp = undefined;
                    }
                }
            }
            if (this.isDirty("tooltipText")) {
                var tooltipText = this.get("tooltipText");
                if (tooltipText) {
                    this._tooltipDp = new MultiDisposer([
                        events.on("pointerover", function () {
                            _this.showTooltip();
                        }),
                        events.on("pointerout", function () {
                            if (_this.get("showTooltipOn") != "always") {
                                _this.hideTooltip();
                            }
                        })
                    ]);
                }
                else {
                    if (this._tooltipDp) {
                        this._tooltipDp.dispose();
                        this._tooltipDp = undefined;
                    }
                }
            }
            if (this.isDirty("toggleKey")) {
                var toggleKey_1 = this.get("toggleKey");
                if (toggleKey_1 && toggleKey_1 != "none") {
                    this._toggleDp = events.on("click", function () {
                        if (!_this._isDragging) {
                            _this.set(toggleKey_1, !_this.get(toggleKey_1));
                        }
                    });
                }
                else {
                    if (this._toggleDp) {
                        this._toggleDp.dispose();
                        this._toggleDp = undefined;
                    }
                }
            }
            this._handleStates();
            if (this.isDirty("opacity")) {
                display.alpha = Math.max(0, this.get("opacity", 1));
            }
            if (this.isDirty("rotation")) {
                this.markDirtyBounds();
                display.angle = this.get("rotation", 0);
            }
            if (this.isDirty("scale")) {
                this.markDirtyBounds();
                display.scale = this.get("scale", 0);
            }
            if (this.isDirty("centerX") || this.isDirty("centerY")) {
                this.markDirtyBounds();
                this.updatePivotPoint();
            }
            if (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) {
                if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                    display.visible = false;
                    this.hideTooltip();
                }
                else {
                    display.visible = true;
                }
                this.markDirtyBounds();
                if (this.get("focusable")) {
                    this.markDirtyAccessibility();
                }
            }
            if (this.isDirty("width") || this.isDirty("height")) {
                this.markDirtyBounds();
                this._addPercentageSizeChildren();
                var parent_2 = this.parent;
                if (parent_2) {
                    if ((this.isDirty("width") && this.get("width") instanceof Percent) || (this.isDirty("height") && this.get("height") instanceof Percent)) {
                        parent_2.markDirty();
                        parent_2._prevWidth = 0;
                    }
                }
                this._sizeDirty = true;
            }
            if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this.markDirtyBounds();
                this._sizeDirty = true;
            }
            if (this._sizeDirty) {
                this._updateSize();
            }
            if (this.isDirty("wheelable")) {
                var wheelable = this.get("wheelable");
                if (wheelable) {
                    this.set("interactive", true);
                }
                display.wheelable = wheelable ? true : false;
            }
            // Accessibility
            if (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) {
                if (this.get("focusable")) {
                    this._root._registerTabindexOrder(this);
                }
                else {
                    this._root._unregisterTabindexOrder(this);
                }
            }
            if (this.isDirty("filter")) {
                //this.markDirtyBounds();
                display.filter = this.get("filter");
            }
            if (this.isDirty("cursorOverStyle")) {
                display.cursorOverStyle = this.get("cursorOverStyle");
            }
            if (this.isDirty("hoverOnFocus")) {
                if (this.get("hoverOnFocus")) {
                    this._focusDp = new MultiDisposer([
                        events.on("focus", function () {
                            // TODO: proper hover, not just tooltip
                            _this.showTooltip();
                        }),
                        events.on("blur", function () {
                            // TODO: proper hover, not just tooltip
                            _this.hideTooltip();
                        })
                    ]);
                }
                else {
                    if (this._focusDp) {
                        this._focusDp.dispose();
                        this._focusDp = undefined;
                    }
                }
            }
            if (this.isDirty("focusable")) {
                if (this.get("focusable")) {
                    this._root._registerTabindexOrder(this);
                }
                else {
                    this._root._unregisterTabindexOrder(this);
                }
                this.markDirtyAccessibility();
            }
            if (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) {
                // display.accessibility.ariaLabel = populateString(this, this.get("ariaLabel", ""));
                // @todo make sure ariaLabel gets populated in Root
                this.markDirtyAccessibility();
            }
            if (this.isDirty("exportable")) {
                display.exportable = this.get("exportable");
            }
            if (this.isDirty("interactive")) {
                var events_1 = this.events;
                if (this.get("interactive")) {
                    this._hoverDp = new MultiDisposer([
                        events_1.on("click", function (ev) {
                            if (isTouchEvent(ev.originalEvent)) {
                                if (!_this.getPrivate("touchHovering")) {
                                    _this.setTimeout(function () {
                                        _this._handleOver();
                                        if (_this.get("tooltipText")) {
                                            _this.showTooltip();
                                        }
                                        _this.setPrivateRaw("touchHovering", true);
                                    }, 10);
                                }
                            }
                        }),
                        events_1.on("globalpointerup", function (ev) {
                            if (isTouchEvent(ev.originalEvent)) {
                                if (_this.getPrivate("touchHovering")) {
                                    _this._handleOut();
                                    if (_this.get("tooltipText")) {
                                        _this.hideTooltip();
                                    }
                                }
                                _this.setPrivateRaw("touchHovering", false);
                            }
                            if (_this._isDown) {
                                _this._handleUp(ev);
                            }
                            //this._isDown = false;
                        }),
                        events_1.on("pointerover", function () {
                            _this._handleOver();
                        }),
                        events_1.on("pointerout", function () {
                            _this._handleOut();
                        }),
                        events_1.on("pointerdown", function (e) {
                            _this._handleDown(e);
                        })
                    ]);
                }
                else {
                    this._display.interactive = false;
                    if (this._hoverDp) {
                        this._hoverDp.dispose();
                        this._hoverDp = undefined;
                    }
                }
            }
            if (this.isDirty("forceInactive")) {
                this._display.inactive = this.get("forceInactive", false);
            }
            if (this.get("showTooltipOn") == "always" && this._display.visible) {
                this.showTooltip();
            }
        }
    });
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    Object.defineProperty(Sprite.prototype, "dragStart", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            this._dragEvent = e;
            this.events.stopParentDispatch();
        }
    });
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    Object.defineProperty(Sprite.prototype, "dragStop", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            this._dragEvent = undefined;
            this._dragPoint = undefined;
            this.events.stopParentDispatch();
            if (this._isDragging) {
                this._isDragging = false;
                var type = "dragstop";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_handleOver", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("hoverActive")) {
                    this.states.applyAnimate("hoverActive");
                }
                else if (this.get("disabled") && this.states.lookup("hoverDisabled")) {
                    this.states.applyAnimate("hoverDisabled");
                }
                else {
                    this.states.applyAnimate("hover");
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_handleOut", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("active")) {
                    this.states.applyAnimate("active");
                }
                else if (this.get("disabled") && this.states.lookup("disabled")) {
                    this.states.applyAnimate("disabled");
                }
                else {
                    if (this.states.lookup("hover") || this.states.lookup("hoverActive")) {
                        this.states.applyAnimate("default");
                    }
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_handleUp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("active")) {
                    this.states.applyAnimate("active");
                }
                else if (this.get("disabled") && this.states.lookup("disabled")) {
                    this.states.applyAnimate("disabled");
                }
                else if (this.states.lookup("down")) {
                    if (this.isHover()) {
                        this.states.applyAnimate("hover");
                    }
                    else {
                        this.states.applyAnimate("default");
                    }
                }
                // @todo remove this once migrated to _downPoints
                this._downPoint = undefined;
                var pointerId = getPointerId(e.originalEvent);
                delete this._downPoints[pointerId];
                if (keys(this._downPoints).length == 0) {
                    this._isDown = false;
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_hasMoved", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            // @todo remove this once migrated to _downPoints
            // if (this._downPoint) {
            // 	const x = Math.abs(this._downPoint.x - e.point.x);
            // 	const y = Math.abs(this._downPoint.y - e.point.y);
            // 	return (x > 5) || (y > 5);
            // }
            var pointerId = getPointerId(e.originalEvent);
            var downPoint = this._downPoints[pointerId];
            if (downPoint) {
                var x = Math.abs(downPoint.x - e.point.x);
                var y = Math.abs(downPoint.y - e.point.y);
                return (x > 5) || (y > 5);
            }
            return false;
        }
    });
    Object.defineProperty(Sprite.prototype, "_hasDown", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return keys(this._downPoints).length > 0;
        }
    });
    Object.defineProperty(Sprite.prototype, "_handleDown", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            var parent = this.parent;
            if (parent && !this.get("draggable")) {
                parent._handleDown(e);
            }
            if (this.get("interactive") && !this.isHidden()) {
                if (this.states.lookup("down")) {
                    this.states.applyAnimate("down");
                }
                this._downPoint = {
                    x: e.point.x,
                    y: e.point.y
                };
                // @todo remove this once migrated to _downPoints
                this._isDown = true;
                var pointerId = getPointerId(e.originalEvent);
                this._downPoints[pointerId] = {
                    x: e.point.x,
                    y: e.point.y
                };
            }
        }
    });
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    Object.defineProperty(Sprite.prototype, "dragMove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (e) {
            var dragEvent = this._dragEvent;
            if (dragEvent) {
                var angle = 0;
                var parent_3 = this.parent;
                while (parent_3 != null) {
                    angle += parent_3.get("rotation", 0);
                    parent_3 = parent_3.parent;
                }
                var x = e.point.x - dragEvent.point.x;
                var y = e.point.y - dragEvent.point.y;
                var events = this.events;
                if (dragEvent.simulated && !this._isDragging) {
                    this._isDragging = true;
                    this._dragEvent = e;
                    this._dragPoint = {
                        x: this.x(),
                        y: this.y()
                    };
                    var type = "dragstart";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated,
                        });
                    }
                }
                if (this._isDragging) {
                    var dragPoint = this._dragPoint;
                    this.set("x", dragPoint.x + x * cos(angle) + y * sin(angle));
                    this.set("y", dragPoint.y + y * cos(angle) - x * sin(angle));
                    var type = "dragged";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated,
                        });
                    }
                }
                else {
                    if (Math.hypot(x, y) > 5) {
                        this._isDragging = true;
                        this._dragEvent = e;
                        this._dragPoint = {
                            x: this.x(),
                            y: this.y()
                        };
                        var type = "dragstart";
                        if (events.isEnabled(type)) {
                            events.dispatch(type, {
                                type: type,
                                target: this,
                                originalEvent: e.originalEvent,
                                point: e.point,
                                simulated: e.simulated
                            });
                        }
                    }
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_updateSize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Sprite.prototype, "_getBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._localBounds = this._display.getLocalBounds();
        }
    });
    /**
     * Returns depth (how deep in the hierachy of the content tree) of this
     * element.
     *
     * @return Depth
     */
    Object.defineProperty(Sprite.prototype, "depth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var self = this.parent;
            var depth = 0;
            while (true) {
                if (self) {
                    ++depth;
                    self = self.parent;
                }
                else {
                    return depth;
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirtySize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._sizeDirty = true;
            this.markDirty();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirtyBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var display = this._display;
            if (this.get("isMeasured")) {
                this._root._addDirtyBounds(this);
                display.isMeasured = true;
                display.invalidateBounds();
                var parent_4 = this.parent;
                if (parent_4 && this.get("position") != "absolute") {
                    if (parent_4.get("width") == null || parent_4.get("height") == null || parent_4.get("layout")) {
                        parent_4.markDirtyBounds();
                    }
                }
                if (this.get("focusable") && this.isFocus()) {
                    this.markDirtyAccessibility();
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirtyAccessibility", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            //if (this._root.focused(this)) {
            this._root._invalidateAccessibility(this);
            //}
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirtyLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            //this._display.markDirtyLayer(this.isDirty("opacity") || this.isDirty("visible")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems
            this._display.markDirtyLayer(true);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "markDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.markDirty.call(this);
            this.markDirtyLayer();
        }
    });
    Object.defineProperty(Sprite.prototype, "_updateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var oldBounds = this._adjustedLocalBounds;
            var newBounds;
            // if display.visible == false, it still returns bounds
            if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                newBounds = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                this._localBounds = newBounds;
                this._adjustedLocalBounds = newBounds;
            }
            else {
                this._getBounds();
                this._fixMinBounds(this._localBounds);
                this.updatePivotPoint();
                this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);
                newBounds = this._adjustedLocalBounds;
            }
            if (!oldBounds || (oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom)) {
                var eventType = "boundschanged";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this });
                }
                if (this.parent) {
                    this.parent.markDirty();
                    this.parent.markDirtyBounds();
                }
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_fixMinBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            var minWidth = this.get("minWidth");
            var minHeight = this.get("minHeight");
            if (isNumber(minWidth)) {
                if (bounds.right - bounds.left < minWidth) {
                    bounds.right = bounds.left + minWidth;
                }
            }
            if (isNumber(minHeight)) {
                if (bounds.bottom - bounds.top < minHeight) {
                    bounds.bottom = bounds.top + minHeight;
                }
            }
            var privateWidth = this.getPrivate("width");
            var privateHeight = this.getPrivate("height");
            if (isNumber(privateWidth)) {
                bounds.right = bounds.left + privateWidth;
            }
            if (isNumber(privateHeight)) {
                bounds.bottom = bounds.top + privateHeight;
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_removeParent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parent) {
            if (parent) {
                parent.children.removeValue(this);
                removeFirst(parent._percentageSizeChildren, this);
                removeFirst(parent._percentagePositionChildren, this);
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._sizeDirty = false;
            this._statesHandled = false;
        }
    });
    /**
     * Simulate hover over element.
     */
    Object.defineProperty(Sprite.prototype, "hover", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.showTooltip();
            this._handleOver();
        }
    });
    /**
     * Simulate unhover over element.
     */
    Object.defineProperty(Sprite.prototype, "unhover", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.hideTooltip();
            this._handleOut();
        }
    });
    /**
     * Shows element's [[Tooltip]].
     */
    Object.defineProperty(Sprite.prototype, "showTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            var tooltip = this.getTooltip();
            var tooltipText = this.get("tooltipText");
            if (tooltipText && tooltip) {
                var tooltipPosition = this.get("tooltipPosition");
                var tooltipTarget = this.getPrivate("tooltipTarget", this);
                if (tooltipPosition == "fixed" || !point) {
                    this._display._setMatrix();
                    point = this.toGlobal(tooltipTarget._getTooltipPoint());
                }
                tooltip.set("pointTo", point);
                tooltip.set("tooltipTarget", tooltipTarget);
                if (!tooltip.get("x")) {
                    tooltip.set("x", point.x);
                }
                if (!tooltip.get("y")) {
                    tooltip.set("y", point.y);
                }
                tooltip.label.set("text", tooltipText);
                var dataItem = this.dataItem;
                if (dataItem) {
                    tooltip.label._setDataItem(dataItem);
                }
                if (this.get("showTooltipOn") == "always" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {
                    this.hideTooltip();
                    return;
                }
                tooltip.label.text.markDirtyText();
                var promise = tooltip.show();
                this.setPrivateRaw("showingTooltip", true);
                return promise;
            }
        }
    });
    /**
     * Hides element's [[Tooltip]].
     */
    Object.defineProperty(Sprite.prototype, "hideTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltip = this.getTooltip();
            if (tooltip) {
                var promise = tooltip.hide();
                this.setPrivateRaw("showingTooltip", false);
                return promise;
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_getTooltipPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var bounds = this._localBounds;
            if (bounds) {
                var x = 0;
                var y = 0;
                if (!this.get("isMeasured")) {
                    x = relativeToValue(this.get("tooltipX", 0), this.width());
                    y = relativeToValue(this.get("tooltipY", 0), this.height());
                }
                else {
                    x = bounds.left + relativeToValue(this.get("tooltipX", 0), bounds.right - bounds.left);
                    y = bounds.top + relativeToValue(this.get("tooltipY", 0), bounds.bottom - bounds.top);
                }
                return { x: x, y: y };
            }
            return { x: 0, y: 0 };
        }
    });
    /**
     * Returns [[Tooltip]] used for this element.
     *
     * @return Tooltip
     */
    Object.defineProperty(Sprite.prototype, "getTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltip = this.get("tooltip");
            if (!tooltip) {
                var parent_5 = this.parent;
                if (parent_5) {
                    return parent_5.getTooltip();
                }
            }
            else {
                return tooltip;
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_updatePosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var parent = this.parent;
            var dx = this.get("dx", 0);
            var dy = this.get("dy", 0);
            var x = this.get("x");
            var _x = this.getPrivate("x");
            var xx = 0;
            var yy = 0;
            var position = this.get("position");
            if (x instanceof Percent) {
                if (parent) {
                    x = parent.innerWidth() * x.value + parent.get("paddingLeft", 0);
                }
                else {
                    x = 0;
                }
            }
            if (isNumber(x)) {
                xx = x + dx;
            }
            else {
                if (_x != null) {
                    xx = _x;
                }
                else if (parent) {
                    if (position == "relative") {
                        xx = parent.get("paddingLeft", 0) + dx;
                    }
                }
            }
            var y = this.get("y");
            var _y = this.getPrivate("y");
            if (y instanceof Percent) {
                if (parent) {
                    y = parent.innerHeight() * y.value + parent.get("paddingTop", 0);
                }
                else {
                    y = 0;
                }
            }
            if (isNumber(y)) {
                yy = y + dy;
            }
            else {
                if (_y != null) {
                    yy = _y;
                }
                else if (parent) {
                    if (position == "relative") {
                        yy = parent.get("paddingTop", 0) + dy;
                    }
                }
            }
            var display = this._display;
            if (display.x != xx || display.y != yy) {
                display.invalidateBounds();
                display.x = xx;
                display.y = yy;
                var eventType = "positionchanged";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this });
                }
            }
            // Update tooltip position together with the Sprite
            if (this.getPrivate("showingTooltip")) {
                this.showTooltip();
            }
        }
    });
    /**
     * Returns element's actual X position in pixels.
     *
     * @return X (px)
     */
    Object.defineProperty(Sprite.prototype, "x", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var x = this.get("x");
            var _x = this.getPrivate("x");
            var parent = this.parent;
            if (parent) {
                if (x instanceof Percent) {
                    return relativeToValue(x, parent.innerWidth()) + parent.get("paddingLeft", 0);
                }
                else {
                    if (!isNumber(x)) {
                        if (_x != null) {
                            return _x;
                        }
                        else {
                            return parent.get("paddingLeft", this._display.x);
                        }
                    }
                    else {
                        return x;
                    }
                }
            }
            return this._display.x;
        }
    });
    /**
     * Returns element's actual Y position in pixels.
     *
     * @return Y (px)
     */
    Object.defineProperty(Sprite.prototype, "y", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _y = this.getPrivate("y");
            if (_y != null) {
                return _y;
            }
            var y = this.get("y");
            var parent = this.parent;
            if (parent) {
                if (y instanceof Percent) {
                    return relativeToValue(y, parent.innerHeight()) + parent.get("paddingTop", 0);
                }
                else {
                    if (!isNumber(y)) {
                        if (_y != null) {
                            return _y;
                        }
                        else {
                            return parent.get("paddingTop", this._display.y);
                        }
                    }
                    else {
                        return y;
                    }
                }
            }
            return this._display.y;
        }
    });
    Object.defineProperty(Sprite.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._dispose.call(this);
            this._display.dispose();
            this._removeTemplateField();
            this._removeParent(this.parent);
            var focusElement = this.getPrivate("focusElement");
            if (focusElement) {
                each(focusElement.disposers, function (x) {
                    x.dispose();
                });
            }
            var tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.dispose();
            }
            this.markDirty();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Sprite.prototype, "adjustedLocalBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._fixMinBounds(this._adjustedLocalBounds);
            return this._adjustedLocalBounds;
        }
    });
    /**
     * Returns local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    Object.defineProperty(Sprite.prototype, "localBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._localBounds;
        }
    });
    /**
     * Returns adjusted local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    Object.defineProperty(Sprite.prototype, "bounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var bounds = this._adjustedLocalBounds;
            var x = this.x();
            var y = this.y();
            return { left: bounds.left + x, right: bounds.right + x, top: bounds.top + y, bottom: bounds.bottom + y };
        }
    });
    /**
     * Returns global coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    Object.defineProperty(Sprite.prototype, "globalBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var bounds = this.localBounds();
            var p0 = this.toGlobal({ x: bounds.left, y: bounds.top });
            var p1 = this.toGlobal({ x: bounds.right, y: bounds.top });
            var p2 = this.toGlobal({ x: bounds.right, y: bounds.bottom });
            var p3 = this.toGlobal({ x: bounds.left, y: bounds.bottom });
            return {
                left: Math.min(p0.x, p1.x, p2.x, p3.x),
                top: Math.min(p0.y, p1.y, p2.y, p3.y),
                right: Math.max(p0.x, p1.x, p2.x, p3.x),
                bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
            };
        }
    });
    Object.defineProperty(Sprite.prototype, "_onShow", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_duration) {
        }
    });
    Object.defineProperty(Sprite.prototype, "_onHide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_duration) {
        }
    });
    /**
     * Plays initial reveal animation regardless if element is currently hidden
     * or visible.
     *
     * @param   duration  Duration of the animation in milliseconds
     * @param   delay     Delay showing of the element by X milliseconds
     * @return            Promise
     */
    Object.defineProperty(Sprite.prototype, "appear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration, delay) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.hide(0)];
                        case 1:
                            _a.sent();
                            if (delay) {
                                return [2 /*return*/, new Promise(function (success, _error) {
                                        _this.setTimeout(function () {
                                            success(_this.show(duration));
                                        }, delay);
                                    })];
                            }
                            else {
                                return [2 /*return*/, this.show(duration)];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Shows currently hidden element and returns a `Promise` which completes
     * when all showing animations are finished.
     *
     * ```TypeScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     * ```JavaScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     *
     * @return Promise
     */
    Object.defineProperty(Sprite.prototype, "show", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            return __awaiter(this, void 0, void 0, function () {
                var animations;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this._isShowing) return [3 /*break*/, 2];
                            this._isHidden = false;
                            this._isShowing = true;
                            this._isHiding = false;
                            if (this.states.lookup("default").get("visible")) {
                                this.set("visible", true);
                            }
                            this._onShow(duration);
                            animations = this.states.applyAnimate("default", duration);
                            return [4 /*yield*/, waitForAnimations(animations)];
                        case 1:
                            _a.sent();
                            this._isShowing = false;
                            _a.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Hides the element and returns a `Promise` which completes when all hiding
     * animations are finished.
     *
     * ```TypeScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     * ```JavaScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     *
     * @return Promise
     */
    Object.defineProperty(Sprite.prototype, "hide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            return __awaiter(this, void 0, void 0, function () {
                var state, animations;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(!this._isHiding && !this._isHidden)) return [3 /*break*/, 2];
                            this._isHiding = true;
                            this._isShowing = false;
                            state = this.states.lookup("hidden");
                            if (!state) {
                                state = this.states.create("hidden", {
                                    "opacity": 0,
                                    "visible": false
                                });
                            }
                            this._isHidden = true;
                            this._onHide(duration);
                            animations = this.states.applyAnimate("hidden", duration);
                            return [4 /*yield*/, waitForAnimations(animations)];
                        case 1:
                            _a.sent();
                            this._isHiding = false;
                            _a.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Returns `true` if this element is currently hidden.
     *
     * @return Is hidden?
     */
    Object.defineProperty(Sprite.prototype, "isHidden", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isHidden;
        }
    });
    /**
     * Returns `true` if this element is currently animating to a default state.
     *
     * @return Is showing?
     */
    Object.defineProperty(Sprite.prototype, "isShowing", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isShowing;
        }
    });
    /**
     * Returns `true` if this element is currently animating to a hidden state.
     *
     * @return Is hiding?
     */
    Object.defineProperty(Sprite.prototype, "isHiding", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isHiding;
        }
    });
    /**
     * Returns `true` if this element is currently hovered by a pointer.
     *
     * @return Is hovered?
     */
    Object.defineProperty(Sprite.prototype, "isHover", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._display.hovering();
        }
    });
    /**
     * Returns `true` if this element does currently have focus.
     *
     * @return Is focused?
     */
    Object.defineProperty(Sprite.prototype, "isFocus", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._root.focused(this);
        }
    });
    /**
     * Returns `true` if this element is currently being dragged.
     *
     * @return Is dragged?
     */
    Object.defineProperty(Sprite.prototype, "isDragging", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isDragging;
        }
    });
    /**
     * Returns width of this element in pixels.
     *
     * @return Width (px)
     */
    Object.defineProperty(Sprite.prototype, "width", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var width = this.get("width");
            var maxWidth = this.get("maxWidth");
            var minWidth = this.get("minWidth");
            var privateWidth = this.getPrivate("width");
            var w = 0;
            if (isNumber(privateWidth)) {
                w = privateWidth;
            }
            else {
                if (width == null) {
                    if (this._adjustedLocalBounds) {
                        w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;
                    }
                }
                else {
                    if (width instanceof Percent) {
                        var parent_6 = this.parent;
                        if (parent_6) {
                            w = parent_6.innerWidth() * width.value;
                        }
                        else {
                            w = this._root.width() * width.value;
                        }
                    }
                    else if (isNumber(width)) {
                        w = width;
                    }
                }
            }
            if (isNumber(minWidth)) {
                w = Math.max(minWidth, w);
            }
            if (isNumber(maxWidth)) {
                w = Math.min(maxWidth, w);
            }
            return w;
        }
    });
    /**
     * Returns maximum allowed width of this element in pixels.
     *
     * @return Maximum width (px)
     */
    Object.defineProperty(Sprite.prototype, "maxWidth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var maxWidth = this.get("maxWidth");
            if (isNumber(maxWidth)) {
                return maxWidth;
            }
            else {
                var width = this.get("width");
                if (isNumber(width)) {
                    return width;
                }
            }
            var parent = this.parent;
            if (parent) {
                return parent.innerWidth();
            }
            return this._root.width();
        }
    });
    /**
     * Returns maximum allowed height of this element in pixels.
     *
     * @return Maximum height (px)
     */
    Object.defineProperty(Sprite.prototype, "maxHeight", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var maxHeight = this.get("maxHeight");
            if (isNumber(maxHeight)) {
                return maxHeight;
            }
            else {
                var height = this.get("height");
                if (isNumber(height)) {
                    return height;
                }
            }
            var parent = this.parent;
            if (parent) {
                return parent.innerHeight();
            }
            return this._root.height();
        }
    });
    /**
     * Returns height of this element in pixels.
     *
     * @return Height (px)
     */
    Object.defineProperty(Sprite.prototype, "height", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var height = this.get("height");
            var maxHeight = this.get("maxHeight");
            var minHeight = this.get("minHeight");
            var privateHeight = this.getPrivate("height");
            var h = 0;
            if (isNumber(privateHeight)) {
                h = privateHeight;
            }
            else {
                if (height == null) {
                    if (this._adjustedLocalBounds) {
                        h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;
                    }
                }
                else {
                    if (height instanceof Percent) {
                        var parent_7 = this.parent;
                        if (parent_7) {
                            h = parent_7.innerHeight() * height.value;
                        }
                        else {
                            h = this._root.height() * height.value;
                        }
                    }
                    else if (isNumber(height)) {
                        h = height;
                    }
                }
            }
            if (isNumber(minHeight)) {
                h = Math.max(minHeight, h);
            }
            if (isNumber(maxHeight)) {
                h = Math.min(maxHeight, h);
            }
            return h;
        }
    });
    Object.defineProperty(Sprite.prototype, "_findStaticTemplate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            // templateField overrides template
            if (this._templateField && f(this._templateField)) {
                return this._templateField;
            }
            return _super.prototype._findStaticTemplate.call(this, f);
        }
    });
    Object.defineProperty(Sprite.prototype, "_walkParents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            if (this._parent) {
                this._walkParent(f);
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_walkParent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            if (this._parent) {
                this._parent._walkParent(f);
            }
            f(this);
        }
    });
    Object.defineProperty(Sprite.prototype, "parent", {
        /**
         * Parent [[Container]] of this element.
         *
         * @return Parent container
         */
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "_setParent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parent, updateChildren) {
            if (updateChildren === void 0) { updateChildren = false; }
            var prevParent = this._parent;
            if (parent !== prevParent) {
                this.markDirtyBounds();
                parent.markDirty();
                this._parent = parent;
                if (updateChildren) {
                    this._removeParent(prevParent);
                    if (parent) {
                        this._addPercentageSizeChildren();
                        this._addPercentagePositionChildren();
                    }
                }
                this.markDirtyPosition();
                this._applyThemes();
            }
        }
    });
    /**
     * Returns an instance of [[NumberFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return NumberFormatter instace
     */
    Object.defineProperty(Sprite.prototype, "getNumberFormatter", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.get("numberFormatter", this._root.numberFormatter);
        }
    });
    /**
     * Returns an instance of [[DateFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DateFormatter instace
     */
    Object.defineProperty(Sprite.prototype, "getDateFormatter", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.get("dateFormatter", this._root.dateFormatter);
        }
    });
    /**
     * Returns an instance of [[DurationFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DurationFormatter instace
     */
    Object.defineProperty(Sprite.prototype, "getDurationFormatter", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.get("durationFormatter", this._root.durationFormatter);
        }
    });
    /**
     * Converts X/Y coordinate within this element to a global coordinate.
     *
     * @param  point  Local coordinate
     * @return        Global coordinate
     */
    Object.defineProperty(Sprite.prototype, "toGlobal", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            return this._display.toGlobal(point);
        }
    });
    /**
     * Converts global X/Y coordinate to a coordinate within this element.
     *
     * @param  point  Global coordinate
     * @return        Local coordinate
     */
    Object.defineProperty(Sprite.prototype, "toLocal", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            return this._display.toLocal(point);
        }
    });
    Object.defineProperty(Sprite.prototype, "_getDownPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var id = this._getDownPointId();
            if (id) {
                return this._downPoints[id];
            }
        }
    });
    Object.defineProperty(Sprite.prototype, "_getDownPointId", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._downPoints) {
                return keysOrdered(this._downPoints, function (a, b) {
                    if (a > b) {
                        return 1;
                    }
                    if (a < b) {
                        return -1;
                    }
                    return 0;
                })[0];
            }
        }
    });
    /**
     * Moves sprite to the end of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    Object.defineProperty(Sprite.prototype, "toFront", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var parent = this.parent;
            if (parent) {
                parent.children.moveValue(this, parent.children.length - 1);
            }
        }
    });
    /**
     * Moves sprite to the beginning of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    Object.defineProperty(Sprite.prototype, "toBack", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var parent = this.parent;
            if (parent) {
                parent.children.moveValue(this, 0);
            }
        }
    });
    Object.defineProperty(Sprite, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Sprite"
    });
    Object.defineProperty(Sprite, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Sprite.className])
    });
    return Sprite;
}(Entity));

//# sourceMappingURL=Sprite.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js
;
/**
 * From https://github.com/pixijs/pixi.js/blob/3dd0ff9a935f0bc13a09aefff9eb2872f02c51b9/packages/canvas/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts#L13
 */
var BlendMode;
(function (BlendMode) {
    BlendMode["ADD"] = "lighter";
    BlendMode["COLOR"] = "color";
    BlendMode["COLOR_BURN"] = "color-burn";
    BlendMode["COLOR_DODGE"] = "color-dodge";
    BlendMode["DARKEN"] = "darken";
    BlendMode["DIFFERENCE"] = "difference";
    BlendMode["DST_OVER"] = "destination-over";
    BlendMode["EXCLUSION"] = "exclusion";
    BlendMode["HARD_LIGHT"] = "hard-light";
    BlendMode["HUE"] = "hue";
    BlendMode["LIGHTEN"] = "lighten";
    BlendMode["LUMINOSITY"] = "luminosity";
    BlendMode["MULTIPLY"] = "multiply";
    BlendMode["NORMAL"] = "source-over";
    BlendMode["OVERLAY"] = "overlay";
    BlendMode["SATURATION"] = "saturation";
    BlendMode["SCREEN"] = "screen";
    BlendMode["SOFT_LIGHT"] = "soft-light";
    BlendMode["SRC_ATOP"] = "source-atop";
    BlendMode["XOR"] = "xor";
})(BlendMode || (BlendMode = {}));
//# sourceMappingURL=Renderer.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js





var visualSettings = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset"];
/**
 * Base class used for drawing shapes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
var Graphics = /** @class */ (function (_super) {
    __extends(Graphics, _super);
    function Graphics() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._root._renderer.makeGraphics()
        });
        Object.defineProperty(_this, "_clear", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(Graphics.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("draw") || this.isDirty("svgPath")) {
                this.markDirtyBounds();
            }
            if (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) {
                this._clear = true;
            }
            if (this.isDirty("fillGradient")) {
                var gradient = this.get("fillGradient");
                if (gradient) {
                    this._display.isMeasured = true;
                    var gradientTarget = gradient.get("target");
                    if (gradientTarget) {
                        this._disposers.push(gradientTarget.events.on("boundschanged", function () {
                            _this._markDirtyKey("fill");
                        }));
                        this._disposers.push(gradientTarget.events.on("positionchanged", function () {
                            _this._markDirtyKey("fill");
                        }));
                    }
                }
            }
            if (this.isDirty("strokeGradient")) {
                var gradient = this.get("strokeGradient");
                if (gradient) {
                    this._display.isMeasured = true;
                    var gradientTarget = gradient.get("target");
                    if (gradientTarget) {
                        this._disposers.push(gradientTarget.events.on("boundschanged", function () {
                            _this._markDirtyKey("stroke");
                        }));
                        this._disposers.push(gradientTarget.events.on("positionchanged", function () {
                            _this._markDirtyKey("stroke");
                        }));
                    }
                }
            }
        }
    });
    Object.defineProperty(Graphics.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this._clear) {
                this.markDirtyLayer();
                this._display.clear();
                var strokeDasharray = this.get("strokeDasharray");
                if (isNumber(strokeDasharray)) {
                    if (strokeDasharray < 0.5) {
                        strokeDasharray = [0];
                    }
                    else {
                        strokeDasharray = [strokeDasharray];
                    }
                }
                this._display.setLineDash(strokeDasharray);
                var strokeDashoffset = this.get("strokeDashoffset");
                if (strokeDashoffset) {
                    this._display.setLineDashOffset(strokeDashoffset);
                }
                var blendMode = this.get("blendMode", BlendMode.NORMAL);
                this._display.blendMode = blendMode;
                var draw = this.get("draw");
                if (draw) {
                    draw(this._display, this);
                }
                var svgPath = this.get("svgPath");
                if (svgPath != null) {
                    this._display.svgPath(svgPath);
                }
            }
        }
    });
    Object.defineProperty(Graphics.prototype, "_afterChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterChanged.call(this);
            if (this._clear) {
                var fill_1 = this.get("fill");
                var fillGradient = this.get("fillGradient");
                var fillPattern = this.get("fillPattern");
                var fillOpacity_1 = this.get("fillOpacity");
                var stroke_1 = this.get("stroke");
                var strokeGradient = this.get("strokeGradient");
                var strokePattern = this.get("strokePattern");
                var shadowColor = this.get("shadowColor");
                var shadowBlur = this.get("shadowBlur");
                var shadowOffsetX = this.get("shadowOffsetX");
                var shadowOffsetY = this.get("shadowOffsetY");
                var shadowOpacity = this.get("shadowOpacity");
                //const bounds = this._display.getLocalBounds();
                if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {
                    this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);
                }
                if (fillPattern) {
                    var changed = false;
                    if (fill_1 && (!fillPattern.get("fill") || fillPattern.get("fillInherited"))) {
                        fillPattern.set("fill", fill_1);
                        fillPattern.set("fillInherited", true);
                        changed = true;
                    }
                    if (stroke_1 && (!fillPattern.get("color") || fillPattern.get("colorInherited"))) {
                        fillPattern.set("color", stroke_1);
                        fillPattern.set("colorInherited", true);
                        changed = true;
                    }
                    if (changed) {
                        // @todo: is this OK?
                        fillPattern._changed();
                    }
                    var pattern = fillPattern.pattern;
                    if (pattern) {
                        this._display.beginFill(pattern, fillOpacity_1);
                        this._display.endFill();
                    }
                }
                else if (fillGradient) {
                    if (fill_1) {
                        var stops = fillGradient.get("stops", []);
                        if (stops.length) {
                            each(stops, function (stop) {
                                if ((!stop.color || stop.colorInherited) && fill_1) {
                                    stop.color = fill_1;
                                    stop.colorInherited = true;
                                }
                                if (stop.opacity == null || stop.opacityInherited) {
                                    stop.opacity = fillOpacity_1;
                                    stop.opacityInherited = true;
                                }
                            });
                        }
                    }
                    var gradient = fillGradient.getFill(this);
                    if (gradient) {
                        this._display.beginFill(gradient, fillOpacity_1);
                        this._display.endFill();
                    }
                }
                else if (fill_1) {
                    this._display.beginFill(fill_1, fillOpacity_1);
                    this._display.endFill();
                }
                if (stroke_1 || strokeGradient || strokePattern) {
                    var strokeOpacity_1 = this.get("strokeOpacity");
                    var strokeWidth = this.get("strokeWidth", 1);
                    if (strokePattern) {
                        var changed = false;
                        if (stroke_1 && (!strokePattern.get("color") || strokePattern.get("colorInherited"))) {
                            strokePattern.set("color", stroke_1);
                            strokePattern.set("colorInherited", true);
                            changed = true;
                        }
                        if (changed) {
                            // @todo: is this OK?
                            strokePattern._changed();
                        }
                        var pattern = strokePattern.pattern;
                        if (pattern) {
                            this._display.lineStyle(strokeWidth, pattern, strokeOpacity_1);
                            this._display.endStroke();
                        }
                    }
                    else if (strokeGradient) {
                        var stops = strokeGradient.get("stops", []);
                        if (stops.length) {
                            each(stops, function (stop) {
                                if ((!stop.color || stop.colorInherited) && stroke_1) {
                                    stop.color = stroke_1;
                                    stop.colorInherited = true;
                                }
                                if (stop.opacity == null || stop.opacityInherited) {
                                    stop.opacity = strokeOpacity_1;
                                    stop.opacityInherited = true;
                                }
                            });
                        }
                        var gradient = strokeGradient.getFill(this);
                        if (gradient) {
                            this._display.lineStyle(strokeWidth, gradient, strokeOpacity_1);
                            this._display.endStroke();
                        }
                    }
                    else if (stroke_1) {
                        this._display.lineStyle(strokeWidth, stroke_1, strokeOpacity_1);
                        this._display.endStroke();
                    }
                }
            }
            this._clear = false;
        }
    });
    Object.defineProperty(Graphics, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Graphics"
    });
    Object.defineProperty(Graphics, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Graphics.className])
    });
    return Graphics;
}(Sprite));

//# sourceMappingURL=Graphics.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js


/**
 * Draws a rectangle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
var Rectangle = /** @class */ (function (_super) {
    __extends(Rectangle, _super);
    function Rectangle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Rectangle.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
    });
    Object.defineProperty(Rectangle.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this._clear && !this.get("draw")) {
                this._draw();
            }
        }
    });
    Object.defineProperty(Rectangle.prototype, "_draw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._display.drawRect(0, 0, this.width(), this.height());
        }
    });
    Object.defineProperty(Rectangle.prototype, "_updateSize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.markDirty();
            this._clear = true;
        }
    });
    Object.defineProperty(Rectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Rectangle"
    });
    Object.defineProperty(Rectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Rectangle.className])
    });
    return Rectangle;
}(Graphics));

//# sourceMappingURL=Rectangle.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js


function eachChildren(container, f) {
    if (container.get("reverseChildren", false)) {
        container.children.eachReverse(f);
    }
    else {
        container.children.each(f);
    }
}
/**
 * Base class for [[Container]] layouts.
 */
var Layout = /** @class */ (function (_super) {
    __extends(Layout, _super);
    function Layout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Layout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Layout"
    });
    Object.defineProperty(Layout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Layout.className])
    });
    return Layout;
}(Entity));

//# sourceMappingURL=Layout.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js




/**
 * A horizontal children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
var HorizontalLayout = /** @class */ (function (_super) {
    __extends(HorizontalLayout, _super);
    function HorizontalLayout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(HorizontalLayout.prototype, "updateContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (container) {
            var paddingLeft = container.get("paddingLeft", 0);
            var availableWidth = container.innerWidth();
            var totalPercent = 0;
            eachChildren(container, function (child) {
                if (child.get("position") == "relative") {
                    var childWidth = child.get("width");
                    if (childWidth instanceof Percent) {
                        totalPercent += childWidth.value;
                        var w = availableWidth * childWidth.value;
                        var minWidth = child.get("minWidth", -Infinity);
                        if (minWidth > w) {
                            availableWidth -= minWidth;
                            totalPercent -= childWidth.value;
                        }
                        var maxWidth = child.get("maxWidth", Infinity);
                        if (w > maxWidth) {
                            availableWidth -= maxWidth;
                            totalPercent -= childWidth.value;
                        }
                    }
                    else {
                        if (!isNumber(childWidth)) {
                            childWidth = child.width();
                        }
                        availableWidth -= childWidth + child.get("marginLeft", 0) + child.get("marginRight", 0);
                    }
                }
            });
            if (availableWidth > 0) {
                eachChildren(container, function (child) {
                    if (child.get("position") == "relative") {
                        var childWidth = child.get("width");
                        if (childWidth instanceof Percent) {
                            var privateWidth = availableWidth * childWidth.value / totalPercent - child.get("marginLeft", 0) - child.get("marginRight", 0);
                            var minWidth = child.get("minWidth", -Infinity);
                            var maxWidth = child.get("maxWidth", Infinity);
                            privateWidth = Math.min(Math.max(minWidth, privateWidth), maxWidth);
                            child.setPrivate("width", privateWidth);
                        }
                    }
                });
            }
            var prevX = paddingLeft;
            eachChildren(container, function (child) {
                if (child.get("position") == "relative") {
                    var bounds = child.adjustedLocalBounds();
                    var marginLeft = child.get("marginLeft", 0);
                    var marginRight = child.get("marginRight", 0);
                    var x = prevX + marginLeft - bounds.left;
                    child.setPrivate("x", x);
                    prevX = x + bounds.right + marginRight;
                }
            });
        }
    });
    Object.defineProperty(HorizontalLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "HorizontalLayout"
    });
    Object.defineProperty(HorizontalLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([HorizontalLayout.className])
    });
    return HorizontalLayout;
}(Layout));

//# sourceMappingURL=HorizontalLayout.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js




/**
 * A vertical children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
var VerticalLayout = /** @class */ (function (_super) {
    __extends(VerticalLayout, _super);
    function VerticalLayout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(VerticalLayout.prototype, "updateContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (container) {
            var paddingTop = container.get("paddingTop", 0);
            var availableHeight = container.innerHeight();
            var totalPercent = 0;
            eachChildren(container, function (child) {
                if (child.get("position") == "relative") {
                    var childHeight = child.get("height");
                    if (childHeight instanceof Percent) {
                        totalPercent += childHeight.value;
                        var h = availableHeight * childHeight.value;
                        var minHeight = child.get("minHeight", -Infinity);
                        if (minHeight > h) {
                            availableHeight -= minHeight;
                            totalPercent -= childHeight.value;
                        }
                        var maxHeight = child.get("minHeight", Infinity);
                        if (h > maxHeight) {
                            availableHeight -= maxHeight;
                            totalPercent -= childHeight.value;
                        }
                    }
                    else {
                        if (!isNumber(childHeight)) {
                            childHeight = child.height();
                        }
                        availableHeight -= childHeight + child.get("marginTop", 0) + child.get("marginBottom", 0);
                    }
                }
            });
            if (availableHeight > 0) {
                eachChildren(container, function (child) {
                    if (child.get("position") == "relative") {
                        var childHeight = child.get("height");
                        if (childHeight instanceof Percent) {
                            var privateHeight = availableHeight * childHeight.value / totalPercent - child.get("marginTop", 0) - child.get("marginBottom", 0);
                            var minHeight = child.get("minHeight", -Infinity);
                            var maxHeight = child.get("maxHeight", Infinity);
                            privateHeight = Math.min(Math.max(minHeight, privateHeight), maxHeight);
                            child.setPrivate("height", privateHeight);
                        }
                    }
                });
            }
            var prevY = paddingTop;
            eachChildren(container, function (child) {
                if (child.get("position") == "relative") {
                    var bounds = child.adjustedLocalBounds();
                    var marginTop = child.get("marginTop", 0);
                    var marginBottom = child.get("marginBottom", 0);
                    var y = prevY + marginTop - bounds.top;
                    child.setPrivate("y", y);
                    prevY = y + bounds.bottom + marginBottom;
                }
            });
        }
    });
    Object.defineProperty(VerticalLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "VerticalLayout"
    });
    Object.defineProperty(VerticalLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([VerticalLayout.className])
    });
    return VerticalLayout;
}(Layout));

//# sourceMappingURL=VerticalLayout.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js




/**
 * A grid children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
var GridLayout = /** @class */ (function (_super) {
    __extends(GridLayout, _super);
    function GridLayout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(GridLayout.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._setRawDefault("maxColumns", Number.MAX_VALUE);
            _super.prototype._afterNew.call(this);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(GridLayout.prototype, "updateContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (container) {
            var paddingLeft = container.get("paddingLeft", 0);
            var paddingRight = container.get("paddingRight", 0);
            var paddingTop = container.get("paddingTop", 0);
            var availableWidth = container.maxWidth() - paddingLeft - paddingRight;
            var minCellWidth = availableWidth;
            var maxCellWidth = 1;
            eachChildren(container, function (child) {
                if (child.get("position") != "absolute") {
                    var childWidth = child.width();
                    if (childWidth < minCellWidth) {
                        minCellWidth = childWidth;
                    }
                    if (childWidth > maxCellWidth) {
                        maxCellWidth = childWidth;
                    }
                }
            });
            minCellWidth = fitToRange(minCellWidth, 1, availableWidth);
            maxCellWidth = fitToRange(maxCellWidth, 1, availableWidth);
            var columnCount = 1;
            if (this.get("fixedWidthGrid")) {
                columnCount = availableWidth / maxCellWidth;
            }
            else {
                columnCount = availableWidth / minCellWidth;
            }
            columnCount = Math.max(1, Math.floor(columnCount));
            columnCount = Math.min(this.get("maxColumns", Number.MAX_VALUE), columnCount);
            var columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
            var prevY = paddingTop;
            var column = 0;
            var maxColumnHeight = 0;
            columnCount = columnWidths.length;
            var prevX = paddingLeft;
            eachChildren(container, function (child) {
                if (child.get("position") == "relative" && !child.isHidden()) {
                    var marginTop = child.get("marginTop", 0);
                    var marginBottom = child.get("marginBottom", 0);
                    var bounds = child.adjustedLocalBounds();
                    var marginLeft = child.get("marginLeft", 0);
                    var marginRight = child.get("marginRight", 0);
                    var x = prevX + marginLeft - bounds.left;
                    var y = prevY + marginTop - bounds.top;
                    child.setPrivate("x", x);
                    child.setPrivate("y", y);
                    prevX += columnWidths[column] + marginRight;
                    maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);
                    column++;
                    if (column >= columnCount) {
                        column = 0;
                        prevX = paddingLeft;
                        prevY += maxColumnHeight;
                    }
                }
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(GridLayout.prototype, "getColumnWidths", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (container, columnCount, maxCellWidth, availableWidth) {
            var _this = this;
            var totalWidth = 0;
            var columnWidths = [];
            var column = 0;
            eachChildren(container, function (child) {
                var bounds = child.adjustedLocalBounds();
                if (child.get("position") != "absolute" && !child.isHidden()) {
                    if (_this.get("fixedWidthGrid")) {
                        columnWidths[column] = maxCellWidth;
                    }
                    else {
                        columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get("marginLeft", 0) + child.get("marginRight", 0));
                    }
                    if (column < container.children.length - 1) {
                        column++;
                        if (column == columnCount) {
                            column = 0;
                        }
                    }
                }
            });
            each(columnWidths, function (w) {
                totalWidth += w;
            });
            if (totalWidth > availableWidth) {
                if (columnCount > 2) {
                    columnCount -= 1;
                    return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
                }
                else {
                    return [availableWidth];
                }
            }
            return columnWidths;
        }
    });
    Object.defineProperty(GridLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "GridLayout"
    });
    Object.defineProperty(GridLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([GridLayout.className])
    });
    return GridLayout;
}(Layout));

//# sourceMappingURL=GridLayout.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js










/**
 * A basic element that can have child elements, maintain their layout, and
 * have a background.
 *
 * It can have any [[Sprite]] element as a child, from very basic shapes, to
 * full-fledged charts.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 * @important
 */
var Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    function Container() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._root._renderer.makeContainer()
        });
        Object.defineProperty(_this, "_childrenDisplay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._root._renderer.makeContainer()
        });
        /**
         * List of Container's child elements.
         */
        Object.defineProperty(_this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Children(_this)
        });
        Object.defineProperty(_this, "_percentageSizeChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_percentagePositionChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_prevWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_prevHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_contentWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_contentHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_contentMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(Container.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterNew.call(this);
            this._display.addChild(this._childrenDisplay);
        }
    });
    Object.defineProperty(Container.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            eachReverse(this.allChildren(), function (child) {
                child.dispose();
            });
            _super.prototype._dispose.call(this);
        }
    });
    Object.defineProperty(Container.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this.isDirty("interactiveChildren")) {
                this._display.interactiveChildren = this.get("interactiveChildren", false);
            }
            if (this.isDirty("layout")) {
                this._prevWidth = 0;
                this._prevHeight = 0;
                this.markDirtyBounds();
                if (this._prevSettings.layout) {
                    this.children.each(function (child) {
                        child.removePrivate("x");
                        child.removePrivate("y");
                    });
                }
            }
            if (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) {
                this.children.each(function (child) {
                    child.markDirtyPosition();
                });
            }
            if (this.isDirty("maskContent")) {
                var childrenDisplay = this._childrenDisplay;
                var contentMask = this._contentMask;
                if (this.get("maskContent")) {
                    if (!contentMask) {
                        contentMask = Rectangle.new(this._root, {
                            width: this.width(),
                            height: this.height()
                        });
                        this._contentMask = contentMask;
                        childrenDisplay.addChildAt(contentMask._display, 0);
                        childrenDisplay.mask = contentMask._display;
                    }
                }
                else {
                    if (contentMask) {
                        childrenDisplay.removeChild(contentMask._display);
                        childrenDisplay.mask = null;
                        contentMask.dispose();
                    }
                }
            }
        }
    });
    Object.defineProperty(Container.prototype, "_updateSize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._updateSize.call(this);
            each(this._percentageSizeChildren, function (child) {
                child._updateSize();
            });
            each(this._percentagePositionChildren, function (child) {
                child.markDirtyPosition();
                child._updateSize();
            });
            this.updateBackground();
        }
    });
    Object.defineProperty(Container.prototype, "updateBackground", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var background = this.get("background");
            var bounds = this._localBounds;
            if (bounds && !this.isHidden()) {
                var x = bounds.left;
                var y = bounds.top;
                var w = bounds.right - x;
                var h = bounds.bottom - y;
                var width = this.width();
                var height = this.height();
                if (background) {
                    background.setAll({ width: w, height: h, x: x, y: y });
                    if (this._display.interactive) {
                        background._display.interactive = true;
                    }
                }
                var contentMask = this._contentMask;
                if (contentMask) {
                    contentMask.setAll({ width: width, height: height });
                }
                var verticalScrollbar = this.get("verticalScrollbar");
                if (verticalScrollbar) {
                    verticalScrollbar.set("height", height);
                    verticalScrollbar.set("x", width - verticalScrollbar.width() - verticalScrollbar.get("marginRight", 0));
                    verticalScrollbar.set("end", verticalScrollbar.get("start", 0) + height / this._contentHeight);
                    var bg = verticalScrollbar.get("background");
                    if (bg) {
                        bg.setAll({ width: verticalScrollbar.width(), height: height });
                    }
                    var visible = true;
                    if (this._contentHeight <= height) {
                        visible = false;
                    }
                    verticalScrollbar.setPrivate("visible", visible);
                }
            }
        }
    });
    Object.defineProperty(Container.prototype, "_applyThemes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (_super.prototype._applyThemes.call(this)) {
                this.eachChildren(function (child) {
                    child._applyThemes();
                });
                return true;
            }
            else {
                return false;
            }
        }
    });
    Object.defineProperty(Container.prototype, "_applyState", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name) {
            _super.prototype._applyState.call(this, name);
            if (this.get("setStateOnChildren")) {
                this.eachChildren(function (child) {
                    child.states.apply(name);
                });
            }
        }
    });
    Object.defineProperty(Container.prototype, "_applyStateAnimated", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, duration) {
            _super.prototype._applyStateAnimated.call(this, name, duration);
            if (this.get("setStateOnChildren")) {
                this.eachChildren(function (child) {
                    child.states.applyAnimate(name, duration);
                });
            }
        }
    });
    /**
     * Returns container's inner width (width without padding) in pixels.
     *
     * @return Inner width (px)
     */
    Object.defineProperty(Container.prototype, "innerWidth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
        }
    });
    /**
     * Returns container's inner height (height without padding) in pixels.
     *
     * @return Inner height (px)
     */
    Object.defineProperty(Container.prototype, "innerHeight", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
        }
    });
    Object.defineProperty(Container.prototype, "_getBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var width = this.get("width");
            var height = this.get("height");
            var pWidth = this.getPrivate("width");
            var pHeight = this.getPrivate("height");
            var bounds = {
                left: 0,
                top: 0,
                right: this.width(),
                bottom: this.height(),
            };
            var layout = this.get("layout");
            var horizontal = false;
            var vertical = false;
            if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {
                horizontal = true;
            }
            if (layout instanceof VerticalLayout) {
                vertical = true;
            }
            if ((width != null || pWidth != null) && (height != null || pHeight != null) && !this.get("verticalScrollbar")) {
                // void
            }
            else {
                var m = Number.MAX_VALUE;
                var l_1 = m;
                var r_1 = -m;
                var t_1 = m;
                var b_1 = -m;
                var paddingLeft = this.get("paddingLeft", 0);
                var paddingTop = this.get("paddingTop", 0);
                var paddingRight = this.get("paddingRight", 0);
                var paddingBottom = this.get("paddingBottom", 0);
                this.children.each(function (child) {
                    if (child.get("position") != "absolute" && child.get("isMeasured")) {
                        var childBounds = child.adjustedLocalBounds();
                        var childX = child.x();
                        var childY = child.y();
                        var cl = childX + childBounds.left;
                        var cr = childX + childBounds.right;
                        var ct = childY + childBounds.top;
                        var cb = childY + childBounds.bottom;
                        if (horizontal) {
                            cl -= child.get("marginLeft", 0);
                            cr += child.get("marginRight", 0);
                        }
                        if (vertical) {
                            ct -= child.get("marginTop", 0);
                            cb += child.get("marginBottom", 0);
                        }
                        if (cl < l_1) {
                            l_1 = cl;
                        }
                        if (cr > r_1) {
                            r_1 = cr;
                        }
                        if (ct < t_1) {
                            t_1 = ct;
                        }
                        if (cb > b_1) {
                            b_1 = cb;
                        }
                    }
                });
                if (l_1 == m) {
                    l_1 = 0;
                }
                if (r_1 == -m) {
                    r_1 = 0;
                }
                if (t_1 == m) {
                    t_1 = 0;
                }
                if (b_1 == -m) {
                    b_1 = 0;
                }
                bounds.left = l_1 - paddingLeft;
                bounds.top = t_1 - paddingTop;
                bounds.right = r_1 + paddingRight;
                bounds.bottom = b_1 + paddingBottom;
            }
            this._contentWidth = bounds.right - bounds.left;
            this._contentHeight = bounds.bottom - bounds.top;
            if (isNumber(width)) {
                bounds.left = 0;
                bounds.right = width;
            }
            if (isNumber(pWidth)) {
                bounds.left = 0;
                bounds.right = pWidth;
            }
            if (isNumber(height)) {
                bounds.top = 0;
                bounds.bottom = height;
            }
            if (isNumber(pHeight)) {
                bounds.top = 0;
                bounds.bottom = pHeight;
            }
            this._localBounds = bounds;
        }
    });
    Object.defineProperty(Container.prototype, "_updateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var layout = this.get("layout");
            if (layout) {
                layout.updateContainer(this);
            }
            _super.prototype._updateBounds.call(this);
            this.updateBackground();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Container.prototype, "markDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.markDirty.call(this);
            this._root._addDirtyParent(this);
        }
    });
    Object.defineProperty(Container.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var innerWidth = this.innerWidth();
            var innerHeight = this.innerHeight();
            if (innerWidth != this._prevWidth || innerHeight != this._prevHeight) {
                var layout = this.get("layout");
                var horizontal_1 = false;
                var vertical_1 = false;
                if (layout) {
                    if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {
                        horizontal_1 = true;
                    }
                    if (layout instanceof VerticalLayout) {
                        vertical_1 = true;
                    }
                }
                each(this._percentageSizeChildren, function (child) {
                    if (!horizontal_1) {
                        var width = child.get("width");
                        if (width instanceof Percent) {
                            child.setPrivate("width", width.value * innerWidth);
                        }
                    }
                    if (!vertical_1) {
                        var height = child.get("height");
                        if (height instanceof Percent) {
                            child.setPrivate("height", height.value * innerHeight);
                        }
                    }
                });
                each(this._percentagePositionChildren, function (child) {
                    child.markDirtyPosition();
                    child.markDirtyBounds();
                });
                this._prevWidth = innerWidth;
                this._prevHeight = innerHeight;
                this._sizeDirty = true;
                this.updateBackground();
            }
            this._handleStates();
        }
    });
    Object.defineProperty(Container.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this.isDirty("verticalScrollbar")) {
                var verticalScrollbar_1 = this.get("verticalScrollbar");
                if (verticalScrollbar_1) {
                    verticalScrollbar_1._setParent(this);
                    verticalScrollbar_1.children.removeValue(verticalScrollbar_1.startGrip);
                    verticalScrollbar_1.children.removeValue(verticalScrollbar_1.endGrip);
                    this.set("maskContent", true);
                    this.set("paddingRight", verticalScrollbar_1.width() + verticalScrollbar_1.get("marginRight", 0) + verticalScrollbar_1.get("marginLeft", 0));
                    var background = this.get("background");
                    if (!background) {
                        background = this.set("background", Rectangle.new(this._root, {
                            themeTags: ["background"],
                            fillOpacity: 0,
                            fill: this._root.interfaceColors.get("alternativeBackground")
                        }));
                    }
                    this._disposers.push(this.events.on("wheel", function (event) {
                        var wheelEvent = event.originalEvent;
                        wheelEvent.preventDefault();
                        var shiftY = wheelEvent.deltaY / 5000;
                        var start = verticalScrollbar_1.get("start", 0);
                        var end = verticalScrollbar_1.get("end", 1);
                        if (start + shiftY > 0 && end + shiftY < 1) {
                            verticalScrollbar_1.set("start", start + shiftY);
                            verticalScrollbar_1.set("end", end + shiftY);
                        }
                    }));
                    this._disposers.push(verticalScrollbar_1.events.on("rangechanged", function () {
                        var h = _this._contentHeight;
                        var childrenDisplay = _this._childrenDisplay;
                        var contentMask = _this._contentMask;
                        childrenDisplay.y = -verticalScrollbar_1.get("start") * h;
                        childrenDisplay.markDirtyLayer();
                        if (contentMask) {
                            contentMask._display.y = -childrenDisplay.y;
                            childrenDisplay.mask = contentMask._display;
                        }
                    }));
                    this._display.addChild(verticalScrollbar_1._display);
                }
            }
            if (this.isDirty("background")) {
                // TODO maybe this should dispose ?
                var previous = this._prevSettings["background"];
                if (previous) {
                    this._display.removeChild(previous._display);
                }
                var background = this.get("background");
                if (background instanceof Sprite) {
                    background.set("isMeasured", false);
                    background._setParent(this);
                    this._display.addChildAt(background._display, 0);
                }
            }
            if (this.isDirty("mask")) {
                var mask = this.get("mask");
                var previous = this._prevSettings["mask"];
                if (previous) {
                    this._display.removeChild(previous._display);
                    if (previous != mask) {
                        previous.dispose();
                    }
                }
                if (mask) {
                    var parent = mask.parent;
                    if (parent) {
                        parent.children.removeValue(mask);
                    }
                    mask._setParent(this);
                    this._display.addChildAt(mask._display, 0);
                    this._childrenDisplay.mask = mask._display;
                }
            }
        }
    });
    Object.defineProperty(Container.prototype, "_processTemplateField", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._processTemplateField.call(this);
            this.children.each(function (child) {
                child._processTemplateField();
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Container.prototype, "walkChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            this.children.each(function (child) {
                if (child instanceof Container) {
                    child.walkChildren(f);
                }
                f(child);
            });
        }
    });
    Object.defineProperty(Container.prototype, "eachChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            var background = this.get("background");
            if (background) {
                f(background);
            }
            var verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                f(verticalScrollbar);
            }
            var mask = this.get("mask");
            if (mask) {
                f(mask);
            }
            this.children.values.forEach(function (child) {
                f(child);
            });
        }
    });
    Object.defineProperty(Container.prototype, "allChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var output = [];
            this.eachChildren(function (x) {
                output.push(x);
            });
            return output;
        }
    });
    Object.defineProperty(Container, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Container"
    });
    Object.defineProperty(Container, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Container.className])
    });
    return Container;
}(Sprite));

//# sourceMappingURL=Container.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js
/** @ignore */ /** */

/**
 * @ignore
 */
var Native = /** @class */ (function () {
    function Native() {
        var _this = this;
        Object.defineProperty(this, "_observer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this._observer = new ResizeObserver(function (entries) {
            each(entries, function (entry) {
                each(_this._targets, function (x) {
                    if (x.target === entry.target) {
                        x.callback();
                    }
                });
            });
        });
    }
    Object.defineProperty(Native.prototype, "addTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target, callback) {
            this._observer.observe(target, { box: "content-box" });
            this._targets.push({ target: target, callback: callback });
        }
    });
    Object.defineProperty(Native.prototype, "removeTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            this._observer.unobserve(target);
            keepIf(this._targets, function (x) {
                return x.target !== target;
            });
        }
    });
    return Native;
}());
/**
 * @ignore
 */
var Raf = /** @class */ (function () {
    function Raf() {
        Object.defineProperty(this, "_timer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    Object.defineProperty(Raf.prototype, "addTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target, callback) {
            var _this = this;
            if (this._timer === null) {
                var lastTime_1 = null;
                var loop_1 = function () {
                    var currentTime = Date.now();
                    if (lastTime_1 === null || currentTime > (lastTime_1 + Raf.delay)) {
                        lastTime_1 = currentTime;
                        each(_this._targets, function (x) {
                            var newSize = x.target.getBoundingClientRect();
                            if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                                x.size = newSize;
                                x.callback();
                            }
                        });
                    }
                    if (_this._targets.length === 0) {
                        _this._timer = null;
                    }
                    else {
                        _this._timer = requestAnimationFrame(loop_1);
                    }
                };
                this._timer = requestAnimationFrame(loop_1);
            }
            // We start off with fake bounds so that sensor always kicks in
            //let size = target.getBoundingClientRect();
            var size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 };
            this._targets.push({ target: target, callback: callback, size: size });
        }
    });
    Object.defineProperty(Raf.prototype, "removeTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            keepIf(this._targets, function (x) {
                return x.target !== target;
            });
            if (this._targets.length === 0) {
                if (this._timer !== null) {
                    cancelAnimationFrame(this._timer);
                    this._timer = null;
                }
            }
        }
    });
    Object.defineProperty(Raf, "delay", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 200
    });
    return Raf;
}());
/**
 * @ignore
 */
var observer = null;
/**
 * @ignore
 */
function makeSensor() {
    if (observer === null) {
        if (typeof ResizeObserver !== "undefined") {
            observer = new Native();
        }
        else {
            observer = new Raf();
        }
    }
    return observer;
}
/**
 * @ignore
 */
var ResizeSensor = /** @class */ (function () {
    function ResizeSensor(element, callback) {
        Object.defineProperty(this, "_sensor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this._sensor = makeSensor();
        this._element = element;
        this._sensor.addTarget(element, callback);
    }
    Object.defineProperty(ResizeSensor.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._disposed;
        }
    });
    Object.defineProperty(ResizeSensor.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._disposed) {
                this._disposed = true;
                this._sensor.removeTarget(this._element);
            }
        }
    });
    Object.defineProperty(ResizeSensor.prototype, "sensor", {
        get: function () {
            return this._sensor;
        },
        enumerable: false,
        configurable: true
    });
    return ResizeSensor;
}());

//# sourceMappingURL=ResizeSensor.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js


/**
 * Presets for common UI elements.
 */
var InterfaceColors = /** @class */ (function (_super) {
    __extends(InterfaceColors, _super);
    function InterfaceColors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(InterfaceColors, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InterfaceColors"
    });
    Object.defineProperty(InterfaceColors, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([InterfaceColors.className])
    });
    return InterfaceColors;
}(Entity));

//# sourceMappingURL=InterfaceColors.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js


var TextFormatter = /** @class */ (function () {
    function TextFormatter() {
    }
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    Object.defineProperty(TextFormatter, "escape", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.
                replace(/\[\[/g, this.prefix + "1").
                replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").
                replace(/\]\]/g, this.prefix + "2").
                replace(/\{\{/g, this.prefix + "3").
                replace(/\}\}/g, this.prefix + "4").
                replace(/\'\'/g, this.prefix + "5");
        }
    });
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    Object.defineProperty(TextFormatter, "unescape", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.
                replace(new RegExp(this.prefix + "1", "g"), "[[").
                replace(new RegExp(this.prefix + "2", "g"), "]]").
                replace(new RegExp(this.prefix + "3", "g"), "{{").
                replace(new RegExp(this.prefix + "4", "g"), "}}").
                replace(new RegExp(this.prefix + "5", "g"), "''");
        }
    });
    /**
     * Cleans up the text text for leftover double square brackets.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Cleaned up text
     */
    Object.defineProperty(TextFormatter, "cleanUp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.
                replace(/\[\[/g, "[").
                replace(/\]\]/g, "]").
                replace(/\{\{/g, "{").
                replace(/\}\}/g, "}").
                replace(/\'\'/g, "'");
        }
    });
    /**
     * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
     *
     * If the second parameter `quotedBlocks` is set to `true` this method will
     * also single out text blocks enclosed within single quotes that no
     * formatting should be applied to, and they should be displayed as is.
     *
     * Default for the above is `false`, so that you can use single quote in text
     * without escaping it.
     *
     * If enabled, single quotes can be escaped by doubling it - adding two
     * single quotes, which will be replaced by a one single quote in the final
     * output.
     *
     * @ignore Exclude from docs
     * @param text          Text to chunk
     * @param quotedBlocks  Use quoted blocks
     * @param noFormatting  Formatting blocks will be treated as regular text
     * @return Array of string chunks
     */
    Object.defineProperty(TextFormatter, "chunk", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text, quotedBlocks, noFormatting) {
            if (quotedBlocks === void 0) { quotedBlocks = false; }
            if (noFormatting === void 0) { noFormatting = false; }
            // Init result
            var res = [];
            // Replace double (escaped) square spaces and quotes with temporary codes
            text = this.escape(text);
            // Deal with style blocks
            var chunks = quotedBlocks ? text.split("'") : [text];
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                // Empty?
                if (chunk === "") {
                    continue;
                }
                if ((i % 2) === 0) {
                    // Text outside quotes
                    // Parse for style blocks which are "text" chunks, the rest chunks are
                    // "value"
                    chunk = chunk.replace(/\]\[/g, "]" + PLACEHOLDER + "[");
                    chunk = chunk.replace(/\[\]/g, "[ ]");
                    var chunks2 = chunk.split(/[\[\]]+/);
                    for (var i2 = 0; i2 < chunks2.length; i2++) {
                        var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                        // Placeholder?
                        if (chunk2 === PLACEHOLDER) {
                            continue;
                        }
                        // Empty?
                        if (chunk2 === "") {
                            continue;
                        }
                        // Block or value
                        if ((i2 % 2) === 0) {
                            res.push({
                                "type": "value",
                                "text": chunk2
                            });
                        }
                        else {
                            res.push({
                                "type": noFormatting ? "value" : "format",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                    }
                }
                else {
                    // A text within doublequotes
                    // All chunks are "text"
                    var chunks2 = chunk.split(/[\[\]]+/);
                    for (var i2 = 0; i2 < chunks2.length; i2++) {
                        var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                        // Empty?
                        if (chunk2 === "") {
                            continue;
                        }
                        // Block or text
                        if ((i2 % 2) === 0) {
                            res.push({
                                "type": "text",
                                "text": chunk2
                            });
                        }
                        else if (this.isImage(chunk2)) {
                            res.push({
                                "type": "image",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                        else {
                            res.push({
                                "type": "format",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                    }
                }
            }
            return res;
        }
    });
    /**
     * Checks if supplied format contains image information and should be
     * formatted as such.
     * I.e.: `[img: myImage.png]`
     *
     * @ignore
     * @param  text  Format
     * @return true if it is an image
     */
    Object.defineProperty(TextFormatter, "isImage", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.match(/img[ ]?:/) ? true : false;
        }
    });
    Object.defineProperty(TextFormatter, "getTextStyle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (style) {
            // let textStyle: string[] = [];
            // let textFill: string | undefined;
            var format = {};
            if (style == "" || style == "[ ]") {
                return {};
            }
            // TODO: cache
            // let cached = registry.getCache("translateStyleShortcuts_" + style);
            // if (cached) {
            // 	return cached;
            // }
            // Pre-process quoted text
            var q = style.match(/('[^']*')|("[^"]*")/gi);
            if (q) {
                for (var i = 0; i < q.length; i++) {
                    style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
                }
            }
            // Get style parts
            var b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w]+)|(\/)/gi);
            // Empty?
            if (!b) {
                return {};
            }
            //console.log(b)
            // Check each part
            for (var i = 0; i < b.length; i++) {
                if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {
                    format.fontWeight = b[i];
                }
                else if (b[i].match(/^(underline)$/i)) {
                    format.textDecoration = b[i];
                }
                else if (b[i] == "/") {
                    // Just closing tag
                    // Do nothing
                }
                else if (!b[i].match(/:/)) {
                    // Color
                    format.fill = Color.fromString(b[i]);
                }
                else {
                    var p = b[i].split(/:[ ]*/);
                    format[p[0]] = p[1];
                    //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, ""));
                    //b[i] = b[i].replace(/\+/g, " ");
                }
            }
            // TODO: cache
            // registry.setCache("translateStyleShortcuts_" + style, res);
            return format;
        }
    });
    Object.defineProperty(TextFormatter, "prefix", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "__amcharts__"
    });
    return TextFormatter;
}());

//# sourceMappingURL=TextFormatter.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js
/** @ignore */ /** */




/**
 * @ignore
 */
function populateString(target, string) {
    if (string != null) {
        string = "" + string;
        string = TextFormatter.escape(string);
        var tags = string.match(/\{([^}]+)\}/g);
        var i = void 0;
        if (tags) {
            for (i = 0; i < tags.length; i++) {
                var tag = tags[i].replace(/\{([^}]+)\}/, "$1");
                var value = getTagValue(target, tag, "");
                if (value == null) {
                    value = "";
                }
                string = string.split(tags[i]).join(value);
            }
        }
        string = TextFormatter.unescape(string);
    }
    else {
        string = "";
    }
    // TODO: apply adapter?
    return string;
}
/**
 * @ignore
 */
function getTagValue(target, tagName, format) {
    var value;
    var dataItem = target.dataItem;
    // Parse parts
    var parts = [];
    var reg = /([^.]+)\(([^)]*)\)|([^.]+)/g;
    ;
    var matches;
    while (true) {
        matches = reg.exec(tagName);
        if (matches === null) {
            break;
        }
        if (matches[3]) {
            // Simple property
            parts.push({
                prop: matches[3]
            });
            // Check if maybe we should force a formatter on this value
            var dateFields = target.getDateFormatter().get("dateFields", []);
            var numericFields = target.getNumberFormatter().get("numericFields", []);
            var durationFields = target.getDurationFormatter().get("durationFields", []);
            if (dateFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDate",
                    params: []
                });
            }
            else if (numericFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatNumber",
                    params: []
                });
            }
            else if (durationFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDuration",
                    params: []
                });
            }
        }
        else {
            // Method
            // Parse parameters
            var params = [];
            if (trim(matches[2]) != "") {
                var reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
                var matches2 = void 0;
                while (true) {
                    matches2 = reg2.exec(matches[2]);
                    if (matches2 === null) {
                        break;
                    }
                    params.push(matches2[1] || matches2[2] || matches2[3]);
                }
            }
            parts.push({
                method: matches[1],
                params: params
            });
        }
    }
    // Check if we can retrieve the value from data item
    if (dataItem) {
        // Check values
        value = getTagValueFromObject(target, parts, dataItem._settings);
        // Check properties
        if (value == null || isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.
            value = getTagValueFromObject(target, parts, dataItem);
        }
        // Check data context
        var dataContext = dataItem.dataContext;
        if (value == null && dataContext) {
            value = getTagValueFromObject(target, parts, dataContext);
            // Maybe it's a literal dot-separated name of the key in dataContext?
            if (value == null) {
                value = getTagValueFromObject(target, [{
                        prop: tagName
                    }], dataContext);
            }
            // scond data context level sometimes exist (tree map)
            if (value == null && dataContext.dataContext) {
                value = getTagValueFromObject(target, parts, dataContext.dataContext);
            }
        }
        // Check component's data item
        if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {
            value = getTagValue(dataItem.component, tagName, format);
        }
    }
    // Check sprite's properties
    if (value == null) {
        value = getTagValueFromObject(target, parts, target);
    }
    // Finally, check the parent
    if (value == null && target.parent) {
        value = getTagValue(target.parent, tagName, format);
    }
    return value;
}
/**
 * @ignore
 */
function getCustomDataValue(target, prop) {
    var customData = target.getPrivate("customData");
    if (isObject(customData)) {
        return customData[prop];
    }
}
/**
 * @ignore
 */
function getTagValueFromObject(target, parts, object, format) {
    var current = object;
    var formatApplied = false;
    for (var i = 0, len = parts.length; i < len; i++) {
        var part = parts[i];
        if (part.prop) {
            // Regular property
            if (current instanceof Sprite) {
                current = current.get(part.prop) || current.getPrivate(part.prop) || current[part.prop] || getCustomDataValue(current, part.prop);
            }
            else if (current.get) {
                current = current.get(part.prop) || current[part.prop];
            }
            else {
                current = current[part.prop];
            }
            if (current == null) {
                // Not set, return undefined
                return;
            }
        }
        else {
            // Method
            switch (part.method) {
                case "formatNumber":
                    var numberValue = toNumber(current);
                    if (numberValue != null) {
                        current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDate":
                    var dateValue = toDate(current);
                    if (!isDate(dateValue) || Type_isNaN(dateValue.getTime())) {
                        // Was not able to get date out of value, quitting and letting
                        // calling method try another value
                        return;
                    }
                    if (dateValue != null) {
                        current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDuration":
                    var durationValue = toNumber(current);
                    if (durationValue != null) {
                        current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "urlEncode":
                case "encodeURIComponent":
                    current = encodeURIComponent(current);
                    break;
                default:
                    if (current[part.method]) {
                        current[part.method].apply(object, part.params);
                    }
                    break;
            }
        }
    }
    // Apply default format if it wasn't applied explicitly
    if (!formatApplied) {
        var formatParts = [{
                method: "",
                params: format
            }];
        if (format == null) {
            // Format is not set
            // Determine from the type of the value
            if (isNumber(current)) {
                formatParts[0].method = "formatNumber";
                formatParts[0].params = "";
            }
            else if (isDate(current)) {
                formatParts[0].method = "formatDate";
                formatParts[0].params = "";
            }
        }
        else {
            // Format set
            // Try to determine formatter based on the format
            var formatterType = getFormat(format);
            // format
            if (formatterType === "number") {
                formatParts[0].method = "formatNumber";
            }
            else if (formatterType === "date") {
                formatParts[0].method = "formatDate";
            }
            else if (formatterType === "duration") {
                formatParts[0].method = "formatDuration";
            }
        }
        // Apply format
        if (formatParts[0].method) {
            current = getTagValueFromObject(target, formatParts, current);
        }
    }
    return current;
}
//# sourceMappingURL=PopulateString.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js




/**
 * @ignore Text is an internal class. Use Label instead.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "textStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._root._renderer.makeTextStyle()
        });
        Object.defineProperty(_this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._root._renderer.makeText("", _this.textStyle)
        });
        Object.defineProperty(_this, "_textStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale"
            ]
        });
        Object.defineProperty(_this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(Text.prototype, "_updateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this.get("text")) {
                var newBounds = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                };
                this._adjustedLocalBounds = newBounds;
            }
            else {
                _super.prototype._updateBounds.call(this);
            }
        }
    });
    Object.defineProperty(Text.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._changed.call(this);
            this._display.clear();
            var textStyle = this.textStyle;
            if (this.isDirty("opacity")) {
                var opacity = this.get("opacity", 1);
                this._display.alpha = opacity;
            }
            if (this.isDirty("text") || this.isDirty("populateText")) {
                this._display.text = this._getText();
                this.markDirtyBounds();
                if (this.get("role") == "tooltip") {
                    this._root.updateTooltip(this);
                }
            }
            if (this.isDirty("width")) {
                textStyle.wordWrapWidth = this.width();
                this.markDirtyBounds();
            }
            if (this.isDirty("oversizedBehavior")) {
                textStyle.oversizedBehavior = this.get("oversizedBehavior", "none");
                this.markDirtyBounds();
            }
            if (this.isDirty("breakWords")) {
                textStyle.breakWords = this.get("breakWords", false);
                this.markDirtyBounds();
            }
            if (this.isDirty("ellipsis")) {
                textStyle.ellipsis = this.get("ellipsis");
                this.markDirtyBounds();
            }
            if (this.isDirty("ignoreFormatting")) {
                textStyle.ignoreFormatting = this.get("ignoreFormatting", false);
                this.markDirtyBounds();
            }
            if (this.isDirty("minScale")) {
                textStyle.minScale = this.get("minScale", 0);
                this.markDirtyBounds();
            }
            if (this.isDirty("fill")) {
                var fill = this.get("fill");
                if (fill) {
                    textStyle.fill = fill;
                }
            }
            if (this.isDirty("maxWidth")) {
                textStyle.maxWidth = this.get("maxWidth");
                this.markDirtyBounds();
            }
            if (this.isDirty("maxHeight")) {
                textStyle.maxHeight = this.get("maxHeight");
                this.markDirtyBounds();
            }
            each(this._textStyles, function (styleName) {
                if (_this._dirty[styleName]) {
                    textStyle[styleName] = _this.get(styleName);
                    _this.markDirtyBounds();
                }
            });
            textStyle["fontSize"] = this.get("fontSize");
            textStyle["fontFamily"] = this.get("fontFamily");
            this._display.style = textStyle;
            if (this.isDirty("role") && this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
        }
    });
    Object.defineProperty(Text.prototype, "_getText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var text = this.get("text", "");
            return this.get("populateText") ? populateString(this, text) : text;
        }
    });
    Object.defineProperty(Text.prototype, "markDirtyText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._display.text = this._getText();
            if (this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
            this.markDirtyBounds();
            this.markDirty();
        }
    });
    Object.defineProperty(Text.prototype, "_setDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            _super.prototype._setDataItem.call(this, dataItem);
            if (this.get("populateText")) {
                this.markDirtyText();
            }
        }
    });
    Object.defineProperty(Text, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Text"
    });
    Object.defineProperty(Text, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Text.className])
    });
    return Text;
}(Sprite));

//# sourceMappingURL=Text.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js






/**
 * Creates a label with support for in-line styling and data bindings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info
 */
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_textKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "text",
                "fill",
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale",
                "populateText",
                "role",
                "ignoreFormatting"
            ]
        });
        return _this;
    }
    Object.defineProperty(Label.prototype, "text", {
        /**
         * @ignore Text is not to be used directly
         */
        get: function () {
            return this._text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._afterNew.call(this);
            this._makeText();
            each(this._textKeys, function (property) {
                var propValue = _this.get(property);
                if (propValue != undefined) {
                    _this._text.set(property, propValue);
                }
            });
        }
    });
    Object.defineProperty(Label.prototype, "_makeText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._text = this.children.push(Text.new(this._root, {}));
        }
    });
    Object.defineProperty(Label.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._updateChildren.call(this);
            each(this._textKeys, function (property) {
                _this._text.set(property, _this.get(property));
            });
            if (this.isDirty("maxWidth")) {
                this._setMaxDimentions();
            }
            if (this.isDirty("maxHeight")) {
                this._setMaxDimentions();
            }
            if (this.isDirty("rotation")) {
                this._setMaxDimentions();
            }
            if (this.isDirty("textAlign") || this.isDirty("width")) {
                var textAlign = this.get("textAlign");
                var x = void 0;
                if (this.get("width") != null) {
                    if (textAlign == "right") {
                        x = p100;
                    }
                    else if (textAlign == "center") {
                        x = p50;
                    }
                    else {
                        x = 0;
                    }
                }
                else {
                    if (textAlign == "left" || textAlign == "start") {
                        x = this.get("paddingLeft");
                    }
                    else if (textAlign == "right" || textAlign == "end") {
                        x = -this.get("paddingRight");
                    }
                }
                this.text.set("x", x);
            }
        }
    });
    Object.defineProperty(Label.prototype, "_setMaxDimentions", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var rotation = this.get("rotation");
            var vertical = rotation == 90 || rotation == 270;
            var maxWidth = this.get("maxWidth", Infinity);
            if (isNumber(maxWidth)) {
                this.text.set(vertical ? "maxHeight" : "maxWidth", maxWidth - this.get("paddingLeft", 0) - this.get("paddingRight", 0));
            }
            else {
                this.text.set(vertical ? "maxHeight" : "maxWidth", undefined);
            }
            var maxHeight = this.get("maxHeight", Infinity);
            if (isNumber(maxHeight)) {
                this.text.set(vertical ? "maxWidth" : "maxHeight", maxHeight - this.get("paddingTop", 0) - this.get("paddingBottom", 0));
            }
            else {
                this.text.set(vertical ? "maxWidth" : "maxHeight", undefined);
            }
        }
    });
    Object.defineProperty(Label.prototype, "_setDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            _super.prototype._setDataItem.call(this, dataItem);
            this._markDirtyKey("text");
            if (this.text.get("populateText")) {
                this.text.markDirtyText();
            }
        }
    });
    /**
     * Returns text with populated placeholders and formatting if `populateText` is
     * set to `true`.
     *
     * @return Populated text
     */
    Object.defineProperty(Label.prototype, "getText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._text._getText();
        }
    });
    Object.defineProperty(Label, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Label"
    });
    Object.defineProperty(Label, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Label.className])
    });
    return Label;
}(Container));

//# sourceMappingURL=Label.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js



/**
 * Draws a rectangle with a pointer.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
var PointedRectangle = /** @class */ (function (_super) {
    __extends(PointedRectangle, _super);
    function PointedRectangle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PointedRectangle.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) {
                this._clear = true;
            }
        }
    });
    Object.defineProperty(PointedRectangle.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this._clear) {
                this.markDirtyBounds();
                var w = this.width();
                var h = this.height();
                if (w > 0 && h > 0) {
                    var cr = this.get("cornerRadius", 8);
                    cr = fitToRange(cr, 0, Math.min(w / 2, h / 2));
                    var x = this.get("pointerX", 0);
                    var y = this.get("pointerY", 0);
                    var bwh = this.get("pointerBaseWidth", 15) / 2;
                    // corner coordinates
                    // top left
                    var xtl = 0;
                    var ytl = 0;
                    // top right
                    var xtr = w;
                    var ytr = 0;
                    // bottom right
                    var xbr = w;
                    var ybr = h;
                    // bottom left
                    var xbl = 0;
                    var ybl = h;
                    // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located
                    // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)
                    var d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
                    var d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
                    var display = this._display;
                    // top
                    display.moveTo(cr, 0);
                    if (d1 > 0 && d2 > 0) {
                        var stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));
                        y = fitToRange(y, -Infinity, 0);
                        display.lineTo(stemX - bwh, 0);
                        display.lineTo(x, y);
                        display.lineTo(stemX + bwh, 0);
                    }
                    display.lineTo(w - cr, 0);
                    display.arcTo(w, 0, w, cr, cr);
                    // right
                    if (d1 > 0 && d2 < 0) {
                        var stemY = Math.round(fitToRange(y, cr + bwh, h - bwh - cr));
                        x = fitToRange(x, w, Infinity);
                        display.lineTo(w, cr);
                        display.lineTo(w, stemY - bwh);
                        display.lineTo(x, y);
                        display.lineTo(w, stemY + bwh);
                    }
                    display.lineTo(w, h - cr);
                    display.arcTo(w, h, w - cr, h, cr);
                    // bottom
                    if (d1 < 0 && d2 < 0) {
                        var stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));
                        y = fitToRange(y, h, Infinity);
                        display.lineTo(w - cr, h);
                        display.lineTo(stemX + bwh, h);
                        display.lineTo(x, y);
                        display.lineTo(stemX - bwh, h);
                    }
                    display.lineTo(cr, h);
                    display.arcTo(0, h, 0, h - cr, cr);
                    // left
                    if (d1 < 0 && d2 > 0) {
                        var stemY = Math.round(fitToRange(y, cr + bwh, h - cr - bwh));
                        x = fitToRange(x, -Infinity, 0);
                        display.lineTo(0, h - cr);
                        display.lineTo(0, stemY + bwh);
                        display.lineTo(x, y);
                        display.lineTo(0, stemY - bwh);
                    }
                    display.lineTo(0, cr);
                    display.arcTo(0, 0, cr, 0, cr);
                }
            }
        }
    });
    Object.defineProperty(PointedRectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PointedRectangle"
    });
    Object.defineProperty(PointedRectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([PointedRectangle.className])
    });
    return PointedRectangle;
}(Graphics));

//# sourceMappingURL=PointedRectangle.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js









/**
 * Creates a tooltip.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info
 * @important
 */
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_arrangeDisposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_fx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_fy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_fillDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_strokeDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_labelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_w", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_h", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        return _this;
    }
    Object.defineProperty(Tooltip.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["tooltip"]);
            _super.prototype._afterNew.call(this);
            this.set("background", PointedRectangle.new(this._root, {
                themeTags: ["tooltip", "background"]
            }));
            this._label = this.children.push(Label.new(this._root, {}));
            this._disposers.push(this._label.events.on("boundschanged", function () {
                _this._updateBackground();
            }));
            this.on("bounds", function () {
                _this._updateBackground();
            });
            this._updateTextColor();
            this._root.tooltipContainer.children.push(this);
            this.hide(0);
            this._root._tooltips.push(this);
        }
    });
    Object.defineProperty(Tooltip.prototype, "label", {
        /**
         * A [[Label]] element for the tooltip.
         *
         * @readonly
         * @return Label
         */
        get: function () {
            return this._label;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Permanently disposes the tooltip.
     */
    Object.defineProperty(Tooltip.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.dispose.call(this);
            remove(this._root._tooltips, this);
        }
    });
    Object.defineProperty(Tooltip.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._updateChildren.call(this);
            var labelText = this.get("labelText");
            if (labelText != null) {
                this.label.set("text", this.get("labelText"));
            }
        }
    });
    Object.defineProperty(Tooltip.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this.isDirty("pointTo")) {
                // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)
                this._updateBackground();
            }
            if (this.isDirty("tooltipTarget")) {
                this.updateBackgroundColor();
            }
        }
    });
    Object.defineProperty(Tooltip.prototype, "_onShow", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._onShow.call(this);
            this.updateBackgroundColor();
        }
    });
    Object.defineProperty(Tooltip.prototype, "updateBackgroundColor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var tooltipTarget = this.get("tooltipTarget");
            var background = this.get("background");
            var fill;
            var stroke;
            if (tooltipTarget && background) {
                fill = tooltipTarget.get("fill");
                stroke = tooltipTarget.get("stroke");
                if (fill == null) {
                    fill = stroke;
                }
                if (this.get("getFillFromSprite")) {
                    if (this._fillDp) {
                        this._fillDp.dispose();
                    }
                    if (fill != null) {
                        background.set("fill", fill);
                    }
                    this._fillDp = tooltipTarget.on("fill", function (fill) {
                        if (fill != null) {
                            background.set("fill", fill);
                            _this._updateTextColor(fill);
                        }
                    });
                }
                if (this.get("getStrokeFromSprite")) {
                    if (this._strokeDp) {
                        this._strokeDp.dispose();
                    }
                    if (fill != null) {
                        background.set("stroke", fill);
                    }
                    this._strokeDp = tooltipTarget.on("fill", function (fill) {
                        if (fill != null) {
                            background.set("stroke", fill);
                        }
                    });
                }
                if (this.get("getLabelFillFromSprite")) {
                    if (this._labelDp) {
                        this._labelDp.dispose();
                    }
                    if (fill != null) {
                        this.label.set("fill", fill);
                    }
                    this._labelDp = tooltipTarget.on("fill", function (fill) {
                        if (fill != null) {
                            _this.label.set("fill", fill);
                        }
                    });
                }
            }
            this._updateTextColor(fill);
        }
    });
    Object.defineProperty(Tooltip.prototype, "_updateTextColor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fill) {
            if (this.get("autoTextColor")) {
                if (fill == null) {
                    fill = this.get("background").get("fill");
                }
                if (fill == null) {
                    fill = this._root.interfaceColors.get("background");
                }
                if (fill instanceof Color) {
                    this.label.set("fill", Color.alternative(fill, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")));
                }
            }
        }
    });
    Object.defineProperty(Tooltip.prototype, "_setDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            _super.prototype._setDataItem.call(this, dataItem);
            this.label._setDataItem(dataItem);
        }
    });
    Object.defineProperty(Tooltip.prototype, "_updateBackground", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.updateBackground.call(this);
            var parent = this._root.container;
            if (parent) {
                var cw = 0.5;
                var ch = 0.5;
                var centerX = this.get("centerX");
                if (centerX instanceof Percent) {
                    cw = centerX.value;
                }
                var centerY = this.get("centerY");
                if (centerY instanceof Percent) {
                    ch = centerY.value;
                }
                var parentW = parent.width();
                var parentH = parent.height();
                var bounds = this.get("bounds", { left: 0, top: 0, right: parentW, bottom: parentH });
                this._updateBounds();
                var w = this.width();
                var h = this.height();
                // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens
                if (w === 0) {
                    w = this._w;
                }
                if (h === 0) {
                    h = this._h;
                }
                var pointTo = this.get("pointTo", { x: parentW / 2, y: parentH / 2 });
                var x = pointTo.x;
                var y = pointTo.y;
                var pointerOrientation = this.get("pointerOrientation");
                var background = this.get("background");
                var pointerLength = 0;
                if (background instanceof PointedRectangle) {
                    pointerLength = background.get("pointerLength", 0);
                }
                var pointerX = 0;
                var pointerY = 0;
                var boundsW = bounds.right - bounds.left;
                var boundsH = bounds.bottom - bounds.top;
                // horizontal
                if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
                    if (pointerOrientation == "horizontal") {
                        if (x > bounds.left + boundsW / 2) {
                            x -= (w * (1 - cw) + pointerLength);
                        }
                        else {
                            x += (w * cw + pointerLength);
                        }
                    }
                    else if (pointerOrientation == "left") {
                        x += (w * (1 - cw) + pointerLength);
                    }
                    else {
                        x -= (w * cw + pointerLength);
                    }
                }
                // vertical pointer
                else {
                    if (pointerOrientation == "vertical") {
                        if (y > bounds.top + h / 2 + pointerLength) {
                            y -= (h * (1 - ch) + pointerLength);
                        }
                        else {
                            y += (h * ch + pointerLength);
                        }
                    }
                    else if (pointerOrientation == "down") {
                        y -= (h * (1 - ch) + pointerLength);
                    }
                    else {
                        y += (h * ch + pointerLength);
                    }
                }
                x = fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw));
                y = fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch));
                pointerX = pointTo.x - x + w * cw;
                pointerY = pointTo.y - y + h * ch;
                this._fx = x;
                this._fy = y;
                var animationDuration = this.get("animationDuration", 0);
                if (animationDuration > 0 && this.get("visible") && this.get("opacity") > 0.1) {
                    var animationEasing = this.get("animationEasing");
                    this.animate({ key: "x", to: x, duration: animationDuration, easing: animationEasing });
                    this.animate({ key: "y", to: y, duration: animationDuration, easing: animationEasing });
                }
                else {
                    this.set("x", x);
                    this.set("y", y);
                }
                if (background instanceof PointedRectangle) {
                    background.set("pointerX", pointerX);
                    background.set("pointerY", pointerY);
                }
                if (w > 0) {
                    this._w = w;
                }
                if (h > 0) {
                    this._h = h;
                }
            }
        }
    });
    Object.defineProperty(Tooltip, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Tooltip"
    });
    Object.defineProperty(Tooltip, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Tooltip.className])
    });
    return Tooltip;
}(Container));

//# sourceMappingURL=Tooltip.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js






/**
 * Number formatter
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
 * @important
 */
var NumberFormatter = /** @class */ (function (_super) {
    __extends(NumberFormatter, _super);
    function NumberFormatter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NumberFormatter.prototype, "_setDefaults", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // Defaults
            this._setDefault("negativeBase", 0);
            this._setDefault("numberFormat", "#,###.#####");
            this._setDefault("smallNumberThreshold", 1.00);
            var bns = "_big_number_suffix_";
            var sns = "_small_number_suffix_";
            var bs = "_byte_suffix_";
            this._setDefault("bigNumberPrefixes", [
                { "number": 1e+3, "suffix": this._t(bns + "3") },
                { "number": 1e+6, "suffix": this._t(bns + "6") },
                { "number": 1e+9, "suffix": this._t(bns + "9") },
                { "number": 1e+12, "suffix": this._t(bns + "12") },
                { "number": 1e+15, "suffix": this._t(bns + "15") },
                { "number": 1e+18, "suffix": this._t(bns + "18") },
                { "number": 1e+21, "suffix": this._t(bns + "21") },
                { "number": 1e+24, "suffix": this._t(bns + "24") }
            ]);
            this._setDefault("smallNumberPrefixes", [
                { "number": 1e-24, "suffix": this._t(sns + "24") },
                { "number": 1e-21, "suffix": this._t(sns + "21") },
                { "number": 1e-18, "suffix": this._t(sns + "18") },
                { "number": 1e-15, "suffix": this._t(sns + "15") },
                { "number": 1e-12, "suffix": this._t(sns + "12") },
                { "number": 1e-9, "suffix": this._t(sns + "9") },
                { "number": 1e-6, "suffix": this._t(sns + "6") },
                { "number": 1e-3, "suffix": this._t(sns + "3") }
            ]);
            this._setDefault("bytePrefixes", [
                { "number": 1, suffix: this._t(bs + "B") },
                { "number": 1024, suffix: this._t(bs + "KB") },
                { "number": 1048576, suffix: this._t(bs + "MB") },
                { "number": 1073741824, suffix: this._t(bs + "GB") },
                { "number": 1099511627776, suffix: this._t(bs + "TB") },
                { "number": 1125899906842624, suffix: this._t(bs + "PB") }
            ]);
            _super.prototype._setDefaults.call(this);
        }
    });
    Object.defineProperty(NumberFormatter.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
        }
    });
    /**
     * Formats the number according to specific format.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @return Formatted number
     */
    Object.defineProperty(NumberFormatter.prototype, "format", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, format, precision) {
            // no format passed in or "Number"
            if (format == null || (isString(format) && format.toLowerCase() === "number")) {
                format = this.get("numberFormat", "");
            }
            // Init return value
            var formatted;
            // Cast to number just in case
            // TODO: maybe use better casting
            var source = Number(value);
            // Is it a built-in format or Intl.NumberFormatOptions
            if (isObject(format)) {
                try {
                    if (this.get("intlLocales")) {
                        return new Intl.NumberFormat(this.get("intlLocales"), format).format(source);
                    }
                    else {
                        return new Intl.NumberFormat(undefined, format).format(source);
                    }
                }
                catch (e) {
                    return "Invalid";
                }
            }
            else {
                // Clean format
                format = cleanFormat(format);
                // Get format info (it will also deal with parser caching)
                var info = this.parseFormat(format, this._root.language);
                // format and replace the number
                var details = void 0;
                if (source > this.get("negativeBase")) {
                    details = info.positive;
                }
                else if (source < this.get("negativeBase")) {
                    details = info.negative;
                }
                else {
                    details = info.zero;
                }
                // Adjust precision
                if (precision != null && !details.mod) {
                    details = Object_copy(details);
                    details.decimals.active = source == 0 ? 0 : precision;
                }
                // Format
                formatted = details.template.split(PLACEHOLDER).join(this.applyFormat(source, details));
            }
            return formatted;
        }
    });
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format Format string, i.e. "#,###.00"
     * @param language Language
     * @ignore
     */
    Object.defineProperty(NumberFormatter.prototype, "parseFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (format, language) {
            // Check cache
            // TODO
            // let cached = this.getCache(format);
            // if (cached != null) {
            // 	return cached;
            // }
            var _this = this;
            var thousandSeparator = language.translateEmpty("_thousandSeparator");
            var decimalSeparator = language.translateEmpty("_decimalSeparator");
            // init format parse info holder
            var info = {
                "positive": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                },
                "negative": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                },
                "zero": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                }
            };
            // Escape double vertical bars (that mean display one vertical bar)
            format = format.replace("||", PLACEHOLDER2);
            // Split it up and deal with different formats
            var parts = format.split("|");
            info.positive.source = parts[0];
            if (typeof parts[2] === "undefined") {
                info.zero = info.positive;
            }
            else {
                info.zero.source = parts[2];
            }
            if (typeof parts[1] === "undefined") {
                info.negative = info.positive;
            }
            else {
                info.negative.source = parts[1];
            }
            // Parse each
            Object_each(info, function (_part, item) {
                // Already parsed
                if (item.parsed) {
                    return;
                }
                // Check cached
                // TODO
                // if (typeof this.getCache(item.source) !== "undefined") {
                // 	info[part] = this.getCache(item.source);
                // 	return;
                // }
                // Begin parsing
                var partFormat = item.source;
                // Just "Number"?
                if (partFormat.toLowerCase() === "number") {
                    partFormat = _this.get("numberFormat", "#,###.#####");
                }
                // Let TextFormatter split into chunks
                var chunks = TextFormatter.chunk(partFormat, true);
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    // replace back double vertical bar
                    chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                    if (chunk.type === "value") {
                        // Parse format
                        // Look for codes
                        var matches = chunk.text.match(/[#0.,]+[ ]?[abesABES%!]?[abesABES‰!]?/);
                        if (matches) {
                            if (matches === null || matches[0] === "") {
                                // no codes here - assume string
                                // nothing to do here
                                item.template += chunk.text;
                            }
                            else {
                                // look for the format modifiers at the end
                                var mods = matches[0].match(/[abesABES%‰!]{2}|[abesABES%‰]{1}$/);
                                if (mods) {
                                    item.mod = mods[0].toLowerCase();
                                    item.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰!]{1}$/) ? true : false;
                                }
                                // break the format up
                                var a = matches[0].split(".");
                                // Deal with thousands
                                if (a[0] === "") {
                                    // No directives for thousands
                                    // Leave default settings (no formatting)
                                }
                                else {
                                    // Counts
                                    item.thousands.active = (a[0].match(/0/g) || []).length;
                                    item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                                    // Separator interval
                                    var b = a[0].split(",");
                                    if (b.length === 1) {
                                        // No thousands separators
                                        // Do nothing
                                    }
                                    else {
                                        // Use length fo the last chunk as thousands length
                                        item.thousands.interval = (b.pop() || "").length;
                                        if (item.thousands.interval === 0) {
                                            item.thousands.interval = -1;
                                        }
                                    }
                                }
                                // Deal with decimals
                                if (typeof (a[1]) === "undefined") {
                                    // No directives for decimals
                                    // Leave at defaults (no formatting)
                                }
                                else {
                                    // Counts
                                    item.decimals.active = (a[1].match(/0/g) || []).length;
                                    item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                                }
                                // Add special code to template
                                item.template += chunk.text.split(matches[0]).join(PLACEHOLDER);
                            }
                        }
                    }
                    else {
                        // Quoted string - take it as it is
                        item.template += chunk.text;
                    }
                }
                // Apply style formatting
                //item.template = getTextFormatter().format(item.template, this.outputFormat);
                // Save cache
                // TODO
                //this.setCache(item.source, item);
                // Mark this as parsed
                item.parsed = true;
            });
            // Save cache (the whole thing)
            // TODO
            //this.setCache(format, info);
            return info;
        }
    });
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by parseFormat()
     * @return Formatted number
     * @ignore
     */
    Object.defineProperty(NumberFormatter.prototype, "applyFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, details) {
            // Use absolute values
            var negative = value < 0;
            value = Math.abs(value);
            // Recalculate according to modifier
            var prefix = "", suffix = "";
            var mods = details.mod ? details.mod.split("") : [];
            if (mods.indexOf("b") !== -1) {
                var a_1 = this.applyPrefix(value, this.get("bytePrefixes"), mods.indexOf("!") !== -1);
                value = a_1[0];
                prefix = a_1[1];
                suffix = a_1[2];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (mods.indexOf("a") !== -1) {
                var a_2 = this.applyPrefix(value, value < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), mods.indexOf("!") !== -1);
                value = a_2[0];
                prefix = a_2[1];
                suffix = a_2[2];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (mods.indexOf("%") !== -1) {
                var ol = Math.min(value.toString().length + 2, 21);
                value *= 100;
                value = parseFloat(value.toPrecision(ol));
                suffix = "%";
            }
            else if (mods.indexOf("‰") !== -1) {
                var ol = Math.min(value.toString().length + 3, 21);
                value *= 1000;
                value = parseFloat(value.toPrecision(ol));
                suffix = "‰";
            }
            // Round to passive
            if (mods.indexOf("e") !== -1) {
                // convert the value to exponential
                var exp = void 0;
                if (details.decimals.passive >= 0) {
                    exp = value.toExponential(details.decimals.passive).split("e");
                }
                else {
                    exp = value.toExponential().split("e");
                }
                value = Number(exp[0]);
                suffix = "e" + exp[1];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (details.decimals.passive === 0) {
                value = Math.round(value);
            }
            else if (details.decimals.passive > 0) {
                var d = Math.pow(10, details.decimals.passive);
                value = Math.round(value * d) / d;
            }
            // Init return value
            var res = "";
            // Calc integer and decimal parts
            var a = numberToString(value).split(".");
            // Format integers
            var ints = a[0];
            // Pad integers to active length
            if (ints.length < details.thousands.active) {
                ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
            }
            // Insert thousands separators
            if (details.thousands.interval > 0) {
                var ip = [];
                var intsr = ints.split("").reverse().join("");
                for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
                    var c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
                    if (c !== "") {
                        ip.unshift(c);
                    }
                }
                ints = ip.join(details.thousands.separator);
            }
            // Add integers
            res += ints;
            // Add decimals
            if (a.length === 1) {
                a.push("");
            }
            var decs = a[1];
            // Fill zeros?
            if (decs.length < details.decimals.active) {
                decs += Array(details.decimals.active - decs.length + 1).join("0");
            }
            if (decs !== "") {
                res += details.decimals.separator + decs;
            }
            // Can't have empty return value
            if (res === "") {
                res = "0";
            }
            // Add minus sign back
            if (value !== 0 && negative && (mods.indexOf("s") === -1)) {
                res = "-" + res;
            }
            // Add suffixes/prefixes
            if (prefix) {
                res = prefix + res;
            }
            if (suffix) {
                res += suffix;
            }
            return res;
        }
    });
    Object.defineProperty(NumberFormatter.prototype, "applyPrefix", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, prefixes, force) {
            if (force === void 0) { force = false; }
            var newvalue = value;
            var prefix = "";
            var suffix = "";
            var applied = false;
            var k = 1;
            for (var i = 0, len = prefixes.length; i < len; i++) {
                if (prefixes[i].number <= value) {
                    if (prefixes[i].number === 0) {
                        newvalue = 0;
                    }
                    else {
                        newvalue = value / prefixes[i].number;
                        k = prefixes[i].number;
                    }
                    prefix = prefixes[i].prefix;
                    suffix = prefixes[i].suffix;
                    applied = true;
                }
            }
            if (!applied && force && prefixes.length && value != 0) {
                // Prefix was not applied. Use the first prefix.
                newvalue = value / prefixes[0].number;
                prefix = prefixes[0].prefix;
                suffix = prefixes[0].suffix;
                applied = true;
            }
            if (applied) {
                newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
            }
            return [newvalue, prefix, suffix];
        }
    });
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    Object.defineProperty(NumberFormatter.prototype, "escape", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.replace("||", PLACEHOLDER2);
        }
    });
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    Object.defineProperty(NumberFormatter.prototype, "unescape", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            return text.replace(PLACEHOLDER2, "|");
        }
    });
    return NumberFormatter;
}(Entity));

//# sourceMappingURL=NumberFormatter.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js





var DateFormatter = /** @class */ (function (_super) {
    __extends(DateFormatter, _super);
    function DateFormatter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(DateFormatter.prototype, "_setDefaults", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // Defaults
            this._setDefault("capitalize", true);
            this._setDefault("dateFormat", "yyyy-MM-dd");
            _super.prototype._setDefaults.call(this);
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
        }
    });
    Object.defineProperty(DateFormatter.prototype, "format", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (source, format) {
            // Locale?
            // TODO
            // No format passed in or it's empty
            if (typeof format === "undefined" || format === "") {
                format = this.get("dateFormat", "yyyy-MM-dd");
            }
            // Init return value
            var formatted;
            // Cast?
            // TODO: decide if we need to cast
            var date = source;
            // Is it a built-in format or Intl.DateTimeFormat
            if (isObject(format)) {
                try {
                    var locales = this.get("intlLocales");
                    if (locales) {
                        return new Intl.DateTimeFormat(locales, format).format(date);
                    }
                    else {
                        return new Intl.DateTimeFormat(undefined, format).format(date);
                    }
                }
                catch (e) {
                    return "Invalid";
                }
            }
            // get format info (it will also deal with parser caching)
            var info = this.parseFormat(format);
            // Should we apply custom time zone?
            var timezone = this._root.timezone;
            if (timezone && !this._root.utc) {
                date = timezone.convertLocal(date);
            }
            // Check if it's a valid date
            if (!isNumber(date.getTime())) {
                // TODO translation
                //return this._t("Invalid date");
                return "Invalid date";
            }
            // Apply format
            formatted = this.applyFormat(date, info);
            // Capitalize
            if (this.get("capitalize")) {
                formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
            }
            // We're done
            return formatted;
        }
    });
    /**
     * Applies format to Date.
     *
     * @param date      Date object
     * @param info      Parsed format information
     * @return Formatted date string
     */
    Object.defineProperty(DateFormatter.prototype, "applyFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (date, info) {
            // Init return value
            var res = info.template;
            // Get values
            var fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, offset = date.getTimezoneOffset(), timestamp = date.getTime();
            if (this._root.utc) {
                fullYear = date.getUTCFullYear();
                month = date.getUTCMonth();
                weekday = date.getUTCDay();
                day = date.getUTCDate();
                hours = date.getUTCHours();
                minutes = date.getUTCMinutes();
                seconds = date.getUTCSeconds();
                milliseconds = date.getUTCMilliseconds();
            }
            else {
                fullYear = date.getFullYear();
                month = date.getMonth();
                weekday = date.getDay();
                day = date.getDate();
                hours = date.getHours();
                minutes = date.getMinutes();
                seconds = date.getSeconds();
                milliseconds = date.getMilliseconds();
            }
            // Go through each part and format/replace it in template
            for (var i = 0, len = info.parts.length; i < len; i++) {
                var value = "";
                switch (info.parts[i]) {
                    case "G":
                        value = this._t(fullYear < 0
                            ? "_era_bc"
                            : "_era_ad");
                        break;
                    case "yyyy":
                        value = Math.abs(fullYear).toString();
                        if (fullYear < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "yyy":
                    case "yy":
                    case "y":
                        value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
                        if (fullYear < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "YYYY":
                    case "YYY":
                    case "YY":
                    case "Y":
                        var week = getWeek(date);
                        var year = fullYear;
                        if (week == 1 && (weekday > 4)) {
                            year--;
                        }
                        if (info.parts[i] == "YYYY") {
                            value = Math.abs(year).toString();
                        }
                        else {
                            value = Math.abs(year).toString().substr(-info.parts[i].length);
                        }
                        if (year < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "u":
                        // @todo
                        break;
                    case "q":
                        value = "" + Math.ceil((date.getMonth() + 1) / 3);
                        break;
                    case "MMMMM":
                        value = this._t(this._getMonth(month)).substr(0, 1);
                        break;
                    case "MMMM":
                        value = this._t(this._getMonth(month));
                        break;
                    case "MMM":
                        value = this._t(this._getShortMonth(month));
                        break;
                    case "MM":
                        value = padString(month + 1, 2, "0");
                        break;
                    case "M":
                        value = (month + 1).toString();
                        break;
                    case "ww":
                        value = padString(getWeek(date, this._root.utc), 2, "0");
                        break;
                    case "w":
                        value = getWeek(date, this._root.utc).toString();
                        break;
                    case "W":
                        value = getMonthWeek(date, this._root.utc).toString();
                        break;
                    case "dd":
                        value = padString(day, 2, "0");
                        break;
                    case "d":
                        value = day.toString();
                        break;
                    case "DD":
                    case "DDD":
                        value = padString(getYearDay(date, this._root.utc).toString(), info.parts[i].length, "0");
                        break;
                    case "D":
                        value = getYearDay(date, this._root.utc).toString();
                        break;
                    case "F":
                        // @todo
                        break;
                    case "g":
                        // @todo
                        break;
                    case "t":
                        value = this._root.language.translateFunc("_dateOrd").call(this, day);
                        break;
                    case "E":
                        value = (weekday || 7).toString();
                        break;
                    case "EE":
                        value = padString((weekday || 7).toString(), 2, "0");
                        break;
                    case "EEE":
                    case "eee":
                        value = this._t(this._getShortWeekday(weekday));
                        break;
                    case "EEEE":
                    case "eeee":
                        value = this._t(this._getShortWeekday(weekday));
                        break;
                    case "EEEEE":
                    case "eeeee":
                        value = this._t(this._getShortWeekday(weekday)).substr(0, 1);
                        break;
                    case "e":
                    case "ee":
                        value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();
                        if (info.parts[i] == "ee") {
                            value = padString(value, 2, "0");
                        }
                        break;
                    case "a":
                        if (hours >= 12) {
                            value = this._t("PM");
                        }
                        else {
                            value = this._t("AM");
                        }
                        break;
                    case "aa":
                        if (hours >= 12) {
                            value = this._t("P.M.");
                        }
                        else {
                            value = this._t("A.M.");
                        }
                        break;
                    case "aaa":
                        if (hours >= 12) {
                            value = this._t("P");
                        }
                        else {
                            value = this._t("A");
                        }
                        break;
                    case "h":
                        value = get12Hours(hours).toString();
                        break;
                    case "hh":
                        value = padString(get12Hours(hours), 2, "0");
                        break;
                    case "H":
                        value = hours.toString();
                        break;
                    case "HH":
                        value = padString(hours, 2, "0");
                        break;
                    case "K":
                        value = get12Hours(hours, 0).toString();
                        break;
                    case "KK":
                        value = padString(get12Hours(hours, 0), 2, "0");
                        break;
                    case "k":
                        value = (hours + 1).toString();
                        break;
                    case "kk":
                        value = padString(hours + 1, 2, "0");
                        break;
                    case "m":
                        value = minutes.toString();
                        break;
                    case "mm":
                        value = padString(minutes, 2, "0");
                        break;
                    case "s":
                        value = seconds.toString();
                        break;
                    case "ss":
                        value = padString(seconds, 2, "0");
                        break;
                    case "S":
                    case "SS":
                    case "SSS":
                        value = Math.round((milliseconds / 1000) * Math.pow(10, info.parts[i].length)).toString();
                        break;
                    case "x":
                        value = timestamp.toString();
                        break;
                    case "n":
                    case "nn":
                    case "nnn":
                        value = padString(milliseconds, info.parts[i].length, "0");
                        break;
                    case "z":
                        value = getTimeZone(date, false, false, this._root.utc);
                        break;
                    case "zz":
                        value = getTimeZone(date, true, false, this._root.utc);
                        break;
                    case "zzz":
                        value = getTimeZone(date, false, true, this._root.utc);
                        break;
                    case "zzzz":
                        value = getTimeZone(date, true, true, this._root.utc);
                        break;
                    case "Z":
                    case "ZZ":
                        var tz = Math.abs(offset) / 60;
                        var tzh = Math.floor(tz);
                        var tzm = tz * 60 - tzh * 60;
                        if (this._root.utc) {
                            tzh = 0;
                            tzm = 0;
                        }
                        if (info.parts[i] == "Z") {
                            value = "GMT";
                            value += offset > 0 ? "-" : "+";
                            value += padString(tzh, 2) + ":" + padString(tzm, 2);
                        }
                        else {
                            value = offset > 0 ? "-" : "+";
                            value += padString(tzh, 2) + padString(tzm, 2);
                        }
                        break;
                    case "i":
                        value = date.toISOString();
                        break;
                    case "I":
                        value = date.toUTCString();
                        break;
                }
                res = res.replace(PLACEHOLDER, value);
            }
            return res;
        }
    });
    /**
     * Parses format into structured infromation.
     *
     * @param format Format template
     */
    Object.defineProperty(DateFormatter.prototype, "parseFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (format) {
            // Check cache
            // TODO: implement caching of the parsed format
            // Init format parse info holder
            var info = {
                "template": "",
                "parts": []
            };
            // Let TextFormatter split into chunks
            var chunks = TextFormatter.chunk(format, true);
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                if (chunk.type === "value") {
                    // Just "Date"?
                    if (chunk.text.match(/^date$/i)) {
                        var dateFormat = this.get("dateFormat", "yyyy-MM-dd");
                        if (!isString(dateFormat)) {
                            dateFormat = "yyyy-MM-dd";
                        }
                        chunk.text = dateFormat;
                    }
                    // Find all possible parts
                    var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
                    // Found?
                    if (matches) {
                        // Populate template
                        for (var x = 0; x < matches.length; x++) {
                            info.parts.push(matches[x]);
                            chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                        }
                    }
                }
                // Apply to template
                info.template += chunk.text;
            }
            // Save cache
            // TODO
            return info;
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_months", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_getMonth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return this._months()[index];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_shortMonths", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_getShortMonth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return this._shortMonths()[index];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_weekdays", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_getWeekday", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return this._weekdays()[index];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_shortWeekdays", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "_getShortWeekday", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            return this._shortWeekdays()[index];
        }
    });
    Object.defineProperty(DateFormatter.prototype, "parse", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (source, format) {
            // Is it already a Date
            if (source instanceof Date) {
                return source;
            }
            // Is it a numeric timestamp
            if (isNumber(source)) {
                return new Date(source);
            }
            // No? Let's check if it's string, and try converting to it if nec
            if (!isString(source)) {
                source = source.toString();
            }
            // Init return value
            var res;
            // Init RegEx for parsing
            var reg = "";
            // Clean format
            format = cleanFormat(format);
            // Clip format to length of the source string
            format = format.substr(0, source.length);
            // Parse format
            var info = this.parseFormat(format);
            // Init parsed items holder
            var parsedIndexes = {
                "year": -1,
                "year3": -1,
                "year2": -1,
                "year1": -1,
                "month": -1,
                "monthShort": -1,
                "monthLong": -1,
                "weekdayShort": -1,
                "weekdayLong": -1,
                "day": -1,
                "yearDay": -1,
                "week": -1,
                "hourBase0": -1,
                "hour12Base0": -1,
                "hourBase1": -1,
                "hour12Base1": -1,
                "minute": -1,
                "second": -1,
                "millisecond": -1,
                "millisecondDigits": -1,
                "am": -1,
                "zone": -1,
                "timestamp": -1,
                "iso": -1
            };
            // Init values
            var resValues = {
                "year": 1970,
                "month": 0,
                "day": 1,
                "hour": 0,
                "minute": 0,
                "second": 0,
                "millisecond": 0,
                "timestamp": null,
                "offset": 0,
                "utc": this._root.utc
            };
            // Index adjuster
            var indexAdjust = 0;
            var index = 0;
            // Iterate through all of the parts
            for (var i = 0; i < info.parts.length; i++) {
                // Set current match index
                index = i + indexAdjust + 1;
                switch (info.parts[i]) {
                    case "yyyy":
                    case "YYYY":
                        reg += "([0-9]{4})";
                        parsedIndexes.year = index;
                        break;
                    case "yyy":
                    case "YYY":
                        reg += "([0-9]{3})";
                        parsedIndexes.year3 = index;
                        break;
                    case "yy":
                    case "YY":
                        reg += "([0-9]{2})";
                        parsedIndexes.year2 = index;
                        break;
                    case "y":
                    case "Y":
                        reg += "([0-9]{1})";
                        parsedIndexes.year1 = index;
                        break;
                    case "MMMM":
                        reg += "(" + this.getStringList(this._months()).join("|") + ")";
                        parsedIndexes.monthLong = index;
                        break;
                    case "MMM":
                        reg += "(" + this.getStringList(this._shortMonths()).join("|") + ")";
                        parsedIndexes.monthShort = index;
                        break;
                    case "MM":
                    case "M":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.month = index;
                        break;
                    case "ww":
                    case "w":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.week = index;
                        break;
                    case "dd":
                    case "d":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.day = index;
                        break;
                    case "DDD":
                    case "DD":
                    case "D":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.yearDay = index;
                        break;
                    case "dddd":
                        reg += "(" + this.getStringList(this._weekdays()).join("|") + ")";
                        parsedIndexes.weekdayLong = index;
                        break;
                    case "ddd":
                        reg += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")";
                        parsedIndexes.weekdayShort = index;
                        break;
                    case "aaa":
                    case "aa":
                    case "a":
                        // TODO: fix (escape regex)
                        reg += "(" + this.getStringList(["AM", "PM", "A\.M\.", "P\.M\.", "A", "P"]).join("|") + ")";
                        parsedIndexes.am = index;
                        break;
                    case "hh":
                    case "h":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hour12Base1 = index;
                        break;
                    case "HH":
                    case "H":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hourBase0 = index;
                        break;
                    case "KK":
                    case "K":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hour12Base0 = index;
                        break;
                    case "kk":
                    case "k":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hourBase1 = index;
                        break;
                    case "mm":
                    case "m":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.minute = index;
                        break;
                    case "ss":
                    case "s":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.second = index;
                        break;
                    case "SSS":
                    case "SS":
                    case "S":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.millisecond = index;
                        parsedIndexes.millisecondDigits = info.parts[i].length;
                        break;
                    case "nnn":
                    case "nn":
                    case "n":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.millisecond = index;
                        break;
                    case "x":
                        reg += "([0-9]{1,})";
                        parsedIndexes.timestamp = index;
                        break;
                    case "Z":
                        reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
                        parsedIndexes.zone = index;
                        break;
                    case "ZZ":
                        reg += "([\\-+]+[0-9]{2}[0-9]{2})";
                        parsedIndexes.zone = index;
                        break;
                    case "i":
                        reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\.?([0-9]{0,3})([zZ]|[+\-][0-9]{2}:?[0-9]{2}|$)";
                        parsedIndexes.iso = index;
                        indexAdjust += 7;
                        break;
                    case "G":
                    case "YYYY":
                    case "YYY":
                    case "YY":
                    case "Y":
                    case "MMMMM":
                    case "W":
                    case "EEEEE":
                    case "EEEE":
                    case "EEE":
                    case "EE":
                    case "E":
                    case "eeeee":
                    case "eeee":
                    case "eee":
                    case "ee":
                    case "e":
                    case "zzzz":
                    case "zzz":
                    case "zz":
                    case "z":
                    case "t":
                        // Ignore
                        indexAdjust--;
                        break;
                }
                reg += "[^0-9]*";
            }
            // Try matching
            var regex = new RegExp(reg);
            var matches = source.match(regex);
            if (matches) {
                // Populate the date object
                // Full year
                if (parsedIndexes.year > -1) {
                    resValues.year = parseInt(matches[parsedIndexes.year]);
                }
                // 3-digit year
                if (parsedIndexes.year3 > -1) {
                    var val = parseInt(matches[parsedIndexes.year3]);
                    val += 1000;
                    resValues.year = val;
                }
                // 2-digit year
                if (parsedIndexes.year2 > -1) {
                    var val = parseInt(matches[parsedIndexes.year2]);
                    if (val > 50) {
                        val += 1000;
                    }
                    else {
                        val += 2000;
                    }
                    resValues.year = val;
                }
                // 1-digit year
                if (parsedIndexes.year1 > -1) {
                    var val = parseInt(matches[parsedIndexes.year1]);
                    val = Math.floor((new Date().getFullYear()) / 10) * 10 + val;
                    resValues.year = val;
                }
                // Full month
                if (parsedIndexes.monthLong > -1) {
                    resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
                }
                // Short month
                if (parsedIndexes.monthShort > -1) {
                    resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
                }
                // Numeric month
                if (parsedIndexes.month > -1) {
                    resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
                }
                // Weekday
                // @todo
                // Week
                if ((parsedIndexes.week > -1) && (parsedIndexes.day === -1)) {
                    // We parse weeks ONLY if day is not explicitly set
                    // TODO: this needs work
                    // (but maybe later - I can hardly imagine anyone passing their dates in weeks)
                    resValues.month = 0;
                    resValues.day = getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);
                }
                // Day
                if (parsedIndexes.day > -1) {
                    resValues.day = parseInt(matches[parsedIndexes.day]);
                }
                // Year day
                if (parsedIndexes.yearDay > -1) {
                    resValues.month = 0;
                    resValues.day = parseInt(matches[parsedIndexes.yearDay]);
                }
                // 24 Hour (0-23)
                if (parsedIndexes.hourBase0 > -1) {
                    resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
                }
                // 24 Hour (1-24)
                if (parsedIndexes.hourBase1 > -1) {
                    resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
                }
                // 12 Hour (0-11)
                if (parsedIndexes.hour12Base0 > -1) {
                    var val = parseInt(matches[parsedIndexes.hour12Base0]);
                    if (val == 11) {
                        val = 0;
                    }
                    if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                        val += 12;
                    }
                    resValues.hour = val;
                }
                // 12 Hour (1-12)
                if (parsedIndexes.hour12Base1 > -1) {
                    var val = parseInt(matches[parsedIndexes.hour12Base1]);
                    if (val == 12) {
                        val = 0;
                    }
                    if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                        val += 12;
                    }
                    resValues.hour = val;
                }
                // Minute
                if (parsedIndexes.minute > -1) {
                    resValues.minute = parseInt(matches[parsedIndexes.minute]);
                }
                // Second
                if (parsedIndexes.second > -1) {
                    resValues.second = parseInt(matches[parsedIndexes.second]);
                }
                // Millisecond
                if (parsedIndexes.millisecond > -1) {
                    var val = parseInt(matches[parsedIndexes.millisecond]);
                    if (parsedIndexes.millisecondDigits == 2) {
                        val *= 10;
                    }
                    else if (parsedIndexes.millisecondDigits == 1) {
                        val *= 100;
                    }
                    resValues.millisecond = val;
                }
                // Timestamp
                if (parsedIndexes.timestamp > -1) {
                    resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
                    var ts = new Date(resValues.timestamp);
                    resValues.year = ts.getUTCFullYear();
                    resValues.month = ts.getUTCMonth();
                    resValues.day = ts.getUTCDate();
                    resValues.hour = ts.getUTCHours();
                    resValues.minute = ts.getUTCMinutes();
                    resValues.second = ts.getUTCSeconds();
                    resValues.millisecond = ts.getUTCMilliseconds();
                }
                // Adjust time zone
                if (parsedIndexes.zone > -1) {
                    resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);
                }
                // ISO
                if (parsedIndexes.iso > -1) {
                    resValues.year = toNumber(matches[parsedIndexes.iso + 0]);
                    resValues.month = toNumber(matches[parsedIndexes.iso + 1]) - 1;
                    resValues.day = toNumber(matches[parsedIndexes.iso + 2]);
                    resValues.hour = toNumber(matches[parsedIndexes.iso + 3]);
                    resValues.minute = toNumber(matches[parsedIndexes.iso + 4]);
                    resValues.second = toNumber(matches[parsedIndexes.iso + 5]);
                    resValues.millisecond = toNumber(matches[parsedIndexes.iso + 6]);
                    if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
                        resValues.utc = true;
                    }
                    else if (matches[parsedIndexes.iso + 7] != "") {
                        resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);
                    }
                }
                // Create Date object
                if (resValues.utc) {
                    res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
                }
                else {
                    res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);
                }
            }
            else {
                // Didn't match anything
                // Let's try dropping it into Date constructor and hope for the best
                res = new Date(source);
            }
            return res;
        }
    });
    Object.defineProperty(DateFormatter.prototype, "resolveTimezoneOffset", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (date, zone) {
            var value = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
            if (value) {
                var match = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
                var dir = match[1];
                var hour = match[2];
                var minute = match[3];
                var offset = parseInt(hour) * 60 + parseInt(minute);
                // Adjust offset
                // Making it negative does not seem to make sense, but it's right
                // because of how JavaScript calculates GMT offsets
                if (dir == "+") {
                    offset *= -1;
                }
                // Check the difference in offset
                var originalOffset = (date || new Date()).getTimezoneOffset();
                var diff = offset - originalOffset;
                return diff;
            }
            return 0;
        }
    });
    /**
     * Resolves month name (i.e. "December") into a month number (11).
     *
     * @param value  Month name
     * @return Month number
     */
    Object.defineProperty(DateFormatter.prototype, "resolveMonth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            // Let's try English first
            var month = this._months().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Try the translation
            if (!this._root.language.isDefault()) {
                month = this._root.language.translateAll(this._months()).indexOf(value);
                if (month > -1) {
                    return month;
                }
            }
            return 0;
        }
    });
    /**
     * Resolves short month name (i.e. "Dec") into a month number.
     *
     * @param value  Short month name
     * @return Month number
     */
    Object.defineProperty(DateFormatter.prototype, "resolveShortMonth", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            // Let's try English first
            var month = this._shortMonths().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Maybe long month (workaround for May)
            month = this._months().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Try the translation
            if (this._root.language && !this._root.language.isDefault()) {
                month = this._root.language.translateAll(this._shortMonths()).indexOf(value);
                if (month > -1) {
                    return month;
                }
            }
            return 0;
        }
    });
    /**
     * Checks if passed in string represents AM/PM notation in many of its
     * versions.
     *
     * @param value  Source string
     * @return Is it AM/PM?
     */
    Object.defineProperty(DateFormatter.prototype, "isAm", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var list = this.getStringList(["AM", "A.M.", "A"]);
            return list.indexOf(value.toUpperCase()) > -1;
        }
    });
    /**
     * Translates list of strings.
     *
     * @param list  Source strings
     * @return Translated strings
     */
    Object.defineProperty(DateFormatter.prototype, "getStringList", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (list) {
            var res = [];
            for (var i = 0; i < list.length; i++) {
                // translate?
                if (this._root.language) {
                    res.push(escapeForRgex(this._t(list[i])));
                }
                else {
                    res.push(escapeForRgex(list[i]));
                }
            }
            return res;
        }
    });
    return DateFormatter;
}(Entity));

//# sourceMappingURL=DateFormatter.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js






/**
 * A class used to format numberic values as time duration.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info
 */
var DurationFormatter = /** @class */ (function (_super) {
    __extends(DurationFormatter, _super);
    function DurationFormatter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Collection of aliases for units.
         */
        Object.defineProperty(_this, "_unitAliases", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                "Y": "y",
                "D": "d",
                "H": "h",
                "K": "h",
                "k": "h",
                "n": "S"
            }
        });
        return _this;
    }
    Object.defineProperty(DurationFormatter.prototype, "_setDefaults", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var dmillisecond = "_duration_millisecond";
            var dsecond = "_duration_second";
            var dminute = "_duration_minute";
            var dhour = "_duration_hour";
            var dday = "_duration_day";
            var dweek = "_duration_week";
            var dmonth = "_duration_month";
            var dyear = "_duration_year";
            var asecond = "_second";
            var aminute = "_minute";
            var ahour = "_hour";
            var aday = "_day";
            var aweek = "_week";
            var amonth = "_week";
            var ayear = "_year";
            // Defaults
            this._setDefault("negativeBase", 0);
            this._setDefault("baseUnit", "second");
            this._setDefault("durationFormats", {
                "millisecond": {
                    "millisecond": this._t(dmillisecond),
                    "second": this._t((dmillisecond + asecond)),
                    "minute": this._t((dmillisecond + aminute)),
                    "hour": this._t((dmillisecond + ahour)),
                    "day": this._t((dmillisecond + aday)),
                    "week": this._t((dmillisecond + aweek)),
                    "month": this._t((dmillisecond + amonth)),
                    "year": this._t((dmillisecond + ayear))
                },
                "second": {
                    "second": this._t((dsecond)),
                    "minute": this._t((dsecond + aminute)),
                    "hour": this._t((dsecond + ahour)),
                    "day": this._t((dsecond + aday)),
                    "week": this._t((dsecond + aweek)),
                    "month": this._t((dsecond + amonth)),
                    "year": this._t((dsecond + ayear))
                },
                "minute": {
                    "minute": this._t((dminute)),
                    "hour": this._t((dminute + ahour)),
                    "day": this._t((dminute + aday)),
                    "week": this._t((dminute + aweek)),
                    "month": this._t((dminute + amonth)),
                    "year": this._t((dminute + ayear))
                },
                "hour": {
                    "hour": this._t((dhour)),
                    "day": this._t((dhour + aday)),
                    "week": this._t((dhour + aweek)),
                    "month": this._t((dhour + amonth)),
                    "year": this._t((dhour + ayear))
                },
                "day": {
                    "day": this._t((dday)),
                    "week": this._t((dday + aweek)),
                    "month": this._t((dday + amonth)),
                    "year": this._t((dday + ayear))
                },
                "week": {
                    "week": this._t((dweek)),
                    "month": this._t((dweek + amonth)),
                    "year": this._t((dweek + ayear))
                },
                "month": {
                    "month": this._t((dmonth)),
                    "year": this._t((dmonth + ayear))
                },
                "year": {
                    "year": this._t(dyear)
                }
            });
            _super.prototype._setDefaults.call(this);
        }
    });
    Object.defineProperty(DurationFormatter.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
        }
    });
    /**
     * Formats the number as duration.
     *
     * For example `1000` (base unit seconds) would be converted to `16:40` as in
     * 16 minutes and 40 seconds.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @param base    Override base unit
     * @return Formatted number
     */
    Object.defineProperty(DurationFormatter.prototype, "format", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, format, base) {
            // no base unit?
            var baseUnit = base || this.get("baseUnit");
            // no format passed in or empty
            if (typeof format === "undefined" || format === "") {
                if (this.get("durationFormat") != null) {
                    format = this.get("durationFormat");
                }
                else {
                    format = this.getFormat(toNumber(value), undefined, baseUnit);
                }
            }
            // Clean format
            format = cleanFormat(format);
            // get format info (it will also deal with parser caching)
            var info = this.parseFormat(format, baseUnit);
            // cast to number just in case
            // TODO: maybe use better casting
            var source = Number(value);
            // format and replace the number
            var details;
            if (source > this.get("negativeBase")) {
                details = info.positive;
            }
            else if (source < this.get("negativeBase")) {
                details = info.negative;
            }
            else {
                details = info.zero;
            }
            // Format
            var formatted = this.applyFormat(source, details);
            // Apply color?
            if (details.color !== "") {
                formatted = "[" + details.color + "]" + formatted + "[/]";
            }
            return formatted;
        }
    });
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format  Format string, i.e. "#,###.00"
     * @param base    Override base unit
     * @return Parsed information
     */
    Object.defineProperty(DurationFormatter.prototype, "parseFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (format, base) {
            // Check cache
            // TODO
            // let cached = this.getCache(format);
            // if (cached != null) {
            // 	return cached;
            // }
            var _this = this;
            // no base unit?
            var baseUnit = base || this.get("baseUnit");
            // Initialize duration parsing info
            var info = {
                "positive": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                },
                "negative": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                },
                "zero": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                }
            };
            // Escape double vertical bars (that mean display one vertical bar)
            format = format.replace("||", PLACEHOLDER2);
            // Split it up and deal with different formats
            var parts = format.split("|");
            info.positive.source = parts[0];
            if (typeof parts[2] === "undefined") {
                info.zero = info.positive;
            }
            else {
                info.zero.source = parts[2];
            }
            if (typeof parts[1] === "undefined") {
                info.negative = info.positive;
            }
            else {
                info.negative.source = parts[1];
            }
            // Parse each
            Object_each(info, function (_part, item) {
                // Already parsed
                if (item.parsed) {
                    return;
                }
                // Check cached
                // TODO
                // if (typeof this.getCache(item.source) !== "undefined") {
                // 	info[part] = this.getCache(item.source);
                // 	return;
                // }
                // Begin parsing
                var partFormat = item.source;
                // Check for [] directives
                var dirs = [];
                dirs = item.source.match(/^\[([^\]]*)\]/);
                if (dirs && dirs.length && dirs[0] !== "") {
                    partFormat = item.source.substr(dirs[0].length);
                    item.color = dirs[1];
                }
                // Let TextFormatter split into chunks
                var chunks = TextFormatter.chunk(partFormat, true);
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    // replace back double vertical bar
                    chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                    if (chunk.type === "value") {
                        // Just "Duration"?
                        // if (chunk.text.toLowerCase() === "duration") {
                        // 	chunk.text = durationFormat;
                        // }
                        // Check for "a" (absolute) modifier
                        if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
                            item.absolute = true;
                            chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
                        }
                        // Find all possible parts
                        var matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
                        if (matches) {
                            // Populate template
                            for (var x = 0; x < matches.length; x++) {
                                // Is it an alias?
                                if (matches[x] == null) {
                                    matches[x] = _this._unitAliases[matches[x]];
                                }
                                item.parts.push(matches[x]);
                                chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                            }
                        }
                    }
                    // Apply to template
                    item.template += chunk.text;
                }
                // Apply style formatting
                //item.template = TextFormatter.format(item.template, this.outputFormat);
                // Save cache
                // TODO
                //this.setCache(item.source, item);
                // Mark this as parsed
                item.parsed = true;
            });
            // Save cache (the whole thing)
            // TODO
            //this.setCache(format, info);
            return info;
        }
    });
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by {parseFormat}
     * @return Formatted duration
     */
    Object.defineProperty(DurationFormatter.prototype, "applyFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, details) {
            // Use absolute values
            var negative = !details.absolute && (value < this.get("negativeBase"));
            value = Math.abs(value);
            // Recalculate to milliseconds
            var tstamp = this.toTimeStamp(value, details.baseUnit);
            // Init return value
            var res = details.template;
            // Iterate through duration parts
            for (var i = 0, len = details.parts.length; i < len; i++) {
                // Gather the part
                var part = details.parts[i];
                var unit = this._toTimeUnit(part.substr(0, 1));
                var digits = part.length;
                // Calculate current unit value
                var ints = Math.floor(tstamp / this._getUnitValue(unit));
                res = res.replace(PLACEHOLDER, padString(ints, digits, "0"));
                // Reduce timestamp
                tstamp -= ints * this._getUnitValue(unit);
            }
            // Reapply negative sign
            if (negative) {
                res = "-" + res;
            }
            return res;
        }
    });
    /**
     * Converts numeric value to timestamp in milliseconds.
     *
     * @param value     A source value
     * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
     * @return Value representation as a timestamp in milliseconds
     */
    Object.defineProperty(DurationFormatter.prototype, "toTimeStamp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, baseUnit) {
            return value * this._getUnitValue(baseUnit);
        }
    });
    Object.defineProperty(DurationFormatter.prototype, "_toTimeUnit", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (code) {
            switch (code) {
                case "S":
                    return "millisecond";
                case "s":
                    return "second";
                case "m":
                    return "minute";
                case "h":
                    return "hour";
                case "d":
                    return "day";
                case "w":
                    return "week";
                case "M":
                    return "month";
                case "y":
                    return "year";
            }
            ;
        }
    });
    /**
     * Returns appropriate default format for the value.
     *
     * If `maxValue` is sepcified, it will use that value to determine the time
     * unit for the format.
     *
     * For example if your `baseUnit` is `"second"` and you pass in `10`, you
     * will get `"10"`.
     *
     * However, you might want it to be formatted in the context of bigger scale,
     * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
     * values, including small ones will use format with minutes, e.g.:
     * `00:10`, `00:50`, `12: 30`, etc.
     *
     * @param value     Value to format
     * @param maxValue  Maximum value to be used to determine format
     * @param baseUnit  Base unit of the value
     * @return Format
     */
    Object.defineProperty(DurationFormatter.prototype, "getFormat", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, maxValue, baseUnit) {
            // Is format override set?
            if (this.get("durationFormat") != null) {
                return this.get("durationFormat");
            }
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            if (maxValue != null && value != maxValue) {
                value = Math.abs(value);
                maxValue = Math.abs(maxValue);
                var maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit);
                //let diffUnit = this.getValueUnit(Math.abs(maxValue - value), baseUnit);
                //console.log(maxUnit, diffUnit);
                return this.get("durationFormats")[baseUnit][maxUnit];
            }
            else {
                var unit = this.getValueUnit(value, baseUnit);
                return this.get("durationFormats")[baseUnit][unit];
            }
        }
    });
    /**
     * Returns value's closest denominator time unit, e.g 100 seconds is
     * `"minute"`, while 59 seconds would still be `second`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Denominator
     */
    Object.defineProperty(DurationFormatter.prototype, "getValueUnit", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, baseUnit) {
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            // Convert to milliseconds
            var currentUnit;
            var ms = this.getMilliseconds(value, baseUnit);
            Object_eachContinue(this._getUnitValues(), function (key, val) {
                if (key == baseUnit || currentUnit) {
                    var num = ms / val;
                    if (num <= 1) {
                        if (!currentUnit) {
                            currentUnit = key;
                        }
                        return false;
                    }
                    currentUnit = key;
                }
                return true;
            });
            return currentUnit;
        }
    });
    /**
     * Converts value to milliseconds according to `baseUnit`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Value in milliseconds
     */
    Object.defineProperty(DurationFormatter.prototype, "getMilliseconds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, baseUnit) {
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            return value * this._getUnitValue(baseUnit);
        }
    });
    Object.defineProperty(DurationFormatter.prototype, "_getUnitValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (timeUnit) {
            return this._getUnitValues()[timeUnit];
        }
    });
    Object.defineProperty(DurationFormatter.prototype, "_getUnitValues", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return {
                "millisecond": 1,
                "second": 1000,
                "minute": 60000,
                "hour": 3600000,
                "day": 86400000,
                "week": 604800000,
                "month": 2592000000,
                "year": 31536000000,
            };
        }
    });
    return DurationFormatter;
}(Entity));

//# sourceMappingURL=DurationFormatter.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/locales/en.js
/**
 * amCharts 5 locale
 *
 * Locale: en
 * Language: International English
 * Author: Martynas Majeris
 *
 * Follow instructions in [on this page](https://www.amcharts.com/docs/v5/tutorials/creating-translations/) to make corrections or add new translations.
 *
 * ---
 * Edit but leave the header section above this line. You can remove any
 * subsequent comment sections.
 * ---
 *
 * Use this file as a template to create translations. Leave the key part in
 * English intact. Fill the value with a translation.
 *
 * Empty string means no translation, so default "International English"
 * will be used.
 *
 * If you need the translation to literally be an empty string, use `null`
 * instead.
 *
 * IMPORTANT:
 * When translating make good effort to keep the translation length
 * at least the same chartcount as the English, especially for short prompts.
 *
 * Having significantly longer prompts may distort the actual charts.
 *
 * NOTE:
 * Some prompts - like months or weekdays - come in two versions: full and
 * shortened.
 *
 * If there's no official shortened version of these in your language, and it
 * would not be possible to invent such short versions that don't seem weird
 * to native speakers of that language, fill those with the same as full
 * version.
 *
 * PLACEHOLDERS:
 * Some prompts have placeholders like "%1". Those will be replaced by actual
 * values during translation and should be retained in the translated prompts.
 *
 * Placeholder positions may be changed to better suit structure of the
 * sentence.
 *
 * For example "From %1 to %2", when actually used will replace "%1" with an
 * actual value representing range start, and "%2" will be replaced by end
 * value.
 *
 * E.g. in a Scrollbar for Value axis "From %1 to %2" will become
 * "From 100 to 200". You may translate "From" and "to", as well as re-arrange
 * the order of the prompt itself, but make sure the "%1" and "%2" remain, in
 * places where they will make sense.
 *
 * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.
 */
/* harmony default export */ var en = ({
    "firstDayOfWeek": 1,
    // Number formatting options.
    // 
    // Please check with the local standards which separator is accepted to be
    // used for separating decimals, and which for thousands.
    "_decimalSeparator": ".",
    "_thousandSeparator": ",",
    // Suffixes for numbers
    // When formatting numbers, big or small numers might be reformatted to
    // shorter version, by applying a suffix.
    // 
    // For example, 1000000 might become "1m".
    // Or 1024 might become "1KB" if we're formatting byte numbers.
    // 
    // This section defines such suffixes for all such cases.
    "_big_number_suffix_3": "k",
    "_big_number_suffix_6": "M",
    "_big_number_suffix_9": "G",
    "_big_number_suffix_12": "T",
    "_big_number_suffix_15": "P",
    "_big_number_suffix_18": "E",
    "_big_number_suffix_21": "Z",
    "_big_number_suffix_24": "Y",
    "_small_number_suffix_3": "m",
    "_small_number_suffix_6": "μ",
    "_small_number_suffix_9": "n",
    "_small_number_suffix_12": "p",
    "_small_number_suffix_15": "f",
    "_small_number_suffix_18": "a",
    "_small_number_suffix_21": "z",
    "_small_number_suffix_24": "y",
    "_byte_suffix_B": "B",
    "_byte_suffix_KB": "KB",
    "_byte_suffix_MB": "MB",
    "_byte_suffix_GB": "GB",
    "_byte_suffix_TB": "TB",
    "_byte_suffix_PB": "PB",
    // Default date formats for various periods.
    // 
    // This should reflect official or de facto formatting universally accepted
    // in the country translation is being made for
    // Available format codes here:
    // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
    // 
    // This will be used when formatting date/time for particular granularity,
    // e.g. "_date_hour" will be shown whenever we need to show time as hours.
    // 
    // "date" is used as in default date format when showing standalone dates.
    "_date": "yyyy-MM-dd",
    "_date_millisecond": "mm:ss SSS",
    "_date_millisecond_full": "HH:mm:ss SSS",
    "_date_second": "HH:mm:ss",
    "_date_second_full": "HH:mm:ss",
    "_date_minute": "HH:mm",
    "_date_minute_full": "HH:mm - MMM dd, yyyy",
    "_date_hour": "HH:mm",
    "_date_hour_full": "HH:mm - MMM dd, yyyy",
    "_date_day": "MMM dd",
    "_date_day_full": "MMM dd, yyyy",
    "_date_week": "ww",
    "_date_week_full": "MMM dd, yyyy",
    "_date_month": "MMM",
    "_date_month_full": "MMM, yyyy",
    "_date_year": "yyyy",
    // Default duration formats for various base units.
    // 
    // This will be used by DurationFormatter to format numeric values into
    // duration.
    // 
    // Notice how each duration unit comes in several versions. This is to ensure
    // that each base unit is shown correctly.
    // 
    // For example, if we have baseUnit set to "second", meaning our duration is
    // in seconds.
    // 
    // If we pass in `50` to formatter, it will know that we have just 50 seconds
    // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
    // and the formatted result will be in like `"50"`.
    // 
    // If we pass in `70`, which is more than a minute, the formatter will switch
    // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
    // text.
    // 
    // Available codes here:
    // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
    "_duration_millisecond": "SSS",
    "_duration_millisecond_second": "ss.SSS",
    "_duration_millisecond_minute": "mm:ss SSS",
    "_duration_millisecond_hour": "hh:mm:ss SSS",
    "_duration_millisecond_day": "d'd' mm:ss SSS",
    "_duration_millisecond_week": "d'd' mm:ss SSS",
    "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
    "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
    "_duration_second": "ss",
    "_duration_second_minute": "mm:ss",
    "_duration_second_hour": "hh:mm:ss",
    "_duration_second_day": "d'd' hh:mm:ss",
    "_duration_second_week": "d'd' hh:mm:ss",
    "_duration_second_month": "M'm' dd'd' hh:mm:ss",
    "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
    "_duration_minute": "mm",
    "_duration_minute_hour": "hh:mm",
    "_duration_minute_day": "d'd' hh:mm",
    "_duration_minute_week": "d'd' hh:mm",
    "_duration_minute_month": "M'm' dd'd' hh:mm",
    "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
    "_duration_hour": "hh'h'",
    "_duration_hour_day": "d'd' hh'h'",
    "_duration_hour_week": "d'd' hh'h'",
    "_duration_hour_month": "M'm' dd'd' hh'h'",
    "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
    "_duration_day": "d'd'",
    "_duration_day_week": "d'd'",
    "_duration_day_month": "M'm' dd'd'",
    "_duration_day_year": "y'y' MM'm' dd'd'",
    "_duration_week": "w'w'",
    "_duration_week_month": "w'w'",
    "_duration_week_year": "w'w'",
    "_duration_month": "M'm'",
    "_duration_month_year": "y'y' MM'm'",
    "_duration_year": "y'y'",
    // Era translations
    "_era_ad": "AD",
    "_era_bc": "BC",
    // Day part, used in 12-hour formats, e.g. 5 P.M.
    // Please note that these come in 3 variants:
    // * one letter (e.g. "A")
    // * two letters (e.g. "AM")
    // * two letters with dots (e.g. "A.M.")
    // 
    // All three need to to be translated even if they are all the same. Some
    // users might use one, some the other.
    "A": "",
    "P": "",
    "AM": "",
    "PM": "",
    "A.M.": "",
    "P.M.": "",
    // Date-related stuff.
    // 
    // When translating months, if there's a difference, use the form which is
    // best for a full date, e.g. as you would use it in "2018 January 1".
    // 
    // Note that May is listed twice. This is because in English May is the same
    // in both long and short forms, while in other languages it may not be the
    // case. Translate "May" to full word, while "May(short)" to shortened
    // version.
    // 
    // Should month names and weekdays be capitalized or not?
    // 
    // Rule of thumb is this: if the names should always be capitalized,
    // regardless of name position within date ("January", "21st January 2018",
    // etc.) use capitalized names. Otherwise enter all lowercase.
    // 
    // The date formatter will automatically capitalize names if they are the
    // first (or only) word in resulting date.
    "January": "",
    "February": "",
    "March": "",
    "April": "",
    "May": "",
    "June": "",
    "July": "",
    "August": "",
    "September": "",
    "October": "",
    "November": "",
    "December": "",
    "Jan": "",
    "Feb": "",
    "Mar": "",
    "Apr": "",
    "May(short)": "May",
    "Jun": "",
    "Jul": "",
    "Aug": "",
    "Sep": "",
    "Oct": "",
    "Nov": "",
    "Dec": "",
    // Weekdays.
    "Sunday": "",
    "Monday": "",
    "Tuesday": "",
    "Wednesday": "",
    "Thursday": "",
    "Friday": "",
    "Saturday": "",
    "Sun": "",
    "Mon": "",
    "Tue": "",
    "Wed": "",
    "Thu": "",
    "Fri": "",
    "Sat": "",
    // Date ordinal function.
    // 
    // This is used when adding number ordinal when formatting days in dates.
    // 
    // E.g. "January 1st", "February 2nd".
    // 
    // The function accepts day number, and returns a string to be added to the
    // day, like in default English translation, if we pass in 2, we will receive
    // "nd" back.
    "_dateOrd": function (day) {
        var res = "th";
        if ((day < 11) || (day > 13)) {
            switch (day % 10) {
                case 1:
                    res = "st";
                    break;
                case 2:
                    res = "nd";
                    break;
                case 3:
                    res = "rd";
                    break;
            }
        }
        return res;
    },
    // Various chart controls.
    // Shown as a tooltip on zoom out button.
    "Zoom Out": "",
    // Timeline buttons
    "Play": "",
    "Stop": "",
    // Chart's Legend screen reader title.
    "Legend": "",
    // Legend's item screen reader indicator.
    "Press ENTER to toggle": "",
    // Shown when the chart is busy loading something.
    "Loading": "",
    // Shown as the first button in the breadcrumb navigation, e.g.:
    // Home > First level > ...
    "Home": "",
    // Chart types.
    // Those are used as default screen reader titles for the main chart element
    // unless developer has set some more descriptive title.
    "Chart": "",
    "Serial chart": "",
    "X/Y chart": "",
    "Pie chart": "",
    "Gauge chart": "",
    "Radar chart": "",
    "Sankey diagram": "",
    "Flow diagram": "",
    "Chord diagram": "",
    "TreeMap chart": "",
    "Force directed tree": "",
    "Sliced chart": "",
    // Series types.
    // Used to name series by type for screen readers if they do not have their
    // name set.
    "Series": "",
    "Candlestick Series": "",
    "OHLC Series": "",
    "Column Series": "",
    "Line Series": "",
    "Pie Slice Series": "",
    "Funnel Series": "",
    "Pyramid Series": "",
    "X/Y Series": "",
    // Map-related stuff.
    "Map": "",
    "Press ENTER to zoom in": "",
    "Press ENTER to zoom out": "",
    "Use arrow keys to zoom in and out": "",
    "Use plus and minus keys on your keyboard to zoom in and out": "",
    // Export-related stuff.
    // These prompts are used in Export menu labels.
    // 
    // "Export" is the top-level menu item.
    // 
    // "Image", "Data", "Print" as second-level indicating type of export
    // operation.
    // 
    // Leave actual format untranslated, unless you absolutely know that they
    // would convey more meaning in some other way.
    "Export": "",
    "Image": "",
    "Data": "",
    "Print": "",
    "Press ENTER or use arrow keys to navigate": "",
    "Press ENTER to open": "",
    "Press ENTER to print.": "",
    "Press ENTER to export as %1.": "",
    "(Press ESC to close this message)": "",
    "Image Export Complete": "",
    "Export operation took longer than expected. Something might have gone wrong.": "",
    "Saved from": "",
    "PNG": "",
    "JPG": "",
    "GIF": "",
    "SVG": "",
    "PDF": "",
    "JSON": "",
    "CSV": "",
    "XLSX": "",
    "HTML": "",
    // Scrollbar-related stuff.
    // 
    // Scrollbar is a control which can zoom and pan the axes on the chart.
    // 
    // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
    // upper and lower (for vertical one).
    // 
    // Prompts change in relation to whether Scrollbar is vertical or horizontal.
    // 
    // The final section is used to indicate the current range of selection.
    "Use TAB to select grip buttons or left and right arrows to change selection": "",
    "Use left and right arrows to move selection": "",
    "Use left and right arrows to move left selection": "",
    "Use left and right arrows to move right selection": "",
    "Use TAB select grip buttons or up and down arrows to change selection": "",
    "Use up and down arrows to move selection": "",
    "Use up and down arrows to move lower selection": "",
    "Use up and down arrows to move upper selection": "",
    "From %1 to %2": "",
    "From %1": "",
    "To %1": "",
    // Data loader-related.
    "No parser available for file: %1": "",
    "Error parsing file: %1": "",
    "Unable to load file: %1": "",
    "Invalid date": "",
    // Common actions
    "Close": "",
    "Minimize": ""
});
//# sourceMappingURL=en.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js




;
var Language = /** @class */ (function (_super) {
    __extends(Language, _super);
    function Language() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Language.prototype, "_setDefaults", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setPrivate("defaultLocale", en);
            _super.prototype._setDefaults.call(this);
        }
    });
    Object.defineProperty(Language.prototype, "translate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (prompt, locale) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            // Get langauge
            if (!locale) {
                locale = this._root.locale || this.getPrivate("defaultLocale");
            }
            // Init translation
            var translation = prompt;
            var value = locale[prompt];
            // Try to look for the translation
            if (value === null) {
                translation = "";
            }
            else if (value != null) {
                // It might be an empty string
                if (value) {
                    translation = value;
                }
            }
            else if (locale !== this.getPrivate("defaultLocale")) {
                // Try to look in default language
                return this.translate.apply(this, __spreadArray([prompt, this.getPrivate("defaultLocale")], __read(rest)));
            }
            // Replace %1, %2, etc params
            if (rest.length) {
                for (var len = rest.length, i = 0; i < len; ++i) {
                    translation = translation.split("%" + (i + 1)).join(rest[i]);
                }
            }
            // Return the translation
            return translation;
        }
    });
    Object.defineProperty(Language.prototype, "translateAny", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (prompt, locale) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            return this.translate.apply(this, __spreadArray([prompt, locale], __read(rest)));
        }
    });
    Object.defineProperty(Language.prototype, "setTranslationAny", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (prompt, translation, locale) {
            var localeTarget = locale || this._root.locale;
            localeTarget[prompt] = translation;
        }
    });
    Object.defineProperty(Language.prototype, "translateEmpty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (prompt, locale) {
            var rest = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                rest[_i - 2] = arguments[_i];
            }
            var translation = this.translate.apply(this, __spreadArray([prompt, locale], __read(rest)));
            return translation == prompt ? "" : translation;
        }
    });
    Object.defineProperty(Language.prototype, "translateFunc", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (prompt, locale) {
            if (this._root.locale[prompt]) {
                return this._root.locale[prompt];
            }
            // Try to look in default language
            if (locale !== this.getPrivate("defaultLocale")) {
                return this.translateFunc(prompt, this.getPrivate("defaultLocale"));
            }
            // Fail - return empty function
            return function () {
                return "";
            };
        }
    });
    Object.defineProperty(Language.prototype, "translateAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (list, locale) {
            var _this = this;
            // Translate all items in the list
            if (!this.isDefault()) {
                return map(list, function (x) { return _this.translate(x, locale); });
            }
            else {
                return list;
            }
        }
    });
    /**
     * Returns `true` if the currently selected locale is a default locale.
     *
     * @return `true` if locale is default; `false` if it is not.
     */
    Object.defineProperty(Language.prototype, "isDefault", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.getPrivate("defaultLocale") === this._root.locale;
        }
    });
    return Language;
}(Entity));

//# sourceMappingURL=Language.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Theme.js



/**
 * A base class for an amCharts theme.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
 * @important
 */
var Theme = /** @class */ (function () {
    function Theme(root, isReal) {
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._root = root;
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    Object.defineProperty(Theme, "new", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root) {
            var x = (new this(root, true));
            x.setupDefaultRules();
            return x;
        }
    });
    Object.defineProperty(Theme.prototype, "setupDefaultRules", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    /**
     * Looks up the rules for a specific theme class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @return             Array<IRule<A>>
     */
    Object.defineProperty(Theme.prototype, "_lookupRules", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (themeClass) {
            return this._rules[themeClass];
        }
    });
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
     * type checks.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    Object.defineProperty(Theme.prototype, "ruleRaw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (themeClass, themeTags) {
            if (themeTags === void 0) { themeTags = []; }
            var rules = this._rules[themeClass];
            if (!rules) {
                rules = this._rules[themeClass] = [];
            }
            themeTags.sort(compare);
            var _a = getSortedIndex(rules, function (x) {
                var order = compare(x.tags.length, themeTags.length);
                if (order === 0) {
                    return compareArray(x.tags, themeTags, compare);
                }
                else {
                    return order;
                }
            }), index = _a.index, found = _a.found;
            if (found) {
                return rules[index].template;
            }
            else {
                var template = Template.new({});
                rules.splice(index, 0, {
                    tags: themeTags,
                    template: template,
                });
                return template;
            }
        }
    });
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    Object.defineProperty(Theme.prototype, "rule", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (themeClass, themeTags) {
            if (themeTags === void 0) { themeTags = []; }
            return this.ruleRaw(themeClass, themeTags);
        }
    });
    return Theme;
}());

//# sourceMappingURL=Theme.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js






/**
 * @ignore
 */
function setColor(rule, key, ic, name) {
    // TODO this shouldn't use get, figure out a better way
    rule.set(key, ic.get(name));
    ic.on(name, function (value) {
        rule.set(key, value);
    });
}
/**
 * @ignore
 */
var DefaultTheme = /** @class */ (function (_super) {
    __extends(DefaultTheme, _super);
    function DefaultTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(DefaultTheme.prototype, "setupDefaultRules", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.setupDefaultRules.call(this);
            var language = this._root.language;
            var ic = this._root.interfaceColors;
            var horizontalLayout = this._root.horizontalLayout;
            var verticalLayout = this._root.verticalLayout;
            var r = this.rule.bind(this);
            /**
             * ========================================================================
             * core
             * ========================================================================
             */
            r("InterfaceColors").setAll({
                stroke: Color.fromHex(0xe5e5e5),
                fill: Color.fromHex(0xf3f3f3),
                primaryButton: Color.fromHex(0x6794dc),
                primaryButtonHover: Color.fromHex(0x6771dc),
                primaryButtonDown: Color.fromHex(0x68dc76),
                primaryButtonActive: Color.fromHex(0x68dc76),
                primaryButtonText: Color.fromHex(0xffffff),
                primaryButtonStroke: Color.fromHex(0xffffff),
                secondaryButton: Color.fromHex(0xd9d9d9),
                secondaryButtonHover: Color.fromHex(0xa3a3a3),
                secondaryButtonDown: Color.fromHex(0x8d8d8d),
                secondaryButtonActive: Color.fromHex(0xe6e6e6),
                secondaryButtonText: Color.fromHex(0x000000),
                secondaryButtonStroke: Color.fromHex(0xffffff),
                grid: Color.fromHex(0x000000),
                background: Color.fromHex(0xffffff),
                alternativeBackground: Color.fromHex(0x000000),
                text: Color.fromHex(0x000000),
                alternativeText: Color.fromHex(0xffffff),
                disabled: Color.fromHex(0xadadad),
                positive: Color.fromHex(0x50b300),
                negative: Color.fromHex(0xb30000)
            });
            {
                var rule = r("ColorSet");
                rule.setAll({
                    passOptions: {
                        hue: 0.05,
                        saturation: 0,
                        lightness: 0
                    },
                    colors: [
                        Color.fromHex(0x67b7dc)
                    ],
                    step: 1,
                    //baseColor: Color.fromRGB(103, 183, 220),
                    //count: 20,
                    reuse: false,
                    startIndex: 0
                });
                rule.setPrivate("currentStep", 0);
                rule.setPrivate("currentPass", 0);
            }
            r("Entity").setAll({
                stateAnimationDuration: 0,
                stateAnimationEasing: out(cubic)
            });
            r("Component").setAll({
                interpolationDuration: 0,
                interpolationEasing: out(cubic)
            });
            r("Sprite").setAll({
                visible: true,
                scale: 1,
                opacity: 1,
                rotation: 0,
                position: "relative",
                tooltipX: p50,
                tooltipY: p50,
                tooltipPosition: "fixed",
                isMeasured: true
            });
            r("Sprite").states.create("default", { "visible": true, opacity: 1 });
            r("Container").setAll({
                interactiveChildren: true,
                setStateOnChildren: false
            });
            r("Graphics").setAll({
                strokeWidth: 1
            });
            r("Chart").setAll({
                width: p100,
                height: p100
            });
            /**
             * ------------------------------------------------------------------------
             * core: alignment
             * ------------------------------------------------------------------------
             */
            r("Sprite", ["horizontal", "center"]).setAll({
                centerX: p50,
                x: p50
            });
            r("Sprite", ["vertical", "center"]).setAll({
                centerY: p50,
                y: p50
            });
            r("Container", ["horizontal", "layout"]).setAll({
                layout: horizontalLayout
            });
            r("Container", ["vertical", "layout"]).setAll({
                layout: verticalLayout
            });
            /**
             * ------------------------------------------------------------------------
             * core: patterns
             * ------------------------------------------------------------------------
             */
            r("Pattern").setAll({
                repetition: "repeat",
                width: 50,
                height: 50,
                rotation: 0,
                fillOpacity: 1
            });
            r("LinePattern").setAll({
                gap: 6,
                colorOpacity: 1,
                width: 49,
                height: 49
            });
            r("RectanglePattern").setAll({
                gap: 6,
                checkered: false,
                centered: true,
                maxWidth: 5,
                maxHeight: 5,
                width: 48,
                height: 48,
                strokeWidth: 0
            });
            r("CirclePattern").setAll({
                gap: 5,
                checkered: false,
                centered: false,
                radius: 3,
                strokeWidth: 0,
                width: 45,
                height: 45
            });
            /**
             * ------------------------------------------------------------------------
             * core: gradients
             * ------------------------------------------------------------------------
             */
            r("LinearGradient").setAll({
                rotation: 90
            });
            /**
             * ------------------------------------------------------------------------
             * core: Legend
             * ------------------------------------------------------------------------
             */
            r("Legend").setAll({
                fillField: "fill",
                strokeField: "stroke",
                nameField: "name",
                layout: GridLayout.new(this._root, {}),
                layer: 30,
                clickTarget: "itemContainer"
            });
            // Class: Container
            r("Container", ["legend", "item", "itemcontainer"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingBottom: 5,
                paddingTop: 5,
                layout: horizontalLayout,
                setStateOnChildren: true,
                interactiveChildren: false,
                ariaChecked: true,
                focusable: true,
                ariaLabel: language.translate("Press ENTER to toggle")
            });
            {
                var rule = r("Rectangle", ["legend", "item", "background"]);
                rule.setAll({
                    fillOpacity: 0,
                });
                setColor(rule, "fill", ic, "background");
            }
            r("Container", ["legend", "marker"]).setAll({
                setStateOnChildren: true,
                centerY: p50,
                paddingLeft: 0,
                paddingRight: 0,
                paddingBottom: 0,
                paddingTop: 0,
                width: 18,
                height: 18
            });
            r("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
                width: p100,
                height: p100,
                cornerRadiusBL: 3,
                cornerRadiusTL: 3,
                cornerRadiusBR: 3,
                cornerRadiusTR: 3
            });
            {
                var rule = r("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
                setColor(rule, "stroke", ic, "disabled");
            }
            r("Label", ["legend", "label"]).setAll({
                centerY: p50,
                marginLeft: 5,
                paddingRight: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingBottom: 0,
                populateText: true
            });
            {
                var rule = r("Label", ["legend", "label"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
            }
            r("Label", ["legend", "value", "label"]).setAll({
                centerY: p50,
                marginLeft: 5,
                paddingRight: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingBottom: 0,
                width: 50,
                centerX: p100,
                populateText: true
            });
            {
                var rule = r("Label", ["legend", "value", "label"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
            }
            /**
             * ------------------------------------------------------------------------
             * core: HeatLegend
             * ------------------------------------------------------------------------
             */
            r("HeatLegend").setAll({
                stepCount: 1
            });
            r("RoundedRectangle", ["heatlegend", "marker"]).setAll({
                cornerRadiusTR: 0,
                cornerRadiusBR: 0,
                cornerRadiusTL: 0,
                cornerRadiusBL: 0
            });
            r("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
                height: p100,
                width: 15
            });
            r("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
                width: p100,
                height: 15
            });
            r("HeatLegend", ["vertical"]).setAll({
                height: p100
            });
            r("HeatLegend", ["horizontal"]).setAll({
                width: p100
            });
            r("Label", ["heatlegend", "start"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingTop: 5,
                paddingBottom: 5
            });
            r("Label", ["heatlegend", "end"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingTop: 5,
                paddingBottom: 5
            });
            /**
             * ------------------------------------------------------------------------
             * core: Labels
             * ------------------------------------------------------------------------
             */
            {
                var rule = r("Label");
                rule.setAll({
                    paddingTop: 8,
                    paddingBottom: 8,
                    paddingLeft: 10,
                    paddingRight: 10,
                    fontFamily: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
                    fontSize: "1em",
                    populateText: false
                });
                setColor(rule, "fill", ic, "text");
            }
            r("RadialLabel").setAll({
                textType: "regular",
                centerY: p50,
                centerX: p50,
                inside: false,
                radius: 0,
                baseRadius: p100,
                orientation: "auto",
                textAlign: "center"
            });
            /**
             * ------------------------------------------------------------------------
             * core: Elements and shapes
             * ------------------------------------------------------------------------
             */
            r("RoundedRectangle").setAll({
                cornerRadiusTL: 8,
                cornerRadiusBL: 8,
                cornerRadiusTR: 8,
                cornerRadiusBR: 8
            });
            r("PointedRectangle").setAll({
                pointerBaseWidth: 15,
                pointerLength: 10,
                cornerRadius: 8
            });
            r("Slice").setAll({
                shiftRadius: 0,
                dRadius: 0,
                dInnerRadius: 0
            });
            {
                var rule = r("Tick");
                rule.setAll({
                    strokeOpacity: .15,
                    isMeasured: false,
                    length: 5,
                    position: "absolute"
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("Bullet").setAll({
                locationX: 0.5,
                locationY: 0.5
            });
            /**
             * ------------------------------------------------------------------------
             * core: Tooltip
             * ------------------------------------------------------------------------
             */
            r("Tooltip").setAll({
                position: "absolute",
                getFillFromSprite: true,
                getStrokeFromSprite: false,
                autoTextColor: true,
                paddingTop: 9,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                marginBottom: 5,
                pointerOrientation: "vertical",
                centerX: p50,
                centerY: p50,
                animationEasing: out(cubic),
                exportable: false
                //layer: 100
            });
            {
                var rule = r("PointedRectangle", ["tooltip", "background"]);
                rule.setAll({
                    strokeOpacity: 0.9,
                    cornerRadius: 4,
                    pointerLength: 4,
                    pointerBaseWidth: 8,
                    fillOpacity: 0.9,
                    stroke: Color.fromHex(0xffffff)
                });
            }
            {
                var rule = r("Label", ["tooltip"]);
                rule.setAll({
                    role: "tooltip",
                    populateText: true,
                    paddingRight: 0,
                    paddingTop: 0,
                    paddingLeft: 0,
                    paddingBottom: 0
                });
                setColor(rule, "fill", ic, "alternativeText");
            }
            /**
             * ------------------------------------------------------------------------
             * core: Button
             * ------------------------------------------------------------------------
             */
            r("Button").setAll({
                paddingTop: 8,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                interactive: true,
                layout: horizontalLayout,
                interactiveChildren: false,
                setStateOnChildren: true,
                focusable: true
            });
            r("Button").states.create("hover", {});
            r("Button").states.create("down", { stateAnimationDuration: 0 });
            r("Button").states.create("active", {});
            {
                var rule = r("RoundedRectangle", ["button", "background"]);
                setColor(rule, "fill", ic, "primaryButton");
                setColor(rule, "stroke", ic, "primaryButtonStroke");
            }
            {
                var rule = r("RoundedRectangle", ["button", "background"]).states.create("hover", {});
                setColor(rule, "fill", ic, "primaryButtonHover");
            }
            {
                var rule = r("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "primaryButtonDown");
            }
            {
                var rule = r("RoundedRectangle", ["button", "background"]).states.create("active", {});
                setColor(rule, "fill", ic, "primaryButtonActive");
            }
            {
                var rule = r("Graphics", ["button", "icon"]);
                setColor(rule, "stroke", ic, "primaryButtonText");
            }
            {
                var rule = r("Label", ["button"]);
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            /**
             * ------------------------------------------------------------------------
             * charts/xy: ZoomOutButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["zoom"]).setAll({
                paddingTop: 18,
                paddingBottom: 18,
                paddingLeft: 12,
                paddingRight: 12,
                centerX: 46,
                centerY: -10,
                y: 0,
                x: p100,
                role: "button",
                ariaLabel: language.translate("Zoom Out"),
                layer: 30
            });
            {
                var rule = r("RoundedRectangle", ["background", "button", "zoom"]);
                rule.setAll({
                    cornerRadiusBL: 40,
                    cornerRadiusBR: 40,
                    cornerRadiusTL: 40,
                    cornerRadiusTR: 40
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                var rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
                setColor(rule, "fill", ic, "primaryButtonHover");
            }
            {
                var rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "primaryButtonDown");
            }
            {
                var rule = r("Graphics", ["icon", "button", "zoom"]);
                rule.setAll({
                    strokeOpacity: 0.7,
                    draw: function (display) {
                        display.moveTo(0, 0);
                        display.lineTo(12, 0);
                    }
                });
                setColor(rule, "stroke", ic, "primaryButtonText");
            }
            /**
             * ------------------------------------------------------------------------
             * core: ResizeButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["resize"]).setAll({
                paddingTop: 9,
                paddingBottom: 9,
                paddingLeft: 13,
                paddingRight: 13,
                draggable: true,
                centerX: p50,
                centerY: p50,
                position: "absolute",
                role: "slider",
                ariaValueMin: "0",
                ariaValueMax: "100",
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            {
                var rule = r("RoundedRectangle", ["background", "resize", "button"]);
                rule.setAll({
                    cornerRadiusBL: 40,
                    cornerRadiusBR: 40,
                    cornerRadiusTL: 40,
                    cornerRadiusTR: 40
                });
                setColor(rule, "fill", ic, "secondaryButton");
            }
            {
                var rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
                setColor(rule, "fill", ic, "secondaryButtonHover");
            }
            {
                var rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "secondaryButtonDown");
            }
            {
                var rule = r("Graphics", ["resize", "button", "icon"]);
                rule.setAll({
                    strokeOpacity: 0.7,
                    draw: function (display) {
                        display.moveTo(0, 0);
                        display.lineTo(0, 12);
                        display.moveTo(4, 0);
                        display.lineTo(4, 12);
                    }
                });
                setColor(rule, "stroke", ic, "secondaryButtonText");
            }
            r("Button", ["resize", "vertical"]).setAll({
                rotation: 90,
                cursorOverStyle: "ns-resize"
            });
            r("Button", ["resize", "horizontal"]).setAll({
                cursorOverStyle: "ew-resize"
            });
            /**
             * ------------------------------------------------------------------------
             * core: PlayButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["play"]).setAll({
                paddingTop: 13,
                paddingBottom: 13,
                paddingLeft: 14,
                paddingRight: 14,
                ariaLabel: language.translate("Play"),
                toggleKey: "active"
            });
            {
                var rule = r("RoundedRectangle", ["play", "background"]);
                rule.setAll({
                    strokeOpacity: 0.5,
                    cornerRadiusBL: 100,
                    cornerRadiusBR: 100,
                    cornerRadiusTL: 100,
                    cornerRadiusTR: 100
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                var rule = r("Graphics", ["play", "icon"]);
                rule.setAll({
                    stateAnimationDuration: 0,
                    dx: 1,
                    draw: function (display) {
                        display.moveTo(0, -5);
                        display.lineTo(8, 0);
                        display.lineTo(0, 5);
                        display.lineTo(0, -5);
                    }
                });
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            r("Graphics", ["play", "icon"]).states.create("default", {
                stateAnimationDuration: 0
            });
            r("Graphics", ["play", "icon"]).states.create("active", {
                stateAnimationDuration: 0,
                draw: function (display) {
                    display.moveTo(-4, -5);
                    display.lineTo(-1, -5);
                    display.lineTo(-1, 5);
                    display.lineTo(-4, 5);
                    display.lineTo(-4, -5);
                    display.moveTo(4, -5);
                    display.lineTo(1, -5);
                    display.lineTo(1, 5);
                    display.lineTo(4, 5);
                    display.lineTo(4, -5);
                }
            });
            /**
             * ------------------------------------------------------------------------
             * core: SwitchButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["switch"]).setAll({
                paddingTop: 4,
                paddingBottom: 4,
                paddingLeft: 4,
                paddingRight: 4,
                ariaLabel: language.translate("Press ENTER to toggle"),
                toggleKey: "active",
                width: 40,
                height: 24,
                layout: null
            });
            {
                var rule = r("RoundedRectangle", ["switch", "background"]);
                rule.setAll({
                    strokeOpacity: 0.5,
                    cornerRadiusBL: 100,
                    cornerRadiusBR: 100,
                    cornerRadiusTL: 100,
                    cornerRadiusTR: 100
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                var rule = r("Circle", ["switch", "icon"]);
                rule.setAll({
                    radius: 8,
                    centerY: 0,
                    centerX: 0,
                    dx: 0
                });
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            r("Graphics", ["switch", "icon"]).states.create("active", {
                dx: 16
            });
            /**
             * ------------------------------------------------------------------------
             * core: Scrollbar
             * ------------------------------------------------------------------------
             */
            r("Scrollbar").setAll({
                start: 0,
                end: 1,
                layer: 30,
                animationEasing: out(cubic)
            });
            r("Scrollbar", ["vertical"]).setAll({
                marginRight: 13,
                marginLeft: 13,
                minWidth: 12,
                height: p100
            });
            r("Scrollbar", ["horizontal"]).setAll({
                marginTop: 13,
                marginBottom: 13,
                minHeight: 12,
                width: p100
            });
            this.rule("Button", ["scrollbar"]).setAll({
                exportable: false
            });
            {
                var rule = r("RoundedRectangle", ["scrollbar", "main", "background"]);
                rule.setAll({
                    cornerRadiusTL: 8,
                    cornerRadiusBL: 8,
                    cornerRadiusTR: 8,
                    cornerRadiusBR: 8,
                    fillOpacity: 0.8,
                });
                setColor(rule, "fill", ic, "fill");
            }
            {
                var rule = r("RoundedRectangle", ["scrollbar", "thumb"]);
                rule.setAll({
                    role: "slider",
                    ariaLive: "polite",
                    position: "absolute",
                    draggable: true
                });
                setColor(rule, "fill", ic, "secondaryButton");
            }
            {
                var rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
                setColor(rule, "fill", ic, "secondaryButtonHover");
            }
            {
                var rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "secondaryButtonDown");
            }
            r("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
                x: p50,
                width: p100,
                centerX: p50,
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            r("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
                y: p50,
                centerY: p50,
                height: p100,
                ariaLabel: language.translate("Use left and right arrows to move selection")
            });
            // @todo: is this needed? used to be "ContentScrollbar"
            // r("Scrollbar", ["content?"]).setAll({
            // 	marginRight: 0,
            // 	marginLeft: 5,
            // 	layer: 5
            // });
            /**
             * ========================================================================
             * charts/xy
             * ========================================================================
             *
             * This needs to be in DefaultTheme because it's the only theme that is
             * automatically applied to Root, and tooltips different ancestors
             * than actual charts using them.
             */
            {
                var rule = r("PointedRectangle", ["axis", "tooltip", "background"]);
                rule.setAll({
                    cornerRadius: 0
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            r("Label", ["axis", "tooltip"]).setAll({
                role: undefined
            });
            r("Label", ["axis", "tooltip", "y"]).setAll({
                textAlign: "right"
            });
            r("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
                textAlign: "left"
            });
            r("Label", ["axis", "tooltip", "x"]).setAll({
                textAlign: "center"
            });
            r("Tooltip", ["categoryaxis"]).setAll({
                labelText: "{category}"
            });
            /**
             * ------------------------------------------------------------------------
             * Shapes
             * ------------------------------------------------------------------------
             */
            // Class: Graphics
            r("Star").setAll({
                spikes: 5,
                innerRadius: 5,
                radius: 10
            });
        }
    });
    return DefaultTheme;
}(Theme));

//# sourceMappingURL=DefaultTheme.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js
/**
 * Modified from Pixi:
 *
 * The MIT License
 *
 * Copyright (c) 2013-2017 Mathew Groves, Chad Engler
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @ignore
 */
var Matrix = /** @class */ (function () {
    function Matrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        Object.defineProperty(this, "a", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "b", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "c", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "d", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
     * Sets the matrix based on all the available properties
     */
    Object.defineProperty(Matrix.prototype, "setTransform", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y, pivotX, pivotY, rotation, scale) {
            if (scale === void 0) { scale = 1; }
            this.a = Math.cos(rotation) * scale;
            this.b = Math.sin(rotation) * scale;
            this.c = -Math.sin(rotation) * scale;
            this.d = Math.cos(rotation) * scale;
            this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
            this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        }
    });
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     */
    Object.defineProperty(Matrix.prototype, "apply", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (origin) {
            return {
                x: (this.a * origin.x) + (this.c * origin.y) + this.tx,
                y: (this.b * origin.x) + (this.d * origin.y) + this.ty
            };
        }
    });
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     */
    Object.defineProperty(Matrix.prototype, "applyInverse", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (origin) {
            var id = 1 / ((this.a * this.d) + (this.c * -this.b));
            return {
                x: (this.d * id * origin.x) + (-this.c * id * origin.y) + (((this.ty * this.c) - (this.tx * this.d)) * id),
                y: (this.a * id * origin.y) + (-this.b * id * origin.x) + (((-this.ty * this.a) + (this.tx * this.b)) * id)
            };
        }
    });
    /**
     * Appends the given Matrix to this Matrix.
     */
    Object.defineProperty(Matrix.prototype, "append", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (matrix) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            this.a = (matrix.a * a1) + (matrix.b * c1);
            this.b = (matrix.a * b1) + (matrix.b * d1);
            this.c = (matrix.c * a1) + (matrix.d * c1);
            this.d = (matrix.c * b1) + (matrix.d * d1);
            this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
            this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        }
    });
    /**
     * Prepends the given Matrix to this Matrix.
     */
    Object.defineProperty(Matrix.prototype, "prepend", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (matrix) {
            var tx1 = this.tx;
            if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
                var a1 = this.a;
                var c1 = this.c;
                this.a = (a1 * matrix.a) + (this.b * matrix.c);
                this.b = (a1 * matrix.b) + (this.b * matrix.d);
                this.c = (c1 * matrix.a) + (this.d * matrix.c);
                this.d = (c1 * matrix.b) + (this.d * matrix.d);
            }
            this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
            this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        }
    });
    /**
     * Copies the other matrix's properties into this matrix
     */
    Object.defineProperty(Matrix.prototype, "copyFrom", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (matrix) {
            this.a = matrix.a;
            this.b = matrix.b;
            this.c = matrix.c;
            this.d = matrix.d;
            this.tx = matrix.tx;
            this.ty = matrix.ty;
        }
    });
    return Matrix;
}());

//# sourceMappingURL=Matrix.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Throttler.js
var Throttler = /** @class */ (function () {
    function Throttler(fn) {
        Object.defineProperty(this, "_ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_pending", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_fn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._fn = fn;
    }
    Object.defineProperty(Throttler.prototype, "run", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this._ready) {
                this._ready = false;
                this._pending = false;
                requestAnimationFrame(function () {
                    _this._ready = true;
                    if (_this._pending) {
                        _this.run();
                    }
                });
                this._fn();
            }
            else {
                this._pending = true;
            }
        }
    });
    return Throttler;
}());

//# sourceMappingURL=Throttler.js.map
;// CONCATENATED MODULE: ./node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var TAU = Math.PI * 2;

var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x,
      y = _ref.y;

  x *= rx;
  y *= ry;

  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;

  return {
    x: xp + centerx,
    y: yp + centery
  };
};

var approxUnitArc = function approxUnitArc(ang1, ang2) {
  // If 90 degree circular arc, use a constant
  // as derived from http://spencermortensen.com/articles/bezier-circle
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);

  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);

  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};

var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;

  var dot = ux * vx + uy * vy;

  if (dot > 1) {
    dot = 1;
  }

  if (dot < -1) {
    dot = -1;
  }

  return sign * Math.acos(dot);
};

var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);

  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

  if (radicant < 0) {
    radicant = 0;
  }

  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;

  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;

  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }

  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }

  return [centerx, centery, ang1, ang2];
};

var arcToBezier = function arcToBezier(_ref2) {
  var px = _ref2.px,
      py = _ref2.py,
      cx = _ref2.cx,
      cy = _ref2.cy,
      rx = _ref2.rx,
      ry = _ref2.ry,
      _ref2$xAxisRotation = _ref2.xAxisRotation,
      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
      _ref2$largeArcFlag = _ref2.largeArcFlag,
      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
      _ref2$sweepFlag = _ref2.sweepFlag,
      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

  var curves = [];

  if (rx === 0 || ry === 0) {
    return [];
  }

  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);

  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

  if (pxp === 0 && pyp === 0) {
    return [];
  }

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),
      centerx = _getArcCenter2[0],
      centery = _getArcCenter2[1],
      ang1 = _getArcCenter2[2],
      ang2 = _getArcCenter2[3];

  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
  // 1.0000000001. This causes `segments` to be greater than one, which is an
  // unecessary split, and adds extra points to the bezier curve. To alleviate
  // this issue, we round to 1.0 when the ratio is close to 1.0.


  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1.0 - ratio) < 0.0000001) {
    ratio = 1.0;
  }

  var segments = Math.max(Math.ceil(ratio), 1);

  ang2 /= segments;

  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }

  return curves.map(function (curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
        x1 = _mapToEllipse.x,
        y1 = _mapToEllipse.y;

    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
        x2 = _mapToEllipse2.x,
        y2 = _mapToEllipse2.y;

    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
        x = _mapToEllipse3.x,
        y = _mapToEllipse3.y;

    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
  });
};

/* harmony default export */ var modules = (arcToBezier);
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js
/** @ignore */ /** */














/**
 * @ignore
 */
function checkArgs(name, actual, expected) {
    if (actual !== expected) {
        throw new Error("Required " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkMinArgs(name, actual, expected) {
    if (actual < expected) {
        throw new Error("Required at least " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkEvenArgs(name, actual, expected) {
    checkMinArgs(name, actual, expected);
    if ((actual % expected) !== 0) {
        throw new Error("Arguments for " + name + " must be in pairs of " + expected);
    }
}
/**
 * @ignore
 */
function assertBinary(value) {
    if (value === 0 || value === 1) {
        return value;
    }
    else {
        throw new Error("Flag must be 0 or 1");
    }
}
//  1 -> 0xffffff * (2 / 2)
//  2 -> 0xffffff * (1 / 2)
//
//  3 -> 0xffffff * (3 / 4)
//  4 -> 0xffffff * (1 / 4)
//
//  5 -> 0xffffff * (7 / 8)
//  6 -> 0xffffff * (5 / 8)
//  7 -> 0xffffff * (3 / 8)
//  8 -> 0xffffff * (1 / 8)
//
//  9 -> 0xffffff * (15 / 16)
// 10 -> 0xffffff * (13 / 16)
// 11 -> 0xffffff * (11 / 16)
// 12 -> 0xffffff *  (9 / 16)
// 13 -> 0xffffff *  (7 / 16)
// 14 -> 0xffffff *  (5 / 16)
// 15 -> 0xffffff *  (3 / 16)
// 16 -> 0xffffff *  (1 / 16)
// @todo remove this old color distribution algo if the new one pans out
// function distributeIdBAK(id: number): number {
// 	if (id === 1) {
// 		return 0x000001;
// 	} else {
// 		// Finds the closest power of 2
// 		const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));
// 		// Translates the id into an odd fraction index
// 		const index = ((base - id) * 2) + 1;
// 		// TODO is Math.round correct ?
// 		return Math.round(0xffffff * (index / base));
// 	}
// }
/**
 * Function by smeans:
 * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/
 * @ignore
 */
function distributeId(id) {
    var rgb = [0, 0, 0];
    for (var i = 0; i < 24; i++) {
        rgb[i % 3] <<= 1;
        rgb[i % 3] |= id & 0x01;
        id >>= 1;
    }
    return (rgb[2] | 0) + (rgb[1] << 8) + (rgb[0] << 16);
}
/**
 * @ignore
 */
function eachTargets(hitTarget, f) {
    for (;;) {
        if (hitTarget.interactive) {
            if (!f(hitTarget)) {
                break;
            }
        }
        if (hitTarget._parent) {
            hitTarget = hitTarget._parent;
        }
        else {
            break;
        }
    }
}
// TODO feature detection for mouse/touch/pointer
/**
 * @ignore
 */
function onPointerEvent(element, name, f) {
    return addEventListener(element, getRendererEvent(name), function (event) {
        var touches = event.touches;
        if (touches) {
            if (touches.length == 0) {
                touches = event.changedTouches;
            }
            each(touches, function (touch) {
                f(touch);
            });
        }
        else {
            f(event);
        }
    });
}
/**
 * @ignore
 */
function isTainted(image) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext("2d");
    context.drawImage(image, 0, 0, 1, 1);
    try {
        context.getImageData(0, 0, 1, 1);
        return false;
    }
    catch (err) {
        console.warn("Image \"" + image.src + "\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors");
        return true;
    }
}
/**
 * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.
 *
 * @ignore
 */
function clearCanvas(view) {
    view.width = 0;
    view.height = 0;
    view.style.width = "0px";
    view.style.height = "0px";
}
/**
 * @ignore
 */
var CanvasPivot = /** @class */ (function () {
    function CanvasPivot() {
        Object.defineProperty(this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    Object.defineProperty(CanvasPivot.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasPivot.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: false,
        configurable: true
    });
    return CanvasPivot;
}());

/**
 * @ignore
 */
var CanvasDisplayObject = /** @class */ (function (_super) {
    __extends(CanvasDisplayObject, _super);
    function CanvasDisplayObject(renderer) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "_layer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "mask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(_this, "visible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "exportable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "interactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "inactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "wheelable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "isMeasured", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "buttonMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "alpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "compoundAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "angle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "scale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "pivot", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CanvasPivot()
        });
        Object.defineProperty(_this, "filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "cursorOverStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_replacedCursorStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_localMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Matrix()
        });
        Object.defineProperty(_this, "_matrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Matrix()
        });
        // TODO can this be replaced with _localMatrix ?
        Object.defineProperty(_this, "_uMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Matrix()
        });
        Object.defineProperty(_this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_bounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this._renderer = renderer;
        return _this;
    }
    Object.defineProperty(CanvasDisplayObject.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._renderer._removeObject(this);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "getCanvas", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.getLayer().view;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "getLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var self = this;
            for (;;) {
                if (self._layer) {
                    return self._layer;
                }
                else if (self._parent) {
                    self = self._parent;
                }
                else {
                    return this._renderer.defaultLayer;
                }
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "setLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (order, visible) {
            if (visible === void 0) { visible = true; }
            if (order == null) {
                this._layer = undefined;
            }
            else {
                this._layer = this._renderer.getLayer(order, visible);
                this._layer.visible = visible;
                if (this._parent) {
                    this._parent.registerChildLayer(this._layer);
                }
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "markDirtyLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.getLayer().dirty = true;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "clear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.invalidateBounds();
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "invalidateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._localBounds = undefined;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_bounds) { }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_getColorId", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._colorId === undefined) {
                this._colorId = this._renderer.paintId(this);
            }
            return this._colorId;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_isInteractive", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.inactive == false && (this.interactive || this._renderer._forceInteractive > 0);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_isInteractiveMask", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isInteractive();
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "contains", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child) {
            for (;;) {
                if (child === this) {
                    return true;
                }
                else if (child._parent) {
                    child = child._parent;
                }
                else {
                    return false;
                }
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "toGlobal", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            return this._matrix.apply(point);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "toLocal", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            return this._matrix.applyInverse(point);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "getLocalMatrix", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);
            return this._uMatrix;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "getLocalBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._localBounds) {
                var bn = 10000000;
                this._localBounds = {
                    left: bn,
                    top: bn,
                    right: -bn,
                    bottom: -bn
                };
                this._addBounds(this._localBounds);
            }
            return this._localBounds;
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "getAdjustedBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            this._setMatrix();
            var matrix = this.getLocalMatrix();
            var p0 = matrix.apply({ x: bounds.left, y: bounds.top });
            var p1 = matrix.apply({ x: bounds.right, y: bounds.top });
            var p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });
            var p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });
            return {
                left: Math.min(p0.x, p1.x, p2.x, p3.x),
                top: Math.min(p0.y, p1.y, p2.y, p3.y),
                right: Math.max(p0.x, p1.x, p2.x, p3.x),
                bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
            };
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "on", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, callback, context) {
            if (this.interactive) {
                return this._renderer._addEvent(this, key, callback, context);
            }
            else {
                return new Disposer(function () { });
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_setMatrix", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // TODO only calculate this if it has actually changed
            this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, 
            // Converts degrees to radians
            this.angle * Math.PI / 180, this.scale);
            this._matrix.copyFrom(this._localMatrix);
            if (this._parent) {
                // TODO only calculate this if it has actually changed
                this._matrix.prepend(this._parent._matrix);
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_transform", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, resolution) {
            var m = this._matrix;
            context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, m.tx * resolution, m.ty * resolution);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            var _this = this;
            if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {
                this._setMatrix();
                var resolution_1 = this._renderer.resolution;
                var layers = this._renderer.layers;
                var ghostContext = this._renderer._ghostContext;
                var mask_1 = this.mask;
                if (mask_1) {
                    mask_1._setMatrix();
                }
                // TODO improve this
                each(layers, function (layer) {
                    if (layer) {
                        var context = layer.context;
                        context.save();
                        // We must apply the mask before we transform the element
                        if (mask_1) {
                            mask_1._transform(context, layer.scale || resolution_1);
                            mask_1._runPath(context);
                            context.clip();
                        }
                        context.globalAlpha = _this.compoundAlpha * _this.alpha;
                        _this._transform(context, layer.scale || resolution_1);
                        if (_this.filter) {
                            context.filter = _this.filter;
                        }
                    }
                });
                ghostContext.save();
                // We must apply the mask before we transform the element
                if (mask_1 && this._isInteractiveMask()) {
                    mask_1._transform(ghostContext, resolution_1);
                    mask_1._runPath(ghostContext);
                    ghostContext.clip();
                }
                this._transform(ghostContext, resolution_1);
                this._render(parentLayer);
                ghostContext.restore();
                each(layers, function (layer) {
                    if (layer) {
                        layer.context.restore();
                    }
                });
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            if (this.exportable === false) {
                var layer = this._layer || parentLayer;
                layer.tainted = true;
            }
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "hovering", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._renderer._hovering.has(this);
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "dragging", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            return this._renderer._dragging.some(function (x) { return x.value === _this; });
        }
    });
    Object.defineProperty(CanvasDisplayObject.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.getLayer().dirty = true;
        }
    });
    return CanvasDisplayObject;
}(DisposerClass));

/**
 * @ignore
 */
var CanvasContainer = /** @class */ (function (_super) {
    __extends(CanvasContainer, _super);
    function CanvasContainer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "interactiveChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "_childLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        return _this;
    }
    Object.defineProperty(CanvasContainer.prototype, "_isInteractiveMask", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.interactiveChildren || _super.prototype._isInteractiveMask.call(this);
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "addChild", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child) {
            child._parent = this;
            this._children.push(child);
            if (child._layer) {
                this.registerChildLayer(child._layer);
            }
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "addChildAt", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child, index) {
            child._parent = this;
            this._children.splice(index, 0, child);
            if (child._layer) {
                this.registerChildLayer(child._layer);
            }
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "removeChild", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (child) {
            child._parent = undefined;
            removeFirst(this._children, child);
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            var _this = this;
            _super.prototype._render.call(this, parentLayer);
            var renderer = this._renderer;
            if (this.interactive && this.interactiveChildren) {
                ++renderer._forceInteractive;
            }
            var layer = this._layer || parentLayer;
            each(this._children, function (child) {
                child.compoundAlpha = _this.compoundAlpha * _this.alpha;
                child.render(layer);
            });
            if (this.interactive && this.interactiveChildren) {
                --renderer._forceInteractive;
            }
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "registerChildLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (layer) {
            if (!this._childLayers) {
                this._childLayers = [];
            }
            pushOne(this._childLayers, layer);
            if (this._parent) {
                this._parent.registerChildLayer(layer);
            }
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "markDirtyLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (deep) {
            if (deep === void 0) { deep = false; }
            _super.prototype.markDirtyLayer.call(this);
            if (deep && this._childLayers) {
                each(this._childLayers, function (layer) { return layer.dirty = true; });
            }
        }
    });
    Object.defineProperty(CanvasContainer.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.dispose.call(this);
            if (this._childLayers) {
                each(this._childLayers, function (layer) {
                    layer.dirty = true;
                });
            }
        }
    });
    return CanvasContainer;
}(CanvasDisplayObject));

/**
 * @ignore
 */
function setPoint(bounds, point) {
    bounds.left = Math.min(bounds.left, point.x);
    bounds.top = Math.min(bounds.top, point.y);
    bounds.right = Math.max(bounds.right, point.x);
    bounds.bottom = Math.max(bounds.bottom, point.y);
}
/**
 * @ignore
 */
var Op = /** @class */ (function () {
    function Op() {
    }
    Object.defineProperty(Op.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_context, _forceColor) { }
    });
    Object.defineProperty(Op.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_context) { }
    });
    Object.defineProperty(Op.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_bounds) { }
    });
    return Op;
}());
/**
 * @ignore
 */
var BeginFill = /** @class */ (function (_super) {
    __extends(BeginFill, _super);
    function BeginFill(color) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        return _this;
    }
    Object.defineProperty(BeginFill.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, forceColor) {
            if (forceColor !== undefined) {
                context.fillStyle = forceColor;
            }
            else {
                context.fillStyle = this.color;
            }
        }
    });
    return BeginFill;
}(Op));
/**
 * @ignore
 */
var EndFill = /** @class */ (function (_super) {
    __extends(EndFill, _super);
    function EndFill(clearShadow) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "clearShadow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clearShadow
        });
        return _this;
    }
    Object.defineProperty(EndFill.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, _forceColor) {
            context.fill();
            if (this.clearShadow) {
                context.shadowColor = "";
                context.shadowBlur = 0;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
            }
        }
    });
    return EndFill;
}(Op));
/**
 * @ignore
 */
var EndStroke = /** @class */ (function (_super) {
    __extends(EndStroke, _super);
    function EndStroke() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(EndStroke.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, _forceColor) {
            context.stroke();
        }
    });
    return EndStroke;
}(Op));
/**
 * @ignore
 */
var LineStyle = /** @class */ (function (_super) {
    __extends(LineStyle, _super);
    function LineStyle(width, color) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(_this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        return _this;
    }
    Object.defineProperty(LineStyle.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, forceColor) {
            if (forceColor !== undefined) {
                context.strokeStyle = forceColor;
            }
            else {
                context.strokeStyle = this.color;
            }
            context.lineWidth = this.width;
        }
    });
    return LineStyle;
}(Op));
/**
 * @ignore
 */
var LineDash = /** @class */ (function (_super) {
    __extends(LineDash, _super);
    function LineDash(dash) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "dash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dash
        });
        return _this;
    }
    Object.defineProperty(LineDash.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, _forceColor) {
            context.setLineDash(this.dash);
        }
    });
    return LineDash;
}(Op));
/**
 * @ignore
 */
var LineDashOffset = /** @class */ (function (_super) {
    __extends(LineDashOffset, _super);
    function LineDashOffset(dashOffset) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "dashOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dashOffset
        });
        return _this;
    }
    Object.defineProperty(LineDashOffset.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, _forceColor) {
            context.lineDashOffset = this.dashOffset;
        }
    });
    return LineDashOffset;
}(Op));
/**
 * @ignore
 */
var DrawRect = /** @class */ (function (_super) {
    __extends(DrawRect, _super);
    function DrawRect(x, y, width, height) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(_this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(_this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
        return _this;
    }
    Object.defineProperty(DrawRect.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.rect(this.x, this.y, this.width, this.height);
        }
    });
    Object.defineProperty(DrawRect.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            var l = this.x;
            var t = this.y;
            var r = l + this.width;
            var b = t + this.height;
            setPoint(bounds, { x: l, y: t });
            setPoint(bounds, { x: r, y: t });
            setPoint(bounds, { x: l, y: b });
            setPoint(bounds, { x: r, y: b });
        }
    });
    return DrawRect;
}(Op));
/**
 * @ignore
 */
var DrawCircle = /** @class */ (function (_super) {
    __extends(DrawCircle, _super);
    function DrawCircle(x, y, radius) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(_this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
        return _this;
    }
    Object.defineProperty(DrawCircle.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.moveTo(this.x + this.radius, this.y);
            context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        }
    });
    // TODO handle skewing and rotation
    Object.defineProperty(DrawCircle.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });
            setPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });
        }
    });
    return DrawCircle;
}(Op));
/**
 * @ignore
 */
var DrawEllipse = /** @class */ (function (_super) {
    __extends(DrawEllipse, _super);
    function DrawEllipse(x, y, radiusX, radiusY) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(_this, "radiusX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusX
        });
        Object.defineProperty(_this, "radiusY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusY
        });
        return _this;
    }
    Object.defineProperty(DrawEllipse.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
        }
    });
    // TODO handle skewing and rotation
    Object.defineProperty(DrawEllipse.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });
            setPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });
        }
    });
    return DrawEllipse;
}(Op));
/**
 * @ignore
 */
var Arc = /** @class */ (function (_super) {
    __extends(Arc, _super);
    function Arc(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "cx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cx
        });
        Object.defineProperty(_this, "cy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cy
        });
        Object.defineProperty(_this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
        Object.defineProperty(_this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: startAngle
        });
        Object.defineProperty(_this, "endAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: endAngle
        });
        Object.defineProperty(_this, "anticlockwise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: anticlockwise
        });
        return _this;
    }
    Object.defineProperty(Arc.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            if (this.radius > 0) {
                context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
            }
        }
    });
    Object.defineProperty(Arc.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            var arcBounds = getArcBounds(this.cx, this.cy, this.startAngle * DEGREES, this.endAngle * DEGREES, this.radius);
            setPoint(bounds, { x: arcBounds.left, y: arcBounds.top });
            setPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });
        }
    });
    return Arc;
}(Op));
/**
 * @ignore
 */
var ArcTo = /** @class */ (function (_super) {
    __extends(ArcTo, _super);
    function ArcTo(x1, y1, x2, y2, radius) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x1
        });
        Object.defineProperty(_this, "y1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y1
        });
        Object.defineProperty(_this, "x2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x2
        });
        Object.defineProperty(_this, "y2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y2
        });
        Object.defineProperty(_this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
        return _this;
    }
    Object.defineProperty(ArcTo.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            if (this.radius > 0) {
                context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
            }
        }
    });
    // TODO: add points
    Object.defineProperty(ArcTo.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_bounds) {
            /*
            // not finished
            https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically
    
            if (prevPoint) {
                let x1 = prevPoint.x;
                let y1 = prevPoint.y;
                let x2 = this.x2;
                let y2 = this.y2;
                let r = this.radius;
    
                let xa = (x2 - x1) / 2;
                let ya = (y2 - y1) / 2;
    
                let x0 = x1 + xa;
                let y0 = y1 + ya;
    
                let a = Math.hypot(xa, ya);
                let b = Math.sqrt(r * r - a * a);
    
                let cx = x0 + b * ya / a;
                let cy = y0 - b * xa / a;
    
                console.log(cx, cy);
            }*/
        }
    });
    return ArcTo;
}(Op));
/**
 * @ignore
 */
var LineTo = /** @class */ (function (_super) {
    __extends(LineTo, _super);
    function LineTo(x, y) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        return _this;
    }
    Object.defineProperty(LineTo.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.lineTo(this.x, this.y);
        }
    });
    Object.defineProperty(LineTo.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.x, y: this.y });
        }
    });
    return LineTo;
}(Op));
/**
 * @ignore
 */
var MoveTo = /** @class */ (function (_super) {
    __extends(MoveTo, _super);
    function MoveTo(x, y) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(_this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        return _this;
    }
    Object.defineProperty(MoveTo.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.moveTo(this.x, this.y);
        }
    });
    Object.defineProperty(MoveTo.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.x, y: this.y });
        }
    });
    return MoveTo;
}(Op));
/**
 * @ignore
 */
var ClosePath = /** @class */ (function (_super) {
    __extends(ClosePath, _super);
    function ClosePath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ClosePath.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.closePath();
        }
    });
    return ClosePath;
}(Op));
/**
 * @ignore
 */
var BezierCurveTo = /** @class */ (function (_super) {
    __extends(BezierCurveTo, _super);
    function BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(_this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(_this, "cpX2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX2
        });
        Object.defineProperty(_this, "cpY2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY2
        });
        Object.defineProperty(_this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(_this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
        return _this;
    }
    Object.defineProperty(BezierCurveTo.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
        }
    });
    // TODO: OK?
    Object.defineProperty(BezierCurveTo.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.cpX, y: this.cpY });
            setPoint(bounds, { x: this.cpX2, y: this.cpY2 });
            setPoint(bounds, { x: this.toX, y: this.toY });
        }
    });
    return BezierCurveTo;
}(Op));
/**
 * @ignore
 */
var QuadraticCurveTo = /** @class */ (function (_super) {
    __extends(QuadraticCurveTo, _super);
    function QuadraticCurveTo(cpX, cpY, toX, toY) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(_this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(_this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(_this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
        return _this;
    }
    Object.defineProperty(QuadraticCurveTo.prototype, "path", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
        }
    });
    // TODO: OK?
    Object.defineProperty(QuadraticCurveTo.prototype, "addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            setPoint(bounds, { x: this.cpX, y: this.cpY });
            setPoint(bounds, { x: this.toX, y: this.toY });
        }
    });
    return QuadraticCurveTo;
}(Op));
/**
 * @ignore
 */
var Shadow = /** @class */ (function (_super) {
    __extends(Shadow, _super);
    function Shadow(color, blur, offsetX, offsetY, opacity) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        Object.defineProperty(_this, "blur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: blur
        });
        Object.defineProperty(_this, "offsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetX
        });
        Object.defineProperty(_this, "offsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetY
        });
        Object.defineProperty(_this, "opacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: opacity
        });
        return _this;
    }
    Object.defineProperty(Shadow.prototype, "colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, _forceColor) {
            if (this.opacity) {
                context.fillStyle = this.color;
            }
            context.shadowColor = this.color;
            if (this.blur) {
                context.shadowBlur = this.blur;
            }
            if (this.offsetX) {
                context.shadowOffsetX = this.offsetX;
            }
            if (this.offsetY) {
                context.shadowOffsetY = this.offsetY;
            }
        }
    });
    return Shadow;
}(Op));
/**
 * @ignore
 */
var CanvasGraphics = /** @class */ (function (_super) {
    __extends(CanvasGraphics, _super);
    function CanvasGraphics() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_operations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "blendMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: BlendMode.NORMAL
        });
        Object.defineProperty(_this, "_hasShadows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_fillAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_strokeAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(CanvasGraphics.prototype, "clear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.clear.call(this);
            this._operations.length = 0;
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "_pushOp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (op) {
            this._operations.push(op);
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "beginFill", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, alpha) {
            if (alpha === void 0) { alpha = 1; }
            this._fillAlpha = alpha;
            if (color) {
                if (color instanceof Color) {
                    this._pushOp(new BeginFill(color.toCSS(alpha)));
                }
                else {
                    this.isMeasured = true;
                    this._pushOp(new BeginFill(color));
                }
            }
            else {
                this._pushOp(new BeginFill("rgba(0, 0, 0, " + alpha + ")"));
            }
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "endFill", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._pushOp(new EndFill(this._hasShadows));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "endStroke", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._pushOp(new EndStroke());
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "lineStyle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (width, color, alpha) {
            if (width === void 0) { width = 0; }
            if (alpha === void 0) { alpha = 1; }
            this._strokeAlpha = alpha;
            if (color) {
                if (color instanceof Color) {
                    this._pushOp(new LineStyle(width, color.toCSS(alpha)));
                }
                else {
                    this._pushOp(new LineStyle(width, color));
                }
            }
            else {
                this._pushOp(new LineStyle(width, "rgba(0, 0, 0, " + alpha + ")"));
            }
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "setLineDash", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dash) {
            this._pushOp(new LineDash(dash ? dash : []));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "setLineDashOffset", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dashOffset) {
            this._pushOp(new LineDashOffset(dashOffset || 0));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "drawRect", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y, width, height) {
            this._pushOp(new DrawRect(x, y, width, height));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "drawCircle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y, radius) {
            this._pushOp(new DrawCircle(x, y, radius));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "drawEllipse", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y, radiusX, radiusY) {
            this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "arc", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (cx, cy, radius, startAngle, endAngle, anticlockwise) {
            if (anticlockwise === void 0) { anticlockwise = false; }
            this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "arcTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x1, y1, x2, y2, radius) {
            this._pushOp(new ArcTo(x1, y1, x2, y2, radius));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "lineTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y) {
            this._pushOp(new LineTo(x, y));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "moveTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x, y) {
            this._pushOp(new MoveTo(x, y));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "bezierCurveTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (cpX, cpY, cpX2, cpY2, toX, toY) {
            this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "quadraticCurveTo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (cpX, cpY, toX, toY) {
            this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "closePath", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._pushOp(new ClosePath());
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "shadow", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (color, blur, offsetX, offsetY, opacity) {
            this._hasShadows = true;
            this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));
        }
    });
    // https://svgwg.org/svg2-draft/paths.html#DProperty
    // TODO better error checking
    Object.defineProperty(CanvasGraphics.prototype, "svgPath", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (path) {
            var _this = this;
            var x = 0;
            var y = 0;
            var cpx = null;
            var cpy = null;
            var qcpx = null;
            var qcpy = null;
            var SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;
            var ARGS_REGEXP = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
            var match;
            while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {
                var name_1 = match[1];
                var rest = match[2];
                var args = [];
                while ((match = ARGS_REGEXP.exec(rest)) !== null) {
                    args.push(+match[1]);
                }
                // Reset control point
                if (name_1 !== "S" && name_1 !== "s" && name_1 !== "C" && name_1 !== "c") {
                    cpx = null;
                    cpy = null;
                }
                // Reset control point
                if (name_1 !== "Q" && name_1 !== "q" && name_1 !== "T" && name_1 !== "t") {
                    qcpx = null;
                    qcpy = null;
                }
                switch (name_1) {
                    case "M":
                        checkEvenArgs(name_1, args.length, 2);
                        x = args[0];
                        y = args[1];
                        this.moveTo(x, y);
                        for (var i = 2; i < args.length; i += 2) {
                            x = args[i];
                            y = args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "m":
                        checkEvenArgs(name_1, args.length, 2);
                        x += args[0];
                        y += args[1];
                        this.moveTo(x, y);
                        for (var i = 2; i < args.length; i += 2) {
                            x += args[i];
                            y += args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "L":
                        checkEvenArgs(name_1, args.length, 2);
                        for (var i = 0; i < args.length; i += 2) {
                            x = args[i];
                            y = args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "l":
                        checkEvenArgs(name_1, args.length, 2);
                        for (var i = 0; i < args.length; i += 2) {
                            x += args[i];
                            y += args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "H":
                        checkMinArgs(name_1, args.length, 1);
                        for (var i = 0; i < args.length; ++i) {
                            x = args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "h":
                        checkMinArgs(name_1, args.length, 1);
                        for (var i = 0; i < args.length; ++i) {
                            x += args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "V":
                        checkMinArgs(name_1, args.length, 1);
                        for (var i = 0; i < args.length; ++i) {
                            y = args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "v":
                        checkMinArgs(name_1, args.length, 1);
                        for (var i = 0; i < args.length; ++i) {
                            y += args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "C":
                        checkEvenArgs(name_1, args.length, 6);
                        for (var i = 0; i < args.length; i += 6) {
                            var x1 = args[i];
                            var y1 = args[i + 1];
                            cpx = args[i + 2];
                            cpy = args[i + 3];
                            x = args[i + 4];
                            y = args[i + 5];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "c":
                        checkEvenArgs(name_1, args.length, 6);
                        for (var i = 0; i < args.length; i += 6) {
                            var x1 = args[i] + x;
                            var y1 = args[i + 1] + y;
                            cpx = args[i + 2] + x;
                            cpy = args[i + 3] + y;
                            x += args[i + 4];
                            y += args[i + 5];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "S":
                        checkEvenArgs(name_1, args.length, 4);
                        if (cpx === null || cpy === null) {
                            cpx = x;
                            cpy = y;
                        }
                        for (var i = 0; i < args.length; i += 4) {
                            var x1 = 2 * x - cpx;
                            var y1 = 2 * y - cpy;
                            cpx = args[i];
                            cpy = args[i + 1];
                            x = args[i + 2];
                            y = args[i + 3];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "s":
                        checkEvenArgs(name_1, args.length, 4);
                        if (cpx === null || cpy === null) {
                            cpx = x;
                            cpy = y;
                        }
                        for (var i = 0; i < args.length; i += 4) {
                            var x1 = 2 * x - cpx;
                            var y1 = 2 * y - cpy;
                            cpx = args[i] + x;
                            cpy = args[i + 1] + y;
                            x += args[i + 2];
                            y += args[i + 3];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "Q":
                        checkEvenArgs(name_1, args.length, 4);
                        for (var i = 0; i < args.length; i += 4) {
                            qcpx = args[i];
                            qcpy = args[i + 1];
                            x = args[i + 2];
                            y = args[i + 3];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "q":
                        checkEvenArgs(name_1, args.length, 4);
                        for (var i = 0; i < args.length; i += 4) {
                            qcpx = args[i] + x;
                            qcpy = args[i + 1] + y;
                            x += args[i + 2];
                            y += args[i + 3];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "T":
                        checkEvenArgs(name_1, args.length, 2);
                        if (qcpx === null || qcpy === null) {
                            qcpx = x;
                            qcpy = y;
                        }
                        for (var i = 0; i < args.length; i += 2) {
                            qcpx = 2 * x - qcpx;
                            qcpy = 2 * y - qcpy;
                            x = args[i];
                            y = args[i + 1];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "t":
                        checkEvenArgs(name_1, args.length, 2);
                        if (qcpx === null || qcpy === null) {
                            qcpx = x;
                            qcpy = y;
                        }
                        for (var i = 0; i < args.length; i += 2) {
                            qcpx = 2 * x - qcpx;
                            qcpy = 2 * y - qcpy;
                            x += args[i];
                            y += args[i + 1];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "A":
                    case "a":
                        var relative = (name_1 === "a");
                        checkEvenArgs(name_1, args.length, 7);
                        for (var i = 0; i < args.length; i += 7) {
                            var cx = args[i + 5];
                            var cy = args[i + 6];
                            if (relative) {
                                cx += x;
                                cy += y;
                            }
                            var bs = modules({
                                px: x,
                                py: y,
                                rx: args[i],
                                ry: args[i + 1],
                                xAxisRotation: args[i + 2],
                                largeArcFlag: assertBinary(args[i + 3]),
                                sweepFlag: assertBinary(args[i + 4]),
                                cx: cx,
                                cy: cy,
                            });
                            each(bs, function (b) {
                                _this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);
                                x = b.x;
                                y = b.y;
                            });
                        }
                        break;
                    case "Z":
                    case "z":
                        checkArgs(name_1, args.length, 0);
                        this.closePath();
                        break;
                }
            }
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "_runPath", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            context.beginPath();
            each(this._operations, function (op) {
                op.path(context);
            });
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            _super.prototype._render.call(this, parentLayer);
            var layer = this._layer || parentLayer;
            var layerDirty = layer.dirty;
            var interactive = this._isInteractive();
            if (layerDirty || interactive) {
                var context_1 = layer.context;
                var ghostContext_1 = this._renderer._ghostContext;
                if (layerDirty) {
                    context_1.globalCompositeOperation = this.blendMode;
                    context_1.beginPath();
                }
                var color_1;
                if (interactive) {
                    ghostContext_1.beginPath();
                    color_1 = this._getColorId();
                }
                each(this._operations, function (op) {
                    if (layerDirty) {
                        op.path(context_1);
                        op.colorize(context_1, undefined);
                    }
                    if (interactive) {
                        op.path(ghostContext_1);
                        op.colorize(ghostContext_1, color_1);
                    }
                });
            }
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "renderDetached", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            if (this.visible) {
                this._setMatrix();
                context.save();
                // We must apply the mask before we transform the element
                var mask = this.mask;
                if (mask) {
                    mask._setMatrix();
                    mask._transform(context, 1);
                    mask._runPath(context);
                    context.clip();
                }
                // TODO handle compoundAlpha somehow ?
                context.globalAlpha = this.compoundAlpha * this.alpha;
                this._transform(context, 1);
                if (this.filter) {
                    context.filter = this.filter;
                }
                context.globalCompositeOperation = this.blendMode;
                context.beginPath();
                each(this._operations, function (op) {
                    op.path(context);
                    op.colorize(context, undefined);
                });
                context.restore();
            }
        }
    });
    Object.defineProperty(CanvasGraphics.prototype, "_addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            if (this.visible && this.isMeasured) {
                each(this._operations, function (op) {
                    op.addBounds(bounds);
                });
            }
        }
    });
    return CanvasGraphics;
}(CanvasDisplayObject));

/**
 * @ignore
 */
var CanvasText = /** @class */ (function (_super) {
    __extends(CanvasText, _super);
    function CanvasText(renderer, text, style) {
        var _this = _super.call(this, renderer) || this;
        Object.defineProperty(_this, "text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_textInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_textVisible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        _this.text = text;
        _this.style = style;
        return _this;
    }
    Object.defineProperty(CanvasText.prototype, "invalidateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.invalidateBounds.call(this);
            this._textInfo = undefined;
        }
    });
    Object.defineProperty(CanvasText.prototype, "_shared", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context) {
            if (this.style.textAlign) {
                context.textAlign = this.style.textAlign;
            }
            if (this.style.direction) {
                context.direction = this.style.direction;
            }
            if (this.style.textBaseline) {
                context.textBaseline = this.style.textBaseline;
            }
        }
    });
    Object.defineProperty(CanvasText.prototype, "_prerender", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (layer, ignoreGhost, ignoreFontWeight) {
            if (ignoreGhost === void 0) { ignoreGhost = false; }
            if (ignoreFontWeight === void 0) { ignoreFontWeight = false; }
            _super.prototype._render.call(this, layer);
            var context = layer.context;
            var ghostContext = this._renderer._ghostContext;
            // Font style
            var style = this.style;
            var fontStyle = this._getFontStyle(undefined, ignoreFontWeight);
            context.font = fontStyle;
            if (this._isInteractive() && !ignoreGhost) {
                ghostContext.font = fontStyle;
            }
            // Other parameters
            if (style.fill) {
                if (style.fill instanceof Color) {
                    context.fillStyle = style.fill.toCSS();
                }
                else {
                    context.fillStyle = style.fill;
                }
            }
            if (style.shadowColor) {
                layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);
            }
            if (style.shadowBlur) {
                layer.context.shadowBlur = style.shadowBlur;
            }
            if (style.shadowOffsetX) {
                layer.context.shadowOffsetX = style.shadowOffsetX;
            }
            if (style.shadowOffsetY) {
                layer.context.shadowOffsetY = style.shadowOffsetY;
            }
            this._shared(context);
            if (this._isInteractive() && !ignoreGhost) {
                ghostContext.fillStyle = this._getColorId();
                this._shared(ghostContext);
            }
        }
    });
    Object.defineProperty(CanvasText.prototype, "_getFontStyle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (style2, ignoreFontWeight) {
            if (ignoreFontWeight === void 0) { ignoreFontWeight = false; }
            // Process defaults
            var style = this.style;
            var fontStyle = [];
            if (style2 && style2.fontVariant) {
                fontStyle.push(style2.fontVariant);
            }
            else if (style.fontVariant) {
                fontStyle.push(style.fontVariant);
            }
            if (!ignoreFontWeight) {
                if (style2 && style2.fontWeight) {
                    fontStyle.push(style2.fontWeight);
                }
                else if (style.fontWeight) {
                    fontStyle.push(style.fontWeight);
                }
            }
            if (style2 && style2.fontStyle) {
                fontStyle.push(style2.fontStyle);
            }
            else if (style.fontStyle) {
                fontStyle.push(style.fontStyle);
            }
            if (style2 && style2.fontSize) {
                if (isNumber(style2.fontSize)) {
                    style2.fontSize = style2.fontSize + "px";
                }
                fontStyle.push(style2.fontSize);
            }
            else if (style.fontSize) {
                if (isNumber(style.fontSize)) {
                    style.fontSize = style.fontSize + "px";
                }
                fontStyle.push(style.fontSize);
            }
            if (style2 && style2.fontFamily) {
                fontStyle.push(style2.fontFamily);
            }
            else if (style.fontFamily) {
                fontStyle.push(style.fontFamily);
            }
            else if (fontStyle.length) {
                fontStyle.push("Arial");
            }
            return fontStyle.join(" ");
        }
    });
    Object.defineProperty(CanvasText.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            var _this = this;
            var layer = this._layer || parentLayer;
            // We need measurements in order to properly position text for alignment
            if (!this._textInfo) {
                this._measure(layer);
            }
            if (this._textVisible) {
                var interactive_1 = this._isInteractive();
                var context_2 = layer.context;
                var layerDirty_1 = layer.dirty;
                var ghostContext_2 = this._renderer._ghostContext;
                context_2.save();
                ghostContext_2.save();
                this._prerender(layer);
                // const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
                // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;
                // Process text info produced by _measure()
                each(this._textInfo, function (line, _index) {
                    each(line.textChunks, function (chunk, _index) {
                        // Set style
                        if (chunk.style) {
                            context_2.save();
                            ghostContext_2.save();
                            context_2.font = chunk.style;
                            if (_this._isInteractive()) {
                                ghostContext_2.font = chunk.style;
                            }
                        }
                        if (chunk.fill) {
                            context_2.save();
                            context_2.fillStyle = chunk.fill.toCSS();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Draw text
                        if (layerDirty_1) {
                            context_2.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                        }
                        // Draw underline
                        if (chunk.textDecoration == "underline") {
                            var thickness = 1;
                            var offset = 1;
                            var fontSize = chunk.height;
                            var offsetX = chunk.offsetX;
                            switch (_this.style.textAlign) {
                                case "right":
                                case "end":
                                    offsetX -= chunk.width;
                                    break;
                                case "center":
                                    offsetX -= chunk.width / 2;
                                    break;
                            }
                            if (chunk.style) {
                                var format = TextFormatter.getTextStyle(chunk.style);
                                switch (format.fontWeight) {
                                    case "bolder":
                                    case "bold":
                                    case "700":
                                    case "800":
                                    case "900":
                                        thickness = 2;
                                        break;
                                }
                            }
                            if (fontSize) {
                                offset = fontSize / 20;
                            }
                            var y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;
                            context_2.save();
                            context_2.beginPath();
                            if (chunk.fill) {
                                context_2.strokeStyle = chunk.fill.toCSS();
                            }
                            else if (_this.style.fill && _this.style.fill instanceof Color) {
                                context_2.strokeStyle = _this.style.fill.toCSS();
                            }
                            context_2.lineWidth = thickness * offset;
                            context_2.moveTo(offsetX, y);
                            context_2.lineTo(offsetX + chunk.width, y);
                            context_2.stroke();
                            context_2.restore();
                        }
                        if (interactive_1 && _this.interactive) {
                            // Draw text in ghost canvas ONLY if it is set as interactive
                            // explicitly. This way we avoid hit test anomalies caused by anti
                            // aliasing of text.
                            ghostContext_2.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                        }
                        if (chunk.fill) {
                            context_2.restore();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Reset style
                        if (chunk.style) {
                            context_2.restore();
                            ghostContext_2.restore();
                        }
                    });
                });
                context_2.restore();
                ghostContext_2.restore();
            }
        }
    });
    Object.defineProperty(CanvasText.prototype, "_addBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            if (this.visible && this.isMeasured) {
                //if (this._textVisible) {
                var x = this._measure(this.getLayer());
                setPoint(bounds, { x: x.left, y: x.top });
                setPoint(bounds, { x: x.right, y: x.bottom });
                //}
            }
        }
    });
    Object.defineProperty(CanvasText.prototype, "_measure", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (layer) {
            var _this = this;
            var context = layer.context;
            var ghostContext = this._renderer._ghostContext;
            var rtl = this.style.direction == "rtl";
            // Reset text info
            this._textInfo = [];
            // Init
            var oversizedBehavior = this.style.oversizedBehavior;
            var maxWidth = this.style.maxWidth;
            var truncate = isNumber(maxWidth) && oversizedBehavior == "truncate";
            var wrap = isNumber(maxWidth) && oversizedBehavior == "wrap";
            // Pre-render
            context.save();
            ghostContext.save();
            this._prerender(layer, true, true);
            // Get default font metrix
            var refText = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
            // Split up text into lines
            var lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            var styleRestored = true;
            var minX = 0;
            var maxX = 0;
            // Iterate through the lines
            var offsetY = 0;
            var currentStyle;
            each(lines, function (line, _index) {
                // Split up line into format/value chunks
                var chunks;
                if (line == "") {
                    chunks = [{
                            type: "value",
                            text: ""
                        }];
                }
                else {
                    chunks = TextFormatter.chunk(line, false, _this.style.ignoreFormatting);
                }
                var _loop_1 = function () {
                    // Init line object
                    var lineInfo = {
                        offsetY: offsetY,
                        ascent: 0,
                        width: 0,
                        height: 0,
                        left: 0,
                        right: 0,
                        textChunks: []
                    };
                    // Measure reference text
                    var metrics = _this._measureText(refText, context);
                    var height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                    lineInfo.height = height;
                    lineInfo.ascent = metrics.actualBoundingBoxAscent;
                    var currentFormat;
                    var currentDecoration = _this.style.textDecoration;
                    var currentFill;
                    var currentChunkWidth;
                    var skipFurtherText = false;
                    var firstTextChunk = true;
                    var leftoverChunks = [];
                    //let offsetX = 0;
                    //let chunk;
                    //while(chunk = chunks.shift()) {
                    eachContinue(chunks, function (chunk, index) {
                        // Format chunk
                        if (chunk.type == "format") {
                            if (chunk.text == "[/]") {
                                if (!styleRestored) {
                                    context.restore();
                                    ghostContext.restore();
                                    styleRestored = true;
                                }
                                currentFill = undefined;
                                currentStyle = undefined;
                                currentChunkWidth = undefined;
                                currentDecoration = _this.style.textDecoration;
                                currentFormat = chunk.text;
                            }
                            else {
                                if (!styleRestored) {
                                    context.restore();
                                    ghostContext.restore();
                                }
                                var format = TextFormatter.getTextStyle(chunk.text);
                                var fontStyle = _this._getFontStyle(format);
                                context.save();
                                ghostContext.save();
                                context.font = fontStyle;
                                currentStyle = fontStyle;
                                currentFormat = chunk.text;
                                if (format.textDecoration) {
                                    currentDecoration = format.textDecoration;
                                }
                                if (format.fill) {
                                    currentFill = format.fill;
                                }
                                if (format.width) {
                                    currentChunkWidth = toNumber(format.width);
                                }
                                styleRestored = false;
                                // Measure reference text after change of format
                                var metrics_1 = _this._measureText(refText, context);
                                var height_1 = metrics_1.actualBoundingBoxAscent + metrics_1.actualBoundingBoxDescent;
                                if (height_1 > lineInfo.height) {
                                    lineInfo.height = height_1;
                                }
                                if (metrics_1.actualBoundingBoxAscent > lineInfo.ascent) {
                                    lineInfo.ascent = metrics_1.actualBoundingBoxAscent;
                                }
                            }
                        }
                        // Text chunk
                        else if (chunk.type == "value" && !skipFurtherText) {
                            // Measure
                            var metrics_2 = _this._measureText(chunk.text, context);
                            var chunkWidth = metrics_2.actualBoundingBoxLeft + metrics_2.actualBoundingBoxRight;
                            // Check for fit
                            if (truncate) {
                                // Break words?
                                var breakWords = firstTextChunk || _this.style.breakWords || false;
                                // Measure ellipsis and check if it fits
                                var ellipsis = _this.style.ellipsis || "";
                                var ellipsisMetrics = _this._measureText(ellipsis, context);
                                var ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                                // Check fit
                                if ((lineInfo.width + chunkWidth) > maxWidth) {
                                    var excessWidth = maxWidth - lineInfo.width - ellipsisWidth;
                                    chunk.text = _this._truncateText(context, chunk.text, excessWidth, breakWords);
                                    chunk.text += ellipsis;
                                    skipFurtherText = true;
                                }
                            }
                            else if (wrap) {
                                // Check fit
                                if ((lineInfo.width + chunkWidth) > maxWidth) {
                                    var excessWidth = maxWidth - lineInfo.width;
                                    var tmpText = _this._truncateText(context, chunk.text, excessWidth, false, firstTextChunk);
                                    if (tmpText == "") {
                                        // Unable to fit a single letter - hide the whole label
                                        _this._textVisible = true;
                                        return false;
                                    }
                                    //skipFurtherText = true;
                                    //Add remaining chunks for the next line
                                    leftoverChunks = chunks.slice(index + 1);
                                    //Add remaining text of current chunk if it was forced-cut
                                    if (trim(tmpText) != trim(chunk.text)) {
                                        leftoverChunks.unshift({
                                            type: "value",
                                            text: chunk.text.substr(tmpText.length)
                                        });
                                        if (currentFormat) {
                                            leftoverChunks.unshift({
                                                type: "format",
                                                text: currentFormat
                                            });
                                        }
                                    }
                                    // Set current chunk (truncated)
                                    chunk.text = trim(tmpText);
                                    chunks = [];
                                    skipFurtherText = true;
                                }
                            }
                            // Chunk width?
                            var leftBoundMod = 1;
                            var rightBoundMod = 1;
                            if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                                // increase horizontal bounding boxes accordingly
                                var boundsMod = chunkWidth / currentChunkWidth;
                                switch (_this.style.textAlign) {
                                    case "right":
                                    case "end":
                                        leftBoundMod = boundsMod;
                                        break;
                                    case "center":
                                        leftBoundMod = boundsMod;
                                        rightBoundMod = boundsMod;
                                        break;
                                    default:
                                        rightBoundMod = boundsMod;
                                }
                                chunkWidth = currentChunkWidth;
                            }
                            var chunkHeight = metrics_2.actualBoundingBoxAscent + metrics_2.actualBoundingBoxDescent;
                            if (chunkHeight > lineInfo.height) {
                                lineInfo.height = chunkHeight;
                            }
                            if (metrics_2.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics_2.actualBoundingBoxAscent;
                            }
                            lineInfo.width += chunkWidth;
                            lineInfo.left += metrics_2.actualBoundingBoxLeft / leftBoundMod;
                            lineInfo.right += metrics_2.actualBoundingBoxRight / rightBoundMod;
                            lineInfo.textChunks.push({
                                style: currentStyle,
                                fill: currentFill,
                                text: chunk.text,
                                width: chunkWidth,
                                height: chunkHeight,
                                left: metrics_2.actualBoundingBoxLeft,
                                right: metrics_2.actualBoundingBoxRight,
                                ascent: metrics_2.actualBoundingBoxAscent,
                                offsetX: 0,
                                offsetY: 0,
                                textDecoration: currentDecoration
                            });
                            //offsetX += chunkWidth;
                            firstTextChunk = false;
                        }
                        if (leftoverChunks) {
                            //return false;
                        }
                        return true;
                        //}
                    });
                    if (_this.style.lineHeight instanceof Percent) {
                        lineInfo.height *= _this.style.lineHeight.value;
                        lineInfo.ascent *= _this.style.lineHeight.value;
                    }
                    else {
                        lineInfo.height *= _this.style.lineHeight || 1.2;
                        lineInfo.ascent *= _this.style.lineHeight || 1.2;
                    }
                    if (minX < lineInfo.left) {
                        minX = lineInfo.left;
                    }
                    if (maxX < lineInfo.right) {
                        maxX = lineInfo.right;
                    }
                    _this._textInfo.push(lineInfo);
                    //lineInfo.offsetY += lineInfo.ascent;
                    offsetY += lineInfo.height;
                    // Reset chunks so that it can proceed to the next line
                    chunks = leftoverChunks || [];
                };
                while (chunks.length > 0) {
                    _loop_1();
                }
            });
            if (!styleRestored) {
                context.restore();
                ghostContext.restore();
            }
            // Adjust chunk internal offsets
            each(this._textInfo, function (lineInfo, _index) {
                var currentChunkOffset = 0;
                each(lineInfo.textChunks, function (chunk) {
                    chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;
                    chunk.offsetY += lineInfo.height - lineInfo.height * (_this.style.baselineRatio || 0.19);
                    currentChunkOffset += chunk.width;
                });
            });
            var bounds = {
                left: rtl ? -maxX : -minX,
                top: 0,
                right: rtl ? minX : maxX,
                bottom: offsetY,
            };
            // We need to fit?
            if (oversizedBehavior !== "none") {
                var ratio = this._fitRatio(bounds);
                if (ratio < 1) {
                    if (oversizedBehavior == "fit") {
                        if (isNumber(this.style.minScale) && (ratio < this.style.minScale)) {
                            this._textVisible = false;
                        }
                        else {
                            if (!this._originalScale || this._originalScale == 1) {
                                this._originalScale = this.scale;
                            }
                            this.scale = ratio;
                            this._textVisible = true;
                        }
                    }
                    else if (oversizedBehavior == "hide") {
                        this._textVisible = false;
                    }
                    else {
                        switch (this.style.textAlign) {
                            case "right":
                            case "end":
                                bounds.left = -maxWidth;
                                bounds.right = 0;
                                break;
                            case "center":
                                bounds.left = -maxWidth / 2;
                                bounds.right = maxWidth / 2;
                                break;
                            default:
                                bounds.left = 0;
                                bounds.right = maxWidth;
                        }
                        this.scale = this._originalScale || 1;
                        this._originalScale = undefined;
                        this._textVisible = true;
                    }
                }
                else {
                    this.scale = this._originalScale || 1;
                    this._originalScale = undefined;
                    this._textVisible = true;
                }
            }
            context.restore();
            ghostContext.restore();
            return bounds;
        }
    });
    Object.defineProperty(CanvasText.prototype, "_fitRatio", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bounds) {
            var maxW = this.style.maxWidth;
            var maxH = this.style.maxHeight;
            if (!isNumber(maxW) && !isNumber(maxH)) {
                return 1;
            }
            var w = bounds.right - bounds.left;
            var h = bounds.bottom - bounds.top;
            return Math.min(maxW / w || 1, maxH / h || 1);
        }
    });
    Object.defineProperty(CanvasText.prototype, "_truncateText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (context, text, maxWidth, breakWords, fallbackBreakWords) {
            if (breakWords === void 0) { breakWords = false; }
            if (fallbackBreakWords === void 0) { fallbackBreakWords = true; }
            var width;
            do {
                if (breakWords) {
                    text = text.slice(0, -1);
                }
                else {
                    var tmp = text.replace(/[^,;:!?\\\/\s]+[,;:!?\\\/\s]*$/g, "");
                    if (tmp == "" && fallbackBreakWords) {
                        breakWords = true;
                    }
                    else {
                        text = tmp;
                    }
                }
                var metrics = this._measureText(text, context);
                width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
            } while ((width > maxWidth) && text != "");
            return text;
        }
    });
    Object.defineProperty(CanvasText.prototype, "_measureText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text, context) {
            var metrics = context.measureText(text);
            var fakeMetrics = {};
            if (metrics.actualBoundingBoxAscent == null) {
                var div = document.createElement("div");
                div.innerText = text;
                div.style.visibility = "hidden";
                div.style.position = "absolute";
                div.style.top = "-1000000px;";
                div.style.fontFamily = this.style.fontFamily || "";
                div.style.fontSize = this.style.fontSize + "";
                document.body.appendChild(div);
                var bbox = div.getBoundingClientRect();
                document.body.removeChild(div);
                var h = bbox.height;
                var w_1 = metrics.width;
                var left = 0;
                var right = w_1;
                fakeMetrics = {
                    actualBoundingBoxAscent: h,
                    actualBoundingBoxDescent: 0,
                    actualBoundingBoxLeft: left,
                    actualBoundingBoxRight: right,
                    fontBoundingBoxAscent: h,
                    fontBoundingBoxDescent: 0,
                    width: w_1
                };
                //return fake;
            }
            else {
                fakeMetrics = {
                    actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                    actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                    actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
                    actualBoundingBoxRight: metrics.actualBoundingBoxRight,
                    fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                    fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                    width: metrics.width
                };
            }
            var w = metrics.width;
            switch (this.style.textAlign) {
                case "right":
                case "end":
                    fakeMetrics.actualBoundingBoxLeft = w;
                    fakeMetrics.actualBoundingBoxRight = 0;
                    break;
                case "center":
                    fakeMetrics.actualBoundingBoxLeft = w / 2;
                    fakeMetrics.actualBoundingBoxRight = w / 2;
                    break;
                default:
                    fakeMetrics.actualBoundingBoxLeft = 0;
                    fakeMetrics.actualBoundingBoxRight = w;
            }
            return fakeMetrics;
        }
    });
    return CanvasText;
}(CanvasDisplayObject));

/**
 * @ignore
 */
var CanvasTextStyle = /** @class */ (function () {
    function CanvasTextStyle() {
        //public wordWrapWidth: number = 100;
        Object.defineProperty(this, "fill", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textAlign", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontFamily", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontWeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontVariant", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textDecoration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // leading?: number;
        // letterSpacing?: number;
        Object.defineProperty(this, "lineHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: percent(120)
        });
        Object.defineProperty(this, "baselineRatio", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0.19
        });
        // padding?: number;
        // stroke?: number;
        // strokeThickness?: number;
        // trim?: number;
        // wordWrap?: boolean;
        Object.defineProperty(this, "direction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textBaseline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oversizedBehavior", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "none"
        });
        Object.defineProperty(this, "breakWords", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ellipsis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "…"
        });
        Object.defineProperty(this, "maxWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ignoreFormatting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    return CanvasTextStyle;
}());

/**
 * @ignore
 */
var CanvasRadialText = /** @class */ (function (_super) {
    __extends(CanvasRadialText, _super);
    function CanvasRadialText() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "textType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "circular"
        });
        Object.defineProperty(_this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "inside", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "orientation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "auto"
        });
        Object.defineProperty(_this, "kerning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_textReversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(CanvasRadialText.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            switch (this.textType) {
                case "circular":
                    this._renderCircular(parentLayer);
                    break;
                default:
                    _super.prototype._render.call(this, parentLayer);
                    break;
            }
        }
    });
    Object.defineProperty(CanvasRadialText.prototype, "_renderCircular", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            var layer = this._layer || parentLayer;
            this._prerender(layer);
            var interactive = this._isInteractive();
            var context = layer.context;
            var layerDirty = layer.dirty;
            var ghostContext = this._renderer._ghostContext;
            // Savepoint
            context.save();
            if (interactive) {
                ghostContext.save();
            }
            // Init
            var radius = (this.radius || 0);
            var startAngle = (this.startAngle || 0);
            var deltaAngle = 0;
            var orientation = this.orientation;
            var inward = orientation == "auto" ? "auto" : orientation == "inward";
            var inside = this.inside;
            var align = this.style.textAlign || "left";
            var kerning = this.kerning || 0;
            var clockwise = align == "left" ? 1 : -1;
            var shouldReverse = !this._textReversed;
            // We need measurements in order to properly position text for alignment
            if (!this._textInfo) {
                this._measure(layer);
            }
            // Check if we need to invert the whole stuff
            if (inward == "auto") {
                // Calc max angle so we know whether we need to flip it
                var maxAngle_1 = 0;
                var midAngle = 0;
                each(this._textInfo, function (line, _index) {
                    var deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;
                    if (deltaAngle > maxAngle_1) {
                        maxAngle_1 = deltaAngle;
                    }
                });
                if (align == "left") {
                    midAngle = (maxAngle_1 + deltaAngle / 2) * DEGREES;
                }
                else if (align == "right") {
                    midAngle = (maxAngle_1 - deltaAngle / 2) * DEGREES;
                }
                else {
                    midAngle = startAngle * DEGREES;
                }
                midAngle = normalizeAngle(midAngle);
                inward = (midAngle >= 270) || (midAngle <= 90);
            }
            if (inward == true && shouldReverse) {
                this._textInfo.reverse();
                this._textReversed = true;
            }
            // if ((inward == false && align == "left") || (inward == true && align == "right")) {
            // 	clockwise *= -1;
            // }
            // Process text info produced by _measure()
            each(this._textInfo, function (line, _index) {
                var textHeight = line.height;
                // Adjust radius (for `inside = false`)
                // Radius adjustment for `inside = false` is below the line calculation
                if (!inside) {
                    radius += textHeight;
                }
                // Reverse letters if we're painting them counter-clockwise
                if (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {
                    line.textChunks.reverse();
                }
                // Init angles
                var lineStartAngle = startAngle;
                deltaAngle = 0;
                // Adjust for center-align
                if (align == "center") {
                    lineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;
                    deltaAngle = lineStartAngle - startAngle;
                }
                // if (inward == "auto") {
                // 	let midAngle;
                // 	if (align == "left") {
                // 		midAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	else if () {
                // 		midAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	inward = (midAngle >= 270) || (midAngle <= 90);
                // }
                // Rotate letters if they are facing outward
                lineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward
                // Savepoint
                context.save();
                if (interactive) {
                    ghostContext.save();
                }
                // Assume starting angle
                context.rotate(lineStartAngle);
                if (interactive) {
                    ghostContext.rotate(lineStartAngle);
                }
                var angleShift = 0;
                each(line.textChunks, function (chunk, _index) {
                    // Draw the letter
                    var char = chunk.text;
                    var charWidth = chunk.width;
                    // Rotate half a letter
                    angleShift = (charWidth / 2) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                    // Set style
                    if (chunk.style) {
                        context.save();
                        ghostContext.save();
                        context.font = chunk.style;
                        if (interactive) {
                            ghostContext.font = chunk.style;
                        }
                    }
                    if (chunk.fill) {
                        context.save();
                        context.fillStyle = chunk.fill.toCSS();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Center letters
                    context.textBaseline = "middle";
                    context.textAlign = "center";
                    if (interactive) {
                        ghostContext.textBaseline = "middle";
                        ghostContext.textAlign = "center";
                    }
                    // Plop the letter
                    if (layerDirty) {
                        context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (interactive) {
                        ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (chunk.fill) {
                        context.restore();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Reset style
                    if (chunk.style) {
                        context.restore();
                        ghostContext.restore();
                    }
                    // Rotate half a letter and add spacing
                    angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                });
                // Restore angle
                context.restore();
                if (interactive) {
                    ghostContext.restore();
                }
                // Adjust radius (for `inside = true`)
                if (inside) {
                    radius -= textHeight;
                }
            });
            // Restore
            context.restore();
            if (interactive) {
                ghostContext.restore();
            }
        }
    });
    Object.defineProperty(CanvasRadialText.prototype, "_measure", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (layer) {
            switch (this.textType) {
                case "circular":
                    return this._measureCircular(layer);
                default:
                    return _super.prototype._measure.call(this, layer);
            }
        }
    });
    Object.defineProperty(CanvasRadialText.prototype, "_measureCircular", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (layer) {
            var _this = this;
            var context = layer.context;
            var ghostContext = this._renderer._ghostContext;
            var rtl = this.style.direction == "rtl";
            // Reset text info
            this._textInfo = [];
            this._textReversed = false;
            // Pre-render
            context.save();
            ghostContext.save();
            this._prerender(layer, true);
            // Split up text into lines
            var lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            var styleRestored = true;
            // Iterate through the lines
            var offsetY = 0;
            each(lines, function (line, _index) {
                // Split up line into format/value chunks
                var chunks = TextFormatter.chunk(line, false, _this.style.ignoreFormatting);
                // Init line object
                var lineInfo = {
                    offsetY: offsetY,
                    ascent: 0,
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    textChunks: []
                };
                var currentStyle;
                var currentFill;
                var currentChunkWidth;
                //while(chunk = chunks.shift()) {
                each(chunks, function (chunk, _index) {
                    // Format chunk
                    if (chunk.type == "format") {
                        if (chunk.text == "[/]") {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                                styleRestored = true;
                            }
                            currentFill = undefined;
                            currentStyle = undefined;
                            currentChunkWidth = undefined;
                        }
                        else {
                            var format = TextFormatter.getTextStyle(chunk.text);
                            var fontStyle = _this._getFontStyle(format);
                            context.save();
                            ghostContext.save();
                            context.font = fontStyle;
                            currentStyle = fontStyle;
                            if (format.fill) {
                                currentFill = format.fill;
                            }
                            if (format.width) {
                                currentChunkWidth = toNumber(format.width);
                            }
                            styleRestored = false;
                        }
                    }
                    // Text format
                    else if (chunk.type == "value") {
                        // Measure each letter
                        var chars = chunk.text.match(/./ug) || [];
                        if (rtl) {
                            chars.reverse();
                        }
                        for (var i = 0; i < chars.length; i++) {
                            var char = chars[i];
                            // Measure
                            var metrics = _this._measureText(char, context);
                            var chunkWidth = metrics.width;
                            // Chunk width?
                            if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                                chunkWidth = currentChunkWidth;
                            }
                            var chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            if (chunkHeight > lineInfo.height) {
                                lineInfo.height = chunkHeight;
                            }
                            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                            }
                            lineInfo.width += chunkWidth;
                            lineInfo.left += metrics.actualBoundingBoxLeft;
                            lineInfo.right += metrics.actualBoundingBoxRight;
                            lineInfo.textChunks.push({
                                style: currentStyle,
                                fill: currentFill,
                                text: char,
                                width: chunkWidth,
                                height: chunkHeight + metrics.actualBoundingBoxDescent,
                                left: metrics.actualBoundingBoxLeft,
                                right: metrics.actualBoundingBoxRight,
                                ascent: metrics.actualBoundingBoxAscent,
                                offsetX: 0,
                                offsetY: chunkHeight,
                                textDecoration: undefined
                            });
                            if (rtl) {
                                break;
                            }
                        }
                    }
                });
                if (_this.style.lineHeight instanceof Percent) {
                    lineInfo.height *= _this.style.lineHeight.value;
                }
                else {
                    lineInfo.height *= _this.style.lineHeight || 1.2;
                }
                _this._textInfo.push(lineInfo);
                //lineInfo.offsetY += lineInfo.ascent;
                offsetY += lineInfo.height;
            });
            if (!styleRestored) {
                context.restore();
                ghostContext.restore();
            }
            // Adjust chunk internal offsets
            each(this._textInfo, function (lineInfo) {
                each(lineInfo.textChunks, function (chunk) {
                    chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);
                });
            });
            context.restore();
            ghostContext.restore();
            return {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
            };
        }
    });
    return CanvasRadialText;
}(CanvasText));

/**
 * @ignore
 */
var CanvasImage = /** @class */ (function (_super) {
    __extends(CanvasImage, _super);
    function CanvasImage(renderer, image) {
        var _this = _super.call(this, renderer) || this;
        Object.defineProperty(_this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "tainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_imageMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this.image = image;
        return _this;
    }
    Object.defineProperty(CanvasImage.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._dispose.call(this);
            if (this._imageMask) {
                clearCanvas(this._imageMask);
            }
        }
    });
    Object.defineProperty(CanvasImage.prototype, "getLocalBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._localBounds) {
                var w = 0;
                var h = 0;
                if (this.width) {
                    w = this.width;
                }
                if (this.height) {
                    h = this.height;
                }
                this._localBounds = {
                    left: 0,
                    top: 0,
                    right: w,
                    bottom: h
                };
                this._addBounds(this._localBounds);
            }
            return this._localBounds;
        }
    });
    Object.defineProperty(CanvasImage.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parentLayer) {
            _super.prototype._render.call(this, parentLayer);
            if (this.image) {
                var layer = this._layer || parentLayer;
                if (this.tainted === undefined) {
                    this.tainted = isTainted(this.image);
                    layer.tainted = true;
                }
                if (this.tainted && this._renderer._omitTainted) {
                    return;
                }
                if (layer.dirty) {
                    if (this.shadowColor) {
                        layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);
                    }
                    if (this.shadowBlur) {
                        layer.context.shadowBlur = this.shadowBlur;
                    }
                    if (this.shadowOffsetX) {
                        layer.context.shadowOffsetX = this.shadowOffsetX;
                    }
                    if (this.shadowOffsetY) {
                        layer.context.shadowOffsetY = this.shadowOffsetY;
                    }
                    var width = this.width || this.image.naturalWidth;
                    var height = this.height || this.image.naturalHeight;
                    layer.context.drawImage(this.image, 0, 0, width, height);
                }
                if (this.interactive && this._isInteractive()) {
                    var mask = this._getMask(this.image);
                    this._renderer._ghostContext.drawImage(mask, 0, 0);
                }
            }
        }
    });
    Object.defineProperty(CanvasImage.prototype, "clear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.clear.call(this);
            this.image = undefined;
            this._imageMask = undefined;
        }
    });
    Object.defineProperty(CanvasImage.prototype, "_getMask", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (image) {
            if (this._imageMask === undefined) {
                var width = this.width || image.naturalWidth;
                var height = this.height || image.naturalHeight;
                // We need to create a second canvas because destination-in clears out the entire canvas
                var canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext("2d");
                context.imageSmoothingEnabled = false;
                context.fillStyle = this._getColorId();
                context.fillRect(0, 0, width, height);
                if (!isTainted(image)) {
                    context.globalCompositeOperation = "destination-in";
                    context.drawImage(image, 0, 0, width, height);
                }
                this._imageMask = canvas;
            }
            return this._imageMask;
        }
    });
    return CanvasImage;
}(CanvasDisplayObject));

/**
 * @ignore
 */
var CanvasRendererEvent = /** @class */ (function () {
    function CanvasRendererEvent(event, point, bbox) {
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "point", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: point
        });
        Object.defineProperty(this, "bbox", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bbox
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "simulated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "native", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        if (supports("touchevents") && event instanceof Touch) {
            this.id = event.identifier;
        }
        else {
            this.id = null;
        }
    }
    return CanvasRendererEvent;
}());

/**
 * @ignore
 */
var CanvasRenderer = /** @class */ (function (_super) {
    __extends(CanvasRenderer, _super);
    function CanvasRenderer(resolution) {
        var _this = _super.call(this) || this;
        Object.defineProperty(_this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(_this, "_layerDom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(_this, "layers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_dirtyLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "defaultLayer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.getLayer(0)
        });
        Object.defineProperty(_this, "_ghostView", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_ghostContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_patternCanvas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("canvas")
        });
        Object.defineProperty(_this, "_patternContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._patternCanvas.getContext("2d")
        });
        Object.defineProperty(_this, "_width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_clientWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_clientHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "interactionsEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_colorMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_forceInteractive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_omitTainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO this should store the Id as well
        Object.defineProperty(_this, "_hovering", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(_this, "_dragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_mousedown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_lastPointerMoveEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_mouseMoveThrottler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Throttler(function () {
                _this._dispatchGlobalMousemove(_this._lastPointerMoveEvent.event, _this._lastPointerMoveEvent.native);
            })
        });
        if (resolution == null) {
            _this.resolution = window.devicePixelRatio;
        }
        else {
            _this.resolution = resolution;
        }
        _this.view.appendChild(_this._layerDom);
        _this._disposers.push(new Disposer(function () {
            Object_each(_this._events, function (_key, events) {
                events.disposer.dispose();
            });
            each(_this.layers, function (layer) {
                clearCanvas(layer.view);
                if (layer.exportableView) {
                    clearCanvas(layer.exportableView);
                }
            });
            clearCanvas(_this._ghostView);
            clearCanvas(_this._patternCanvas);
        }));
        // @todo : do the same for ghost
        _this._ghostView = document.createElement("canvas");
        _this._ghostContext = _this._ghostView.getContext("2d", { alpha: false });
        _this._ghostContext.imageSmoothingEnabled = false;
        // Monitor for possible pixel ratio changes (when page is zoomed)
        _this._disposers.push(addEventListener(window, "resize", function (_ev) {
            if (resolution == null) {
                _this.resolution = window.devicePixelRatio;
            }
        }));
        // We need this in order top prevent default touch gestures when dragging
        // draggable elements
        if (supports("touchevents")) {
            var listener = function (ev) {
                if (_this._dragging.length !== 0) {
                    ev.preventDefault();
                }
            };
            _this._disposers.push(addEventListener(window, "touchstart", listener, { passive: false }));
            _this._disposers.push(addEventListener(_this.view, "touchstart", listener, { passive: false }));
        }
        // Prevent scrolling of the window when hovering on "wheelable" object
        if (supports("wheelevents")) {
            _this._disposers.push(addEventListener(_this.view, "wheel", function (ev) {
                var prevent = false;
                _this._hovering.forEach(function (obj) {
                    if (obj.wheelable) {
                        prevent = true;
                        return false;
                    }
                });
                if (prevent) {
                    ev.preventDefault();
                }
            }, { passive: false }));
        }
        return _this;
    }
    Object.defineProperty(CanvasRenderer.prototype, "createLinearGradient", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x1, y1, x2, y2) {
            return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "createRadialGradient", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (x1, y1, radius1, x2, y2, radius2) {
            return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "createPattern", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (graphics, background, repetition, width, height) {
            // const patternCanvas = document.createElement("canvas");
            // const patternContext = patternCanvas.getContext("2d")!;
            // patternCanvas.width = width;
            // patternCanvas.height = height;
            // if (fill) {
            // 	patternContext.fillStyle = fill.toCSS();
            // 	patternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
            // }
            // const layer = {
            // 	view: patternCanvas,
            // 	context: patternContext,
            // 	visible: true,
            // 	order: 0,
            // 	width: width,
            // 	height: height,
            // 	dirty: true
            // };
            // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);
            // // patternContext.stroke();
            // image.targetLayer = layer;
            // image.render(layer);
            //this._layerDom.appendChild(patternCanvas);
            this._patternCanvas.width = width;
            this._patternCanvas.height = height;
            this._patternContext.clearRect(0, 0, width, height);
            // patternCanvas.style.width = width * this.resolution + "px";
            // patternCanvas.style.height = height * this.resolution + "px";
            background.renderDetached(this._patternContext);
            graphics.renderDetached(this._patternContext);
            return this._patternContext.createPattern(this._patternCanvas, repetition);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makeContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return new CanvasContainer(this);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makeGraphics", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return new CanvasGraphics(this);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makeText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text, style) {
            return new CanvasText(this, text, style);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makeTextStyle", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return new CanvasTextStyle();
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makeRadialText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text, style) {
            return new CanvasRadialText(this, text, style);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "makePicture", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (image) {
            return new CanvasImage(this, image);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "resize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (width, height) {
            var _this = this;
            this._clientWidth = width;
            this._clientHeight = height;
            this._width = Math.floor(width * this.resolution);
            this._height = Math.floor(height * this.resolution);
            each(this.layers, function (layer) {
                if (layer) {
                    layer.dirty = true;
                    if (layer.width != null) {
                        layer.view.width = layer.width;
                        layer.view.style.width = layer.width + "px";
                    }
                    else {
                        layer.view.width = _this._width;
                        layer.view.style.width = width + "px";
                    }
                    if (layer.height != null) {
                        layer.view.height = layer.height;
                        layer.view.style.height = layer.height + "px";
                    }
                    else {
                        layer.view.height = _this._height;
                        layer.view.style.height = height + "px";
                    }
                }
            });
            // @todo: do the same for ghost canvases
            this._ghostView.width = this._width;
            this._ghostView.height = this._height;
            this._ghostView.style.width = width + "px";
            this._ghostView.style.height = height + "px";
            this.view.style.width = width + "px";
            this.view.style.height = height + "px";
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "createDetachedLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var view = document.createElement("canvas");
            var context = view.getContext("2d");
            var layer = {
                view: view,
                context: context,
                order: 0,
                visible: true,
                width: undefined,
                height: undefined,
                dirty: true,
                tainted: false
            };
            view.style.position = "absolute";
            view.style.top = "0px";
            view.style.left = "0px";
            return layer;
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "getLayerByOrder", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (order) {
            var layers = this.layers;
            var length = layers.length;
            for (var i = 0; i < length; i++) {
                var layer = layers[i];
                if (layer.order == order) {
                    return layer;
                }
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "getLayer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (order, visible) {
            if (visible === void 0) { visible = true; }
            var layers = this.layers;
            var existingLayer = this.getLayerByOrder(order);
            if (existingLayer) {
                return existingLayer;
            }
            var layer = this.createDetachedLayer();
            layer.order = order;
            layer.visible = visible;
            if (layer.visible && this._width) {
                layer.view.width = this._width;
                layer.view.style.width = this._clientWidth + "px";
                layer.view.height = this._height;
                layer.view.style.height = this._clientHeight + "px";
            }
            layers.push(layer);
            layers.sort(function (a, b) {
                if (a.order > b.order) {
                    return 1;
                }
                else if (a.order < b.order) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            var length = layers.length;
            var layerIndex = indexOf(layers, layer);
            var next;
            for (var i = layerIndex + 1; i < length; i++) {
                if (layers[i].visible) {
                    next = layers[i];
                    break;
                }
            }
            if (visible) {
                if (next === undefined) {
                    this._layerDom.appendChild(layer.view);
                }
                else {
                    this._layerDom.insertBefore(layer.view, next.view);
                }
            }
            return layer;
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root) {
            var _this = this;
            this._dirtyLayers.length = 0;
            each(this.layers, function (layer) {
                if (layer) {
                    if (layer.dirty && layer.visible) {
                        var context = layer.context;
                        _this._dirtyLayers.push(layer);
                        context.save();
                        context.clearRect(0, 0, _this._width, _this._height);
                    }
                }
            });
            this._ghostContext.save();
            //this._ghostContext.clearRect(0, 0, this._width, this._height);
            //this._ghostContext.beginPath();
            this._ghostContext.fillStyle = '#000';
            this._ghostContext.fillRect(0, 0, this._width, this._height);
            root.render(this.defaultLayer);
            this._ghostContext.restore();
            //setTimeout(() => {
            // Remove this after the Chrome bug is fixed:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394
            each(this.layers, function (layer) {
                if (layer) {
                    var context = layer.context;
                    context.beginPath();
                    context.moveTo(0, 0);
                    context.stroke();
                }
            });
            each(this._dirtyLayers, function (layer) {
                layer.context.restore();
                layer.dirty = false;
            });
            //}, 100)
            if (this._hovering.size && this._lastPointerMoveEvent) {
                this._mouseMoveThrottler.run();
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "paintId", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (obj) {
            var id = distributeId(++this._colorId);
            var color = Color.fromHex(id).toCSS();
            this._colorMap[color] = obj;
            return color;
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_removeObject", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (obj) {
            if (obj._colorId !== undefined) {
                delete this._colorMap[obj._colorId];
            }
        }
    });
    // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
    // 	return this._colorMap[colorId];
    // }
    Object.defineProperty(CanvasRenderer.prototype, "getEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent, adjustPoint) {
            if (adjustPoint === void 0) { adjustPoint = true; }
            var bbox = adjustPoint ? this.view.getBoundingClientRect() : new DOMRect(0, 0, 0, 0);
            return new CanvasRendererEvent(originalEvent, (originalEvent.clientX || originalEvent.clientY ? {
                x: originalEvent.clientX - (originalEvent.clientX ? bbox.left : 0),
                y: originalEvent.clientY - (originalEvent.clientY ? bbox.top : 0),
            } : {
                x: 0,
                y: 0
            }), bbox);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_getHitTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point, bbox) {
            if (point.x < 0 || point.x > bbox.width || point.y < 0 || point.y > bbox.height) {
                return;
            }
            else {
                var pixel = this._ghostContext.getImageData(
                // TODO should this round ?
                Math.round((point.x / bbox.width) * this._width), Math.round((point.y / bbox.height) * this._height), 1, 1);
                if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {
                    return false;
                }
                var colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();
                var hit = this._colorMap[colorId];
                return hit;
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_withEvents", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, f) {
            var events = this._events[key];
            if (events !== undefined) {
                events.dispatching = true;
                try {
                    f(events);
                }
                finally {
                    events.dispatching = false;
                    if (events.cleanup) {
                        events.cleanup = false;
                        keepIf(events.callbacks, function (callback) {
                            return !callback.disposed;
                        });
                        if (events.callbacks.length === 0) {
                            events.disposer.dispose();
                            delete this._events[key];
                        }
                    }
                }
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchEventAll", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, event) {
            if (!this.interactionsEnabled) {
                return;
            }
            this._withEvents(key, function (events) {
                each(events.callbacks, function (callback) {
                    if (!callback.disposed) {
                        callback.callback.call(callback.context, event);
                    }
                });
            });
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, target, event) {
            if (!this.interactionsEnabled) {
                return false;
            }
            var dispatched = false;
            this._withEvents(key, function (events) {
                each(events.callbacks, function (callback) {
                    if (!callback.disposed && callback.object === target) {
                        callback.callback.call(callback.context, event);
                        dispatched = true;
                    }
                });
            });
            return dispatched;
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchMousedown", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent) {
            var _this = this;
            var button = originalEvent.button;
            if (button != 0 && button != 2 && button != 1 && button !== undefined) {
                // Ignore non-primary mouse buttons
                return;
            }
            var event = this.getEvent(originalEvent);
            var target = this._getHitTarget(event.point, event.bbox);
            if (target) {
                var id_1 = event.id;
                var dragged_1 = false;
                eachTargets(target, function (obj) {
                    var info = { id: id_1, value: obj };
                    _this._mousedown.push(info);
                    if (!dragged_1 && _this._dispatchEvent("pointerdown", obj, event)) {
                        // Only dispatch the first element which matches
                        dragged_1 = true;
                        var has = _this._dragging.some(function (x) {
                            return x.value === obj && x.id === id_1;
                        });
                        if (!has) {
                            _this._dragging.push(info);
                        }
                    }
                    return true;
                });
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchGlobalMousemove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent, native) {
            var _this = this;
            var event = this.getEvent(originalEvent);
            var target = this._getHitTarget(event.point, event.bbox);
            event.native = native;
            if (target) {
                this._hovering.forEach(function (obj) {
                    if (!obj.contains(target)) {
                        _this._hovering.delete(obj);
                        if (obj.cursorOverStyle) {
                            setStyle(document.body, "cursor", obj._replacedCursorStyle);
                        }
                        _this._dispatchEvent("pointerout", obj, event);
                    }
                });
                if (event.native) {
                    eachTargets(target, function (obj) {
                        if (!_this._hovering.has(obj)) {
                            _this._hovering.add(obj);
                            if (obj.cursorOverStyle) {
                                obj._replacedCursorStyle = getStyle(document.body, "cursor");
                                setStyle(document.body, "cursor", obj.cursorOverStyle);
                            }
                            _this._dispatchEvent("pointerover", obj, event);
                        }
                        return true;
                    });
                }
                //} else if (target === false) {
            }
            else {
                this._hovering.forEach(function (obj) {
                    if (obj.cursorOverStyle) {
                        setStyle(document.body, "cursor", obj._replacedCursorStyle);
                    }
                    _this._dispatchEvent("pointerout", obj, event);
                });
                this._hovering.clear();
            }
            this._dispatchEventAll("globalpointermove", event);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchGlobalMouseup", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent, native) {
            var event = this.getEvent(originalEvent);
            event.native = native;
            //const target = this._getHitTarget(event.point);
            this._dispatchEventAll("globalpointerup", event);
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchDragMove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent) {
            var _this = this;
            if (this._dragging.length !== 0) {
                var event_1 = this.getEvent(originalEvent);
                var id_2 = event_1.id;
                this._dragging.forEach(function (obj) {
                    if (obj.id === id_2) {
                        _this._dispatchEvent("pointermove", obj.value, event_1);
                    }
                });
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchDragEnd", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent) {
            var _this = this;
            var button = originalEvent.button;
            var clickevent;
            if (button == 0 || button === undefined) {
                clickevent = "click";
            }
            else if (button == 2) {
                clickevent = "rightclick";
            }
            else if (button == 1) {
                clickevent = "middleclick";
            }
            else {
                // Ignore non-primary mouse buttons
                return;
            }
            var event = this.getEvent(originalEvent);
            var id = event.id;
            if (this._mousedown.length !== 0) {
                var target_1 = this._getHitTarget(event.point, event.bbox);
                if (target_1) {
                    this._mousedown.forEach(function (obj) {
                        if (obj.id === id && obj.value.contains(target_1)) {
                            _this._dispatchEvent(clickevent, obj.value, event);
                        }
                    });
                }
                this._mousedown.length = 0;
            }
            if (this._dragging.length !== 0) {
                this._dragging.forEach(function (obj) {
                    if (obj.id === id) {
                        _this._dispatchEvent("pointerup", obj.value, event);
                    }
                });
                this._dragging.length = 0;
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchDoubleClick", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent) {
            var _this = this;
            var event = this.getEvent(originalEvent);
            var target = this._getHitTarget(event.point, event.bbox);
            if (target) {
                eachTargets(target, function (obj) {
                    if (_this._dispatchEvent("dblclick", obj, event)) {
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_dispatchWheel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (originalEvent) {
            var _this = this;
            var event = this.getEvent(originalEvent);
            this._hovering.forEach(function (obj) {
                _this._dispatchEvent("wheel", obj, event);
            });
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_makeSharedEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, f) {
            var _this = this;
            if (this._listeners[key] === undefined) {
                var listener_1 = f();
                this._listeners[key] = new CounterDisposer(function () {
                    delete _this._listeners[key];
                    listener_1.dispose();
                });
            }
            return this._listeners[key].increment();
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_onPointerEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (name, f) {
            var native = false;
            var timer = null;
            function clear() {
                timer = null;
                native = false;
            }
            return new MultiDisposer([
                new Disposer(function () {
                    if (timer !== null) {
                        clearTimeout(timer);
                    }
                    clear();
                }),
                addEventListener(this.view, getRendererEvent(name), function (_) {
                    native = true;
                    if (timer !== null) {
                        clearTimeout(timer);
                    }
                    timer = window.setTimeout(clear, 0);
                }),
                onPointerEvent(window, name, function (ev) {
                    if (timer !== null) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    f(ev, native);
                    native = false;
                }),
            ]);
        }
    });
    // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
    Object.defineProperty(CanvasRenderer.prototype, "_initEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key) {
            var _this = this;
            switch (key) {
                case "globalpointermove":
                case "pointerover":
                case "pointerout":
                    return this._makeSharedEvent("pointermove", function () {
                        //const throttler = new Throttler();
                        // TODO handle throttling properly for multitouch
                        return _this._onPointerEvent("pointermove", function (event, native) {
                            _this._lastPointerMoveEvent = { event: event, native: native };
                            _this._mouseMoveThrottler.run();
                            //throttler.throttle(() => {
                            //});
                        });
                    });
                case "globalpointerup":
                    return this._makeSharedEvent("pointerup", function () {
                        //const throttler = new Throttler();
                        // TODO handle throttling properly for multitouch
                        return _this._onPointerEvent("pointerup", function (event, native) {
                            //throttler.throttle(() => {
                            _this._dispatchGlobalMouseup(event, native);
                            _this._lastPointerMoveEvent = { event: event, native: native };
                            //});
                        });
                    });
                case "click":
                case "rightclick":
                case "middleclick":
                case "pointerdown":
                case "pointermove":
                case "pointerup":
                    return this._makeSharedEvent("pointerdown", function () {
                        //const throttler = new Throttler();
                        var mousedown = onPointerEvent(_this.view, "pointerdown", function (ev) {
                            _this._dispatchMousedown(ev);
                        });
                        // TODO handle throttling properly for multitouch
                        var mousemove = _this._onPointerEvent("pointermove", function (ev) {
                            //throttler.throttle(() => {
                            _this._dispatchDragMove(ev);
                            //});
                        });
                        var mouseup = _this._onPointerEvent("pointerup", function (ev) {
                            _this._dispatchDragEnd(ev);
                        });
                        return new Disposer(function () {
                            mousedown.dispose();
                            mousemove.dispose();
                            mouseup.dispose();
                        });
                    });
                case "dblclick":
                    return this._makeSharedEvent("dblclick", function () {
                        return _this._onPointerEvent("dblclick", function (ev) {
                            _this._dispatchDoubleClick(ev);
                        });
                    });
                case "wheel":
                    return this._makeSharedEvent("wheel", function () {
                        return addEventListener(window, getRendererEvent("wheel"), function (event) {
                            _this._dispatchWheel(event);
                        }, { passive: false });
                    });
            }
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "_addEvent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (object, key, callback, context) {
            var _this = this;
            var events = this._events[key];
            if (events === undefined) {
                events = this._events[key] = {
                    disposer: this._initEvent(key),
                    callbacks: [],
                    dispatching: false,
                    cleanup: false,
                };
            }
            var listener = { object: object, context: context, callback: callback, disposed: false };
            events.callbacks.push(listener);
            return new Disposer(function () {
                listener.disposed = true;
                if (events.dispatching) {
                    events.cleanup = true;
                }
                else {
                    removeFirst(events.callbacks, listener);
                    if (events.callbacks.length === 0) {
                        events.disposer.dispose();
                        delete _this._events[key];
                    }
                }
            });
        }
    });
    Object.defineProperty(CanvasRenderer.prototype, "getCanvas", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (root, options) {
            // Make sure everything is rendered
            this.render(root);
            if (!options) {
                options = {};
            }
            var scale = this.resolution;
            // Check if we need to scale
            if (options.minWidth && (options.minWidth > this._width)) {
                var minScale = options.minWidth / this._width;
                if (minScale > scale) {
                    scale = minScale * this.resolution;
                }
            }
            if (options.minHeight && (options.minHeight > this._height)) {
                var minScale = options.minHeight / this._height;
                if (minScale > scale) {
                    scale = minScale * this.resolution;
                }
            }
            if (options.maxWidth && (options.maxWidth < this._width)) {
                var maxScale = options.maxWidth / this._width;
                if (maxScale < scale) {
                    scale = maxScale * this.resolution;
                }
            }
            if (options.maxHeight && (options.maxHeight > this._height)) {
                var maxScale = options.maxHeight / this._height;
                if (maxScale < scale) {
                    scale = maxScale * this.resolution;
                }
            }
            // Check if we need to compensate for pixel ratio
            if (options.maintainPixelRatio) {
                scale /= this.resolution;
            }
            // Set up new canvas for export
            var forceRender = false;
            var canvasWidth = this._width;
            var canvasHeight = this._height;
            var canvas = document.createElement("canvas");
            if (scale != this.resolution) {
                forceRender = true;
                canvasWidth = this._width * scale / this.resolution;
                canvasHeight = this._height * scale / this.resolution;
            }
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // Context
            var context = canvas.getContext("2d");
            var width = 0;
            var height = 0;
            var needRerender = false;
            each(this.layers, function (layer) {
                if (layer && layer.visible) {
                    if (layer.tainted || forceRender) {
                        needRerender = true;
                        layer.exportableView = layer.view;
                        layer.exportableContext = layer.context;
                        layer.view = document.createElement("canvas");
                        layer.view.width = canvasWidth;
                        layer.view.height = canvasHeight;
                        layer.context = layer.view.getContext("2d");
                        layer.dirty = true;
                        layer.scale = scale;
                    }
                }
            });
            if (needRerender) {
                this._omitTainted = true;
                this.render(root);
                this._omitTainted = false;
            }
            each(this.layers, function (layer) {
                if (layer && layer.visible) {
                    // Layer is fine. Just plop it into our target canvas
                    context.drawImage(layer.view, 0, 0);
                    // Restore layer original canvas
                    if (layer.exportableView) {
                        layer.view = layer.exportableView;
                        layer.exportableView = undefined;
                    }
                    if (layer.exportableContext) {
                        layer.context = layer.exportableContext;
                        layer.exportableContext = undefined;
                    }
                    if (width < layer.view.clientWidth) {
                        width = layer.view.clientWidth;
                    }
                    if (height < layer.view.clientHeight) {
                        height = layer.view.clientHeight;
                    }
                    layer.scale = undefined;
                }
            });
            canvas.style.width = width + "px";
            canvas.style.height = height + "px";
            return canvas;
        }
    });
    return CanvasRenderer;
}(ArrayDisposer));

//# sourceMappingURL=CanvasRenderer.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Root.js


























function rAF(fps, callback) {
    if (fps == null) {
        requestAnimationFrame(callback);
    }
    else {
        setTimeout(function () {
            requestAnimationFrame(callback);
        }, 1000 / fps);
    }
}
// TODO implement Disposer
/**
 * Root element of the chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info
 */
var Root = /** @class */ (function () {
    function Root(id, settings, isReal) {
        if (settings === void 0) { settings = {}; }
        /**
         * A reference to original chart container (div element).
         */
        Object.defineProperty(this, "dom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isDirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyPositions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_ticker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_tickers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * Root's event dispatcher.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
         */
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventDispatcher()
        });
        /**
         * @ignore
         * @todo needs description
         */
        Object.defineProperty(this, "animationTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_animations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Main content container.
         */
        Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A [[Container]] used to display tooltips in.
         */
        Object.defineProperty(this, "tooltipContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Locale-related
        /**
         * @ignore
         */
        Object.defineProperty(this, "language", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Language.new(this, {})
        });
        /**
         * Locale used by the chart.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}
         */
        Object.defineProperty(this, "locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: en
        });
        // Date-time related
        /**
         * Use UTC when formatting date/time.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#UTC_and_time_zones} for more info
         */
        Object.defineProperty(this, "utc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * If set, will format date/time in specific time zone.
         *
         * The value should be named time zone, e.g.:
         * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Time_zone} for more info
         * @since 5.1.0
         */
        Object.defineProperty(this, "timezone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The maximum FPS that the Root will run at.
         *
         * If `undefined` it will run at the highest FPS.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info
         */
        Object.defineProperty(this, "fps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Number formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
         */
        Object.defineProperty(this, "numberFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: NumberFormatter.new(this, {})
        });
        /**
         * Date/time formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "dateFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: DateFormatter.new(this, {})
        });
        /**
         * Duration formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "durationFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: DurationFormatter.new(this, {})
        });
        // Accessibility
        /**
         * Global tab index for using for the whole chart
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
         */
        Object.defineProperty(this, "tabindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        //@todo maybe make this better
        Object.defineProperty(this, "_tabindexes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_focusElementDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_focusElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_focusedSprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyboardDragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_readerAlertElement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_logo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used for dynamically-created CSS and JavaScript with strict source policies.
         */
        Object.defineProperty(this, "nonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Special color set to be used for various controls.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info
         */
        Object.defineProperty(this, "interfaceColors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * An instance of vertical layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "verticalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: VerticalLayout.new(this, {})
        });
        /**
         * An instance of horizontal layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default HorizontalLayout.new()
         */
        Object.defineProperty(this, "horizontalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: HorizontalLayout.new(this, {})
        });
        /**
         * An instance of grid layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "gridLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: GridLayout.new(this, {})
        });
        /**
         * Indicates whether chart should resized automatically when parent container
         * width and/or height changes.
         *
         * If disabled (`autoResize = false`) you can make the chart resize manually
         * by calling root element's `resize()` method.
         */
        Object.defineProperty(this, "autoResize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_isDisposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_resizeSensorDisposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltips", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        if (settings.useSafeResolution == null) {
            settings.useSafeResolution = true;
        }
        var resolution;
        if (settings.useSafeResolution) {
            resolution = getSafeResolution();
        }
        this._renderer = new CanvasRenderer(resolution);
        var dom;
        if (id instanceof HTMLElement) {
            dom = id;
        }
        else {
            dom = document.getElementById(id);
        }
        each(registry.rootElements, function (root) {
            if (root.dom === dom) {
                throw new Error("You cannot have multiple Roots on the same DOM node");
            }
        });
        this.interfaceColors = InterfaceColors.new(this, {});
        if (dom === null) {
            throw new Error("Could not find HTML element with id `" + id + "`");
        }
        this.dom = dom;
        var inner = document.createElement("div");
        inner.style.position = "relative";
        dom.appendChild(inner);
        this._inner = inner;
        registry.rootElements.push(this);
    }
    Object.defineProperty(Root, "new", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (id, settings) {
            var root = new Root(id, settings, true);
            root._init();
            return root;
        }
    });
    Object.defineProperty(Root.prototype, "moveDOM", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (id) {
            var dom;
            if (id instanceof HTMLElement) {
                dom = id;
            }
            else {
                dom = document.getElementById(id);
            }
            if (dom) {
                while (this.dom.childNodes.length > 0) {
                    dom.appendChild(this.dom.childNodes[0]);
                }
                this.dom = dom;
                this._initResizeSensor();
                this.resize();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_handleLogo", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._logo) {
                var w = this.dom.offsetWidth;
                var h = this.dom.offsetHeight;
                if ((w <= 150) || (h <= 60)) {
                    this._logo.hide();
                }
                else {
                    this._logo.show();
                }
            }
        }
    });
    Object.defineProperty(Root.prototype, "_showBranding", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._logo) {
                var logo = this.tooltipContainer.children.push(Container.new(this, {
                    interactive: true,
                    interactiveChildren: false,
                    position: "absolute",
                    setStateOnChildren: true,
                    paddingTop: 9,
                    paddingRight: 9,
                    paddingBottom: 9,
                    paddingLeft: 9,
                    scale: .6,
                    y: percent(100),
                    centerY: p100,
                    tooltipText: "Created using amCharts 5",
                    tooltipX: p100,
                    cursorOverStyle: "pointer",
                    background: Rectangle.new(this, {
                        fill: color(0x474758),
                        fillOpacity: 0,
                        tooltipY: 5
                    })
                }));
                var tooltip = Tooltip.new(this, {
                    pointerOrientation: "horizontal",
                    paddingTop: 4,
                    paddingRight: 7,
                    paddingBottom: 4,
                    paddingLeft: 7
                });
                tooltip.label.setAll({
                    fontSize: 12
                });
                tooltip.get("background").setAll({
                    fill: this.interfaceColors.get("background"),
                    stroke: this.interfaceColors.get("grid"),
                    strokeOpacity: 0.3
                });
                logo.set("tooltip", tooltip);
                logo.events.on("click", function () {
                    window.open("https://www.amcharts.com/", "_blank");
                });
                logo.states.create("hover", {});
                var m = logo.children.push(Graphics.new(this, {
                    stroke: color(0xcccccc),
                    strokeWidth: 3,
                    svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
                }));
                m.states.create("hover", { stroke: color(0x3CABFF) });
                var a = logo.children.push(Graphics.new(this, {
                    stroke: color(0x888888),
                    strokeWidth: 3,
                    svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
                }));
                a.states.create("hover", { stroke: color(0x474758) });
                //logo.set("tooltip", this._tooltip);
                //logo.setPrivate("tooltipTarget", logo.get("background"));
                this._logo = logo;
                this._handleLogo();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_init", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var renderer = this._renderer;
            var rootContainer = Container.new(this, { visible: true, width: this.dom.clientWidth, height: this.dom.clientHeight });
            this._rootContainer = rootContainer;
            this._rootContainer._defaultThemes.push(DefaultTheme.new(this));
            var container = rootContainer.children.push(Container.new(this, { visible: true, width: p100, height: p100 }));
            this.container = container;
            renderer.resize(this.dom.clientWidth, this.dom.clientHeight);
            //@todo: better appendChild - refer
            this._inner.appendChild(renderer.view);
            // TODO: TMP TMP TMP for testing only, remove
            //document.body.appendChild((<any>renderer)._ghostView);
            this._initResizeSensor();
            // Create element which is used to make announcements to screen reader
            var readerAlertElement = document.createElement("div");
            readerAlertElement.setAttribute("role", "alert");
            readerAlertElement.style.zIndex = "-100000";
            readerAlertElement.style.opacity = "0";
            readerAlertElement.style.position = "absolute";
            readerAlertElement.style.top = "0";
            this._readerAlertElement = readerAlertElement;
            this._inner.appendChild(this._readerAlertElement);
            var focusElementContainer = document.createElement("div");
            focusElementContainer.style.position = "absolute";
            focusElementContainer.style.pointerEvents = "none";
            focusElementContainer.style.top = "0px";
            focusElementContainer.style.left = "0px";
            focusElementContainer.style.overflow = "hidden";
            focusElementContainer.style.width = this.dom.clientWidth + "px";
            focusElementContainer.style.height = this.dom.clientHeight + "px";
            focusElementContainer.setAttribute("role", "application");
            setInteractive(focusElementContainer, false);
            this._focusElementContainer = focusElementContainer;
            this._inner.appendChild(this._focusElementContainer);
            this._tooltipElementContainer = document.createElement("div");
            this._inner.appendChild(this._tooltipElementContainer);
            // Add keyboard events for accessibility, e.g. simulating drag with arrow
            // keys and click with ENTER
            if (supports("keyboardevents")) {
                this._disposers.push(addEventListener(focusElementContainer, "keydown", function (ev) {
                    var focusedSprite = _this._focusedSprite;
                    if (focusedSprite) {
                        if (ev.keyCode == 27) {
                            // ESC pressed - lose current focus
                            Utils_blur();
                            _this._focusedSprite = undefined;
                        }
                        var dragOffsetX = 0;
                        var dragOffsetY = 0;
                        // TODO: figure out if using bogus MouseEvent is fine, or it will
                        // fail on some platforms
                        switch (ev.keyCode) {
                            case 13:
                                ev.preventDefault();
                                var downEvent = renderer.getEvent(new MouseEvent("click"));
                                focusedSprite.events.dispatch("click", {
                                    type: "click",
                                    originalEvent: downEvent.event,
                                    point: downEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                                return;
                            case 37:
                                dragOffsetX = -6;
                                break;
                            case 39:
                                dragOffsetX = 6;
                                break;
                            case 38:
                                dragOffsetY = -6;
                                break;
                            case 40:
                                dragOffsetY = 6;
                                break;
                            default:
                                return;
                        }
                        if (dragOffsetX != 0 || dragOffsetY != 0) {
                            ev.preventDefault();
                            if (!focusedSprite.isDragging()) {
                                // Start dragging
                                _this._keyboardDragPoint = {
                                    x: 0,
                                    y: 0
                                };
                                var downEvent = renderer.getEvent(new MouseEvent("mousedown", {
                                    clientX: 0,
                                    clientY: 0
                                }));
                                if (focusedSprite.events.isEnabled("pointerdown")) {
                                    focusedSprite.events.dispatch("pointerdown", {
                                        type: "pointerdown",
                                        originalEvent: downEvent.event,
                                        point: downEvent.point,
                                        simulated: true,
                                        target: focusedSprite
                                    });
                                }
                            }
                            else {
                                // Move focus marker
                                //this._positionFocusElement(focusedSprite);
                            }
                            // Move incrementally
                            var dragPoint = _this._keyboardDragPoint;
                            dragPoint.x += dragOffsetX;
                            dragPoint.y += dragOffsetY;
                            var moveEvent = renderer.getEvent(new MouseEvent("mousemove", {
                                clientX: dragPoint.x,
                                clientY: dragPoint.y
                            }), false);
                            if (focusedSprite.events.isEnabled("globalpointermove")) {
                                focusedSprite.events.dispatch("globalpointermove", {
                                    type: "globalpointermove",
                                    originalEvent: moveEvent.event,
                                    point: moveEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                            }
                        }
                    }
                }));
                this._disposers.push(addEventListener(focusElementContainer, "keyup", function (ev) {
                    if (_this._focusedSprite) {
                        var focusedSprite = _this._focusedSprite;
                        var keyCode = ev.keyCode;
                        switch (keyCode) {
                            case 37:
                            case 39:
                            case 38:
                            case 40:
                                if (focusedSprite.isDragging()) {
                                    // Simulate drag stop
                                    var dragPoint = _this._keyboardDragPoint;
                                    var upEvent = renderer.getEvent(new MouseEvent("mouseup", {
                                        clientX: dragPoint.x,
                                        clientY: dragPoint.y
                                    }));
                                    if (focusedSprite.events.isEnabled("globalpointerup")) {
                                        focusedSprite.events.dispatch("globalpointerup", {
                                            type: "globalpointerup",
                                            originalEvent: upEvent.event,
                                            point: upEvent.point,
                                            simulated: true,
                                            target: focusedSprite
                                        });
                                    }
                                    //this._positionFocusElement(focusedSprite);
                                    _this._keyboardDragPoint = undefined;
                                    // @todo dispatch mouseup event instead of calling dragStop?
                                    // this._dispatchEvent("globalpointerup", target, upEvent);
                                    return;
                                }
                                else if (focusedSprite.get("focusableGroup")) {
                                    // Find next item in focusable group
                                    var group_1 = focusedSprite.get("focusableGroup");
                                    var items = _this._tabindexes.filter(function (item) { return item.get("focusableGroup") == group_1; });
                                    var index = items.indexOf(focusedSprite);
                                    var lastIndex = items.length - 1;
                                    index += (keyCode == 39 || keyCode == 40) ? 1 : -1;
                                    if (index < 0) {
                                        index = lastIndex;
                                    }
                                    else if (index > lastIndex) {
                                        index = 0;
                                    }
                                    Utils_focus(items[index].getPrivate("focusElement").dom);
                                }
                                break;
                        }
                    }
                }));
            }
            this._startTicker();
            this.setThemes([]);
            this._addTooltip();
            if (!this._hasLicense()) {
                this._showBranding();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_initResizeSensor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this._resizeSensorDisposer) {
                this._resizeSensorDisposer.dispose();
            }
            this._resizeSensorDisposer = new ResizeSensor(this.dom, function () {
                if (_this.autoResize) {
                    _this.resize();
                }
            });
            this._disposers.push(this._resizeSensorDisposer);
        }
    });
    /**
     * If automatic resizing of char is disabled (`root.autoResize = false`), it
     * can be resized manually by calling this method.
     */
    Object.defineProperty(Root.prototype, "resize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var dom = this.dom;
            var w = dom.clientWidth;
            var h = dom.clientHeight;
            if (w > 0 && h > 0) {
                var focusElementContainer = this._focusElementContainer;
                focusElementContainer.style.width = w + "px";
                focusElementContainer.style.height = h + "px";
                this._renderer.resize(w, h);
                var rootContainer = this._rootContainer;
                rootContainer.setPrivate("width", w);
                rootContainer.setPrivate("height", h);
                this._render();
                this._handleLogo();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_render", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._renderer.render(this._rootContainer._display);
            if (this._focusElementDirty) {
                this._updateCurrentFocus();
                this._focusElementDirty = false;
            }
        }
    });
    Object.defineProperty(Root.prototype, "_runTickers", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            each(this._tickers, function (f) {
                f(currentTime);
            });
        }
    });
    Object.defineProperty(Root.prototype, "_runAnimations", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            keepIf(this._animations, function (animation) {
                return !animation._runAnimation(currentTime);
            });
        }
    });
    Object.defineProperty(Root.prototype, "_runDirties", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            //console.log("tick **************************************************************");
            var allParents = {};
            while (this._isDirtyParents) {
                // This must be before calling _prepareChildren
                this._isDirtyParents = false;
                keys(this._dirtyParents).forEach(function (key) {
                    var parent = _this._dirtyParents[key];
                    delete _this._dirtyParents[key];
                    if (!parent.isDisposed()) {
                        allParents[parent.uid] = parent;
                        parent._prepareChildren();
                    }
                });
            }
            keys(allParents).forEach(function (key) {
                allParents[key]._updateChildren();
            });
            var objects = [];
            //		console.log("_beforeChanged")
            keys(this._dirty).forEach(function (key) {
                var entity = _this._dirty[key];
                if (entity.isDisposed()) {
                    delete _this._dirty[entity.uid];
                }
                else {
                    objects.push(entity);
                    entity._beforeChanged();
                }
            });
            //		console.log("_changed")
            objects.forEach(function (entity) {
                entity._changed();
                delete _this._dirty[entity.uid];
                entity._clearDirty();
            });
            this._isDirty = false;
            var depths = {};
            var bounds = [];
            keys(this._dirtyBounds).forEach(function (key) {
                var entity = _this._dirtyBounds[key];
                delete _this._dirtyBounds[key];
                if (!entity.isDisposed()) {
                    depths[entity.uid] = entity.depth();
                    bounds.push(entity);
                }
            });
            // High depth -> low depth
            bounds.sort(function (x, y) {
                return compare(depths[y.uid], depths[x.uid]);
            });
            //		console.log("_updateBounds")
            bounds.forEach(function (entity) {
                entity._updateBounds();
            });
            //		console.log("_updatePosition")
            var dirtyPositions = this._dirtyPositions;
            keys(dirtyPositions).forEach(function (key) {
                var sprite = dirtyPositions[key];
                delete dirtyPositions[key];
                if (!sprite.isDisposed()) {
                    sprite._updatePosition();
                }
            });
            //		console.log("_afterChanged")
            objects.forEach(function (entity) {
                entity._afterChanged();
            });
        }
    });
    Object.defineProperty(Root.prototype, "_runTicker", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (currentTime) {
            if (!this.isDisposed()) {
                this.animationTime = currentTime;
                if (this.events.isEnabled("framestarted")) {
                    this.events.dispatch("framestarted", {
                        type: "framestarted",
                        target: this,
                        timestamp: currentTime,
                    });
                }
                this._runTickers(currentTime);
                this._runAnimations(currentTime);
                this._runDirties();
                this._render();
                if (this.events.isEnabled("frameended")) {
                    this.events.dispatch("frameended", {
                        type: "frameended",
                        target: this,
                        timestamp: currentTime,
                    });
                }
                // No more work to do
                if (this._tickers.length === 0 &&
                    this._animations.length === 0 &&
                    !this._isDirty) {
                    this._ticker = null;
                    this.animationTime = null;
                }
                else {
                    rAF(this.fps, this._ticker);
                }
            }
        }
    });
    Object.defineProperty(Root.prototype, "_startTicker", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this._ticker === null) {
                this.animationTime = null;
                this._ticker = function (currentTime) {
                    _this._runTicker(currentTime);
                };
                rAF(this.fps, this._ticker);
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addDirtyEntity", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity) {
            if (this._dirty[entity.uid] === undefined) {
                this._isDirty = true;
                this._dirty[entity.uid] = entity;
                this._startTicker();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addDirtyParent", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (parent) {
            if (this._dirtyParents[parent.uid] === undefined) {
                this._isDirty = true;
                this._isDirtyParents = true;
                this._dirtyParents[parent.uid] = parent;
                this._startTicker();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addDirtyBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (entity) {
            if (this._dirtyBounds[entity.uid] === undefined) {
                this._isDirty = true;
                this._dirtyBounds[entity.uid] = entity;
                this._startTicker();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addDirtyPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (sprite) {
            if (this._dirtyPositions[sprite.uid] === undefined) {
                this._isDirty = true;
                this._dirtyPositions[sprite.uid] = sprite;
                this._startTicker();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (animation) {
            // TODO use numeric id instead
            if (this._animations.indexOf(animation) === -1) {
                this._animations.push(animation);
                this._startTicker();
            }
        }
    });
    Object.defineProperty(Root.prototype, "eachFrame", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (f) {
            var _this = this;
            this._tickers.push(f);
            this._startTicker();
            return new Disposer(function () {
                removeFirst(_this._tickers, f);
            });
        }
    });
    /**
     * Returns width of the target container, in pixels.
     *
     * @return Width
     */
    Object.defineProperty(Root.prototype, "width", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.dom.clientWidth;
        }
    });
    /**
     * Returns height of the target container, in pixels.
     *
     * @return Height
     */
    Object.defineProperty(Root.prototype, "height", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.dom.clientHeight;
        }
    });
    /**
     * Disposes root and all the content in it.
     */
    Object.defineProperty(Root.prototype, "dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this._isDisposed) {
                this._isDisposed = true;
                this._rootContainer.dispose();
                this._renderer.dispose();
                this.horizontalLayout.dispose();
                this.verticalLayout.dispose();
                this.interfaceColors.dispose();
                each(this._disposers, function (x) {
                    x.dispose();
                });
                if (this._inner) {
                    removeElement(this._inner);
                }
                remove(registry.rootElements, this);
            }
        }
    });
    /**
     * Returns `true` if root element is disposed.
     *
     * @return Disposed?
     */
    Object.defineProperty(Root.prototype, "isDisposed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this._isDisposed;
        }
    });
    /**
     * Triggers screen reader read out a message.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
     * @param  text  Alert text
     */
    Object.defineProperty(Root.prototype, "readerAlert", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (text) {
            this._readerAlertElement.innerHTML = text;
        }
    });
    /**
     * Sets themes to be used for the chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
     * @param  themes  A list of themes
     */
    Object.defineProperty(Root.prototype, "setThemes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (themes) {
            this._rootContainer.set("themes", themes);
            // otherwise new themes are not applied
            var tooltipContainer = this.tooltipContainer;
            if (tooltipContainer) {
                tooltipContainer._applyThemes();
            }
            // @todo review this
            var interfaceColors = this.interfaceColors;
            if (interfaceColors) {
                interfaceColors._applyThemes();
            }
        }
    });
    Object.defineProperty(Root.prototype, "_addTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (!this.tooltipContainer) {
                var tooltipContainer = this._rootContainer.children.push(Container.new(this, { position: "absolute", isMeasured: false, width: p100, height: p100, layer: 30 }));
                this.tooltipContainer = tooltipContainer;
                var tooltip = Tooltip.new(this, {});
                this.container.set("tooltip", tooltip);
                tooltip.hide(0);
                this._tooltip = tooltip;
            }
        }
    });
    /**
     * Accesibility
     */
    Object.defineProperty(Root.prototype, "_registerTabindexOrder", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            if (target.get("focusable")) {
                pushOne(this._tabindexes, target);
            }
            else {
                remove(this._tabindexes, target);
            }
            this._invalidateTabindexes();
        }
    });
    Object.defineProperty(Root.prototype, "_unregisterTabindexOrder", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            remove(this._tabindexes, target);
            this._invalidateTabindexes();
        }
    });
    Object.defineProperty(Root.prototype, "_invalidateTabindexes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this._tabindexes.sort(function (a, b) {
                var aindex = a.get("tabindexOrder", 0);
                var bindex = b.get("tabindexOrder", 0);
                if (aindex == bindex) {
                    return 0;
                }
                else if (aindex > bindex) {
                    return 1;
                }
                else {
                    return -1;
                }
            });
            var groups = [];
            each(this._tabindexes, function (item, index) {
                if (!item.getPrivate("focusElement")) {
                    _this._makeFocusElement(index, item);
                }
                else {
                    _this._moveFocusElement(index, item);
                }
                var group = item.get("focusableGroup");
                if (group) {
                    if (groups.indexOf(group) !== -1) {
                        // Non-first element in the group, make it not directly focusable
                        item.getPrivate("focusElement").dom.setAttribute("tabindex", "-1");
                    }
                    else {
                        groups.push(group);
                    }
                }
            });
        }
    });
    Object.defineProperty(Root.prototype, "_updateCurrentFocus", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this._focusedSprite) {
                this._decorateFocusElement(this._focusedSprite);
                this._positionFocusElement(this._focusedSprite);
            }
        }
    });
    Object.defineProperty(Root.prototype, "_decorateFocusElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target, focusElement) {
            // Decorate with proper accessibility attributes
            if (!focusElement) {
                focusElement = target.getPrivate("focusElement").dom;
            }
            if (!focusElement) {
                return;
            }
            if (target.get("visible") && target.get("role") != "tooltip" && !target.isHidden()) {
                if (focusElement.getAttribute("tabindex") != "-1") {
                    focusElement.setAttribute("tabindex", "" + this.tabindex);
                }
            }
            else {
                focusElement.removeAttribute("tabindex");
            }
            var role = target.get("role");
            if (role) {
                focusElement.setAttribute("role", role);
            }
            else {
                focusElement.removeAttribute("role");
            }
            var ariaLabel = target.get("ariaLabel");
            if (ariaLabel) {
                var label = populateString(target, ariaLabel);
                focusElement.setAttribute("aria-label", label);
            }
            else {
                focusElement.removeAttribute("aria-label");
            }
            var ariaLive = target.get("ariaLive");
            if (ariaLive) {
                focusElement.setAttribute("aria-live", ariaLive);
            }
            else {
                focusElement.removeAttribute("aria-live");
            }
            var ariaChecked = target.get("ariaChecked");
            if (ariaChecked != null) {
                focusElement.setAttribute("aria-checked", ariaChecked ? "true" : "false");
            }
            else {
                focusElement.removeAttribute("aria-checked");
            }
            if (target.get("ariaHidden")) {
                focusElement.setAttribute("aria-hidden", "hidden");
            }
            else {
                focusElement.removeAttribute("aria-hidden");
            }
            var ariaOrientation = target.get("ariaOrientation");
            if (ariaOrientation) {
                focusElement.setAttribute("aria-orientation", ariaOrientation);
            }
            else {
                focusElement.removeAttribute("aria-orientation");
            }
            var ariaValueNow = target.get("ariaValueNow");
            if (ariaValueNow) {
                focusElement.setAttribute("aria-valuenow", ariaValueNow);
            }
            else {
                focusElement.removeAttribute("aria-valuenow");
            }
            var ariaValueMin = target.get("ariaValueMin");
            if (ariaValueMin) {
                focusElement.setAttribute("aria-valuemin", ariaValueMin);
            }
            else {
                focusElement.removeAttribute("aria-valuemin");
            }
            var ariaValueMax = target.get("ariaValueMax");
            if (ariaValueMax) {
                focusElement.setAttribute("aria-valuemax", ariaValueMax);
            }
            else {
                focusElement.removeAttribute("aria-valuemax");
            }
            var ariaValueText = target.get("ariaValueText");
            if (ariaValueText) {
                focusElement.setAttribute("aria-valuetext", ariaValueText);
            }
            else {
                focusElement.removeAttribute("aria-valuetext");
            }
            var ariaControls = target.get("ariaControls");
            if (ariaControls) {
                focusElement.setAttribute("aria-controls", ariaControls);
            }
            else {
                focusElement.removeAttribute("aria-controls");
            }
        }
    });
    Object.defineProperty(Root.prototype, "_makeFocusElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, target) {
            var _this = this;
            if (target.getPrivate("focusElement")) {
                return;
            }
            // Init
            var focusElement = document.createElement("div");
            if (target.get("role") != "tooltip") {
                focusElement.tabIndex = this.tabindex;
            }
            focusElement.style.position = "absolute";
            setInteractive(focusElement, false);
            var disposers = [];
            target.setPrivate("focusElement", {
                dom: focusElement,
                disposers: disposers,
            });
            this._decorateFocusElement(target);
            disposers.push(addEventListener(focusElement, "focus", function (ev) {
                _this._handleFocus(ev, index);
            }));
            disposers.push(addEventListener(focusElement, "blur", function (ev) {
                _this._handleBlur(ev, index);
            }));
            this._moveFocusElement(index, target);
        }
    });
    Object.defineProperty(Root.prototype, "_removeFocusElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            // Init
            var container = this._focusElementContainer;
            var focusElement = target.getPrivate("focusElement");
            container.removeChild(focusElement.dom);
            each(focusElement.disposers, function (x) {
                x.dispose();
            });
        }
    });
    Object.defineProperty(Root.prototype, "_moveFocusElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, target) {
            // Get container
            var container = this._focusElementContainer;
            var focusElement = target.getPrivate("focusElement").dom;
            if (focusElement === this._focusElementContainer.children[index]) {
                // Nothing to do
                return;
            }
            var next = this._focusElementContainer.children[index + 1];
            if (next) {
                container.insertBefore(focusElement, next);
            }
            else {
                container.append(focusElement);
            }
        }
    });
    Object.defineProperty(Root.prototype, "_positionFocusElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            var bounds = target.globalBounds();
            var width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;
            var height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;
            var focusElement = target.getPrivate("focusElement").dom;
            focusElement.style.top = (bounds.top - 2) + "px";
            focusElement.style.left = (bounds.left - 2) + "px";
            focusElement.style.width = (width + 4) + "px";
            focusElement.style.height = (height + 4) + "px";
        }
    });
    Object.defineProperty(Root.prototype, "_handleFocus", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (ev, index) {
            // Get element
            var focused = this._tabindexes[index];
            // Size and position
            this._positionFocusElement(focused);
            //this._decorateFocusElement(focused);
            this._focusedSprite = focused;
            if (focused.events.isEnabled("focus")) {
                focused.events.dispatch("focus", {
                    type: "focus",
                    originalEvent: ev,
                    target: focused
                });
            }
        }
    });
    Object.defineProperty(Root.prototype, "_handleBlur", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (ev, _index) {
            var focused = this._focusedSprite;
            if (focused && focused.events.isEnabled("blur")) {
                focused.events.dispatch("blur", {
                    type: "blur",
                    originalEvent: ev,
                    target: focused
                });
            }
            this._focusedSprite = undefined;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Root.prototype, "updateTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            var text = target._getText();
            var tooltipElement = target.getPrivate("tooltipElement");
            if (target.get("role") == "tooltip" && text != "") {
                if (!tooltipElement) {
                    tooltipElement = this._makeTooltipElement(target);
                }
                if (tooltipElement.innerHTML != text) {
                    tooltipElement.innerHTML = text;
                }
            }
            else if (tooltipElement) {
                tooltipElement.remove();
                target.removePrivate("tooltipElement");
            }
        }
    });
    Object.defineProperty(Root.prototype, "_makeTooltipElement", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            var container = this._tooltipElementContainer;
            var tooltipElement = document.createElement("div");
            tooltipElement.style.position = "absolute";
            tooltipElement.style.opacity = "0.0000001";
            setInteractive(tooltipElement, false);
            this._decorateFocusElement(target, tooltipElement);
            container.append(tooltipElement);
            target.setPrivate("tooltipElement", tooltipElement);
            return tooltipElement;
        }
    });
    Object.defineProperty(Root.prototype, "_invalidateAccessibility", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            this._focusElementDirty = true;
            var focusElement = target.getPrivate("focusElement");
            if (target.get("focusable")) {
                if (focusElement) {
                    this._decorateFocusElement(target);
                    this._positionFocusElement(target);
                }
                // else {
                // 	this._renderer._makeFocusElement(0, this);
                // }
            }
            else if (focusElement) {
                this._removeFocusElement(target);
            }
            //this.updateCurrentFocus();
        }
    });
    /**
     * Returns `true` if `target` is currently focused.
     *
     * @param   target  Target
     * @return          Focused?
     */
    Object.defineProperty(Root.prototype, "focused", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (target) {
            return this._focusedSprite === target;
        }
    });
    /**
     * Converts document coordinates to coordinates withing root element.
     *
     * @param   point  Document point
     * @return         Root point
     */
    Object.defineProperty(Root.prototype, "documentPointToRoot", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            var bbox = this.dom.getBoundingClientRect();
            return {
                x: point.x - bbox.left,
                y: point.y - bbox.top
            };
        }
    });
    /**
     * Converts root coordinates to document
     *
     * @param   point  Document point
     * @return         Root point
     */
    Object.defineProperty(Root.prototype, "rootPointToDocument", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            var bbox = this.dom.getBoundingClientRect();
            return {
                x: point.x + bbox.left,
                y: point.y + bbox.top
            };
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Root.prototype, "addDisposer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (disposer) {
            this._disposers.push(disposer);
            return disposer;
        }
    });
    /**
 * To all the clever heads out there. Yes, we did not make any attempts to
 * scramble this.
 *
 * This is a part of a tool meant for our users to manage their commercial
 * licenses for removal of amCharts branding from charts.
 *
 * The only legit way to do so is to purchase a commercial license for amCharts:
 * https://www.amcharts.com/online-store/
 *
 * Removing or altering this code, or disabling amCharts branding in any other
 * way is against the license and thus illegal.
 */
    Object.defineProperty(Root.prototype, "_hasLicense", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            for (var i = 0; i < registry.licenses.length; i++) {
                if (registry.licenses[i].match(/^AM5C.{5,}/i)) {
                    return true;
                }
            }
            return false;
        }
    });
    return Root;
}());

//# sourceMappingURL=Root.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js


/**
 * A universal placeholder for bullet elements.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
 */
var Bullet = /** @class */ (function (_super) {
    __extends(Bullet, _super);
    function Bullet() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // used by MapPolygons where one data item can have multiple bullets of the same kind
        Object.defineProperty(_this, "_index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Target series object if it's a bullet for series.
         */
        Object.defineProperty(_this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(Bullet.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // Applying themes because bullet will not have parent
            _super.prototype._afterNewApplyThemes.call(this);
        }
    });
    Object.defineProperty(Bullet.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("sprite")) {
                var sprite = this.get("sprite");
                if (sprite) {
                    sprite.setAll({ position: "absolute", role: "figure" });
                    this._disposers.push(sprite);
                }
            }
            if (this.isDirty("locationX") || this.isDirty("locationY")) {
                if (this.series) {
                    this.series._positionBullet(this);
                }
            }
        }
    });
    Object.defineProperty(Bullet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bullet"
    });
    Object.defineProperty(Bullet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Bullet.className])
    });
    return Bullet;
}(Entity));

//# sourceMappingURL=Bullet.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js



/**
 * An object which holds list of colors and can generate new ones.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info
 */
var ColorSet = /** @class */ (function (_super) {
    __extends(ColorSet, _super);
    function ColorSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //protected _currentPass: number = 0;
    Object.defineProperty(ColorSet.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // Applying themes because color set will not have parent
            _super.prototype._afterNewApplyThemes.call(this);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ColorSet.prototype, "generateColors", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
            var pass = this.getPrivate("currentPass");
            var colors = this.get("colors", [this.get("baseColor", Color.fromHex(0xff0000))]);
            if (!this.getPrivate("numColors")) {
                this.setPrivate("numColors", colors.length);
            }
            //const len = colors.length;
            var len = this.getPrivate("numColors");
            //const start = len - this.getPrivate("numColors")!;
            var start = 0;
            var passOptions = this.get("passOptions");
            var reuse = this.get("reuse");
            for (var i = start; i < len; i++) {
                if (reuse) {
                    colors.push(colors[i]);
                }
                else {
                    var hsl = colors[i].toHSL();
                    var h = hsl.h + (passOptions.hue || 0) * pass;
                    while (h > 1)
                        h -= 1;
                    var s = hsl.s + (passOptions.saturation || 0) * pass;
                    //if (s > 1) s -= Math.floor(s);
                    if (s > 1)
                        s = 1;
                    if (s < 0)
                        s = 0;
                    var l = hsl.l + (passOptions.lightness || 0) * pass;
                    //if (l > 1) l -= Math.floor(l);
                    while (l > 1)
                        l -= 1;
                    colors.push(Color.fromHSL(h, s, l));
                }
            }
        }
    });
    /**
     * Returns a [[Color]] at specific index.
     *
     * If there's no color at this index, a new color is generated.
     *
     * @param   index  Index
     * @return         Color
     */
    Object.defineProperty(ColorSet.prototype, "getIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index) {
            var colors = this.get("colors", []);
            var saturation = this.get("saturation");
            if (index >= colors.length) {
                this.generateColors();
                return this.getIndex(index);
            }
            return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];
        }
    });
    /**
     * Returns next [[Color]] in the list.
     *
     * If the list is out of colors, new ones are generated dynamically.
     */
    Object.defineProperty(ColorSet.prototype, "next", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));
            this.setPrivate("currentStep", currentStep + this.get("step", 1));
            return this.getIndex(currentStep);
        }
    });
    /**
     * Resets counter to the start of the list, so the next call for `next()` will
     * return the first color.
     */
    Object.defineProperty(ColorSet.prototype, "reset", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setPrivate("currentStep", this.get("startIndex", 0));
        }
    });
    Object.defineProperty(ColorSet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ColorSet"
    });
    Object.defineProperty(ColorSet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([ColorSet.className])
    });
    return ColorSet;
}(Entity));

//# sourceMappingURL=ColorSet.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * Returns a `Promise` which can be used to execute code after number of
 * milliseconds.
 *
 * @param   ms  Sleep duration in ms
 * @return      Promise
 */
function sleep(ms) {
    return new Promise(function (resolve, _reject) {
        setTimeout(resolve, ms);
    });
}
/**
 * Maps time period names to their numeric representations in milliseconds.
 *
 * @ignore Exclude from docs
 */
var timeUnitDurations = {
    millisecond: 1,
    second: 1000,
    minute: 60000,
    hour: 3600000,
    day: 86400000,
    week: 604800000,
    month: 365.242 / 12 * 86400000,
    year: 31536000000
};
/**
 * Returns the next time unit that goes after source `unit`.
 *
 * E.g. "hour" is the next unit after "minute", etc.
 *
 * @ignore Exclude from docs
 * @param unit  Source time unit
 * @return Next time unit
 */
function getNextUnit(unit) {
    switch (unit) {
        case "year":
            return;
        case "month":
            return "year";
        case "week":
            return "month";
        case "day":
            return "month"; // not a mistake
        case "hour":
            return "day";
        case "minute":
            return "hour";
        case "second":
            return "minute";
        case "millisecond":
            return "second";
    }
}
/**
 * Returns number of milliseconds in the `count` of time `unit`.
 *
 * Available units: "millisecond", "second", "minute", "hour", "day", "week",
 * "month", and "year".
 *
 * @param unit   Time unit
 * @param count  Number of units
 * @return Milliseconds
 */
function getDuration(unit, count) {
    if (count == null) {
        count = 1;
    }
    return timeUnitDurations[unit] * count;
}
/**
 * @ignore
 */
function getIntervalDuration(interval) {
    if (interval) {
        return timeUnitDurations[interval.timeUnit] * interval.count;
    }
    return 0;
}
/**
 * Returns current `Date` object.
 *
 * @return Current date
 */
function now() {
    return new Date();
}
/**
 * Returns current timestamp.
 *
 * @return Current timestamp
 */
function getTime() {
    return now().getTime();
}
/**
 * Returns a copy of the `Date` object.
 *
 * @param date  Source date
 * @return Copy
 */
function Time_copy(date) {
    return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3
}
/**
 * Checks if the `unit` part of two `Date` objects do not match. Two dates
 * represent a "range" of time, rather the same time date.
 *
 * @param timeOne  timestamp
 * @param timeTwo  timestamp
 * @param unit     Time unit to check
 * @return Range?
 */
function checkChange(timeOne, timeTwo, unit, utc, timezone) {
    // quick
    if ((timeTwo - timeOne) > getDuration(unit, 1.2)) {
        return true;
    }
    var dateOne = new Date(timeOne);
    var dateTwo = new Date(timeTwo);
    if (timezone) {
        dateOne = timezone.convertLocal(dateOne);
        dateTwo = timezone.convertLocal(dateTwo);
    }
    var timeZoneOffset1 = 0;
    var timeZoneOffset2 = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset1 = dateOne.getTimezoneOffset();
        dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
        timeZoneOffset2 = dateTwo.getTimezoneOffset();
        dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
    }
    var changed = false;
    switch (unit) {
        case "year":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            break;
        case "month":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            break;
        case "day":
            if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
                changed = true;
            }
            break;
        case "hour":
            if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
                changed = true;
            }
            break;
        case "minute":
            if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
                changed = true;
            }
            break;
        case "second":
            if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
                changed = true;
            }
            break;
        case "millisecond":
            if (dateOne.getTime() != dateTwo.getTime()) {
                changed = true;
            }
            break;
    }
    if (changed) {
        return changed;
    }
    var nextUnit = getNextUnit(unit);
    if (nextUnit) {
        return checkChange(timeOne, timeTwo, nextUnit, utc, timezone);
    }
    else {
        return false;
    }
}
/**
 * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.
 *
 * @param date   Source date
 * @param unit   Time unit
 * @param count  Number of units to add
 * @return Modified date
 */
function Time_add(date, unit, count, utc) {
    var timeZoneOffset = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset = date.getTimezoneOffset();
        date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
    }
    switch (unit) {
        case "day":
            var day = date.getUTCDate();
            date.setUTCDate(day + count);
            break;
        case "second":
            var seconds = date.getUTCSeconds();
            date.setUTCSeconds(seconds + count);
            break;
        case "millisecond":
            var milliseconds = date.getUTCMilliseconds();
            date.setUTCMilliseconds(milliseconds + count);
            break;
        case "hour":
            var hours = date.getUTCHours();
            date.setUTCHours(hours + count);
            break;
        case "minute":
            var minutes = date.getUTCMinutes();
            date.setUTCMinutes(minutes + count);
            break;
        case "year":
            var year = date.getUTCFullYear();
            date.setUTCFullYear(year + count);
            break;
        case "month":
            var month = date.getUTCMonth();
            date.setUTCMonth(month + count);
            break;
        case "week":
            var wday = date.getUTCDate();
            date.setUTCDate(wday + count * 7);
            break;
    }
    if (!utc && unit != "millisecond") {
        date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
        if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
            var newTimeZoneOffset = date.getTimezoneOffset();
            if (newTimeZoneOffset != timeZoneOffset) {
                var diff = newTimeZoneOffset - timeZoneOffset;
                date.setUTCMinutes(date.getUTCMinutes() + diff);
                // solves issues if newe time falls back to old time zone
                if (date.getTimezoneOffset() != newTimeZoneOffset) {
                    date.setUTCMinutes(date.getUTCMinutes() - diff);
                }
            }
        }
    }
    return date;
}
/**
 * "Rounds" the date to specific time unit.
 *
 * @param date             Source date
 * @param unit             Time unit
 * @param count            Number of units to round to
 * @param firstDateOfWeek  First day of week
 * @param utc              Use UTC timezone
 * @param firstDate        First date to round to
 * @param roundMinutes     Minutes to round to (some timezones use non-whole hour)
 * @param timezone         Use specific named timezone when rounding
 * @return New date
 */
function Time_round(date, unit, count, firstDateOfWeek, utc, firstDate, timezone) {
    if (!timezone || utc) {
        var timeZoneOffset = 0;
        if (!utc && unit != "millisecond") {
            timeZoneOffset = date.getTimezoneOffset();
            date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
        }
        switch (unit) {
            case "day":
                var day = date.getUTCDate();
                if (count > 1) {
                    //	day = Math.floor(day / count) * count;
                    if (firstDate) {
                        firstDate = Time_round(firstDate, "day", 1);
                        var difference = date.getTime() - firstDate.getTime();
                        var unitCount = Math.floor(difference / getDuration("day") / count);
                        var duration = getDuration("day", unitCount * count);
                        date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                    }
                }
                else {
                    date.setUTCDate(day);
                }
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "second":
                var seconds = date.getUTCSeconds();
                if (count > 1) {
                    seconds = Math.floor(seconds / count) * count;
                }
                date.setUTCSeconds(seconds, 0);
                break;
            case "millisecond":
                if (count == 1) {
                    return date; // much better for perf!
                }
                var milliseconds = date.getUTCMilliseconds();
                milliseconds = Math.floor(milliseconds / count) * count;
                date.setUTCMilliseconds(milliseconds);
                break;
            case "hour":
                var hours = date.getUTCHours();
                if (count > 1) {
                    hours = Math.floor(hours / count) * count;
                }
                date.setUTCHours(hours, 0, 0, 0);
                break;
            case "minute":
                var minutes = date.getUTCMinutes();
                milliseconds = date.getUTCMilliseconds();
                if (count > 1) {
                    minutes = Math.floor(minutes / count) * count;
                }
                date.setUTCMinutes(minutes, 0, 0);
                break;
            case "month":
                var month = date.getUTCMonth();
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                date.setUTCMonth(month, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "year":
                var year = date.getUTCFullYear();
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                date.setUTCFullYear(year, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "week":
                var wday = date.getUTCDate();
                var weekDay = date.getUTCDay();
                if (!isNumber(firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                if (weekDay >= firstDateOfWeek) {
                    wday = wday - weekDay + firstDateOfWeek;
                }
                else {
                    wday = wday - (7 + weekDay) + firstDateOfWeek;
                }
                date.setUTCDate(wday);
                date.setUTCHours(0, 0, 0, 0);
                break;
        }
        if (!utc && unit != "millisecond") {
            date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
            if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
                var newTimeZoneOffset = date.getTimezoneOffset();
                if (newTimeZoneOffset != timeZoneOffset) {
                    var diff = newTimeZoneOffset - timeZoneOffset;
                    date.setUTCMinutes(date.getUTCMinutes() + diff);
                }
            }
        }
        return date;
    }
    else {
        var tzoffset = timezone.offsetUTC(date);
        var timeZoneOffset = date.getTimezoneOffset();
        var parsedDate = timezone.parseDate(date);
        var year = parsedDate.year;
        var month = parsedDate.month;
        var day = parsedDate.day;
        var hour = parsedDate.hour;
        var minute = parsedDate.minute;
        var second = parsedDate.second;
        var millisecond = parsedDate.millisecond;
        switch (unit) {
            case "day":
                if (firstDate) {
                    firstDate = Time_round(firstDate, "day", 1);
                    var difference = date.getTime() - firstDate.getTime();
                    var unitCount = Math.floor(difference / getDuration("day") / count);
                    var duration = getDuration("day", unitCount * count);
                    date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                    year = date.getUTCFullYear();
                    month = date.getUTCMonth();
                    day = date.getUTCDate();
                }
                hour = 0;
                minute = 0;
                second = 0;
                millisecond = 0;
                break;
            case "second":
                if (count > 1) {
                    second = Math.floor(second / count) * count;
                }
                millisecond = 0;
                break;
            case "millisecond":
                if (count > 1) {
                    millisecond = Math.floor(millisecond / count) * count;
                }
                break;
            case "hour":
                if (count > 1) {
                    hour = Math.floor(hour / count) * count;
                }
                minute = 0;
                second = 0;
                millisecond = 0;
                break;
            case "minute":
                if (count > 1) {
                    minute = Math.floor(minute / count) * count;
                }
                second = 0;
                millisecond = 0;
                break;
            case "month":
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                day = 1;
                hour = 0;
                minute = 0;
                second = 0;
                millisecond = 0;
                break;
            case "year":
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                month = 0;
                day = 1;
                hour = 0;
                minute = 0;
                second = 0;
                millisecond = 0;
                break;
            case "week":
                if (!isNumber(firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                var wday = date.getUTCDate();
                var weekDay = date.getUTCDay();
                if (weekDay >= firstDateOfWeek) {
                    wday = wday - weekDay + firstDateOfWeek;
                }
                else {
                    wday = wday - (7 + weekDay) + firstDateOfWeek;
                }
                day = wday;
                hour = 0;
                minute = 0;
                second = 0;
                millisecond = 0;
                break;
        }
        minute += tzoffset - timeZoneOffset;
        date = new Date(year, month, day, hour, minute, second, millisecond);
        return date;
    }
}
/**
 * @ignore
 */
function chooseInterval(index, duration, gridCount, intervals) {
    var gridInterval = intervals[index];
    var intervalDuration = getIntervalDuration(gridInterval);
    var lastIndex = intervals.length - 1;
    if (index >= lastIndex) {
        return __assign({}, intervals[lastIndex]);
    }
    var count = Math.ceil(duration / intervalDuration);
    if (duration < intervalDuration && index > 0) {
        return __assign({}, intervals[index - 1]);
    }
    if (count <= gridCount) {
        return __assign({}, intervals[index]);
    }
    else {
        if (index + 1 < intervals.length) {
            return chooseInterval(index + 1, duration, gridCount, intervals);
        }
        else {
            return __assign({}, intervals[index]);
        }
    }
}
/**
 * @ignore
 */
function getUnitValue(date, unit) {
    switch (unit) {
        case "day":
            return date.getDate();
        case "second":
            return date.getSeconds();
        case "millisecond":
            return date.getMilliseconds();
        case "hour":
            return date.getHours();
        case "minute":
            return date.getMinutes();
        case "month":
            return date.getMonth();
        case "year":
            return date.getFullYear();
        case "week":
            return $utils.getWeek(date);
    }
}
//# sourceMappingURL=Time.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js










/**
 * @ignore
 */
var XYChartDefaultTheme = /** @class */ (function (_super) {
    __extends(XYChartDefaultTheme, _super);
    function XYChartDefaultTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(XYChartDefaultTheme.prototype, "setupDefaultRules", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype.setupDefaultRules.call(this);
            var ic = this._root.interfaceColors;
            var language = this._root.language;
            var r = this.rule.bind(this);
            /**
             * ========================================================================
             * charts/xy
             * ========================================================================
             */
            r("XYChart").setAll({
                colors: ColorSet.new(this._root, {}),
                paddingLeft: 20,
                paddingRight: 20,
                paddingTop: 16,
                paddingBottom: 16,
                panX: false,
                panY: false,
                wheelStep: 0.25,
                arrangeTooltips: true
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: XYChartScrollbar
             * ------------------------------------------------------------------------
             */
            r("XYChart", ["scrollbar", "chart"]).setAll({
                paddingBottom: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingRight: 0,
                colors: ColorSet.new(this._root, {
                    saturation: 0
                })
            });
            {
                var rule = r("Graphics", ["scrollbar", "overlay"]);
                rule.setAll({
                    fillOpacity: 0.5
                });
                setColor(rule, "fill", ic, "background");
            }
            // Class: RoundedRectangle
            r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
                cornerRadiusTR: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusBL: 0,
                fillOpacity: 0,
                focusable: true
            });
            r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 });
            r("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
                cornerRadiusTL: 0,
                cornerRadiusBL: 0,
                cornerRadiusTR: 0,
                cornerRadiusBR: 0
            });
            r("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            r("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
                strokeOpacity: 0,
                inside: true
            });
            r("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
                strokeOpacity: 0,
                inside: true,
                minGridDistance: 5
            });
            r("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
                opacity: 0.5,
                centerY: p100,
                minPosition: 0.01,
                maxPosition: 0.99,
                fontSize: "0.8em"
            });
            r("AxisLabel", ["category"]).setAll({
                text: "{category}",
                populateText: true
            });
            r("AxisLabel", ["x"]).setAll({
                centerY: 0
            });
            r("AxisLabel", ["x", "inside"]).setAll({
                centerY: p100
            });
            r("AxisLabel", ["x", "inside", "opposite"]).setAll({
                centerY: 0
            });
            r("AxisLabel", ["x", "opposite"]).setAll({
                centerY: p100
            });
            r("AxisLabel", ["y"]).setAll({
                centerX: p100
            });
            r("AxisLabel", ["y", "inside"]).setAll({
                centerX: 0
            });
            r("AxisLabel", ["y", "inside", "opposite"]).setAll({
                centerX: p100
            });
            r("AxisLabel", ["y", "opposite"]).setAll({
                centerX: 0
            });
            r("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
                visible: false
            });
            // Class: Grid
            r("Grid", ["xy", "scrollbar", "y"]).setAll({
                visible: false
            });
            // Class: Grid
            r("Grid", ["xy", "scrollbar", "x"]).setAll({
                opacity: 0.5
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Cursor
             * ------------------------------------------------------------------------
             */
            r("XYCursor").setAll({
                behavior: "none",
                layer: 30,
                exportable: false,
                snapToSeriesBy: "xy"
            });
            {
                var rule = r("Grid", ["cursor", "x"]);
                rule.setAll({
                    strokeOpacity: 0.8,
                    strokeDasharray: [2, 2]
                });
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            {
                var rule = r("Grid", ["cursor", "y"]);
                rule.setAll({
                    strokeOpacity: 0.8,
                    strokeDasharray: [2, 2]
                });
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            {
                var rule = r("Graphics", ["cursor", "selection"]);
                rule.setAll({
                    fillOpacity: 0.15,
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Axes
             * ------------------------------------------------------------------------
             */
            r("Axis").setAll({
                start: 0,
                end: 1,
                minZoomCount: 1,
                maxZoomCount: Infinity,
                maxZoomFactor: 1000,
                maxDeviation: 0.1,
                snapTooltip: true,
                tooltipLocation: 0.5,
                panX: true,
                panY: true,
                zoomX: true,
                zoomY: true,
                fixAxisSize: true
            });
            r("AxisLabel").setAll({
                location: 0.5,
                multiLocation: 0,
                centerX: p50,
                centerY: p50,
                paddingTop: 3,
                paddingBottom: 3,
                paddingLeft: 5,
                paddingRight: 5
            });
            // The following is deprecated following text measuring updates in 5.0.5
            // r("AxisLabel", ["y"]).setAll({
            // 	textAlign: "right"
            // });
            // r("AxisLabel", ["y", "opposite"]).setAll({
            // 	textAlign: "left"
            // });
            r("Container", ["axis", "header"]).setAll({
                layer: 30
            });
            {
                var rule = r("AxisRenderer");
                rule.setAll({
                    strokeOpacity: 0
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("AxisRendererX").setAll({
                minGridDistance: 120,
                opposite: false,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1,
                width: p100
            });
            r("AxisRendererY").setAll({
                minGridDistance: 40,
                opposite: false,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1,
                height: p100
            });
            {
                var rule = r("Rectangle", ["axis", "thumb"]);
                rule.setAll({
                    fillOpacity: 0
                });
                setColor(rule, "fill", ic, "alternativeBackground");
                rule.states.create("hover", { fillOpacity: 0.1 });
            }
            r("Rectangle", ["axis", "thumb", "x"]).setAll({
                cursorOverStyle: "ew-resize"
            });
            r("Rectangle", ["axis", "thumb", "y"]).setAll({
                cursorOverStyle: "ns-resize"
            });
            {
                var rule = r("Grid");
                rule.setAll({
                    location: 0,
                    strokeOpacity: 0.15,
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("Grid", ["base"]).setAll({
                strokeOpacity: 0.3
            });
            {
                var rule = r("Graphics", ["axis", "fill"]);
                rule.setAll({
                    visible: false,
                    isMeasured: false,
                    position: "absolute",
                    fillOpacity: 0.05,
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            r("Graphics", ["axis", "fill", "range"]).setAll({
                isMeasured: true
            });
            // hides all elements of series axis range
            r("Graphics", ["series", "fill", "range"]).setAll({
                visible: false,
                isMeasured: true
            });
            r("Grid", ["series", "range"]).setAll({
                visible: false
            });
            r("AxisTick", ["series", "range"]).setAll({
                visible: false
            });
            r("AxisLabel", ["series", "range"]).setAll({
                visible: false
            });
            {
                var rule = r("AxisTick");
                rule.setAll({
                    location: 0.5,
                    multiLocation: 0,
                    strokeOpacity: 1,
                    isMeasured: false,
                    position: "absolute",
                    visible: false
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("CategoryAxis").setAll({
                startLocation: 0,
                endLocation: 1,
                fillRule: function (dataItem, index) {
                    var axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        if (!isNumber(index) || index % 2 == 0) {
                            axisFill.setPrivate("visible", true);
                        }
                        else {
                            axisFill.setPrivate("visible", false);
                        }
                    }
                }
            });
            var gridIntervals = [
                { timeUnit: "millisecond", count: 1 },
                { timeUnit: "millisecond", count: 5 },
                { timeUnit: "millisecond", count: 10 },
                { timeUnit: "millisecond", count: 50 },
                { timeUnit: "millisecond", count: 100 },
                { timeUnit: "millisecond", count: 500 },
                { timeUnit: "second", count: 1 },
                { timeUnit: "second", count: 5 },
                { timeUnit: "second", count: 10 },
                { timeUnit: "second", count: 30 },
                { timeUnit: "minute", count: 1 },
                { timeUnit: "minute", count: 5 },
                { timeUnit: "minute", count: 10 },
                { timeUnit: "minute", count: 15 },
                { timeUnit: "minute", count: 30 },
                { timeUnit: "hour", count: 1 },
                { timeUnit: "hour", count: 3 },
                { timeUnit: "hour", count: 6 },
                { timeUnit: "hour", count: 12 },
                { timeUnit: "day", count: 1 },
                { timeUnit: "day", count: 2 },
                { timeUnit: "day", count: 3 },
                { timeUnit: "day", count: 4 },
                { timeUnit: "day", count: 5 },
                { timeUnit: "week", count: 1 },
                { timeUnit: "month", count: 1 },
                { timeUnit: "month", count: 2 },
                { timeUnit: "month", count: 3 },
                { timeUnit: "month", count: 6 },
                { timeUnit: "year", count: 1 },
                { timeUnit: "year", count: 2 },
                { timeUnit: "year", count: 5 },
                { timeUnit: "year", count: 10 },
                { timeUnit: "year", count: 50 },
                { timeUnit: "year", count: 100 },
                { timeUnit: "year", count: 200 },
                { timeUnit: "year", count: 500 },
                { timeUnit: "year", count: 1000 },
                { timeUnit: "year", count: 2000 },
                { timeUnit: "year", count: 5000 },
                { timeUnit: "year", count: 10000 },
                { timeUnit: "year", count: 100000 }
            ];
            var dateFormats = {
                "millisecond": language.translate("_date_millisecond"),
                "second": language.translate("_date_second"),
                "minute": language.translate("_date_minute"),
                "hour": language.translate("_date_hour"),
                "day": language.translate("_date_day"),
                "week": language.translate("_date_day"),
                "month": language.translate("_date_month"),
                "year": language.translate("_date_year")
            };
            var periodChangeDateFormats = {
                "millisecond": language.translate("_date_millisecond"),
                "second": language.translate("_date_second"),
                "minute": language.translate("_date_minute"),
                "hour": language.translate("_date_day"),
                "day": language.translate("_date_day"),
                "week": language.translate("_date_day"),
                "month": language.translate("_date_month") + " " + language.translate("_date_year"),
                "year": language.translate("_date_year")
            };
            var tooltipDateFormats = {
                "millisecond": language.translate("_date_millisecond_full"),
                "second": language.translate("_date_second_full"),
                "minute": language.translate("_date_minute_full"),
                "hour": language.translate("_date_hour_full"),
                "day": language.translate("_date_day_full"),
                "week": language.translate("_date_week_full"),
                "month": language.translate("_date_month_full"),
                "year": language.translate("_date_year")
            };
            r("CategoryDateAxis").setAll({
                markUnitChange: true,
                gridIntervals: copy(gridIntervals),
                dateFormats: Object_copy(dateFormats),
                periodChangeDateFormats: Object_copy(periodChangeDateFormats)
            });
            r("DateAxis").setAll({
                strictMinMax: true,
                startLocation: 0,
                endLocation: 1,
                markUnitChange: true,
                groupData: false,
                groupCount: 500,
                gridIntervals: copy(gridIntervals),
                dateFormats: Object_copy(dateFormats),
                periodChangeDateFormats: Object_copy(periodChangeDateFormats),
                tooltipDateFormats: tooltipDateFormats,
                groupIntervals: [
                    { timeUnit: "millisecond", count: 1 },
                    { timeUnit: "millisecond", count: 10 },
                    { timeUnit: "millisecond", count: 100 },
                    { timeUnit: "second", count: 1 },
                    { timeUnit: "second", count: 10 },
                    { timeUnit: "minute", count: 1 },
                    { timeUnit: "minute", count: 10 },
                    { timeUnit: "hour", count: 1 },
                    { timeUnit: "day", count: 1 },
                    { timeUnit: "week", count: 1 },
                    { timeUnit: "month", count: 1 },
                    { timeUnit: "year", count: 1 }
                ],
                fillRule: function (dataItem) {
                    var axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        var axis = dataItem.component;
                        var value = dataItem.get("value");
                        var endValue = dataItem.get("endValue");
                        var intervalDuration = axis.intervalDuration();
                        var baseInterval = axis.getPrivate("baseInterval");
                        var min = axis.getPrivate("min", 0);
                        min = Time_round(new Date(min), baseInterval.timeUnit, baseInterval.count, _this._root.locale.firstDayOfWeek, _this._root.utc, undefined, _this._root.timezone).getTime();
                        if (value != null && endValue != null) {
                            var val = Math.round((value - min) / intervalDuration) / 2;
                            if (val == Math.round(val)) {
                                axisFill.setPrivate("visible", true);
                            }
                            else {
                                axisFill.setPrivate("visible", false);
                            }
                        }
                    }
                }
            });
            r("GaplessDateAxis").setAll({
                fillRule: function (dataItem) {
                    var axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        var index = dataItem.get("index");
                        var visible = false;
                        if (!isNumber(index) || index % 2 == 0) {
                            visible = true;
                        }
                        axisFill.setPrivate("visible", visible);
                    }
                }
            });
            r("ValueAxis").setAll({
                baseValue: 0,
                logarithmic: false,
                extraMin: 0,
                extraMax: 0,
                strictMinMax: false,
                fillRule: function (dataItem) {
                    var axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        var axis = dataItem.component;
                        var value = dataItem.get("value");
                        var step = axis.getPrivate("step");
                        if (isNumber(value) && isNumber(step)) {
                            if (round(value / step / 2, 5) == Math.round(value / step / 2)) {
                                axisFill.setPrivate("visible", false);
                            }
                            else {
                                axisFill.setPrivate("visible", true);
                            }
                        }
                    }
                }
            });
            r("DurationAxis").setAll({
                baseUnit: "second"
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Series
             * ------------------------------------------------------------------------
             */
            r("XYSeries").setAll({
                maskBullets: true,
                stackToNegative: true,
                locationX: 0.5,
                locationY: 0.5,
                snapTooltip: false,
                openValueXGrouped: "open",
                openValueYGrouped: "open",
                valueXGrouped: "close",
                valueYGrouped: "close",
                seriesTooltipTarget: "series"
            });
            r("BaseColumnSeries").setAll({
                adjustBulletPosition: true
            });
            r("ColumnSeries").setAll({
                clustered: true
            });
            r("RoundedRectangle", ["series", "column"]).setAll({
                position: "absolute",
                isMeasured: false,
                width: percent(70),
                height: percent(70),
                strokeWidth: 1,
                strokeOpacity: 1,
                cornerRadiusBL: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTR: 0,
                fillOpacity: 1,
                role: "figure"
            });
            r("LineSeries").setAll({
                connect: true,
                autoGapCount: 1.1,
                stackToNegative: false
            });
            r("Graphics", ["series", "stroke"]).setAll({
                position: "absolute",
                strokeWidth: 1,
                strokeOpacity: 1,
                isMeasured: false
            });
            r("Graphics", ["series", "fill"]).setAll({
                visible: false,
                fillOpacity: 0,
                position: "absolute",
                strokeWidth: 0,
                strokeOpacity: 0,
                isMeasured: false
            });
            r("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
                draw: function (display, sprite) {
                    var parent = sprite.parent;
                    if (parent) {
                        var h = parent.height();
                        var w = parent.width();
                        display.moveTo(0, h / 2);
                        display.lineTo(w, h / 2);
                    }
                }
            });
            {
                var rule = r("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
                setColor(rule, "stroke", ic, "disabled");
            }
            r("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
                draw: function (display, sprite) {
                    var parent = sprite.parent;
                    if (parent) {
                        var h = parent.height();
                        var w = parent.width();
                        display.moveTo(0, 0);
                        display.lineTo(w, 0);
                        display.lineTo(w, h);
                        display.lineTo(0, h);
                        display.lineTo(0, 0);
                    }
                }
            });
            {
                var rule = r("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
                setColor(rule, "stroke", ic, "disabled");
            }
            r("SmoothedXYLineSeries").setAll({
                tension: 0.5
            });
            r("SmoothedXLineSeries").setAll({
                tension: 0.5
            });
            r("SmoothedYLineSeries").setAll({
                tension: 0.5
            });
            r("Candlestick").setAll({
                position: "absolute",
                isMeasured: false,
                width: percent(50),
                height: percent(50),
                strokeWidth: 1,
                strokeOpacity: 1,
                cornerRadiusBL: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTR: 0,
                fillOpacity: 1,
                role: "figure"
            });
            r("OHLC").setAll({
                width: percent(80),
                height: percent(80)
            });
            r("CandlestickSeries").setAll({
                lowValueXGrouped: "low",
                lowValueYGrouped: "low",
                highValueXGrouped: "high",
                highValueYGrouped: "high",
                openValueXGrouped: "open",
                openValueYGrouped: "open",
                valueXGrouped: "close",
                valueYGrouped: "close"
            });
            // These rules can be used for regular columns, too
            {
                var rule = r("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
                setColor(rule, "fill", ic, "positive");
                setColor(rule, "stroke", ic, "positive");
            }
            {
                var rule = r("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
                setColor(rule, "fill", ic, "negative");
                setColor(rule, "stroke", ic, "negative");
            }
            r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", { fillOpacity: 1 });
            r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", { fillOpacity: 0 });
        }
    });
    return XYChartDefaultTheme;
}(Theme));

//# sourceMappingURL=XYChartDefaultTheme.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js



/**
 * A base class for all charts.
 */
var Chart = /** @class */ (function (_super) {
    __extends(Chart, _super);
    function Chart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A [[Container]] chart places its elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "chartContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.children.push(Container.new(_this._root, { width: p100, height: p100, interactiveChildren: false }))
        });
        /**
         * A [[Container]] chart places its bullets in.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { interactiveChildren: false, isMeasured: false, position: "absolute", width: p100, height: p100 })
        });
        return _this;
    }
    Object.defineProperty(Chart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Chart"
    });
    Object.defineProperty(Chart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Chart.className])
    });
    return Chart;
}(Container));

//# sourceMappingURL=Chart.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js






/**
 * A base class for all series-based charts.
 */
var SerialChart = /** @class */ (function (_super) {
    __extends(SerialChart, _super);
    function SerialChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A [[Container]] where chart will store all series.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "seriesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { width: p100, height: p100, isMeasured: false })
        });
        /**
         * A list of chart's series.
         */
        Object.defineProperty(_this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListAutoDispose()
        });
        return _this;
    }
    Object.defineProperty(SerialChart.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._afterNew.call(this);
            this._disposers.push(this.series);
            var children = this.seriesContainer.children;
            this._disposers.push(this.series.events.onAll(function (change) {
                if (change.type === "clear") {
                    each(change.oldValues, function (series) {
                        _this._removeSeries(series);
                    });
                    var colors = _this.get("colors");
                    if (colors) {
                        colors.reset();
                    }
                }
                else if (change.type === "push") {
                    children.moveValue(change.newValue);
                    _this._processSeries(change.newValue);
                }
                else if (change.type === "setIndex") {
                    children.setIndex(change.index, change.newValue);
                    _this._processSeries(change.newValue);
                }
                else if (change.type === "insertIndex") {
                    children.insertIndex(change.index, change.newValue);
                    _this._processSeries(change.newValue);
                }
                else if (change.type === "removeIndex") {
                    _this._removeSeries(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    children.moveValue(change.value, change.newIndex);
                    _this._processSeries(change.value);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            }));
        }
    });
    Object.defineProperty(SerialChart.prototype, "_processSeries", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series) {
            series.chart = this;
            series._placeBulletsContainer(this);
        }
    });
    Object.defineProperty(SerialChart.prototype, "_removeSeries", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series) {
            if (!series.isDisposed()) {
                this.seriesContainer.children.removeValue(series);
                series._removeBulletsContainer();
            }
        }
    });
    Object.defineProperty(SerialChart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SerialChart"
    });
    Object.defineProperty(SerialChart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Chart.classNames.concat([SerialChart.className])
    });
    return SerialChart;
}(Chart));

//# sourceMappingURL=SerialChart.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js





/**
 * Draws a rectangle with rounded corners.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
var RoundedRectangle = /** @class */ (function (_super) {
    __extends(RoundedRectangle, _super);
    function RoundedRectangle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RoundedRectangle.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {
                this._clear = true;
            }
        }
    });
    Object.defineProperty(RoundedRectangle.prototype, "_draw", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var width = this.width();
            var height = this.height();
            var w = width;
            var h = height;
            var wSign = w / Math.abs(width);
            var hSign = h / Math.abs(height);
            if (isNumber(w) && isNumber(h)) {
                var minSide = Math.min(w, h) / 2;
                var crtl = relativeToValue(this.get("cornerRadiusTL", 8), minSide);
                var crtr = relativeToValue(this.get("cornerRadiusTR", 8), minSide);
                var crbr = relativeToValue(this.get("cornerRadiusBR", 8), minSide);
                var crbl = relativeToValue(this.get("cornerRadiusBL", 8), minSide);
                var maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));
                crtl = fitToRange(crtl, 0, maxcr);
                crtr = fitToRange(crtr, 0, maxcr);
                crbr = fitToRange(crbr, 0, maxcr);
                crbl = fitToRange(crbl, 0, maxcr);
                this._display.moveTo(crtl * wSign, 0);
                this._display.lineTo(w - crtr * wSign, 0);
                if (crtr > 0) {
                    this._display.arcTo(w, 0, w, crtr * hSign, crtr);
                }
                this._display.lineTo(w, h - crbr * hSign);
                if (crbr > 0) {
                    this._display.arcTo(w, h, w - crbr * wSign, h, crbr);
                }
                this._display.lineTo(crbl * wSign, h);
                if (crbl > 0) {
                    this._display.arcTo(0, h, 0, h - crbl * hSign, crbl);
                }
                this._display.lineTo(0, crtl * hSign);
                if (crtl > 0) {
                    this._display.arcTo(0, 0, crtl * wSign, 0, crtl);
                }
            }
        }
    });
    Object.defineProperty(RoundedRectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RoundedRectangle"
    });
    Object.defineProperty(RoundedRectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Rectangle.classNames.concat([RoundedRectangle.className])
    });
    return RoundedRectangle;
}(Rectangle));

//# sourceMappingURL=RoundedRectangle.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js




/**
 * Draws an interactive button.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info
 * @important
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Button.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["button"]);
            _super.prototype._afterNew.call(this);
            if (!this._settings.background) {
                this.set("background", RoundedRectangle.new(this._root, {
                    themeTags: mergeTags(this._settings.themeTags, ["background"])
                }));
            }
        }
    });
    Object.defineProperty(Button.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._prepareChildren.call(this);
            if (this.isDirty("icon")) {
                var previous = this._prevSettings.icon;
                var icon = this.get("icon");
                if (icon !== previous) {
                    this._disposeProperty("icon");
                    if (previous) {
                        previous.dispose();
                    }
                    if (icon) {
                        this.children.push(icon);
                    }
                    this._prevSettings.icon = icon;
                }
            }
            if (this.isDirty("label")) {
                var previous = this._prevSettings.label;
                var label = this.get("label");
                if (label !== previous) {
                    this._disposeProperty("label");
                    if (previous) {
                        previous.dispose();
                    }
                    if (label) {
                        this.children.push(label);
                    }
                    this._prevSettings.label = label;
                }
            }
        }
    });
    Object.defineProperty(Button, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Button"
    });
    Object.defineProperty(Button, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Button.className])
    });
    return Button;
}(Container));

//# sourceMappingURL=Button.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js














/**
 * Creates an XY chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info
 * @important
 */
var XYChart = /** @class */ (function (_super) {
    __extends(XYChart, _super);
    function XYChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A list of horizontal axes.
         */
        Object.defineProperty(_this, "xAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListAutoDispose()
        });
        /**
         * A list of vertical axes.
         */
        Object.defineProperty(_this, "yAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListAutoDispose()
        });
        /**
         * A [[Container]] located on top of the chart, used to store top horizontal
         * axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "topAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.chartContainer.children.push(Container.new(_this._root, { width: p100, layout: _this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located in the middle the chart, used to store vertical axes
         * and plot area container.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "yAxesAndPlotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.chartContainer.children.push(Container.new(_this._root, { width: p100, height: p100, layout: _this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located on bottom of the chart, used to store bottom
         * horizontal axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "bottomAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.chartContainer.children.push(Container.new(_this._root, { width: p100, layout: _this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located on left of the chart, used to store left-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "leftAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, { height: p100, layout: _this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located in the middle of the chart, used to store actual
         * plots (series).
         *
         * NOTE: `plotContainer` will automatically have its `background` preset. If
         * you need to modify background or outline for chart's plot area, you can
         * use `plotContainer.get("background")` for that.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "plotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, { width: p100, height: p100, maskContent: false }))
        });
        /**
         * A [[Container]] axis grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.plotContainer.children.push(Container.new(_this._root, { width: p100, height: p100, isMeasured: false }))
        });
        /**
         * A [[Container]] axis background grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { width: p100, height: p100, isMeasured: false })
        });
        /**
         * A [[Container]] located on right of the chart, used to store right-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "rightAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, { height: p100, layout: _this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] axis headers are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(_this, "axisHeadersContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.plotContainer.children.push(Container.new(_this._root, {}))
        });
        /**
         * A button that is shown when chart is not fully zoomed out.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info
         * @default Button.new()
         */
        Object.defineProperty(_this, "zoomOutButton", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.plotContainer.children.push(Button.new(_this._root, {
                themeTags: ["zoom"],
                icon: Graphics.new(_this._root, {
                    themeTags: ["button", "icon"]
                })
            }))
        });
        Object.defineProperty(_this, "_movePoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { x: 0, y: 0 }
        });
        Object.defineProperty(_this, "_wheelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_otherCharts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(XYChart.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this._defaultThemes.push(XYChartDefaultTheme.new(this._root));
            _super.prototype._afterNew.call(this);
            this._disposers.push(this.xAxes);
            this._disposers.push(this.yAxes);
            var root = this._root;
            var verticalLayout = this._root.verticalLayout;
            var zoomOutButton = this.zoomOutButton;
            zoomOutButton.events.on("click", function () {
                _this.zoomOut();
            });
            zoomOutButton.set("opacity", 0);
            zoomOutButton.states.lookup("default").set("opacity", 1);
            this.chartContainer.set("layout", verticalLayout);
            var plotContainer = this.plotContainer;
            plotContainer.children.push(this.seriesContainer);
            this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));
            this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));
            plotContainer.children.push(this.topGridContainer);
            plotContainer.children.push(this.bulletsContainer);
            plotContainer.children.moveValue(zoomOutButton);
            // Setting trasnparent background so that full body of the plot container
            // is interactive
            plotContainer.set("interactive", true);
            plotContainer.set("interactiveChildren", false);
            plotContainer.set("background", Rectangle.new(root, {
                themeTags: ["xy", "background"],
                fill: Color.fromHex(0x000000),
                fillOpacity: 0
            }));
            this._disposers.push(plotContainer.events.on("pointerdown", function (event) {
                _this._handlePlotDown(event.originalEvent);
            }));
            this._disposers.push(plotContainer.events.on("globalpointerup", function (event) {
                _this._handlePlotUp(event.originalEvent);
            }));
            this._disposers.push(plotContainer.events.on("globalpointermove", function (event) {
                _this._handlePlotMove(event.originalEvent);
            }));
        }
    });
    Object.defineProperty(XYChart.prototype, "_removeSeries", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series) {
            var xAxis = series.get("xAxis");
            if (xAxis) {
                remove(xAxis.series, series);
            }
            var yAxis = series.get("yAxis");
            if (yAxis) {
                remove(yAxis.series, series);
            }
            _super.prototype._removeSeries.call(this, series);
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleSetWheel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var wheelX = this.get("wheelX");
            var wheelY = this.get("wheelY");
            var plotContainer = this.plotContainer;
            if (wheelX !== "none" || wheelY !== "none") {
                this._wheelDp = plotContainer.events.on("wheel", function (event) {
                    var wheelEvent = event.originalEvent;
                    wheelEvent.preventDefault();
                    var plotPoint = plotContainer.toLocal(_this._root.documentPointToRoot({ x: wheelEvent.clientX, y: wheelEvent.clientY }));
                    var wheelStep = _this.get("wheelStep", 0.2);
                    var shiftY = wheelEvent.deltaY / 100;
                    var shiftX = wheelEvent.deltaX / 100;
                    if ((wheelX === "zoomX" || wheelX === "zoomXY") && shiftX != 0) {
                        _this.xAxes.each(function (axis) {
                            if (axis.get("zoomX")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.x / plotContainer.width());
                                var newStart = start - wheelStep * (end - start) * shiftX * position;
                                var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                                if (1 / (newEnd - newStart) < axis.get("maxZoomFactor", Infinity)) {
                                    _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                                }
                            }
                        });
                    }
                    if ((wheelY === "zoomX" || wheelY === "zoomXY") && shiftY != 0) {
                        _this.xAxes.each(function (axis) {
                            if (axis.get("zoomX")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.x / plotContainer.width());
                                var newStart = start - wheelStep * (end - start) * shiftY * position;
                                var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                                if (1 / (newEnd - newStart) < axis.get("maxZoomFactor", Infinity)) {
                                    _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                                }
                            }
                        });
                    }
                    if ((wheelX === "zoomY" || wheelX === "zoomXY") && shiftX != 0) {
                        _this.yAxes.each(function (axis) {
                            if (axis.get("zoomY")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.y / plotContainer.height());
                                var newStart = start - wheelStep * (end - start) * shiftX * position;
                                var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                                if (1 / (newEnd - newStart) < axis.get("maxZoomFactor", Infinity)) {
                                    _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                                }
                            }
                        });
                    }
                    if ((wheelY === "zoomY" || wheelY === "zoomXY") && shiftY != 0) {
                        _this.yAxes.each(function (axis) {
                            if (axis.get("zoomY")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.y / plotContainer.height());
                                var newStart = start - wheelStep * (end - start) * shiftY * position;
                                var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                                if (1 / (newEnd - newStart) < axis.get("maxZoomFactor", Infinity)) {
                                    _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                                }
                            }
                        });
                    }
                    if ((wheelX === "panX" || wheelX === "panXY") && shiftX != 0) {
                        _this.xAxes.each(function (axis) {
                            if (axis.get("panX")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.x / plotContainer.width());
                                var newStart = start + wheelStep * (end - start) * shiftX * position;
                                var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                                _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                            }
                        });
                    }
                    if ((wheelY === "panX" || wheelY === "panXY") && shiftY != 0) {
                        _this.xAxes.each(function (axis) {
                            if (axis.get("panX")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.x / plotContainer.width());
                                var newStart = start + wheelStep * (end - start) * shiftY * position;
                                var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                                _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                            }
                        });
                    }
                    if ((wheelX === "panY" || wheelX === "panXY") && shiftX != 0) {
                        _this.yAxes.each(function (axis) {
                            if (axis.get("panY")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.y / plotContainer.height());
                                var newStart = start + wheelStep * (end - start) * shiftX * position;
                                var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                                _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                            }
                        });
                    }
                    if ((wheelY === "panY" || wheelY === "panXY") && shiftY != 0) {
                        _this.yAxes.each(function (axis) {
                            if (axis.get("panY")) {
                                var start = axis.get("start");
                                var end = axis.get("end");
                                var position = axis.fixPosition(plotPoint.y / plotContainer.height());
                                var newStart = start + wheelStep * (end - start) * shiftY * position;
                                var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                                _this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                            }
                        });
                    }
                });
                this._disposers.push(this._wheelDp);
            }
            else {
                if (this._wheelDp) {
                    this._wheelDp.dispose();
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_handlePlotDown", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (event) {
            // TODO: handle multitouch
            if (this.get("panX") || this.get("panY")) {
                var plotContainer = this.plotContainer;
                var local = plotContainer.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
                if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {
                    this._downPoint = local;
                    var panX = this.get("panX");
                    var panY = this.get("panY");
                    if (panX) {
                        this.xAxes.each(function (axis) {
                            axis._panStart = axis.get("start");
                            axis._panEnd = axis.get("end");
                        });
                    }
                    if (panY) {
                        this.yAxes.each(function (axis) {
                            axis._panStart = axis.get("start");
                            axis._panEnd = axis.get("end");
                        });
                    }
                    var eventType = "panstarted";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this });
                    }
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleWheelAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (animation) {
            var _this = this;
            if (animation) {
                animation.events.on("stopped", function () {
                    _this._dispatchWheelAnimation();
                });
            }
            else {
                this._dispatchWheelAnimation();
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_dispatchWheelAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var eventType = "wheelended";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_handlePlotUp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_event) {
            if (this._downPoint) {
                if (this.get("panX") || this.get("panY")) {
                    var eventType = "panended";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this });
                    }
                }
            }
            // TODO: handle multitouch
            this._downPoint = undefined;
            this.xAxes.each(function (xAxis) {
                xAxis._isPanning = false;
            });
            this.yAxes.each(function (yAxis) {
                yAxis._isPanning = false;
            });
        }
    });
    Object.defineProperty(XYChart.prototype, "_handlePlotMove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (event) {
            // TODO: handle multitouch
            var downPoint = this._downPoint;
            if (downPoint) {
                var plotContainer_1 = this.plotContainer;
                var local_1 = plotContainer_1.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
                var panX = this.get("panX");
                var panY = this.get("panY");
                if (panX) {
                    var scrollbarX = this.get("scrollbarX");
                    if (scrollbarX) {
                        scrollbarX.events.disableType("rangechanged");
                    }
                    this.xAxes.each(function (axis) {
                        if (axis.get("panX")) {
                            axis._isPanning = true;
                            //const maxDeviation = axis.get("maxDeviation", 0);
                            var panStart = axis._panStart;
                            var panEnd = axis._panEnd;
                            var difference = (panEnd - panStart);
                            var deltaX = difference * (downPoint.x - local_1.x) / plotContainer_1.width();
                            if (axis.get("renderer").get("inversed")) {
                                deltaX *= -1;
                            }
                            var start = panStart + deltaX;
                            var end = panEnd + deltaX;
                            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                                axis.set("start", start);
                                axis.set("end", end);
                            }
                        }
                    });
                    if (scrollbarX) {
                        scrollbarX.events.enableType("rangechanged");
                    }
                }
                if (panY) {
                    var scrollbarY = this.get("scrollbarY");
                    if (scrollbarY) {
                        scrollbarY.events.disableType("rangechanged");
                    }
                    this.yAxes.each(function (axis) {
                        if (axis.get("panY")) {
                            axis._isPanning = true;
                            //const maxDeviation = axis.get("maxDeviation", 0);
                            var panStart = axis._panStart;
                            var panEnd = axis._panEnd;
                            var difference = (panEnd - panStart);
                            var deltaY = difference * (downPoint.y - local_1.y) / plotContainer_1.height();
                            if (axis.get("renderer").get("inversed")) {
                                deltaY *= -1;
                            }
                            var start = panStart - deltaY;
                            var end = panEnd - deltaY;
                            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                                axis.set("start", start);
                                axis.set("end", end);
                            }
                        }
                    });
                    if (scrollbarY) {
                        scrollbarY.events.enableType("rangechanged");
                    }
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleCursorPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var cursor = this.get("cursor");
            if (cursor) {
                var cursorPoint_1 = cursor.getPrivate("point");
                var snapToSeries = cursor.get("snapToSeries");
                if (snapToSeries && cursorPoint_1) {
                    var snapToSeriesBy_1 = cursor.get("snapToSeriesBy");
                    var dataItems_1 = [];
                    each(snapToSeries, function (series) {
                        if (!series.isHidden() && !series.isHiding()) {
                            if (snapToSeriesBy_1 != "x!" && snapToSeriesBy_1 != "y!") {
                                var startIndex = series.startIndex();
                                var endIndex = series.endIndex();
                                for (var i = startIndex; i < endIndex; i++) {
                                    var dataItem = series.dataItems[i];
                                    if (dataItem && !dataItem.isHidden()) {
                                        dataItems_1.push(dataItem);
                                    }
                                }
                            }
                            else {
                                var tooltipDataItem = series.get("tooltipDataItem");
                                if (tooltipDataItem) {
                                    dataItems_1.push(tooltipDataItem);
                                }
                            }
                        }
                    });
                    var minDistance_1 = Infinity;
                    var closestItem_1;
                    each(dataItems_1, function (dataItem) {
                        var point = dataItem.get("point");
                        if (point) {
                            var distance = 0;
                            if (snapToSeriesBy_1 == "x" || snapToSeriesBy_1 == "x!") {
                                distance = Math.abs(cursorPoint_1.x - point.x);
                            }
                            else if (snapToSeriesBy_1 == "y" || snapToSeriesBy_1 == "y!") {
                                distance = Math.abs(cursorPoint_1.y - point.y);
                            }
                            else {
                                distance = Math.hypot(cursorPoint_1.x - point.x, cursorPoint_1.y - point.y);
                            }
                            if (distance < minDistance_1) {
                                minDistance_1 = distance;
                                closestItem_1 = dataItem;
                            }
                        }
                    });
                    each(snapToSeries, function (series) {
                        var tooltip = series.get("tooltip");
                        if (tooltip) {
                            tooltip._setDataItem(undefined);
                        }
                    });
                    if (closestItem_1) {
                        var series = closestItem_1.component;
                        series.showDataItemTooltip(closestItem_1);
                        var point = closestItem_1.get("point");
                        if (point) {
                            cursor.handleMove(series.toGlobal(point), true);
                        }
                    }
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_updateCursor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var cursor = this.get("cursor");
            if (cursor) {
                cursor.handleMove();
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_addCursor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (cursor) {
            this.plotContainer.children.push(cursor);
        }
    });
    Object.defineProperty(XYChart.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._prepareChildren.call(this);
            this.series.each(function (series) {
                _this._colorize(series);
            });
            if (this.isDirty("wheelX") || this.isDirty("wheelY")) {
                this._handleSetWheel();
            }
            if (this.isDirty("cursor")) {
                var previous = this._prevSettings.cursor;
                var cursor = this.get("cursor");
                if (cursor !== previous) {
                    this._disposeProperty("cursor");
                    if (previous) {
                        previous.dispose();
                    }
                    if (cursor) {
                        cursor._setChart(this);
                        this._addCursor(cursor);
                        this._pushPropertyDisposer("cursor", cursor.events.on("selectended", function () {
                            _this._handleCursorSelectEnd();
                        }));
                    }
                    //this.setRaw("cursor", cursor) // to reset previous value
                    this._prevSettings.cursor = cursor;
                }
            }
            if (this.isDirty("scrollbarX")) {
                var previous = this._prevSettings.scrollbarX;
                var scrollbarX = this.get("scrollbarX");
                if (scrollbarX !== previous) {
                    this._disposeProperty("scrollbarX");
                    if (previous) {
                        previous.dispose();
                    }
                    if (scrollbarX) {
                        if (!scrollbarX.parent) {
                            this.topAxesContainer.children.push(scrollbarX);
                        }
                        this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("rangechanged", function (e) {
                            _this._handleScrollbar(_this.xAxes, e.start, e.end);
                        }));
                        // Used to populate `ariaLabel` with meaningful values
                        scrollbarX.setPrivate("positionTextFunction", function (position) {
                            var axis = _this.xAxes.getIndex(0);
                            return axis ? axis.getTooltipText(position) || "" : "";
                        });
                    }
                    this._prevSettings.scrollbarX = scrollbarX;
                }
            }
            if (this.isDirty("scrollbarY")) {
                var previous = this._prevSettings.scrollbarY;
                var scrollbarY = this.get("scrollbarY");
                if (scrollbarY !== previous) {
                    this._disposeProperty("scrollbarY");
                    if (previous) {
                        previous.dispose();
                    }
                    if (scrollbarY) {
                        if (!scrollbarY.parent) {
                            this.rightAxesContainer.children.push(scrollbarY);
                        }
                        this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("rangechanged", function (e) {
                            _this._handleScrollbar(_this.yAxes, e.start, e.end);
                        }));
                        // Used to populate `ariaLabel` with meaningful values
                        scrollbarY.setPrivate("positionTextFunction", function (position) {
                            var axis = _this.yAxes.getIndex(0);
                            return axis ? axis.getTooltipText(position) || "" : "";
                        });
                    }
                    this._prevSettings.scrollbarY = scrollbarY;
                }
            }
            this._handleZoomOut();
        }
    });
    Object.defineProperty(XYChart.prototype, "_processSeries", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series) {
            _super.prototype._processSeries.call(this, series);
            this._colorize(series);
        }
    });
    Object.defineProperty(XYChart.prototype, "_colorize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series) {
            var colorSet = this.get("colors");
            if (colorSet) {
                if (series.get("fill") == null) {
                    var color = colorSet.next();
                    series._setSoft("stroke", color);
                    series._setSoft("fill", color);
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleCursorSelectEnd", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var cursor = this.get("cursor");
            var behavior = cursor.get("behavior");
            var downPositionX = cursor.getPrivate("downPositionX", 0);
            var downPositionY = cursor.getPrivate("downPositionY", 0);
            var positionX = cursor.getPrivate("positionX", 0.5);
            var positionY = cursor.getPrivate("positionY", 0.5);
            this.xAxes.each(function (axis) {
                if (behavior === "zoomX" || behavior === "zoomXY") {
                    var position0 = axis.toAxisPosition(downPositionX);
                    var position1 = axis.toAxisPosition(positionX);
                    axis.zoom(position0, position1);
                }
                axis.setPrivate("updateScrollbar", true);
            });
            this.yAxes.each(function (axis) {
                if (behavior === "zoomY" || behavior === "zoomXY") {
                    var position0 = axis.toAxisPosition(downPositionY);
                    var position1 = axis.toAxisPosition(positionY);
                    axis.zoom(position0, position1);
                }
                axis.setPrivate("updateScrollbar", true);
            });
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleScrollbar", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axes, start, end) {
            axes.each(function (axis) {
                var axisStart = axis.fixPosition(start);
                var axisEnd = axis.fixPosition(end);
                var zoomAnimation = axis.zoom(axisStart, axisEnd);
                var updateScrollbar = "updateScrollbar";
                axis.setPrivateRaw(updateScrollbar, false);
                if (zoomAnimation) {
                    zoomAnimation.events.on("stopped", function () {
                        axis.setPrivateRaw(updateScrollbar, true);
                    });
                }
                else {
                    axis.setPrivateRaw(updateScrollbar, true);
                }
            });
        }
    });
    Object.defineProperty(XYChart.prototype, "_processAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axes, container) {
            var _this = this;
            return axes.events.onAll(function (change) {
                if (change.type === "clear") {
                    each(change.oldValues, function (axis) {
                        _this._removeAxis(axis);
                    });
                }
                else if (change.type === "push") {
                    container.children.push(change.newValue);
                    change.newValue.processChart(_this);
                }
                else if (change.type === "setIndex") {
                    container.children.setIndex(change.index, change.newValue);
                    change.newValue.processChart(_this);
                }
                else if (change.type === "insertIndex") {
                    container.children.insertIndex(change.index, change.newValue);
                    change.newValue.processChart(_this);
                }
                else if (change.type === "removeIndex") {
                    _this._removeAxis(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    container.children.moveValue(change.value, change.newIndex);
                    change.value.processChart(_this);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            });
        }
    });
    Object.defineProperty(XYChart.prototype, "_removeAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axis) {
            if (!axis.isDisposed()) {
                var axisParent = axis.parent;
                if (axisParent) {
                    axisParent.children.removeValue(axis);
                }
                var gridContainer = axis.gridContainer;
                var gridParent = gridContainer.parent;
                if (gridParent) {
                    gridParent.children.removeValue(gridContainer);
                }
                var topGridContainer = axis.topGridContainer;
                var topGridParent = topGridContainer.parent;
                if (topGridParent) {
                    topGridParent.children.removeValue(topGridContainer);
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_updateChartLayout", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var left = this.leftAxesContainer.width();
            var right = this.rightAxesContainer.width();
            var bottomAxesContainer = this.bottomAxesContainer;
            bottomAxesContainer.set("paddingLeft", left);
            bottomAxesContainer.set("paddingRight", right);
            var topAxesContainer = this.topAxesContainer;
            topAxesContainer.set("paddingLeft", left);
            topAxesContainer.set("paddingRight", right);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYChart.prototype, "processAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_axis) { }
    });
    ;
    Object.defineProperty(XYChart.prototype, "_handleAxisSelection", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axis) {
            var _a;
            var start = axis.fixPosition(axis.get("start", 0));
            var end = axis.fixPosition(axis.get("end", 1));
            if (start > end) {
                _a = __read([end, start], 2), start = _a[0], end = _a[1];
            }
            if (this.xAxes.indexOf(axis) != -1) {
                if (axis.getPrivate("updateScrollbar")) {
                    var scrollbarX = this.get("scrollbarX");
                    if (scrollbarX && !scrollbarX.getPrivate("isBusy")) {
                        scrollbarX.setRaw("start", start);
                        scrollbarX.setRaw("end", end);
                        scrollbarX.updateGrips();
                    }
                }
            }
            else if (this.yAxes.indexOf(axis) != -1) {
                if (axis.getPrivate("updateScrollbar")) {
                    var scrollbarY = this.get("scrollbarY");
                    if (scrollbarY && !scrollbarY.getPrivate("isBusy")) {
                        scrollbarY.setRaw("start", start);
                        scrollbarY.setRaw("end", end);
                        scrollbarY.updateGrips();
                    }
                }
            }
            this._handleZoomOut();
        }
    });
    Object.defineProperty(XYChart.prototype, "_handleZoomOut", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var zoomOutButton = this.zoomOutButton;
            if (zoomOutButton && zoomOutButton.parent) {
                var visible_1 = false;
                this.xAxes.each(function (axis) {
                    if (axis.get("start") != 0 || axis.get("end") != 1) {
                        visible_1 = true;
                    }
                });
                this.yAxes.each(function (axis) {
                    if (axis.get("start") != 0 || axis.get("end") != 1) {
                        visible_1 = true;
                    }
                });
                if (visible_1) {
                    if (zoomOutButton.isHidden()) {
                        zoomOutButton.show();
                    }
                }
                else {
                    zoomOutButton.hide();
                }
            }
        }
    });
    /**
     * Checks if point is within plot area.
     *
     * @param   point  Reference point
     * @return         Is within plot area?
     */
    Object.defineProperty(XYChart.prototype, "inPlot", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            var plotContainer = this.plotContainer;
            var otherCharts = this._otherCharts;
            var global = plotContainer.toGlobal(point);
            if (point.x >= -0.1 && point.y >= -0.1 && point.x <= plotContainer.width() + 0.1 && point.y <= plotContainer.height() + 0.1) {
                return true;
            }
            if (otherCharts) {
                for (var i = otherCharts.length - 1; i >= 0; i--) {
                    var chart = otherCharts[i];
                    if (chart != this) {
                        var chartPlotContainer = chart.plotContainer;
                        var documentPoint = this._root.rootPointToDocument(global);
                        var chartRoot = chart._root.documentPointToRoot(documentPoint);
                        var local = chartPlotContainer.toLocal(chartRoot);
                        if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYChart.prototype, "arrangeTooltips", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var plotContainer = this.plotContainer;
            var w = plotContainer.width();
            var h = plotContainer.height();
            var plotT = plotContainer._display.toGlobal({ x: 0, y: 0 });
            var plotB = plotContainer._display.toGlobal({ x: w, y: h });
            var tooltips = [];
            var sum = 0;
            var minDistance = Infinity;
            var movePoint = this._movePoint;
            var maxTooltipDistance = this.get("maxTooltipDistance");
            var closest;
            var closestPoint;
            if (isNumber(maxTooltipDistance)) {
                this.series.each(function (series) {
                    var tooltip = series.get("tooltip");
                    if (tooltip) {
                        var point = tooltip.get("pointTo");
                        if (point) {
                            var distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closest = series;
                                closestPoint = point;
                            }
                        }
                    }
                });
            }
            var tooltipSeries = [];
            this.series.each(function (series) {
                var tooltip = series.get("tooltip");
                if (tooltip) {
                    var hidden = false;
                    var point = tooltip.get("pointTo");
                    if (point) {
                        if (maxTooltipDistance >= 0) {
                            var point_1 = tooltip.get("pointTo");
                            if (point_1) {
                                if (series != closest) {
                                    var distance = Math.hypot(closestPoint.x - point_1.x, closestPoint.y - point_1.y);
                                    if (distance > maxTooltipDistance) {
                                        hidden = true;
                                    }
                                }
                            }
                        }
                        else if (maxTooltipDistance == -1) {
                            if (series != closest) {
                                hidden = true;
                            }
                        }
                        if (!_this.inPlot(_this._tooltipToLocal(point)) || !tooltip.dataItem) {
                            hidden = true;
                        }
                        else {
                            if (!hidden) {
                                sum += point.y;
                            }
                        }
                        if (hidden || series.isHidden() || series.isHiding()) {
                            tooltip.hide(0);
                        }
                        else {
                            tooltip.show();
                            tooltips.push(tooltip);
                            tooltipSeries.push(series);
                        }
                    }
                }
            });
            this.setPrivate("tooltipSeries", tooltipSeries);
            if (this.get("arrangeTooltips")) {
                var tooltipContainer_1 = this._root.tooltipContainer;
                tooltips.sort(function (a, b) { return compareNumber(a.get("pointTo").y, b.get("pointTo").y); });
                var count = tooltips.length;
                var average = sum / count;
                if (average > h / 2 + plotT.y) {
                    tooltips.reverse();
                    var prevY_1 = plotB.y;
                    each(tooltips, function (tooltip) {
                        var height = tooltip.height();
                        var centerY = tooltip.get("centerY");
                        if (centerY instanceof Percent) {
                            height *= centerY.value;
                        }
                        height += tooltip.get("marginBottom", 0);
                        tooltip.set("bounds", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY_1 });
                        prevY_1 = Math.min(prevY_1 - height, tooltip._fy - height);
                        tooltipContainer_1.children.moveValue(tooltip, 0);
                    });
                }
                else {
                    var prevY_2 = 0;
                    each(tooltips, function (tooltip) {
                        var height = tooltip.height();
                        var centerY = tooltip.get("centerY");
                        if (centerY instanceof Percent) {
                            height *= centerY.value;
                        }
                        height += tooltip.get("marginBottom", 0);
                        tooltip.set("bounds", { left: plotT.x, top: prevY_2, right: plotB.x, bottom: Math.max(plotT.y + h, prevY_2 + height) });
                        tooltipContainer_1.children.moveValue(tooltip, 0);
                        prevY_2 = Math.max(prevY_2 + height, tooltip._fy + height);
                    });
                }
            }
        }
    });
    Object.defineProperty(XYChart.prototype, "_tooltipToLocal", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point) {
            return this.plotContainer.toLocal(point);
        }
    });
    /**
     * Fully zooms out the chart.
     */
    Object.defineProperty(XYChart.prototype, "zoomOut", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.xAxes.each(function (axis) {
                axis.setPrivate("updateScrollbar", true);
                axis.zoom(0, 1);
            });
            this.yAxes.each(function (axis) {
                axis.setPrivate("updateScrollbar", true);
                axis.zoom(0, 1);
            });
        }
    });
    Object.defineProperty(XYChart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYChart"
    });
    Object.defineProperty(XYChart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: SerialChart.classNames.concat([XYChart.className])
    });
    return XYChart;
}(SerialChart));

//# sourceMappingURL=XYChart.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js
/** @ignore */ /** */

/**
 * @ignore
 */
function segmentedLine(display, segments) {
    for (var s = 0, len = segments.length; s < len; s++) {
        var groups = segments[s];
        if (groups.length > 0) {
            var firstGroup = groups[0];
            if (firstGroup.length > 0) {
                var firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (var g = 0, len_1 = groups.length; g < len_1; g++) {
                    line(display, groups[g]);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function line(display, points) {
    for (var p = 0, len = points.length; p < len; p++) {
        var point = points[p];
        display.lineTo(point.x, point.y);
    }
}
/**
 * @ignore
 */
function moveTo(display, point) {
    display.moveTo(point.x, point.y);
}
/**
 * @ignore
 */
function clear(display) {
    display.clear();
}
/**
 * @ignore
 */
function smoothedSegmentedline(display, segments, tensionX, tensionY) {
    for (var s = 0, len = segments.length; s < len; s++) {
        var groups = segments[s];
        if (groups.length > 0) {
            var firstGroup = groups[0];
            if (firstGroup.length > 0) {
                var firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (var g = 0, len_2 = groups.length; g < len_2; g++) {
                    var points = groups[g];
                    if (points.length > 0) {
                        display.lineTo(points[0].x, points[0].y);
                    }
                    smoothedLine(display, points, tensionX, tensionY);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function smoothedLine(display, points, tensionX, tensionY) {
    for (var i = points.length - 1; i > 0; i--) {
        var p0 = points[i];
        var p1 = points[i - 1];
        if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {
            points.splice(i - 1, 1);
        }
    }
    if (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {
        line(display, points);
        return;
    }
    tensionX = 1 - tensionX + 0.00001;
    tensionY = 1 - tensionY + 0.00001;
    var first = points[0];
    var last = points[points.length - 1];
    var closed = false;
    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {
        closed = true;
    }
    // Can't moveTo here, as it wont be possible to have fill then.
    var path = "";
    for (var i = 0, len = points.length - 1; i < len; i++) {
        var p0 = points[i - 1];
        var p1 = points[i];
        var p2 = points[i + 1];
        var p3 = points[i + 2];
        if (i === 0) {
            if (closed) {
                p0 = points[len - 2];
            }
            else {
                p0 = points[0];
            }
        }
        else if (i == len - 1) {
            if (closed) {
                p3 = points[1];
            }
            else {
                p3 = p2;
            }
        }
        var controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);
        var controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);
        display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);
    }
    return path;
}
//# sourceMappingURL=Draw.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js



/**
 * Draws a line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
var Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    function Line() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Line.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
    });
    Object.defineProperty(Line.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this._clear) {
                var points = this.get("points");
                var segments = this.get("segments");
                if (points && points.length > 0) {
                    var point = points[0];
                    this._display.moveTo(point.x, point.y);
                    segmentedLine(this._display, [[points]]);
                }
                else if (segments) {
                    segmentedLine(this._display, segments);
                }
                else if (!this.get("draw")) {
                    var w = this.width();
                    var h = this.height();
                    this._display.moveTo(0, 0);
                    this._display.lineTo(w, h);
                }
            }
        }
    });
    Object.defineProperty(Line, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Line"
    });
    Object.defineProperty(Line, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Line.className])
    });
    return Line;
}(Graphics));

//# sourceMappingURL=Line.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js


/**
 * Draws a tick element (mostly used on axes).
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 */
var Tick = /** @class */ (function (_super) {
    __extends(Tick, _super);
    function Tick() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Tick, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Tick"
    });
    Object.defineProperty(Tick, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Line.classNames.concat([Tick.className])
    });
    return Tick;
}(Line));

//# sourceMappingURL=Tick.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js


/**
 * Draws an axis tick.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Ticks} for more info
 * @important
 */
var AxisTick = /** @class */ (function (_super) {
    __extends(AxisTick, _super);
    function AxisTick() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        return _this;
    }
    Object.defineProperty(AxisTick, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisTick"
    });
    Object.defineProperty(AxisTick, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Tick.classNames.concat([AxisTick.className])
    });
    return AxisTick;
}(Tick));

//# sourceMappingURL=AxisTick.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js


/**
 * Creates an axis grid line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Grid} for more info
 * @important
 */
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Grid.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._beforeChanged.call(this);
            if (this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
    });
    Object.defineProperty(Grid, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Grid"
    });
    Object.defineProperty(Grid, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Grid.className])
    });
    return Grid;
}(Graphics));

//# sourceMappingURL=Grid.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js


/**
 * Draws an axis label.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
 * @important
 */
var AxisLabel = /** @class */ (function (_super) {
    __extends(AxisLabel, _super);
    function AxisLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        return _this;
    }
    Object.defineProperty(AxisLabel, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisLabel"
    });
    Object.defineProperty(AxisLabel, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Label.classNames.concat([AxisLabel.className])
    });
    return AxisLabel;
}(Label));

//# sourceMappingURL=AxisLabel.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js








/**
 * Base class for an axis renderer.
 *
 * Should not be used on its own.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 */
var AxisRenderer = /** @class */ (function (_super) {
    __extends(AxisRenderer, _super);
    function AxisRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // save for quick access
        Object.defineProperty(_this, "_axisLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 100
        });
        Object.defineProperty(_this, "_start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_inversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_minSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * Chart the renderer is used in.
         */
        Object.defineProperty(_this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_lc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_ls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_thumbDownPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_downStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_downEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of ticks in the axis.
         *
         * `ticks.template` can be used to configure ticks.
         *
         * @default new ListTemplate<AxisTick>
         */
        Object.defineProperty(_this, "ticks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListTemplate(Template.new({}), function () { return AxisTick._new(_this._root, {
                themeTags: mergeTags(_this.ticks.template.get("themeTags", []), _this.get("themeTags", []))
            }, [_this.ticks.template]); })
        });
        /**
         * A list of grid elements in the axis.
         *
         * `grid.template` can be used to configure grid.
         *
         * @default new ListTemplate<Grid>
         */
        Object.defineProperty(_this, "grid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListTemplate(Template.new({}), function () { return Grid._new(_this._root, {
                themeTags: mergeTags(_this.grid.template.get("themeTags", []), _this.get("themeTags", []))
            }, [_this.grid.template]); })
        });
        /**
         * A list of fills in the axis.
         *
         * `axisFills.template` can be used to configure axis fills.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(_this, "axisFills", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListTemplate(Template.new({}), function () { return Graphics._new(_this._root, {
                themeTags: mergeTags(_this.axisFills.template.get("themeTags", ["axis", "fill"]), _this.get("themeTags", []))
            }, [_this.axisFills.template]); })
        });
        /**
         * A list of labels in the axis.
         *
         * `labels.template` can be used to configure axis labels.
         *
         * @default new ListTemplate<AxisLabel>
         */
        Object.defineProperty(_this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListTemplate(Template.new({}), function () { return AxisLabel._new(_this._root, {
                themeTags: mergeTags(_this.labels.template.get("themeTags", []), _this.get("themeTags", []))
            }, [_this.labels.template]); })
        });
        /**
         * An [[Axis]] renderer is for.
         */
        Object.defineProperty(_this, "axis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "makeTick", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, themeTags) {
            var tick = this.ticks.make();
            tick._setDataItem(dataItem);
            dataItem.setRaw("tick", tick);
            tick.set("themeTags", mergeTags(tick.get("themeTags"), themeTags));
            this.axis.labelsContainer.children.push(tick);
            this.ticks.push(tick);
            return tick;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "makeGrid", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, themeTags) {
            var grid = this.grid.make();
            grid._setDataItem(dataItem);
            dataItem.setRaw("grid", grid);
            grid.set("themeTags", mergeTags(grid.get("themeTags"), themeTags));
            this.axis.gridContainer.children.push(grid);
            this.grid.push(grid);
            return grid;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "makeAxisFill", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, themeTags) {
            var axisFill = this.axisFills.make();
            axisFill._setDataItem(dataItem);
            axisFill.set("themeTags", mergeTags(axisFill.get("themeTags"), themeTags));
            this.axis.gridContainer.children.push(axisFill);
            dataItem.setRaw("axisFill", axisFill);
            this.axisFills.push(axisFill);
            return axisFill;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "makeLabel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, themeTags) {
            var label = this.labels.make();
            if (this.get("opposite")) {
                themeTags.push("opposite");
            }
            if (this.get("inside")) {
                themeTags.push("inside");
            }
            label.set("themeTags", mergeTags(label.get("themeTags"), themeTags));
            this.axis.labelsContainer.children.moveValue(label, 0);
            label._setDataItem(dataItem);
            dataItem.setRaw("label", label);
            this.labels.push(label);
            return label;
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "axisLength", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return 0;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "gridCount", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.axisLength() / this.get("minGridDistance", 50);
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_updatePositions", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._afterNew.call(this);
            this.set("isMeasured", false);
            var thumb = this.thumb;
            if (thumb) {
                this._disposers.push(thumb.events.on("pointerdown", function (event) {
                    _this._handleThumbDown(event.originalEvent);
                }));
                this._disposers.push(thumb.events.on("globalpointerup", function (event) {
                    _this._handleThumbUp(event.originalEvent);
                }));
                this._disposers.push(thumb.events.on("globalpointermove", function (event) {
                    _this._handleThumbMove(event.originalEvent);
                }));
            }
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            if (this.isDirty("pan")) {
                var thumb = this.thumb;
                if (thumb) {
                    var labelsContainer = this.axis.labelsContainer;
                    var pan = this.get("pan");
                    if (pan == "zoom") {
                        labelsContainer.children.push(thumb);
                    }
                    else if (pan == "none") {
                        labelsContainer.children.removeValue(thumb);
                    }
                }
            }
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_handleThumbDown", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (event) {
            this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
            var axis = this.axis;
            this._downStart = axis.get("start");
            this._downEnd = axis.get("end");
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_handleThumbUp", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_event) {
            this._thumbDownPoint = undefined;
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_handleThumbMove", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (event) {
            var downPoint = this._thumbDownPoint;
            if (downPoint) {
                var point = this.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
                var downStart = this._downStart;
                var downEnd = this._downEnd;
                var extra = this._getPan(point, downPoint) * Math.min(1, (downEnd - downStart)) / 2;
                this.axis.setAll({ start: downStart - extra, end: downEnd + extra });
            }
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_getPan", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_point1, _point2) {
            return 0;
        }
    });
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    Object.defineProperty(AxisRenderer.prototype, "positionToCoordinate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            if (this._inversed) {
                return (this._end - position) * this._axisLength;
            }
            else {
                return (position - this._start) * this._axisLength;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "updateTooltipBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_tooltip) { }
    });
    Object.defineProperty(AxisRenderer.prototype, "_updateSize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.markDirty();
            this._clear = true;
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "toAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var start = this._start || 0;
            var end = this._end || 1;
            position = position * (end - start);
            if (!this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRenderer.prototype, "fixPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            if (this.get("inversed")) {
                return 1 - position;
            }
            return position;
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_updateLC", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "toggleVisibility", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (sprite, position, minPosition, maxPosition) {
            var axis = this.axis;
            var start = axis.get("start", 0);
            var end = axis.get("end", 1);
            var updatedStart = start + (end - start) * (minPosition - 0.0001);
            var updatedEnd = start + (end - start) * (maxPosition + 0.0001);
            if (position < updatedStart || position > updatedEnd) {
                sprite.setPrivate("visible", false);
            }
            else {
                sprite.setPrivate("visible", true);
            }
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "_positionTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip, point) {
            var chart = this.chart;
            if (chart) {
                if (chart.inPlot(point)) {
                    tooltip.set("pointTo", this._display.toGlobal(point));
                }
                else {
                    tooltip.hide();
                }
            }
        }
    });
    Object.defineProperty(AxisRenderer.prototype, "processAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    Object.defineProperty(AxisRenderer, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRenderer"
    });
    Object.defineProperty(AxisRenderer, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([AxisRenderer.className])
    });
    return AxisRenderer;
}(Graphics));

//# sourceMappingURL=AxisRenderer.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js






/**
 * Used to render vertical axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
var AxisRendererY = /** @class */ (function (_super) {
    __extends(AxisRendererY, _super);
    function AxisRendererY() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_downY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Rectangle.new(_this._root, { height: p100, themeTags: ["axis", "y", "thumb"] })
        });
        return _this;
    }
    Object.defineProperty(AxisRendererY.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "y"]);
            if (this._settings.opposite) {
                this._settings.themeTags.push("opposite");
            }
            _super.prototype._afterNew.call(this);
            this.setPrivateRaw("letter", "Y");
            var gridTemplate = this.grid.template;
            gridTemplate.set("width", p100);
            gridTemplate.set("height", 0);
            gridTemplate.set("draw", function (display, graphics) {
                display.moveTo(0, 0);
                display.lineTo(graphics.width(), 0);
            });
            this.set("draw", function (display, renderer) {
                display.moveTo(0, 0);
                display.lineTo(0, renderer.height());
            });
        }
    });
    Object.defineProperty(AxisRendererY.prototype, "_getPan", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point1, point2) {
            return (point1.y - point2.y) / this.height();
        }
    });
    Object.defineProperty(AxisRendererY.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            var axis = this.axis;
            if (this.isDirty("inside")) {
                axis.markDirtySize();
            }
            var thumb = this.thumb;
            var opposite = "opposite";
            if (this.isDirty(opposite)) {
                var chart = this.chart;
                var axisChildren = axis.children;
                if (chart) {
                    if (this.get(opposite)) {
                        var children = chart.rightAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis, 0);
                        }
                        axis.addTag(opposite);
                        axisChildren.moveValue(this, 0);
                        thumb.set("centerX", 0);
                    }
                    else {
                        var children = chart.leftAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis);
                        }
                        axis.removeTag("opposite");
                        axisChildren.moveValue(this);
                        thumb.set("centerX", p100);
                    }
                    axis.markDirtySize();
                }
                axis.ghostLabel._applyThemes();
            }
            thumb.setPrivate("width", axis.labelsContainer.width());
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "processAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.processAxis.call(this);
            var axis = this.axis;
            if (axis.get("height") == null) {
                axis.set("height", p100);
            }
            var horizontalLayout = this._root.horizontalLayout;
            axis.set("layout", horizontalLayout);
            axis.labelsContainer.set("height", p100);
            axis.axisHeader.set("layout", horizontalLayout);
        }
    });
    Object.defineProperty(AxisRendererY.prototype, "_updatePositions", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var axis = this.axis;
            axis.gridContainer.set("y", axis.y() - relativeToValue(axis.get("centerY", 0), axis.height()));
            axis.bulletsContainer.set("x", this.x());
            var chart = axis.chart;
            if (chart) {
                var plotContainer = chart.plotContainer;
                var axisHeader = axis.axisHeader;
                var height = axis.get("marginTop", 0);
                if (axisHeader.children.length > 0) {
                    height = axis.axisHeader.height();
                    axis.set("marginTop", height);
                }
                else {
                    axisHeader.set("height", height);
                }
                axisHeader.setAll({ y: axis.y() - height, x: -1, width: plotContainer.width() + 2 });
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "axisLength", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.axis.innerHeight();
        }
    });
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    Object.defineProperty(AxisRendererY.prototype, "positionToPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            return { x: 0, y: this.positionToCoordinate(position) };
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateLabel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (label, position, endPosition, count) {
            if (label) {
                if (!isNumber(position)) {
                    position = 0;
                }
                var location_1 = 0.5;
                if (isNumber(count) && count > 1) {
                    location_1 = label.get("multiLocation", location_1);
                }
                else {
                    location_1 = label.get("location", location_1);
                }
                var opposite = this.get("opposite");
                var inside = label.get("inside", this.get("inside", false));
                if (opposite) {
                    label.set("x", 0);
                    if (inside) {
                        label.set("position", "absolute");
                    }
                    else {
                        label.set("position", "relative");
                    }
                }
                else {
                    if (inside) {
                        label.set("x", 0);
                        label.set("position", "absolute");
                    }
                    else {
                        label.set("x", undefined);
                        label.set("position", "relative");
                    }
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_1;
                }
                label.set("y", this.positionToCoordinate(position));
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateGrid", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (grid, position, endPosition) {
            if (grid) {
                if (!isNumber(position)) {
                    position = 0;
                }
                var location_2 = grid.get("location", 0.5);
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_2;
                }
                var y = this.positionToCoordinate(position);
                grid.set("y", y);
                this.toggleVisibility(grid, position, 0, 1);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateTick", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tick, position, endPosition, count) {
            if (tick) {
                if (!isNumber(position)) {
                    position = 0;
                }
                var location_3 = 0.5;
                if (isNumber(count) && count > 1) {
                    location_3 = tick.get("multiLocation", location_3);
                }
                else {
                    location_3 = tick.get("location", location_3);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_3;
                }
                tick.set("y", this.positionToCoordinate(position));
                var length_1 = tick.get("length", 0);
                var inside = tick.get("inside", this.get("inside", false));
                if (this.get("opposite")) {
                    tick.set("x", 0);
                    if (inside) {
                        length_1 *= -1;
                    }
                }
                else {
                    if (!inside) {
                        length_1 *= -1;
                    }
                }
                tick.set("draw", function (display) {
                    display.moveTo(0, 0);
                    display.lineTo(length_1, 0);
                });
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bullet, position, endPosition) {
            if (bullet) {
                var sprite = bullet.get("sprite");
                if (sprite) {
                    if (!isNumber(position)) {
                        position = 0;
                    }
                    var location_4 = bullet.get("location", 0.5);
                    if (isNumber(endPosition) && endPosition != position) {
                        position = position + (endPosition - position) * location_4;
                    }
                    sprite.set("y", this.positionToCoordinate(position));
                    this.toggleVisibility(sprite, position, 0, 1);
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateFill", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fill, position, endPosition) {
            if (fill) {
                if (!isNumber(position)) {
                    position = 0;
                }
                if (!isNumber(endPosition)) {
                    endPosition = 1;
                }
                var y0 = this.positionToCoordinate(position);
                var y1 = this.positionToCoordinate(endPosition);
                this.fillDrawMethod(fill, y0, y1);
            }
        }
    });
    Object.defineProperty(AxisRendererY.prototype, "fillDrawMethod", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fill, y0, y1) {
            var _this = this;
            fill.set("draw", function (display) {
                var _a;
                // using for holes, so can not be rectangle
                var w = _this.axis.gridContainer.width();
                var h = _this.height();
                if (y1 < y0) {
                    _a = __read([y0, y1], 2), y1 = _a[0], y0 = _a[1];
                }
                if (y0 > h || y1 < 0) {
                    return;
                }
                y0 = Math.max(0, y0);
                y1 = Math.min(h, y1);
                display.moveTo(0, y0);
                display.lineTo(w, y0);
                display.lineTo(w, y1);
                display.lineTo(0, y1);
                display.lineTo(0, y0);
            });
        }
    });
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    Object.defineProperty(AxisRendererY.prototype, "positionToCoordinate", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            if (!this._inversed) {
                return (this._end - position) * this._axisLength;
            }
            else {
                return (position - this._start) * this._axisLength;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "positionTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip, position) {
            this._positionTooltip(tooltip, { x: 0, y: this.positionToCoordinate(position) });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "updateTooltipBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip) {
            var inside = this.get("inside");
            var num = 100000;
            var global = this._display.toGlobal({ x: 0, y: 0 });
            var y = global.y;
            var x = 0;
            var h = this.axisLength();
            var w = num;
            var pointerOrientation = "right";
            if (this.get("opposite")) {
                if (inside) {
                    pointerOrientation = "right";
                    x = global.x - num;
                    w = num;
                }
                else {
                    pointerOrientation = "left";
                    x = global.x;
                    w = num;
                }
            }
            else {
                if (inside) {
                    pointerOrientation = "left";
                    x = global.x;
                    w = num;
                }
                else {
                    pointerOrientation = "right";
                    x = global.x - num;
                    w = num;
                }
            }
            var bounds = { left: x, right: x + w, top: y, bottom: y + h };
            var oldBounds = tooltip.get("bounds");
            if (!sameBounds(bounds, oldBounds)) {
                tooltip.set("bounds", bounds);
                tooltip.set("pointerOrientation", pointerOrientation);
            }
        }
    });
    Object.defineProperty(AxisRendererY.prototype, "_updateLC", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var axis = this.axis;
            var parent = axis.parent;
            if (parent) {
                var h = parent.innerHeight();
                this._lc = this.axisLength() / h;
                this._ls = axis.y() / h;
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "toAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var start = this._start || 0;
            var end = this._end || 1;
            position -= this._ls;
            position = position * (end - start) / this._lc;
            if (this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererY.prototype, "fixPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            if (!this.get("inversed")) {
                return 1 - position;
            }
            return position;
        }
    });
    Object.defineProperty(AxisRendererY, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererY"
    });
    Object.defineProperty(AxisRendererY, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererY.className])
    });
    return AxisRendererY;
}(AxisRenderer));

//# sourceMappingURL=AxisRendererY.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js


/**
 * A [[List]] that holds components data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
 */
var ListData = /** @class */ (function (_super) {
    __extends(ListData, _super);
    function ListData() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * An optional processor for data.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
         */
        Object.defineProperty(_this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(ListData.prototype, "incrementRef", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ListData.prototype, "decrementRef", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    Object.defineProperty(ListData.prototype, "_onPush", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
                //console.log(newValue)
            }
            _super.prototype._onPush.call(this, newValue);
        }
    });
    Object.defineProperty(ListData.prototype, "_onInsertIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
            }
            _super.prototype._onInsertIndex.call(this, index, newValue);
        }
    });
    Object.defineProperty(ListData.prototype, "_onSetIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, oldValue, newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
            }
            _super.prototype._onSetIndex.call(this, index, oldValue, newValue);
        }
    });
    return ListData;
}(List));

/**
 * @deprecated
 * @todo remove
 */
var JsonData = /** @class */ (function () {
    function JsonData(value) {
        Object.defineProperty(this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = value;
    }
    Object.defineProperty(JsonData.prototype, "incrementRef", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    Object.defineProperty(JsonData.prototype, "decrementRef", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () { }
    });
    return JsonData;
}());

//# sourceMappingURL=Data.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js






/**
 * A base element that holds data bit (data item) for any [[Component]].
 */
var DataItem = /** @class */ (function (_super) {
    __extends(DataItem, _super);
    function DataItem(component, dataContext, settings) {
        var _this = _super.call(this, settings) || this;
        /**
         * A data item's owener [[Component]].
         */
        Object.defineProperty(_this, "component", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A reference to actual item in source data this item is based on.
         */
        Object.defineProperty(_this, "dataContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @todo requires description
         */
        Object.defineProperty(_this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "open" values.
         */
        Object.defineProperty(_this, "open", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "close" values.
         */
        Object.defineProperty(_this, "close", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _this.dataContext = dataContext;
        _this.component = component;
        _this._settings.visible = true;
        _this._checkDirty();
        return _this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(DataItem.prototype, "markDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.component.markDirtyValues(this);
        }
    });
    Object.defineProperty(DataItem.prototype, "_startAnimation", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.component._root._addAnimation(this);
        }
    });
    Object.defineProperty(DataItem.prototype, "_animationTime", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.component._root.animationTime;
        }
    });
    Object.defineProperty(DataItem.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.component) {
                this.component.disposeDataItem(this);
            }
            _super.prototype._dispose.call(this);
        }
    });
    /**
     * Shows a data item that's currently hidden.
     */
    Object.defineProperty(DataItem.prototype, "show", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            this.setRaw("visible", true);
            if (this.component) {
                this.component.showDataItem(this, duration);
            }
        }
    });
    /**
     * Hides a data item that's currently visible.
     */
    Object.defineProperty(DataItem.prototype, "hide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            this.setRaw("visible", false);
            if (this.component) {
                this.component.hideDataItem(this, duration);
            }
        }
    });
    Object.defineProperty(DataItem.prototype, "isHidden", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return !this.get("visible");
        }
    });
    return DataItem;
}(Settings));

/**
 * A base class for elements that make use of data.
 */
var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    function Component() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListData()
        });
        Object.defineProperty(_this, "_dataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_mainDataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this._dataItems
        });
        Object.defineProperty(_this, "valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["id"]
        });
        Object.defineProperty(_this, "_valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_valueFieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_fieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_valuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_dataChanged", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_dataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Indicates if the component has already been initialized.
         */
        Object.defineProperty(_this, "inited", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(Component.prototype, "data", {
        /**
         * @return  Data
         */
        get: function () {
            return this._data;
        },
        /**
         * Component's data.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
         */
        set: function (data) {
            data.incrementRef();
            this._data.decrementRef();
            this._data = data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._dispose.call(this);
            this._data.decrementRef();
        }
    });
    Object.defineProperty(Component.prototype, "_onDataClear", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Component.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._afterNew.call(this);
            this._data.incrementRef();
            this._updateFields();
            this._disposers.push(this.data.events.onAll(function (change) {
                var dataItems = _this._mainDataItems;
                _this.markDirtyValues();
                _this._markDirtyGroup();
                _this._dataChanged = true;
                if (change.type === "clear") {
                    each(dataItems, function (dataItem) {
                        dataItem.dispose();
                    });
                    dataItems.length = 0;
                    _this._onDataClear();
                }
                else if (change.type === "push") {
                    var dataItem = new DataItem(_this, change.newValue, _this._makeDataItem(change.newValue));
                    dataItems.push(dataItem);
                    _this.processDataItem(dataItem);
                }
                else if (change.type === "setIndex") {
                    var dataItem_1 = dataItems[change.index];
                    var properties_1 = _this._makeDataItem(change.newValue);
                    keys(properties_1).forEach(function (key) {
                        dataItem_1.animate({
                            key: key,
                            to: properties_1[key],
                            duration: _this.get("interpolationDuration", 0),
                            easing: _this.get("interpolationEasing"),
                        });
                    });
                    dataItem_1.dataContext = change.newValue;
                }
                else if (change.type === "insertIndex") {
                    var dataItem = new DataItem(_this, change.newValue, _this._makeDataItem(change.newValue));
                    dataItems.splice(change.index, 0, dataItem);
                    _this.processDataItem(dataItem);
                }
                else if (change.type === "removeIndex") {
                    var dataItem = dataItems[change.index];
                    dataItem.dispose();
                    dataItems.splice(change.index, 1);
                }
                else if (change.type === "moveIndex") {
                    var dataItem = dataItems[change.oldIndex];
                    dataItems.splice(change.oldIndex, 1);
                    dataItems.splice(change.newIndex, 0, dataItem);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
                _this._afterDataChange();
            }));
        }
    });
    Object.defineProperty(Component.prototype, "_updateFields", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this.valueFields) {
                this._valueFields = [];
                this._valueFieldsF = {};
                each(this.valueFields, function (key) {
                    var field = _this.get((key + "Field"));
                    if (field) {
                        _this._valueFields.push(key);
                        _this._valueFieldsF[key] = { fieldKey: key + "Field", workingKey: key + "Working" };
                    }
                });
            }
            if (this.fields) {
                this._fields = [];
                this._fieldsF = {};
                each(this.fields, function (key) {
                    var field = _this.get((key + "Field"));
                    if (field) {
                        _this._fields.push(key);
                        _this._fieldsF[key] = key + "Field";
                    }
                });
            }
        }
    });
    Object.defineProperty(Component.prototype, "dataItems", {
        /**
         * A list of component's data items.
         *
         * @return  Data items
         */
        get: function () {
            return this._dataItems;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "processDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) { }
    });
    Object.defineProperty(Component.prototype, "_makeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (data) {
            var _this = this;
            //const output: this["_dataItemSettings"] = {};
            var output = {}; // temporary to solve error
            if (this._valueFields) {
                each(this._valueFields, function (key) {
                    var field = _this.get((_this._valueFieldsF[key].fieldKey));
                    output[key] = data[field];
                    output[_this._valueFieldsF[key].workingKey] = output[key];
                });
            }
            if (this._fields) {
                each(this._fields, function (key) {
                    var field = _this.get((_this._fieldsF[key]));
                    output[key] = data[field];
                });
            }
            return output;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Component.prototype, "makeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (data) {
            var dataItem = new DataItem(this, undefined, data);
            this.processDataItem(dataItem);
            return dataItem;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Component.prototype, "pushDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (data) {
            var dataItem = this.makeDataItem(data);
            this._mainDataItems.push(dataItem);
            return dataItem;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Component.prototype, "disposeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) { }
    });
    /**
     * Shows component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    Object.defineProperty(Component.prototype, "showDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, _duration) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    dataItem.set("visible", true);
                    return [2 /*return*/];
                });
            });
        }
    });
    /**
     * Hides component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    Object.defineProperty(Component.prototype, "hideDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, _duration) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    dataItem.set("visible", false);
                    return [2 /*return*/];
                });
            });
        }
    });
    Object.defineProperty(Component.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._valuesDirty = false;
        }
    });
    Object.defineProperty(Component.prototype, "_afterDataChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Component.prototype, "_afterChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterChanged.call(this);
            if (this._dataChanged) {
                var type = "datavalidated";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
                this._dataChanged = false;
            }
            this.inited = true;
        }
    });
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */
    Object.defineProperty(Component.prototype, "markDirtyValues", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
            this.markDirty();
            this._valuesDirty = true;
        }
    });
    Object.defineProperty(Component.prototype, "_markDirtyGroup", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._dataGrouped = false;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Component.prototype, "markDirtySize", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._sizeDirty = true;
            this.markDirty();
        }
    });
    Object.defineProperty(Component, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Component"
    });
    Object.defineProperty(Component, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Component.className])
    });
    return Component;
}(Container));

//# sourceMappingURL=Component.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js










/**
 * A base class for all axes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info
 */
var Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    function Axis() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_isPanning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A [[Container]] that holds all the axis label elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "labelsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.children.push(Container.new(_this._root, {}))
        });
        /**
         * A [[Container]] that holds all the axis grid and fill elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { width: p100, height: p100 })
        });
        /**
         * A [[Container]] that holds axis grid elements which goes above the series.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { width: p100, height: p100 })
        });
        /**
         * A [[Container]] that holds all the axis bullet elements.
         *
         * @default new Container
         */
        Object.defineProperty(_this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.children.push(Container.new(_this._root, { isMeasured: false, width: p100, height: p100, position: "absolute" }))
        });
        /**
         * A referenece to the the chart the axis belongs to.
         */
        Object.defineProperty(_this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_rangesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_panStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_panEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_sAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_eAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of axis ranges.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         * @default new List()
         */
        Object.defineProperty(_this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new List()
        });
        Object.defineProperty(_this, "_seriesAxisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * A control label that is invisible but is used to keep width the width of
         * the axis constant.
         */
        Object.defineProperty(_this, "ghostLabel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_cursorPosition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(_this, "_snapToSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_seriesValuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A container above the axis that can be used to add additional stuff into
         * it. For example a legend, label, or an icon.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default new Container
         */
        Object.defineProperty(_this, "axisHeader", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.children.push(Container.new(_this._root, {
                themeTags: ["axis", "header"],
                position: "absolute",
                background: Rectangle.new(_this._root, {
                    themeTags: ["header", "background"],
                    fill: _this._root.interfaceColors.get("background")
                })
            }))
        });
        return _this;
    }
    Object.defineProperty(Axis.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            // these could be in other parents, so disposing just in case
            this.gridContainer.dispose();
            this.topGridContainer.dispose();
            this.bulletsContainer.dispose();
            this.labelsContainer.dispose();
            this.axisHeader.dispose();
            _super.prototype._dispose.call(this);
        }
    });
    Object.defineProperty(Axis.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._afterNew.call(this);
            this.setPrivate("updateScrollbar", true);
            this._disposers.push(this.axisRanges.events.onAll(function (change) {
                if (change.type === "clear") {
                    each(change.oldValues, function (dataItem) {
                        _this.disposeDataItem(dataItem);
                    });
                }
                else if (change.type === "push") {
                    _this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "setIndex") {
                    _this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "insertIndex") {
                    _this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "removeIndex") {
                    _this.disposeDataItem(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    _this._processAxisRange(change.value, ["range"]);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
            }));
            var renderer = this.get("renderer");
            if (renderer) {
                renderer.axis = this;
                renderer.processAxis();
            }
            this.children.push(renderer);
            this.ghostLabel = renderer.makeLabel(new DataItem(this, undefined, {}), []);
            this.ghostLabel.set("opacity", 0);
        }
    });
    /**
     * Zooms the axis to relative locations.
     *
     * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
     *
     * @param   start     Relative start
     * @param   end       Relative end
     * @param   duration  Duration of the zoom animation in milliseconds
     * @return            Zoom animation
     */
    Object.defineProperty(Axis.prototype, "zoom", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (start, end, duration) {
            var _a;
            if (this.get("start") !== start || this.get("end") != end) {
                var sAnimation = this._sAnimation;
                var eAnimation = this._eAnimation;
                var maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
                if (start < -maxDeviation) {
                    start = -maxDeviation;
                }
                if (end > 1 + maxDeviation) {
                    end = 1 + maxDeviation;
                }
                if (start > end) {
                    _a = __read([end, start], 2), start = _a[0], end = _a[1];
                }
                if (!isNumber(duration)) {
                    duration = this.get("interpolationDuration", 0);
                }
                var priority = "end";
                var maxZoomFactor = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100));
                if (end === 1 && start !== 0) {
                    if (start < this.get("start")) {
                        priority = "start";
                    }
                    else {
                        priority = "end";
                    }
                }
                if (start === 0 && end !== 1) {
                    if (end > this.get("end")) {
                        priority = "end";
                    }
                    else {
                        priority = "start";
                    }
                }
                var minZoomCount = this.get("minZoomCount");
                var maxZoomCount = this.get("maxZoomCount");
                if (isNumber(minZoomCount)) {
                    maxZoomFactor = maxZoomFactor / minZoomCount;
                }
                var minZoomFactor = 1;
                if (isNumber(maxZoomCount)) {
                    minZoomFactor = maxZoomFactor / maxZoomCount;
                }
                // most likely we are dragging left scrollbar grip here, so we tend to modify end
                if (priority === "start") {
                    if (maxZoomCount > 0) {
                        // add to the end
                        if (1 / (end - start) < minZoomFactor) {
                            end = start + 1 / minZoomFactor;
                        }
                    }
                    // add to the end
                    if (1 / (end - start) > maxZoomFactor) {
                        end = start + 1 / maxZoomFactor;
                    }
                    //unless end is > 0
                    if (end > 1 && end - start < 1 / maxZoomFactor) {
                        //end = 1;
                        start = end - 1 / maxZoomFactor;
                    }
                }
                // most likely we are dragging right, so we modify left
                else {
                    if (maxZoomCount > 0) {
                        // add to the end
                        if (1 / (end - start) < minZoomFactor) {
                            start = end - 1 / minZoomFactor;
                        }
                    }
                    // remove from start
                    if (1 / (end - start) > maxZoomFactor) {
                        start = end - 1 / maxZoomFactor;
                    }
                    if (start < 0 && end - start < 1 / maxZoomFactor) {
                        //start = 0;
                        end = start + 1 / maxZoomFactor;
                    }
                }
                if (1 / (end - start) > maxZoomFactor) {
                    end = start + 1 / maxZoomFactor;
                }
                if (1 / (end - start) > maxZoomFactor) {
                    start = end - 1 / maxZoomFactor;
                }
                if (((sAnimation && sAnimation.playing && sAnimation.to == start) || this.get("start") == start) && ((eAnimation && eAnimation.playing && eAnimation.to == end) || this.get("end") == end)) {
                    return;
                }
                if (duration > 0) {
                    var easing = this.get("interpolationEasing");
                    var sAnimation_1 = this.animate({ key: "start", to: start, duration: duration, easing: easing });
                    var eAnimation_1 = this.animate({ key: "end", to: end, duration: duration, easing: easing });
                    this._sAnimation = sAnimation_1;
                    this._eAnimation = eAnimation_1;
                    if (sAnimation_1) {
                        return sAnimation_1;
                    }
                    else if (eAnimation_1) {
                        return eAnimation_1;
                    }
                }
                else {
                    this.set("start", start);
                    this.set("end", end);
                }
            }
        }
    });
    Object.defineProperty(Axis.prototype, "series", {
        /**
         * A list of series using this axis.
         *
         * @return Series
         */
        get: function () {
            return this._series;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "_processAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, themeTags) {
            dataItem.setRaw("isRange", true);
            this._createAssets(dataItem, themeTags);
            this._rangesDirty = true;
            this._prepareDataItem(dataItem);
            var above = dataItem.get("above");
            var container = this.topGridContainer;
            var grid = dataItem.get("grid");
            if (above && grid) {
                container.children.moveValue(grid);
            }
            var fill = dataItem.get("axisFill");
            if (above && fill) {
                container.children.moveValue(fill);
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_prepareDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem, _index) { }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "markDirtyExtremes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "markDirtySelectionExtremes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Axis.prototype, "_calculateTotals", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(Axis.prototype, "_updateAxisRanges", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this.axisRanges.each(function (axisRange) {
                _this._prepareDataItem(axisRange);
            });
            each(this._seriesAxisRanges, function (axisRange) {
                _this._prepareDataItem(axisRange);
            });
        }
    });
    Object.defineProperty(Axis.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._prepareChildren.call(this);
            if (this.get("fixAxisSize")) {
                this.ghostLabel.set("visible", true);
            }
            else {
                this.ghostLabel.set("visible", false);
            }
            if (this.isDirty("start") || this.isDirty("end")) {
                this.chart._updateCursor();
                var start = this.get("start", 0);
                var end = this.get("end", 1);
                var maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
                if (start < -maxDeviation) {
                    var delta = start + maxDeviation;
                    start = -maxDeviation;
                    this.setRaw("start", start);
                    if (this.isDirty("end")) {
                        this.setRaw("end", end - delta);
                    }
                }
                if (end > 1 + maxDeviation) {
                    var delta = end - 1 - maxDeviation;
                    end = 1 + maxDeviation;
                    this.setRaw("end", end);
                    if (this.isDirty("start")) {
                        this.setRaw("start", start - delta);
                    }
                }
            }
            var renderer = this.get("renderer");
            renderer._start = this.get("start");
            renderer._end = this.get("end");
            renderer._inversed = renderer.get("inversed", false);
            renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);
            renderer._updateLC();
            if (this.isDirty("tooltip")) {
                var tooltip = this.get("tooltip");
                if (tooltip) {
                    var rendererTags = renderer.get("themeTags");
                    tooltip.addTag("axis");
                    tooltip.addTag(this.className.toLowerCase());
                    tooltip._applyThemes();
                    if (rendererTags) {
                        tooltip.set("themeTags", mergeTags(tooltip.get("themeTags"), rendererTags));
                        tooltip.label._applyThemes();
                    }
                }
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_updateTooltipBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltip = this.get("tooltip");
            if (tooltip) {
                this.get("renderer").updateTooltipBounds(tooltip);
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_updateBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._updateBounds.call(this);
            this._updateTooltipBounds();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "processChart", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (chart) {
            var _this = this;
            this.chart = chart;
            var renderer = this.get("renderer");
            renderer.chart = chart;
            chart.gridContainer.children.push(this.gridContainer);
            chart.topGridContainer.children.push(this.topGridContainer);
            chart.axisHeadersContainer.children.push(this.axisHeader);
            this.on("start", function () {
                chart._handleAxisSelection(_this);
            });
            this.on("end", function () {
                chart._handleAxisSelection(_this);
            });
            chart.plotContainer.onPrivate("width", function () {
                _this.markDirtySize();
            });
            chart.plotContainer.onPrivate("height", function () {
                _this.markDirtySize();
            });
            chart.processAxis(this);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "hideDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            this._toggleDataItem(dataItem, false);
            return _super.prototype.hideDataItem.call(this, dataItem);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "showDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            this._toggleDataItem(dataItem, true);
            return _super.prototype.showDataItem.call(this, dataItem);
        }
    });
    Object.defineProperty(Axis.prototype, "_toggleDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, visible) {
            var label = dataItem.get("label");
            if (label) {
                label.setPrivate("visible", visible);
            }
            var grid = dataItem.get("grid");
            if (grid) {
                grid.setPrivate("visible", visible);
            }
            var tick = dataItem.get("tick");
            if (tick) {
                tick.setPrivate("visible", visible);
            }
            var axisFill = dataItem.get("axisFill");
            if (axisFill) {
                axisFill.setPrivate("visible", visible);
            }
            var bullet = dataItem.get("bullet");
            if (bullet) {
                var sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", visible);
                }
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_createAssets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, tags) {
            var renderer = this.get("renderer");
            if (!dataItem.get("label")) {
                renderer.makeLabel(dataItem, tags);
            }
            if (!dataItem.get("grid")) {
                renderer.makeGrid(dataItem, tags);
            }
            if (!dataItem.get("tick")) {
                renderer.makeTick(dataItem, tags);
            }
            if (!dataItem.get("axisFill")) {
                renderer.makeAxisFill(dataItem, tags);
            }
            this._processBullet(dataItem);
        }
    });
    Object.defineProperty(Axis.prototype, "_processBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var bullet = dataItem.get("bullet");
            var axisBullet = this.get("bullet");
            if (!bullet && axisBullet && !dataItem.get("isRange")) {
                bullet = axisBullet(this._root, this, dataItem);
            }
            if (bullet) {
                bullet.axis = this;
                var sprite = bullet.get("sprite");
                if (sprite) {
                    sprite._setDataItem(dataItem);
                    dataItem.setRaw("bullet", bullet);
                    if (!sprite.parent) {
                        this.bulletsContainer.children.push(sprite);
                    }
                }
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_afterChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterChanged.call(this);
            var chart = this.chart;
            if (chart) {
                chart._updateChartLayout();
                chart.axisHeadersContainer.markDirtySize();
            }
            this.get("renderer")._updatePositions();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "disposeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            _super.prototype.disposeDataItem.call(this, dataItem);
            var renderer = this.get("renderer");
            var label = dataItem.get("label");
            if (label) {
                renderer.labels.removeValue(label);
                label.dispose();
            }
            var tick = dataItem.get("tick");
            if (tick) {
                renderer.ticks.removeValue(tick);
                tick.dispose();
            }
            var grid = dataItem.get("grid");
            if (grid) {
                renderer.grid.removeValue(grid);
                grid.dispose();
            }
            var axisFill = dataItem.get("axisFill");
            if (axisFill) {
                renderer.axisFills.removeValue(axisFill);
                axisFill.dispose();
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_updateGhost", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var ghostLabel = this.ghostLabel;
            if (!ghostLabel.isHidden()) {
                var bounds = ghostLabel.localBounds();
                var gWidth_1 = bounds.right - bounds.left;
                each(this.dataItems, function (dataItem) {
                    var label = dataItem.get("label");
                    if (label && !label.isHidden()) {
                        var bounds_1 = label.localBounds();
                        var w = bounds_1.right - bounds_1.left;
                        if (w > gWidth_1) {
                            ghostLabel.set("text", label.text._getText());
                        }
                    }
                });
            }
            var start = this.get("start", 0);
            var end = this.get("end", 1);
            this.get("renderer").updateLabel(ghostLabel, start + (end - start) * 0.5);
            ghostLabel.setPrivate("visible", true);
        }
    });
    Object.defineProperty(Axis.prototype, "_handleCursorPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position, snapToSeries) {
            var renderer = this.get("renderer");
            position = renderer.toAxisPosition(position);
            this._cursorPosition = position;
            this._snapToSeries = snapToSeries;
            this.updateTooltip();
        }
    });
    /**
     * Can be called when axis zoom changes and you need to update tooltip
     * position.
     */
    Object.defineProperty(Axis.prototype, "updateTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var snapToSeries = this._snapToSeries;
            var position = this._cursorPosition;
            var tooltip = this.get("tooltip");
            var renderer = this.get("renderer");
            if (isNumber(position)) {
                each(this.series, function (series) {
                    if (series.get("baseAxis") === _this) {
                        var dataItem = _this.getSeriesItem(series, position);
                        series.setRaw("tooltipDataItem", dataItem);
                        if (snapToSeries && snapToSeries.indexOf(series) != -1) {
                            series.updateLegendMarker(dataItem);
                            series.updateLegendValue(dataItem);
                        }
                        else {
                            series.showDataItemTooltip(dataItem);
                        }
                    }
                });
                if (tooltip) {
                    renderer.updateTooltipBounds(tooltip);
                    if (this.get("snapTooltip")) {
                        position = this.roundAxisPosition(position, this.get("tooltipLocation", 0.5));
                    }
                    if (!Type_isNaN(position)) {
                        this._updateTooltipText(tooltip, position);
                        renderer.positionTooltip(tooltip, position);
                        if (position < this.get("start") || position > this.get("end")) {
                            tooltip.hide(0);
                        }
                        else {
                            tooltip.show(0);
                        }
                    }
                    else {
                        tooltip.hide(0);
                    }
                }
            }
        }
    });
    Object.defineProperty(Axis.prototype, "_updateTooltipText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip, position) {
            tooltip.label.set("text", this.getTooltipText(position));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "roundAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position, _location) {
            return position;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "handleCursorShow", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.show();
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "handleCursorHide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.hide();
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "processSeriesDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem, _fields) {
        }
    });
    Object.defineProperty(Axis.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._sizeDirty = false;
            this._rangesDirty = false;
        }
    });
    /**
     * Converts pixel coordinate to a relative position on axis.
     *
     * @param   coordinate  Coordinate
     * @return              Relative position
     */
    Object.defineProperty(Axis.prototype, "coordinateToPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (coordinate) {
            var renderer = this.get("renderer");
            return renderer.toAxisPosition(coordinate / renderer.axisLength());
        }
    });
    /**
     * Converts relative position of the plot area to relative position of the
     * axis with zoom taken into account.
     *
     * @param position Position
     * @return Relative position
     */
    Object.defineProperty(Axis.prototype, "toAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            return this.get("renderer").toAxisPosition(position);
        }
    });
    /**
     * Adjusts position with inversed taken into account.
     *
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "fixPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            return this.get("renderer").fixPosition(position);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "shouldGap", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem, _nextItem, _autoGapCount, _fieldName) {
            return false;
        }
    });
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    Object.defineProperty(Axis.prototype, "createAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axisDataItem) {
            return this.axisRanges.push(axisDataItem);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Axis.prototype, "_groupSeriesData", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_series) { }
    });
    Object.defineProperty(Axis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Axis"
    });
    Object.defineProperty(Axis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Component.classNames.concat([Axis.className])
    });
    return Axis;
}(Component));

//# sourceMappingURL=Axis.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js







/**
 * Creates a category axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info
 * @important
 */
var CategoryAxis = /** @class */ (function (_super) {
    __extends(CategoryAxis, _super);
    function CategoryAxis() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_frequency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_itemMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        return _this;
    }
    Object.defineProperty(CategoryAxis.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            this.fields.push("category");
            this.setPrivateRaw("name", "category");
            this.addTag("category");
            _super.prototype._afterNew.call(this);
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._prepareChildren.call(this);
            var len = this.dataItems.length;
            var i = 0;
            if (this._valuesDirty) {
                each(this.dataItems, function (dataItem) {
                    dataItem.setRaw("index", i);
                    _this._itemMap[dataItem.get("category")] = dataItem;
                    i++;
                });
                this.setPrivateRaw("maxZoomFactor", len);
            }
            this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * len), 0));
            this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * len), len));
            if (this._sizeDirty || this._valuesDirty || (this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height"))) {
                if (this.dataItems.length > 0) {
                    this._handleRangeChange();
                    this._prepareAxisItems();
                    this._updateAxisRanges();
                }
            }
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "_handleRangeChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            each(this.series, function (series) {
                var startCategory = _this.dataItems[_this.startIndex()].get("category");
                var endCategory = _this.dataItems[_this.endIndex() - 1].get("category");
                var baseAxis = series.get("baseAxis");
                var xAxis = series.get("xAxis");
                var yAxis = series.get("yAxis");
                if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {
                    series._markDirtyAxes();
                }
                else if (baseAxis === _this) {
                    var key = void 0;
                    var openKey = void 0;
                    var otherAxis = yAxis;
                    if (xAxis === baseAxis) {
                        if (series.get("categoryXField")) {
                            key = "categoryX";
                        }
                        if (series.get("openCategoryXField")) {
                            openKey = "openCategoryX";
                        }
                    }
                    else if (yAxis === baseAxis) {
                        if (series.get("categoryYField")) {
                            key = "categoryY";
                        }
                        if (series.get("openCategoryYField")) {
                            openKey = "openCategoryY";
                        }
                        otherAxis = xAxis;
                    }
                    if (otherAxis.className == "ValueAxis") {
                        if (key || openKey) {
                            var startDataItem = void 0;
                            var endDataItem = void 0;
                            for (var i = 0, len = series.dataItems.length; i < len; i++) {
                                var dataItem = series.dataItems[i];
                                if (key) {
                                    if (dataItem.get(key) === startCategory) {
                                        startDataItem = dataItem;
                                        break;
                                    }
                                }
                                if (openKey) {
                                    if (dataItem.get(openKey) === startCategory) {
                                        startDataItem = dataItem;
                                        break;
                                    }
                                }
                            }
                            for (var i = series.dataItems.length - 1; i >= 0; i--) {
                                var dataItem = series.dataItems[i];
                                if (key) {
                                    if (dataItem.get(key) === endCategory) {
                                        endDataItem = dataItem;
                                        break;
                                    }
                                }
                                if (openKey) {
                                    if (dataItem.get(openKey) === endCategory) {
                                        endDataItem = dataItem;
                                        break;
                                    }
                                }
                            }
                            if (startDataItem) {
                                series.setPrivate("startIndex", series.dataItems.indexOf(startDataItem));
                            }
                            if (endDataItem) {
                                series.setPrivate("endIndex", series.dataItems.indexOf(endDataItem) + 1);
                            }
                        }
                    }
                    series._markDirtyAxes(); // must be outside
                }
            });
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "_prepareAxisItems", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var renderer = this.get("renderer");
            var len = this.dataItems.length;
            var startIndex = this.startIndex();
            if (startIndex > 0) {
                startIndex--;
            }
            var endIndex = this.endIndex();
            if (endIndex < len) {
                endIndex++;
            }
            var maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
            var frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));
            startIndex = Math.floor(startIndex / frequency) * frequency;
            this._frequency = frequency;
            for (var j = 0; j < len; j++) {
                this.dataItems[j].hide();
            }
            var f = this.dataItems[startIndex].get("index", 0);
            for (var i = startIndex; i < endIndex; i = i + frequency) {
                var dataItem = this.dataItems[i];
                this._createAssets(dataItem, []);
                if (dataItem.isHidden()) {
                    dataItem.show();
                }
                this._prepareDataItem(dataItem, f, frequency);
                f++;
            }
            this._updateGhost();
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "_prepareDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, fillIndex, count) {
            var renderer = this.get("renderer");
            var categoryLocation = dataItem.get("categoryLocation", 0);
            var endCategoryLocation = dataItem.get("endCategoryLocation", 1);
            var index = dataItem.get("index");
            if (!isNumber(index)) {
                index = this.categoryToIndex(dataItem.get("category"));
            }
            var position = this.indexToPosition(index, categoryLocation);
            var endCategory = dataItem.get("endCategory");
            var endIndex;
            if (endCategory) {
                endIndex = this.categoryToIndex(endCategory);
                if (!isNumber(endIndex)) {
                    endIndex = index;
                }
            }
            else {
                endIndex = index;
            }
            var endPosition = this.indexToPosition(endIndex, endCategoryLocation);
            var fillEndIndex;
            var fillEndPosition;
            if (dataItem.get("isRange")) {
                fillEndIndex = endIndex;
            }
            else {
                fillEndIndex = index + this._frequency - 1;
            }
            fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);
            renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
            renderer.updateGrid(dataItem.get("grid"), position, endPosition);
            renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
            renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
            this._processBullet(dataItem);
            renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
            var fillRule = this.get("fillRule");
            if (fillRule) {
                fillRule(dataItem, fillIndex);
            }
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "startIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var len = this.dataItems.length;
            return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), len - 1);
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "endIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var len = this.dataItems.length;
            return Math.max(1, Math.min(this.getPrivate("endIndex", len), len));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "baseValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "basePosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return 0;
        }
    });
    /**
     * Returns X coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         X coordinate
     */
    Object.defineProperty(CategoryAxis.prototype, "getX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var axisDataItem = this._itemMap[value];
            if (axisDataItem) {
                return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
            }
            return NaN;
        }
    });
    /**
     * Returns Y coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         Y coordinate
     */
    Object.defineProperty(CategoryAxis.prototype, "getY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var axisDataItem = this._itemMap[value];
            if (axisDataItem) {
                return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
            }
            return NaN;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "getDataItemPositionX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, cellLocation, _axisLocation) {
            var category = dataItem.get(field);
            var axisDataItem = this._itemMap[category];
            if (axisDataItem) {
                return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
            }
            return NaN;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "getDataItemCoordinateX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, cellLocation, _axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "getDataItemPositionY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, cellLocation, _axisLocation) {
            var category = dataItem.get(field);
            var axisDataItem = this._itemMap[category];
            if (axisDataItem) {
                return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
            }
            return NaN;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "getDataItemCoordinateY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, cellLocation, _axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));
        }
    });
    /**
     * Converts category index to a relative position.
     *
     * `location` indicates relative position within category: 0 - start, 1 - end.
     *
     * If not set, will use middle (0.5) of the category.
     *
     * @param   index     Index
     * @param   location  Location
     * @return            Index
     */
    Object.defineProperty(CategoryAxis.prototype, "indexToPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (index, location) {
            if (!isNumber(location)) {
                location = 0.5;
            }
            var len = this.dataItems.length;
            var startLocation = this.get("startLocation", 0);
            var endLocation = this.get("endLocation", 1);
            len -= startLocation;
            len -= (1 - endLocation);
            var position = (index + location - startLocation) / len;
            var dataItem = this.dataItems[index];
            if (dataItem) {
                position += dataItem.get("deltaPosition", 0);
            }
            return position;
        }
    });
    /**
     * Returns an index of a category.
     *
     * @param   category  Category to look up
     * @return            Index
     */
    Object.defineProperty(CategoryAxis.prototype, "categoryToIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (category) {
            var dataItem = this._itemMap[category];
            if (dataItem) {
                return dataItem.get("index");
            }
            return NaN;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "dataItemToPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            return this.indexToPosition(dataItem.get("index"));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(CategoryAxis.prototype, "roundAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position, location) {
            return this.indexToPosition(this.axisPositionToIndex(position), location);
        }
    });
    /**
     * Returns an index of the category that corresponds to specific pixel
     * position within axis.
     *
     * @param position  Position (px)
     * @return Category index
     */
    Object.defineProperty(CategoryAxis.prototype, "axisPositionToIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var len = this.dataItems.length;
            return fitToRange(Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);
        }
    });
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    Object.defineProperty(CategoryAxis.prototype, "getTooltipText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            //@todo number formatter + tag
            var dataItem = this.dataItems[this.axisPositionToIndex(position)];
            if (dataItem) {
                var label = dataItem.get("label");
                if (label) {
                    return populateString(label, this.get("tooltipText", ""));
                }
            }
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "_updateTooltipText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip, position) {
            tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);
            tooltip.label.text.markDirtyText();
        }
    });
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    Object.defineProperty(CategoryAxis.prototype, "getSeriesItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series, position) {
            if (this.dataItems.length > 0) {
                var fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
                var index = this.axisPositionToIndex(position);
                // try simple first
                var seriesDataItem = series.dataItems[index];
                var axisDataItem = this.dataItems[index];
                var category = axisDataItem.get("category");
                if (seriesDataItem && axisDataItem) {
                    if (seriesDataItem.get(fieldName) === category) {
                        return seriesDataItem;
                    }
                }
                // if not found, try looking
                for (var i = 0, len = series.dataItems.length; i < len; i++) {
                    var dataItem = series.dataItems[i];
                    if (dataItem.get(fieldName) === category) {
                        return dataItem;
                    }
                }
            }
        }
    });
    /**
     * Zooms the axis to specific `start` and `end` indexes.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start index
     * @param  end       End index
     * @param  duration  Duration in milliseconds
     */
    Object.defineProperty(CategoryAxis.prototype, "zoomToIndexes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (start, end, duration) {
            var len = this.dataItems.length;
            this.zoom(start / len, end / len, duration);
        }
    });
    Object.defineProperty(CategoryAxis.prototype, "zoomToCategories", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (startCategory, endCategory, duration) {
            this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);
        }
    });
    Object.defineProperty(CategoryAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CategoryAxis"
    });
    Object.defineProperty(CategoryAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Axis.classNames.concat([CategoryAxis.className])
    });
    return CategoryAxis;
}(Axis));

//# sourceMappingURL=CategoryAxis.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js








/**
 * Creates a value axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info
 * @important
 */
var ValueAxis = /** @class */ (function (_super) {
    __extends(ValueAxis, _super);
    function ValueAxis() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_dirtyExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_dirtySelectionExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_deltaMinMax", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_minReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_maxReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_baseValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_syncDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "markDirtyExtremes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._dirtyExtremes = true;
            this.markDirty();
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "markDirtySelectionExtremes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._dirtySelectionExtremes = true;
            this.markDirty();
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            this.setPrivateRaw("name", "value");
            this.addTag("value");
            _super.prototype._afterNew.call(this);
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._prepareChildren.call(this);
            if (this.isDirty("syncWithAxis")) {
                var previousValue = this._prevSettings.syncWithAxis;
                if (previousValue) {
                    if (this._syncDp) {
                        this._syncDp.dispose();
                    }
                }
                var syncWithAxis = this.get("syncWithAxis");
                if (syncWithAxis) {
                    this._syncDp = new MultiDisposer([
                        syncWithAxis.onPrivate("selectionMinFinal", function () {
                            _this._dirtySelectionExtremes = true;
                        }),
                        syncWithAxis.onPrivate("selectionMaxFinal", function () {
                            _this._dirtySelectionExtremes = true;
                        })
                    ]);
                }
            }
            //if (this._dirtyExtremes || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision")) {
            if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) {
                this._getMinMax();
                this._dirtyExtremes = false;
            }
            if (this._dirtySelectionExtremes && !this._isPanning) {
                this._getSelectionMinMax();
                this._dirtySelectionExtremes = false;
            }
            this._groupData();
            if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) {
                this._handleRangeChange();
                this._prepareAxisItems();
                this._updateAxisRanges();
            }
            this._baseValue = this.baseValue();
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_groupData", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_formatText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var numberFormat = this.get("numberFormat");
            var formatter = this.getNumberFormatter();
            var text = "";
            if (numberFormat) {
                text = formatter.format(value, numberFormat);
            }
            else {
                text = formatter.format(value, undefined, this.getPrivate("stepDecimalPlaces"));
            }
            return text;
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_prepareAxisItems", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var min = this.getPrivate("min");
            var max = this.getPrivate("max");
            if (isNumber(min) && isNumber(max)) {
                var logarithmic = this.get("logarithmic");
                var step = this.getPrivate("step");
                var selectionMin = this.getPrivate("selectionMin");
                var selectionMax = this.getPrivate("selectionMax") + step;
                var value = selectionMin - step;
                var i = 0;
                if (logarithmic) {
                    value = selectionMin;
                }
                while (value < selectionMax) {
                    var dataItem = void 0;
                    if (this.dataItems.length < i + 1) {
                        dataItem = new DataItem(this, undefined, {});
                        this._dataItems.push(dataItem);
                        this.processDataItem(dataItem);
                    }
                    else {
                        dataItem = this.dataItems[i];
                    }
                    this._createAssets(dataItem, []);
                    if (dataItem.isHidden()) {
                        dataItem.show();
                    }
                    dataItem.setRaw("value", value);
                    var label = dataItem.get("label");
                    if (label) {
                        label.set("text", this._formatText(value));
                    }
                    this._prepareDataItem(dataItem);
                    if (!logarithmic) {
                        value += step;
                    }
                    else {
                        var differencePower = Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E;
                        if (differencePower > 1) {
                            value = Math.pow(10, Math.log(min) * Math.LOG10E + i);
                        }
                        else {
                            value += step;
                        }
                    }
                    var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
                    if (stepPower < 1) {
                        // exponent is less then 1 too. Count decimals of exponent
                        var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
                        // round value to avoid floating point issues
                        value = round(value, decCount);
                    }
                    i++;
                }
                for (var j = i; j < this.dataItems.length; j++) {
                    this.dataItems[j].hide();
                }
                each(this.series, function (series) {
                    if (series.inited) {
                        series._markDirtyAxes();
                    }
                });
                this._updateGhost();
            }
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_prepareDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, count) {
            var renderer = this.get("renderer");
            var value = dataItem.get("value");
            var endValue = dataItem.get("endValue");
            var position = this.valueToPosition(value);
            var endPosition = position;
            var fillEndPosition = this.valueToPosition(value + this.getPrivate("step"));
            if (isNumber(endValue)) {
                endPosition = this.valueToPosition(endValue);
                fillEndPosition = endPosition;
            }
            renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
            var grid = dataItem.get("grid");
            renderer.updateGrid(grid, position, endPosition);
            if (grid) {
                if (value == this.get("baseValue", 0)) {
                    grid.addTag("base");
                    grid._applyThemes();
                }
                else if (grid.hasTag("base")) {
                    grid.removeTag("base");
                    grid._applyThemes();
                }
            }
            renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
            renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
            this._processBullet(dataItem);
            renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
            if (!dataItem.get("isRange")) {
                var fillRule = this.get("fillRule");
                if (fillRule) {
                    fillRule(dataItem);
                }
            }
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_handleRangeChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var selectionMin = this.positionToValue(this.get("start", 0));
            var selectionMax = this.positionToValue(this.get("end", 1));
            var gridCount = this.get("renderer").gridCount();
            var minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            var stepDecimalPlaces = decimalPlaces(minMaxStep.step);
            this.setPrivateRaw("stepDecimalPlaces", stepDecimalPlaces);
            selectionMin = round(selectionMin, stepDecimalPlaces);
            selectionMax = round(selectionMax, stepDecimalPlaces);
            minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            var step = minMaxStep.step;
            selectionMin = minMaxStep.min;
            selectionMax = minMaxStep.max;
            if (this.getPrivate("selectionMin") !== selectionMin || this.getPrivate("selectionMax") !== selectionMax || this.getPrivate("step") !== step) {
                this.setPrivateRaw("selectionMin", selectionMin);
                this.setPrivateRaw("selectionMax", selectionMax);
                this.setPrivateRaw("step", step);
            }
        }
    });
    /**
     * Converts a relative position to a corresponding numeric value from axis
     * scale.
     *
     * @param   position  Relative position
     * @return            Value
     */
    Object.defineProperty(ValueAxis.prototype, "positionToValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var min = this.getPrivate("min");
            var max = this.getPrivate("max");
            if (!this.get("logarithmic")) {
                return position * (max - min) + min;
            }
            else {
                return Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);
            }
        }
    });
    /**
     * Convers value to a relative position on axis.
     *
     * @param   value  Value
     * @return         Relative position
     */
    Object.defineProperty(ValueAxis.prototype, "valueToPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var min = this.getPrivate("min");
            var max = this.getPrivate("max");
            if (!this.get("logarithmic")) {
                return (value - min) / (max - min);
            }
            else {
                if (value <= 0) {
                    var treatZeroAs = this.get("treatZeroAs");
                    if (isNumber(treatZeroAs)) {
                        value = treatZeroAs;
                    }
                }
                return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "valueToFinalPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            var min = this.getPrivate("minFinal");
            var max = this.getPrivate("maxFinal");
            if (!this.get("logarithmic")) {
                return (value - min) / (max - min);
            }
            else {
                if (value <= 0) {
                    var treatZeroAs = this.get("treatZeroAs");
                    if (isNumber(treatZeroAs)) {
                        value = treatZeroAs;
                    }
                }
                return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
            }
        }
    });
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    Object.defineProperty(ValueAxis.prototype, "getX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, location, baseValue) {
            value = baseValue + (value - baseValue) * location;
            var position = this.valueToPosition(value);
            return this._settings.renderer.positionToCoordinate(position);
        }
    });
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    Object.defineProperty(ValueAxis.prototype, "getY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value, location, baseValue) {
            value = baseValue + (value - baseValue) * location;
            var position = this.valueToPosition(value);
            return this._settings.renderer.positionToCoordinate(position);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "getDataItemCoordinateX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, _cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "getDataItemPositionX", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, _cellLocation, axisLocation) {
            var value = dataItem.get(field);
            var stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                var series = dataItem.component;
                value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);
            }
            else {
                value = this._baseValue + (value - this._baseValue) * axisLocation;
            }
            return this.valueToPosition(value);
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "getDataItemCoordinateY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, _cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "getDataItemPositionY", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, field, _cellLocation, axisLocation) {
            var value = dataItem.get(field);
            var stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                var series = dataItem.component;
                value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);
            }
            else {
                value = this._baseValue + (value - this._baseValue) * axisLocation;
            }
            return this.valueToPosition(value);
        }
    });
    /**
     * Returns relative position of axis' `baseValue`.
     *
     * @return  Base value position
     */
    Object.defineProperty(ValueAxis.prototype, "basePosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.valueToPosition(this.baseValue());
        }
    });
    /**
     * Base value of the [[ValueAxis]], which determines positive and negative
     * values.
     *
     * @return Base value
     */
    Object.defineProperty(ValueAxis.prototype, "baseValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var min = Math.min(this.getPrivate("minFinal", -Infinity), this.getPrivate("selectionMin", -Infinity));
            var max = Math.max(this.getPrivate("maxFinal", Infinity), this.getPrivate("selectionMax", Infinity));
            var baseValue = this.get("baseValue", 0);
            if (baseValue < min) {
                baseValue = min;
            }
            if (baseValue > max) {
                baseValue = max;
            }
            return baseValue;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(ValueAxis.prototype, "cellEndValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (value) {
            return value;
        }
    });
    Object.defineProperty(ValueAxis.prototype, "fixSmallStep", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (step) {
            // happens because of floating point error
            if (1 + step === 1) {
                step *= 2;
                return this.fixSmallStep(step);
            }
            return step;
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_fixMin", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (min) {
            return min;
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_fixMax", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (max) {
            return max;
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_calculateTotals", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.get("calculateTotals")) {
                var series = this.series[0];
                if (series) {
                    var startIndex = series.startIndex();
                    if (series.dataItems.length > 0) {
                        if (startIndex > 0) {
                            startIndex--;
                        }
                        var endIndex = series.endIndex();
                        if (endIndex < series.dataItems.length) {
                            endIndex++;
                        }
                        var field_1;
                        var vc_1;
                        if (series.get("yAxis") == this) {
                            field_1 = "valueY";
                            vc_1 = "vcy";
                        }
                        else if (series.get("xAxis") == this) {
                            field_1 = "valueX";
                            vc_1 = "vcx";
                        }
                        var fieldWorking_1 = field_1 + "Working";
                        if (field_1) {
                            var _loop_1 = function (i) {
                                var sum = 0;
                                var total = 0;
                                each(this_1.series, function (series) {
                                    if (!series.get("excludeFromTotal")) {
                                        var dataItem = series.dataItems[i];
                                        if (dataItem) {
                                            var value = dataItem.get(fieldWorking_1) * series.get(vc_1);
                                            if (!Type_isNaN(value)) {
                                                sum += value;
                                                total += Math.abs(value);
                                            }
                                        }
                                    }
                                });
                                each(this_1.series, function (series) {
                                    if (!series.get("excludeFromTotal")) {
                                        var dataItem = series.dataItems[i];
                                        if (dataItem) {
                                            var value = dataItem.get(fieldWorking_1) * series.get(vc_1);
                                            if (!Type_isNaN(value)) {
                                                dataItem.set((field_1 + "Total"), total);
                                                dataItem.set((field_1 + "Sum"), sum);
                                                dataItem.set((field_1 + "TotalPercent"), value / total * 100);
                                            }
                                        }
                                    }
                                });
                            };
                            var this_1 = this;
                            for (var i = startIndex; i < endIndex; i++) {
                                _loop_1(i);
                            }
                        }
                    }
                }
            }
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_getSelectionMinMax", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _a;
            var _this = this;
            var min = this.getPrivate("minFinal");
            var max = this.getPrivate("maxFinal");
            var minDefined = this.get("min");
            var maxDefined = this.get("max");
            var extraMin = this.get("extraMin", 0);
            var extraMax = this.get("extraMax", 0);
            var gridCount = this.get("renderer").gridCount();
            var strictMinMax = this.get("strictMinMax", false);
            if (isNumber(min) && isNumber(max)) {
                var selectionMin_1 = max;
                var selectionMax_1 = min;
                each(this.series, function (series) {
                    if (!series.get("ignoreMinMax")) {
                        var seriesMin = void 0;
                        var seriesMax = void 0;
                        if (series.get("xAxis") === _this) {
                            seriesMin = series.getPrivate("selectionMinX", series.getPrivate("minX"));
                            seriesMax = series.getPrivate("selectionMaxX", series.getPrivate("maxX"));
                        }
                        else if (series.get("yAxis") === _this) {
                            seriesMin = series.getPrivate("selectionMinY", series.getPrivate("minY"));
                            seriesMax = series.getPrivate("selectionMaxY", series.getPrivate("maxY"));
                        }
                        if (!series.isHidden() && !series.isShowing()) {
                            if (isNumber(seriesMin)) {
                                selectionMin_1 = Math.min(selectionMin_1, seriesMin);
                            }
                            if (isNumber(seriesMax)) {
                                selectionMax_1 = Math.max(selectionMax_1, seriesMax);
                            }
                        }
                    }
                });
                this.axisRanges.each(function (range) {
                    if (range.get("affectsMinMax")) {
                        var value = range.get("value");
                        if (value != null) {
                            selectionMin_1 = Math.min(selectionMin_1, value);
                            selectionMax_1 = Math.max(selectionMax_1, value);
                        }
                        value = range.get("endValue");
                        if (value != null) {
                            selectionMin_1 = Math.min(selectionMin_1, value);
                            selectionMax_1 = Math.max(selectionMax_1, value);
                        }
                    }
                });
                if (selectionMin_1 > selectionMax_1) {
                    _a = __read([selectionMax_1, selectionMin_1], 2), selectionMin_1 = _a[0], selectionMax_1 = _a[1];
                }
                if (isNumber(minDefined)) {
                    if (strictMinMax) {
                        selectionMin_1 = minDefined;
                    }
                    else {
                        selectionMin_1 = min;
                    }
                }
                else if (strictMinMax) {
                    if (isNumber(this._minReal)) {
                        selectionMin_1 = this._minReal;
                    }
                }
                if (isNumber(maxDefined)) {
                    if (strictMinMax) {
                        selectionMax_1 = maxDefined;
                    }
                    else {
                        selectionMax_1 = max;
                    }
                }
                else if (strictMinMax) {
                    if (isNumber(this._maxReal)) {
                        selectionMax_1 = this._maxReal;
                    }
                }
                if (selectionMin_1 === selectionMax_1) {
                    selectionMin_1 -= this._deltaMinMax;
                    selectionMax_1 += this._deltaMinMax;
                    var minMaxStep2 = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, strictMinMax);
                    selectionMin_1 = minMaxStep2.min;
                    selectionMax_1 = minMaxStep2.max;
                }
                var minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount);
                selectionMin_1 = minMaxStep.min;
                selectionMax_1 = minMaxStep.max;
                selectionMin_1 -= (selectionMax_1 - selectionMin_1) * extraMin;
                selectionMax_1 += (selectionMax_1 - selectionMin_1) * extraMax;
                selectionMin_1 = fitToRange(selectionMin_1, min, max);
                selectionMax_1 = fitToRange(selectionMax_1, min, max);
                // do it for the second time !important			
                minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, true);
                if (!strictMinMax) {
                    selectionMin_1 = minMaxStep.min;
                    selectionMax_1 = minMaxStep.max;
                }
                var syncWithAxis = this.get("syncWithAxis");
                if (syncWithAxis) {
                    minMaxStep = this._syncAxes(selectionMin_1, selectionMax_1, minMaxStep.step, syncWithAxis.getPrivate("selectionMinFinal", syncWithAxis.getPrivate("minFinal", 0)), syncWithAxis.getPrivate("selectionMaxFinal", syncWithAxis.getPrivate("maxFinal", 1)), syncWithAxis.getPrivate("selectionStepFinal", syncWithAxis.getPrivate("step", 1)));
                    selectionMin_1 = minMaxStep.min;
                    selectionMax_1 = minMaxStep.max;
                }
                if (strictMinMax) {
                    if (isNumber(minDefined)) {
                        selectionMin_1 = Math.max(selectionMin_1, minDefined);
                    }
                    if (isNumber(maxDefined)) {
                        selectionMax_1 = Math.min(selectionMax_1, maxDefined);
                    }
                }
                var start = this.valueToFinalPosition(selectionMin_1);
                var end = this.valueToFinalPosition(selectionMax_1);
                this.setPrivateRaw("selectionMinFinal", selectionMin_1);
                this.setPrivateRaw("selectionMaxFinal", selectionMax_1);
                this.setPrivateRaw("selectionStepFinal", minMaxStep.step);
                this.zoom(start, end);
            }
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_getMinMax", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var minDefined = this.get("min");
            var maxDefined = this.get("max");
            var min = Infinity;
            var max = -Infinity;
            var extraMin = this.get("extraMin", 0);
            var extraMax = this.get("extraMax", 0);
            var minDiff = Infinity;
            each(this.series, function (series) {
                if (!series.get("ignoreMinMax")) {
                    var seriesMin = void 0;
                    var seriesMax = void 0;
                    if (series.get("xAxis") === _this) {
                        seriesMin = series.getPrivate("minX");
                        seriesMax = series.getPrivate("maxX");
                    }
                    else if (series.get("yAxis") === _this) {
                        seriesMin = series.getPrivate("minY");
                        seriesMax = series.getPrivate("maxY");
                    }
                    if (isNumber(seriesMin) && isNumber(seriesMax)) {
                        min = Math.min(min, seriesMin);
                        max = Math.max(max, seriesMax);
                        var diff = seriesMax - seriesMin;
                        if (diff <= 0) {
                            diff = Math.abs(seriesMax / 100);
                        }
                        if (diff < minDiff) {
                            minDiff = diff;
                        }
                    }
                }
            });
            this.axisRanges.each(function (range) {
                if (range.get("affectsMinMax")) {
                    var value = range.get("value");
                    if (value != null) {
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                    }
                    value = range.get("endValue");
                    if (value != null) {
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                    }
                }
            });
            if (this.get("logarithmic")) {
                var treatZeroAs = this.get("treatZeroAs");
                if (isNumber(treatZeroAs)) {
                    if (min <= 0) {
                        min = treatZeroAs;
                    }
                }
                if (min <= 0) {
                    new Error("Logarithmic value axis can not have values <= 0.");
                }
            }
            if (min === 0 && max === 0) {
                max = 0.9;
                min = -0.9;
            }
            if (isNumber(minDefined)) {
                min = minDefined;
            }
            if (isNumber(maxDefined)) {
                max = maxDefined;
            }
            // meaning no min/max found on series/ranges and no min/max was defined
            if (min === Infinity || max === -Infinity) {
                return;
            }
            // adapter
            var minAdapted = this.adapters.fold("min", min);
            var maxAdapted = this.adapters.fold("max", max);
            if (isNumber(minAdapted)) {
                min = minAdapted;
            }
            if (isNumber(maxAdapted)) {
                max = maxAdapted;
            }
            // DateAxis does some magic here
            min = this._fixMin(min);
            max = this._fixMax(max);
            // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date
            if (max - min <= 1 / Math.pow(10, 15)) {
                if (max - min !== 0) {
                    this._deltaMinMax = (max - min) / 2;
                }
                else {
                    // the number by which we need to raise 10 to get difference
                    var exponent = Math.log(Math.abs(max)) * Math.LOG10E;
                    // here we find a number which is power of 10 and has the same count of numbers as difference has
                    var power = Math.pow(10, Math.floor(exponent));
                    // reduce this number by 10 times
                    power = power / 10;
                    this._deltaMinMax = power;
                }
                min -= this._deltaMinMax;
                max += this._deltaMinMax;
            }
            // add extras
            min -= (max - min) * extraMin;
            max += (max - min) * extraMax;
            this._minReal = min;
            this._maxReal = max;
            var strict = this.get("strictMinMax");
            if (isNumber(maxDefined)) {
                strict = true;
            }
            var gridCount = this.get("renderer").gridCount();
            var minMaxStep = this._adjustMinMax(min, max, gridCount, strict);
            min = minMaxStep.min;
            max = minMaxStep.max;
            // do it for the second time with strict true (importat!)
            minMaxStep = this._adjustMinMax(min, max, gridCount, true);
            min = minMaxStep.min;
            max = minMaxStep.max;
            // return min max if strict
            if (this.get("strictMinMax")) {
                if (isNumber(minDefined)) {
                    min = minDefined;
                }
                else {
                    min = this._minReal;
                }
                if (isNumber(maxDefined)) {
                    max = maxDefined;
                }
                else {
                    max = this._maxReal;
                }
                if (max - min <= 0.00000001) {
                    min -= this._deltaMinMax;
                    max += this._deltaMinMax;
                }
                min -= (max - min) * extraMin;
                max += (max - min) * extraMax;
            }
            minAdapted = this.adapters.fold("min", min);
            maxAdapted = this.adapters.fold("max", max);
            if (isNumber(minAdapted)) {
                min = minAdapted;
            }
            if (isNumber(maxAdapted)) {
                max = maxAdapted;
            }
            if (minDiff == Infinity) {
                minDiff = (max - min);
            }
            var syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate("minFinal", syncWithAxis.getPrivate("min", 0)), syncWithAxis.getPrivate("maxFinal", syncWithAxis.getPrivate("max", 1)), syncWithAxis.getPrivate("step", 1));
                min = minMaxStep.min;
                max = minMaxStep.max;
            }
            this.setPrivateRaw("maxZoomFactor", (max - min) / minDiff * this.get("maxZoomFactor", 100));
            if (isNumber(min) && isNumber(max)) {
                if (this.getPrivate("minFinal") !== min || this.getPrivate("maxFinal") !== max) {
                    this.setPrivate("minFinal", min);
                    this.setPrivate("maxFinal", max);
                    var duration = this.get("interpolationDuration", 0);
                    var easing = this.get("interpolationEasing");
                    this.animatePrivate({ key: "min", to: min, duration: duration, easing: easing });
                    this.animatePrivate({ key: "max", to: max, duration: duration, easing: easing });
                }
            }
        }
    });
    Object.defineProperty(ValueAxis.prototype, "_adjustMinMax", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (min, max, gridCount, strictMode) {
            var logarithmic = this.get("logarithmic");
            // will fail if 0
            if (gridCount <= 1) {
                gridCount = 1;
            }
            gridCount = Math.round(gridCount);
            var initialMin = min;
            var initialMax = max;
            var difference = max - min;
            // in case min and max is the same, use max
            if (difference === 0) {
                difference = Math.abs(max);
            }
            // the number by which we need to raise 10 to get difference
            var exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
            // here we find a number which is power of 10 and has the same count of numbers as difference has
            var power = Math.pow(10, Math.floor(exponent));
            // reduce this number by 10 times
            power = power / 10;
            var extra = power;
            if (strictMode) {
                extra = 0;
            }
            if (!logarithmic) {
                // round down min
                if (strictMode) {
                    min = Math.floor(min / power) * power;
                    // round up max
                    max = Math.ceil(max / power) * power;
                }
                else {
                    min = Math.ceil(min / power) * power - extra;
                    // round up max
                    max = Math.floor(max / power) * power + extra;
                }
                // don't let min go below 0 if real min is >= 0
                if (min < 0 && initialMin >= 0) {
                    min = 0;
                }
                // don't let max go above 0 if real max is <= 0
                if (max > 0 && initialMax <= 0) {
                    max = 0;
                }
            }
            // logarithmic
            else {
                if (min <= 0) {
                    //throw Error("Logarithmic value axis can not have values <= 0.");
                    min = this.get("baseValue", 0);
                }
                if (min === Infinity) {
                    min = 1;
                }
                if (max === -Infinity) {
                    max = 10;
                }
                min = Math.pow(10, Math.floor(Math.log(Math.abs(min)) * Math.LOG10E));
                max = Math.pow(10, Math.ceil(Math.log(Math.abs(max)) * Math.LOG10E));
                if (this.get("strictMinMax")) {
                    var minDefined = this.get("min");
                    var maxDefined = this.get("max");
                    if (isNumber(minDefined) && minDefined > 0) {
                        min = minDefined;
                    }
                    if (isNumber(maxDefined) && maxDefined > 0) {
                        max = maxDefined;
                    }
                }
            }
            exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
            power = Math.pow(10, Math.floor(exponent));
            power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance
            // approximate difference between two grid lines
            var step = Math.ceil((difference / gridCount) / power) * power;
            var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
            // the step should divide by  2, 5, and 10.
            var stepDivisor = Math.ceil(step / stepPower); // number 0 - 10
            if (stepDivisor > 5) {
                stepDivisor = 10;
            }
            else if (stepDivisor <= 5 && stepDivisor > 2) {
                stepDivisor = 5;
            }
            // now get real step
            step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
            var maxPrecision = this.get("maxPrecision");
            if (isNumber(maxPrecision)) {
                var ceiledStep = ceil(step, maxPrecision);
                if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {
                    step = ceiledStep;
                }
            }
            var decCount = 0;
            // in case numbers are smaller than 1
            if (stepPower < 1) {
                // exponent is less then 1 too. Count decimals of exponent
                decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
                // round step
                step = round(step, decCount);
            }
            if (!logarithmic) {
                // final min and max
                var minCount = Math.floor(min / step);
                min = round(step * minCount, decCount);
                var maxCount = void 0;
                if (!strictMode) {
                    maxCount = Math.ceil(max / step);
                }
                else {
                    maxCount = Math.floor(max / step);
                }
                if (maxCount === minCount) {
                    maxCount++;
                }
                max = round(step * maxCount, decCount);
                if (max < initialMax) {
                    max = max + step;
                }
                if (min > initialMin) {
                    min = min - step;
                }
            }
            step = this.fixSmallStep(step);
            return { min: min, max: max, step: step };
        }
    });
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    Object.defineProperty(ValueAxis.prototype, "getTooltipText", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var numberFormat = this.get("tooltipNumberFormat", this.get("numberFormat"));
            var formatter = this.getNumberFormatter();
            var extraDecimals = this.get("extraTooltipPrecision", 0);
            var decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
            var value = round(this.positionToValue(position), decimals);
            if (numberFormat) {
                return formatter.format(value, numberFormat);
            }
            else {
                return formatter.format(value, undefined, decimals);
                //label.set("text", this.getNumberFormatter().format(value, undefined, this.getPrivate("stepDecimalPlaces")));
            }
            // //@todo number formatter + tag
            // return $math.round(this.positionToValue(position), this.getPrivate("stepDecimalPlaces")).toString();
        }
    });
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    Object.defineProperty(ValueAxis.prototype, "getSeriesItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (series, position) {
            var fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
            var value = this.positionToValue(position);
            var index = undefined;
            var oldDiff;
            each(series.dataItems, function (dataItem, i) {
                var diff = Math.abs(dataItem.get(fieldName) - value);
                if (index === undefined || diff < oldDiff) {
                    index = i;
                    oldDiff = diff;
                }
            });
            if (index != null) {
                return series.dataItems[index];
            }
        }
    });
    /**
     * Zooms the axis to specific `start` and `end` values.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start value
     * @param  end       End value
     * @param  duration  Duration in milliseconds
     */
    Object.defineProperty(ValueAxis.prototype, "zoomToValues", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (start, end, duration) {
            var min = this.getPrivate("minFinal", 0);
            var max = this.getPrivate("maxFinal", 0);
            if (this.getPrivate("min") != null && this.getPrivate("max") != null) {
                this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);
            }
        }
    });
    /**
     * Syncs with a target axis.
     *
     * @param  min  Min
     * @param  max  Max
     * @param  step Step
     */
    Object.defineProperty(ValueAxis.prototype, "_syncAxes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (min, max, step, syncMin, syncMax, syncStep) {
            var axis = this.get("syncWithAxis");
            if (axis) {
                var count = Math.round(syncMax - syncMin) / syncStep;
                var currentCount = Math.round((max - min) / step);
                var gridCount = this.get("renderer").gridCount();
                if (isNumber(count) && isNumber(currentCount)) {
                    var synced = false;
                    var c = 0;
                    var diff = (max - min) * 0.01;
                    var omin = min;
                    var omax = max;
                    var ostep = step;
                    while (synced != true) {
                        synced = this._checkSync(omin, omax, ostep, count);
                        c++;
                        if (c > 500) {
                            synced = true;
                        }
                        if (!synced) {
                            if (c / 3 == Math.round(c / 3)) {
                                omin = min - diff * c;
                                if (min >= 0 && omin < 0) {
                                    omin = 0;
                                }
                            }
                            else {
                                omax = max + diff * c;
                                if (omax <= 0 && omax > 0) {
                                    omax = 0;
                                }
                            }
                            var minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);
                            omin = minMaxStep.min;
                            omax = minMaxStep.max;
                            ostep = minMaxStep.step;
                        }
                        else {
                            min = omin;
                            max = omax;
                            step = ostep;
                        }
                    }
                }
            }
            return { min: min, max: max, step: step };
        }
    });
    /**
     * Returns `true` if axis needs to be resunced with some other axis.
     */
    Object.defineProperty(ValueAxis.prototype, "_checkSync", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (min, max, step, count) {
            var currentCount = (max - min) / step;
            for (var i = 1; i < count; i++) {
                if (round(currentCount / i, 1) == count || currentCount * i == count) {
                    return true;
                }
            }
            return false;
        }
    });
    Object.defineProperty(ValueAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ValueAxis"
    });
    Object.defineProperty(ValueAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Axis.classNames.concat([ValueAxis.className])
    });
    return ValueAxis;
}(Axis));

//# sourceMappingURL=ValueAxis.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js






/**
 * Used to render horizontal axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
var AxisRendererX = /** @class */ (function (_super) {
    __extends(AxisRendererX, _super);
    function AxisRendererX() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Rectangle.new(_this._root, { width: p100, themeTags: ["axis", "x", "thumb"] })
        });
        return _this;
    }
    Object.defineProperty(AxisRendererX.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "x"]);
            _super.prototype._afterNew.call(this);
            this.setPrivateRaw("letter", "X");
            var gridTemplate = this.grid.template;
            gridTemplate.set("height", p100);
            gridTemplate.set("width", 0);
            gridTemplate.set("draw", function (display, graphics) {
                display.moveTo(0, 0);
                display.lineTo(0, graphics.height());
            });
            this.set("draw", function (display, graphics) {
                display.moveTo(0, 0);
                display.lineTo(graphics.width(), 0);
            });
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "_changed", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._changed.call(this);
            var axis = this.axis;
            if (this.isDirty("inside")) {
                axis.markDirtySize();
            }
            var opposite = "opposite";
            if (this.isDirty(opposite)) {
                var chart = this.chart;
                if (chart) {
                    var axisChildren = axis.children;
                    if (this.get(opposite)) {
                        var children = chart.topAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.insertIndex(0, axis);
                        }
                        axisChildren.moveValue(this);
                        axis.addTag(opposite);
                    }
                    else {
                        var children = chart.bottomAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis);
                        }
                        axisChildren.moveValue(this, 0);
                        axis.removeTag(opposite);
                    }
                    axis.markDirtySize();
                }
                axis.ghostLabel._applyThemes();
            }
            this.thumb.setPrivate("height", axis.labelsContainer.height());
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "_getPan", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (point1, point2) {
            return (point2.x - point1.x) / this.width();
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "toAxisPosition", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var start = this._start || 0;
            var end = this._end || 1;
            position -= this._ls;
            position = position * (end - start) / this._lc;
            if (!this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "_updateLC", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var axis = this.axis;
            var parent = axis.parent;
            if (parent) {
                var w = parent.innerWidth();
                this._lc = this.axisLength() / w;
                this._ls = (axis.x() - parent.get("paddingLeft", 0)) / w;
            }
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "_updatePositions", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var axis = this.axis;
            axis.gridContainer.set("x", axis.x() - relativeToValue(axis.get("centerX", 0), axis.width()) - axis.parent.get("paddingLeft", 0));
            axis.bulletsContainer.set("y", this.y());
            var chart = axis.chart;
            if (chart) {
                var plotContainer = chart.plotContainer;
                var axisHeader = axis.axisHeader;
                var width = axis.get("marginLeft", 0);
                var x = axis.x() - width;
                var parent_1 = axis.parent;
                if (parent_1) {
                    x -= parent_1.get("paddingLeft", 0);
                }
                if (axisHeader.children.length > 0) {
                    width = axis.axisHeader.width();
                    axis.set("marginLeft", width);
                }
                else {
                    axisHeader.set("width", width);
                }
                axisHeader.setAll({ x: x, y: -1, height: plotContainer.height() + 2 });
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "processAxis", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.processAxis.call(this);
            var axis = this.axis;
            axis.set("width", p100);
            var verticalLayout = this._root.verticalLayout;
            axis.set("layout", verticalLayout);
            axis.labelsContainer.set("width", p100);
            axis.axisHeader.setAll({ layout: verticalLayout });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "axisLength", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return this.axis.width();
        }
    });
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    Object.defineProperty(AxisRendererX.prototype, "positionToPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            return { x: this.positionToCoordinate(position), y: 0 };
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateTick", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tick, position, endPosition, count) {
            if (tick) {
                if (!isNumber(position)) {
                    position = 0;
                }
                var location_1 = 0.5;
                if (isNumber(count) && count > 1) {
                    location_1 = tick.get("multiLocation", location_1);
                }
                else {
                    location_1 = tick.get("location", location_1);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_1;
                }
                tick.set("x", this.positionToCoordinate(position));
                var length_1 = tick.get("length", 0);
                var inside = tick.get("inside", this.get("inside", false));
                if (this.get("opposite")) {
                    tick.set("y", p100);
                    if (!inside) {
                        length_1 *= -1;
                    }
                }
                else {
                    tick.set("y", 0);
                    if (inside) {
                        length_1 *= -1;
                    }
                }
                tick.set("draw", function (display) {
                    display.moveTo(0, 0);
                    display.lineTo(0, length_1);
                });
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateLabel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (label, position, endPosition, count) {
            if (label) {
                var location_2 = 0.5;
                if (isNumber(count) && count > 1) {
                    location_2 = label.get("multiLocation", location_2);
                }
                else {
                    location_2 = label.get("location", location_2);
                }
                if (!isNumber(position)) {
                    position = 0;
                }
                var inside = label.get("inside", this.get("inside", false));
                var opposite = this.get("opposite");
                if (opposite) {
                    if (!inside) {
                        label.set("position", "relative");
                        label.set("y", p100);
                    }
                    else {
                        label.set("position", "absolute");
                        label.set("y", 0);
                    }
                }
                else {
                    if (!inside) {
                        label.set("y", undefined);
                        label.set("position", "relative");
                    }
                    else {
                        label.set("y", 0);
                        label.set("position", "absolute");
                    }
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_2;
                }
                label.set("x", this.positionToCoordinate(position));
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateGrid", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (grid, position, endPosition) {
            if (grid) {
                if (!isNumber(position)) {
                    position = 0;
                }
                var location_3 = grid.get("location", 0.5);
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location_3;
                }
                grid.set("x", Math.round(this.positionToCoordinate(position)));
                this.toggleVisibility(grid, position, 0, 1);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bullet, position, endPosition) {
            if (bullet) {
                var sprite = bullet.get("sprite");
                if (sprite) {
                    if (!isNumber(position)) {
                        position = 0;
                    }
                    var location_4 = bullet.get("location", 0.5);
                    if (isNumber(endPosition) && endPosition != position) {
                        position = position + (endPosition - position) * location_4;
                    }
                    sprite.set("x", this.positionToCoordinate(position));
                    this.toggleVisibility(sprite, position, 0, 1);
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateFill", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fill, position, endPosition) {
            if (fill) {
                if (!isNumber(position)) {
                    position = 0;
                }
                if (!isNumber(endPosition)) {
                    endPosition = 1;
                }
                var x0 = this.positionToCoordinate(position);
                var x1 = this.positionToCoordinate(endPosition);
                this.fillDrawMethod(fill, x0, x1);
            }
        }
    });
    Object.defineProperty(AxisRendererX.prototype, "fillDrawMethod", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (fill, x0, x1) {
            var _this = this;
            fill.set("draw", function (display) {
                var _a;
                //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());
                // using for holes, so can not be rectangle
                var h = _this.axis.gridContainer.height();
                var w = _this.width();
                if (x1 < x0) {
                    _a = __read([x0, x1], 2), x1 = _a[0], x0 = _a[1];
                }
                if (x0 > w || x1 < 0) {
                    return;
                }
                x0 = Math.max(0, x0);
                x1 = Math.min(w, x1);
                display.moveTo(x0, 0);
                display.lineTo(x1, 0);
                display.lineTo(x1, h);
                display.lineTo(x0, h);
                display.lineTo(x0, 0);
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "positionTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip, position) {
            this._positionTooltip(tooltip, { x: this.positionToCoordinate(position), y: 0 });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(AxisRendererX.prototype, "updateTooltipBounds", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (tooltip) {
            var inside = this.get("inside");
            var num = 100000;
            var global = this._display.toGlobal({ x: 0, y: 0 });
            var x = global.x;
            var y = 0;
            var w = this.axisLength();
            var h = num;
            var pointerOrientation = "up";
            if (this.get("opposite")) {
                if (inside) {
                    pointerOrientation = "up";
                    y = global.y;
                    h = num;
                }
                else {
                    pointerOrientation = "down";
                    y = global.y - num;
                    h = num;
                }
            }
            else {
                if (inside) {
                    pointerOrientation = "down";
                    y = global.y - num;
                    h = num;
                }
                else {
                    pointerOrientation = "up";
                    y = global.y;
                    h = num;
                }
            }
            var bounds = { left: x, right: x + w, top: y, bottom: y + h };
            var oldBounds = tooltip.get("bounds");
            if (!sameBounds(bounds, oldBounds)) {
                tooltip.set("bounds", bounds);
                tooltip.set("pointerOrientation", pointerOrientation);
            }
        }
    });
    Object.defineProperty(AxisRendererX, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererX"
    });
    Object.defineProperty(AxisRendererX, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererX.className])
    });
    return AxisRendererX;
}(AxisRenderer));

//# sourceMappingURL=AxisRendererX.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js












/**
 * A base class for all series.
 */
var Series = /** @class */ (function (_super) {
    __extends(Series, _super);
    function Series() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_aggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_selectionAggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_dataProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_psi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_pei", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A chart series belongs to.
         */
        Object.defineProperty(_this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * List of bullets to use for the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
         */
        Object.defineProperty(_this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new List()
        });
        /**
         * A [[Container]] series' bullets are stored in.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Container.new(_this._root, { width: p100, height: p100, position: "absolute" })
        });
        return _this;
    }
    Object.defineProperty(Series.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this.valueFields.push("value");
            _super.prototype._afterNew.call(this);
            this.setPrivate("customData", {});
            this._disposers.push(this.bullets.events.onAll(function (change) {
                if (change.type === "clear") {
                    _this._handleBullets(_this.dataItems);
                }
                else if (change.type === "push") {
                    _this._handleBullets(_this.dataItems);
                }
                else if (change.type === "setIndex") {
                    _this._handleBullets(_this.dataItems);
                }
                else if (change.type === "insertIndex") {
                    _this._handleBullets(_this.dataItems);
                }
                else if (change.type === "removeIndex") {
                    _this._handleBullets(_this.dataItems);
                }
                else if (change.type === "moveIndex") {
                    _this._handleBullets(_this.dataItems);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            }));
        }
    });
    Object.defineProperty(Series.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.bulletsContainer.dispose(); // can be in a different parent
            _super.prototype._dispose.call(this);
        }
    });
    Object.defineProperty(Series.prototype, "startIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var len = this.dataItems.length;
            return Math.min(this.getPrivate("startIndex", 0), len);
        }
    });
    Object.defineProperty(Series.prototype, "endIndex", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var len = this.dataItems.length;
            return Math.min(this.getPrivate("endIndex", len), len);
        }
    });
    Object.defineProperty(Series.prototype, "_handleBullets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItems) {
            each(dataItems, function (dataItem) {
                var bullets = dataItem.bullets;
                if (bullets) {
                    each(bullets, function (bullet) {
                        bullet.dispose();
                    });
                    dataItem.bullets = undefined;
                }
            });
            this.markDirtyValues();
        }
    });
    /**
     * Looks up and returns a data item by its ID.
     *
     * @param   id  ID
     * @return      Data item
     */
    Object.defineProperty(Series.prototype, "getDataItemById", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (id) {
            return find(this.dataItems, function (dataItem) {
                return dataItem.get("id") == id;
            });
        }
    });
    Object.defineProperty(Series.prototype, "_makeBullets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var _this = this;
            if (this._shouldMakeBullet(dataItem)) {
                dataItem.bullets = [];
                this.bullets.each(function (bulletFunction) {
                    _this._makeBullet(dataItem, bulletFunction);
                });
            }
        }
    });
    Object.defineProperty(Series.prototype, "_shouldMakeBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
            return true;
        }
    });
    Object.defineProperty(Series.prototype, "_makeBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, bulletFunction, index) {
            var bullet = bulletFunction(this._root, this, dataItem);
            if (bullet) {
                var sprite = bullet.get("sprite");
                if (sprite) {
                    sprite._setDataItem(dataItem);
                    sprite.setRaw("position", "absolute");
                    this.bulletsContainer.children.push(sprite);
                }
                bullet._index = index;
                bullet.series = this;
                dataItem.bullets.push(bullet);
            }
            return bullet;
        }
    });
    Object.defineProperty(Series.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._aggregatesCalculated = false;
            this._selectionAggregatesCalculated = false;
        }
    });
    Object.defineProperty(Series.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._prepareChildren.call(this);
            var startIndex = this.startIndex();
            var endIndex = this.endIndex();
            var calculateAggregates = this.get("calculateAggregates");
            if (calculateAggregates) {
                if (this._valuesDirty && !this._dataProcessed) {
                    if (!this._aggregatesCalculated) {
                        this._calculateAggregates(0, this.dataItems.length);
                        this._aggregatesCalculated = true;
                    }
                }
                if ((this._psi != startIndex || this._pei != endIndex) && !this._selectionAggregatesCalculated) {
                    if (startIndex === 0 && endIndex === this.dataItems.length && this._aggregatesCalculated) {
                        // void
                    }
                    else {
                        this._calculateAggregates(startIndex, endIndex);
                    }
                    this._selectionAggregatesCalculated = true;
                }
            }
            if (this.isDirty("tooltip")) {
                var tooltip = this.get("tooltip");
                if (tooltip) {
                    tooltip.hide(0);
                    tooltip.set("tooltipTarget", this);
                }
            }
            if (this.isDirty("fill") || this.isDirty("stroke")) {
                var markerRectangle = void 0;
                var legendDataItem = this.get("legendDataItem");
                if (legendDataItem) {
                    markerRectangle = legendDataItem.get("markerRectangle");
                    if (markerRectangle) {
                        if (this.isDirty("stroke")) {
                            var stroke = this.get("stroke");
                            markerRectangle.set("stroke", stroke);
                        }
                        if (this.isDirty("fill")) {
                            var fill = this.get("fill");
                            markerRectangle.set("fill", fill);
                        }
                    }
                }
                this.updateLegendMarker(undefined);
            }
            if (this.bullets.length > 0) {
                var startIndex_1 = this.startIndex();
                var endIndex_1 = this.endIndex();
                for (var i = startIndex_1; i < endIndex_1; i++) {
                    var dataItem = this.dataItems[i];
                    if (!dataItem.bullets) {
                        this._makeBullets(dataItem);
                    }
                }
            }
        }
    });
    Object.defineProperty(Series.prototype, "_calculateAggregates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (startIndex, endIndex) {
            var _this = this;
            var fields = this._valueFields;
            if (!fields) {
                throw new Error("No value fields are set for the series.");
            }
            var sum = {};
            var absSum = {};
            var count = {};
            var low = {};
            var high = {};
            var open = {};
            var close = {};
            var average = {};
            var previous = {};
            each(fields, function (key) {
                sum[key] = 0;
                absSum[key] = 0;
                count[key] = 0;
            });
            each(fields, function (key) {
                var change = key + "Change";
                var changePercent = key + "ChangePercent";
                var changePrevious = key + "ChangePrevious";
                var changePreviousPercent = key + "ChangePreviousPercent";
                var changeSelection = key + "ChangeSelection";
                var ChangeSelectionPercent = key + "ChangeSelectionPercent";
                for (var i = startIndex; i < endIndex; i++) {
                    var dataItem = _this.dataItems[i];
                    var value = dataItem.get(key);
                    if (value != null) {
                        count[key]++;
                        sum[key] += value;
                        absSum[key] += Math.abs(value);
                        average[key] = sum[key] / count[key];
                        if (low[key] > value || low[key] == null) {
                            low[key] = value;
                        }
                        if (high[key] < value || high[key] == null) {
                            high[key] = value;
                        }
                        close[key] = value;
                        if (open[key] == null) {
                            open[key] = value;
                            previous[key] = value;
                        }
                        if (startIndex === 0) {
                            dataItem.setRaw((change), value - open[key]);
                            dataItem.setRaw((changePercent), (value - open[key]) / open[key] * 100);
                        }
                        dataItem.setRaw((changePrevious), value - previous[key]);
                        dataItem.setRaw((changePreviousPercent), (value - previous[key]) / previous[key] * 100);
                        dataItem.setRaw((changeSelection), value - open[key]);
                        dataItem.setRaw((ChangeSelectionPercent), (value - open[key]) / open[key] * 100);
                        previous[key] = value;
                    }
                }
            });
            each(fields, function (key) {
                _this.setPrivate((key + "AverageSelection"), average[key]);
                _this.setPrivate((key + "CountSelection"), count[key]);
                _this.setPrivate((key + "SumSelection"), sum[key]);
                _this.setPrivate((key + "AbsoluteSumSelection"), absSum[key]);
                _this.setPrivate((key + "LowSelection"), low[key]);
                _this.setPrivate((key + "HighSelection"), high[key]);
                _this.setPrivate((key + "OpenSelection"), open[key]);
                _this.setPrivate((key + "CloseSelection"), close[key]);
            });
            if (startIndex === 0 && endIndex === this.dataItems.length) {
                each(fields, function (key) {
                    _this.setPrivate((key + "Average"), average[key]);
                    _this.setPrivate((key + "Count"), count[key]);
                    _this.setPrivate((key + "Sum"), sum[key]);
                    _this.setPrivate((key + "AbsoluteSum"), absSum[key]);
                    _this.setPrivate((key + "Low"), low[key]);
                    _this.setPrivate((key + "High"), high[key]);
                    _this.setPrivate((key + "Open"), open[key]);
                    _this.setPrivate((key + "Close"), close[key]);
                });
            }
        }
    });
    Object.defineProperty(Series.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._updateChildren.call(this);
            this._psi = this.startIndex();
            this._pei = this.endIndex();
            if (this.isDirty("visible")) {
                this.bulletsContainer.set("visible", this.get("visible"));
            }
            // Apply heat rules
            if (this._valuesDirty && this.get("heatRules") != null) {
                var rules = this.get("heatRules", []);
                each(rules, function (rule) {
                    var minValue = rule.minValue || _this.getPrivate((rule.dataField + "Low")) || 0;
                    var maxValue = rule.maxValue || _this.getPrivate((rule.dataField + "High")) || 0;
                    each(rule.target._entities, function (target) {
                        var value = target.dataItem.get(rule.dataField);
                        if (!isNumber(value)) {
                            return;
                        }
                        var percent;
                        if (rule.logarithmic) {
                            percent = (Math.log(value) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / ((Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E));
                        }
                        else {
                            percent = (value - minValue) / (maxValue - minValue);
                        }
                        if (isNumber(value) && (!isNumber(percent) || Math.abs(percent) == Infinity)) {
                            percent = 0.5;
                        }
                        // fixes problems if all values are the same
                        var propertyValue;
                        if (isNumber(rule.min)) {
                            propertyValue = rule.min + (rule.max - rule.min) * percent;
                        }
                        else if (rule.min instanceof Color) {
                            propertyValue = Color.interpolate(percent, rule.min, rule.max);
                        }
                        else if (rule.min instanceof Percent) {
                            propertyValue = percentInterpolate(percent, rule.min, rule.max);
                        }
                        if (rule.customFunction) {
                            rule.customFunction.call(_this, target, minValue, maxValue, value);
                        }
                        else {
                            target.set(rule.key, propertyValue);
                        }
                    });
                });
            }
            if (this.bullets.length > 0) {
                var count = this.dataItems.length;
                var startIndex = this.startIndex();
                var endIndex = this.endIndex();
                if (endIndex < count) {
                    endIndex++;
                }
                if (startIndex > 0) {
                    startIndex--;
                }
                for (var i = 0; i < startIndex; i++) {
                    this._hideBullets(this.dataItems[i]);
                }
                for (var i = startIndex; i < endIndex; i++) {
                    this._positionBullets(this.dataItems[i]);
                }
                for (var i = endIndex; i < count; i++) {
                    this._hideBullets(this.dataItems[i]);
                }
            }
        }
    });
    Object.defineProperty(Series.prototype, "_positionBullets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var _this = this;
            if (dataItem.bullets) {
                each(dataItem.bullets, function (bullet) {
                    _this._positionBullet(bullet);
                    var sprite = bullet.get("sprite");
                    if (bullet.get("dynamic")) {
                        if (sprite) {
                            sprite._markDirtyKey("fill");
                            sprite.markDirtySize();
                        }
                        if (sprite instanceof Container) {
                            sprite.walkChildren(function (child) {
                                child._markDirtyKey("fill");
                                child.markDirtySize();
                            });
                        }
                    }
                    if (sprite instanceof Label && sprite.get("populateText")) {
                        sprite.text.markDirtyText();
                    }
                });
            }
        }
    });
    Object.defineProperty(Series.prototype, "_hideBullets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            if (dataItem.bullets) {
                each(dataItem.bullets, function (bullet) {
                    var sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.setPrivate("visible", false);
                    }
                });
            }
        }
    });
    Object.defineProperty(Series.prototype, "_positionBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_bullet) {
        }
    });
    Object.defineProperty(Series.prototype, "_placeBulletsContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (chart) {
            chart.bulletsContainer.children.moveValue(this.bulletsContainer);
        }
    });
    Object.defineProperty(Series.prototype, "_removeBulletsContainer", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var bulletsContainer = this.bulletsContainer;
            if (bulletsContainer.parent) {
                bulletsContainer.parent.children.removeValue(bulletsContainer);
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Series.prototype, "disposeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var bullets = dataItem.bullets;
            if (bullets) {
                each(bullets, function (bullet) {
                    bullet.dispose();
                });
            }
        }
    });
    Object.defineProperty(Series.prototype, "_getItemReaderLabel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            return "";
        }
    });
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(Series.prototype, "showDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, bullets;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.showDataItem.call(this, dataItem, duration)];
                            bullets = dataItem.bullets;
                            if (bullets) {
                                each(bullets, function (bullet) {
                                    promises.push(bullet.get("sprite").show(duration));
                                });
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(Series.prototype, "hideDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, bullets;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.hideDataItem.call(this, dataItem, duration)];
                            bullets = dataItem.bullets;
                            if (bullets) {
                                each(bullets, function (bullet) {
                                    promises.push(bullet.get("sprite").hide(duration));
                                });
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    Object.defineProperty(Series.prototype, "_sequencedShowHide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (show, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var startIndex_2, endIndex_2;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.get("sequencedInterpolation")) return [3 /*break*/, 4];
                            if (!isNumber(duration)) {
                                duration = this.get("interpolationDuration", 0);
                            }
                            if (!(duration > 0)) return [3 /*break*/, 2];
                            startIndex_2 = this.startIndex();
                            endIndex_2 = this.endIndex();
                            return [4 /*yield*/, Promise.all(map(this.dataItems, function (dataItem, i) { return __awaiter(_this, void 0, void 0, function () {
                                    var realDuration, delay;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                realDuration = duration || 0;
                                                if (i < startIndex_2 - 10 || i > endIndex_2 + 10) {
                                                    realDuration = 0;
                                                }
                                                delay = this.get("sequencedDelay", 0) + realDuration / (endIndex_2 - startIndex_2);
                                                return [4 /*yield*/, sleep(delay * (i - startIndex_2))];
                                            case 1:
                                                _a.sent();
                                                if (!show) return [3 /*break*/, 3];
                                                return [4 /*yield*/, this.showDataItem(dataItem, realDuration)];
                                            case 2:
                                                _a.sent();
                                                return [3 /*break*/, 5];
                                            case 3: return [4 /*yield*/, this.hideDataItem(dataItem, realDuration)];
                                            case 4:
                                                _a.sent();
                                                _a.label = 5;
                                            case 5: return [2 /*return*/];
                                        }
                                    });
                                }); }))];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, Promise.all(map(this.dataItems, function (dataItem) {
                                if (show) {
                                    return _this.showDataItem(dataItem, 0);
                                }
                                else {
                                    return _this.hideDataItem(dataItem, 0);
                                }
                            }))];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Series.prototype, "updateLegendValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var legendDataItem = dataItem.get("legendDataItem");
            if (legendDataItem) {
                var valueLabel = legendDataItem.get("valueLabel");
                if (valueLabel) {
                    var text = valueLabel.text;
                    var txt = "";
                    valueLabel._setDataItem(dataItem);
                    txt = this.get("legendValueText", text.get("text", ""));
                    valueLabel.set("text", txt);
                    text.markDirtyText();
                }
                var label = legendDataItem.get("label");
                if (label) {
                    var text = label.text;
                    var txt = "";
                    label._setDataItem(dataItem);
                    txt = this.get("legendLabelText", text.get("text", ""));
                    label.set("text", txt);
                    text.markDirtyText();
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Series.prototype, "updateLegendMarker", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
        }
    });
    Object.defineProperty(Series.prototype, "_onHide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._onHide.call(this);
            var tooltip = this.getTooltip();
            if (tooltip) {
                tooltip.hide();
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Series.prototype, "hoverDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(Series.prototype, "unhoverDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
        }
    });
    Object.defineProperty(Series, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Series"
    });
    Object.defineProperty(Series, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Component.classNames.concat([Series.className])
    });
    return Series;
}(Component));

//# sourceMappingURL=Series.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js










/**
 * @ignore
 */
function min(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right < left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * @ignore
 */
function max(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right > left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * A base class for all XY chart series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/} for more info
 */
var XYSeries = /** @class */ (function (_super) {
    __extends(XYSeries, _super);
    function XYSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_xField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_yField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_xOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_yOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_xLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_xHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_yLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_yHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_axesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_stackDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_selectionProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_dataSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_mainContainerMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * A [[Container]] that us used to put series' elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(_this, "mainContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _this.children.push(Container.new(_this._root, {}))
        });
        /**
         * A list of axis ranges that affect the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         */
        Object.defineProperty(_this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new List()
        });
        Object.defineProperty(_this, "_skipped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(_this, "_couldStackTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(_this, "_reallyStackedTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_stackedSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(_this, "_aLocationX0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_aLocationX1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_aLocationY0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_aLocationY1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(_this, "_showBullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(_this, "valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueX",
                "openValueX",
                "lowValueX",
                "highValueX"
            ]
        });
        Object.defineProperty(_this, "valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueY",
                "openValueY",
                "lowValueY",
                "highValueY"
            ]
        });
        Object.defineProperty(_this, "_valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for full min/max
        Object.defineProperty(_this, "_valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for selection (uses working)
        Object.defineProperty(_this, "__valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "__valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_emptyDataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new DataItem(_this, undefined, {})
        });
        Object.defineProperty(_this, "_dataSetId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_tooltipFieldX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(_this, "_tooltipFieldY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        return _this;
    }
    Object.defineProperty(XYSeries.prototype, "_afterNew", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY");
            this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY");
            this._setRawDefault("vcx", 1);
            this._setRawDefault("vcy", 1);
            // this can't go to themes, as data might be parsed before theme
            this._setRawDefault("valueXShow", "valueXWorking");
            this._setRawDefault("valueYShow", "valueYWorking");
            this._setRawDefault("openValueXShow", "openValueXWorking");
            this._setRawDefault("openValueYShow", "openValueYWorking");
            this._setRawDefault("lowValueXShow", "lowValueXWorking");
            this._setRawDefault("lowValueYShow", "lowValueYWorking");
            this._setRawDefault("highValueXShow", "highValueXWorking");
            this._setRawDefault("highValueYShow", "highValueYWorking");
            this._setRawDefault("lowValueXGrouped", "low");
            this._setRawDefault("lowValueYGrouped", "low");
            this._setRawDefault("highValueXGrouped", "high");
            this._setRawDefault("highValueYGrouped", "high");
            _super.prototype._afterNew.call(this);
            this._settings.xAxis.series.push(this);
            this._settings.yAxis.series.push(this);
            this.set("maskContent", true);
            this._disposers.push(this.axisRanges.events.onAll(function (change) {
                if (change.type === "clear") {
                    each(change.oldValues, function (axisRange) {
                        _this._removeAxisRange(axisRange);
                    });
                }
                else if (change.type === "push") {
                    _this._processAxisRange(change.newValue);
                }
                else if (change.type === "setIndex") {
                    _this._processAxisRange(change.newValue);
                }
                else if (change.type === "insertIndex") {
                    _this._processAxisRange(change.newValue);
                }
                else if (change.type === "removeIndex") {
                    _this._removeAxisRange(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    _this._processAxisRange(change.value);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
            }));
            if (!this.get("baseAxis")) {
                var xAxis = this.get("xAxis");
                var yAxis = this.get("yAxis");
                if (yAxis.isType("CategoryAxis") || yAxis.isType("DateAxis")) {
                    this.set("baseAxis", yAxis);
                }
                else {
                    this.set("baseAxis", xAxis);
                }
            }
            this.states.create("hidden", { opacity: 1, visible: false });
            this._makeFieldNames();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_processAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axisRange) {
            var container = Container.new(this._root, {});
            axisRange.container = container;
            this.children.push(container);
            axisRange.series = this;
            var axisDataItem = axisRange.axisDataItem;
            axisDataItem.setRaw("isRange", true);
            var axis = axisDataItem.component;
            if (axis) {
                axis._processAxisRange(axisDataItem, ["range", "series"]);
                var bullet = axisDataItem.get("bullet");
                if (bullet) {
                    var sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.setPrivate("visible", false);
                    }
                }
                var axisFill = axisDataItem.get("axisFill");
                if (axisFill) {
                    container.set("mask", axisFill);
                }
                axis._seriesAxisRanges.push(axisDataItem);
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_removeAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axisRange) {
            var axisDataItem = axisRange.axisDataItem;
            var axis = axisDataItem.component;
            axis.disposeDataItem(axisDataItem);
            remove(axis._seriesAxisRanges, axisDataItem);
            var container = axisRange.container;
            if (container) {
                container.dispose();
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_updateFields", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._updateFields.call(this);
            this._valueXFields = [];
            this._valueYFields = [];
            this._valueXShowFields = [];
            this._valueYShowFields = [];
            this.__valueXShowFields = [];
            this.__valueYShowFields = [];
            if (this.valueXFields) {
                each(this.valueXFields, function (key) {
                    var field = _this.get((key + "Field"));
                    if (field) {
                        _this._valueXFields.push(key);
                        var field_1 = _this.get((key + "Show"));
                        _this.__valueXShowFields.push(field_1);
                        if (field_1.indexOf("Working") != -1) {
                            _this._valueXShowFields.push(field_1.split("Working")[0]);
                        }
                        else {
                            _this._valueYShowFields.push(field_1);
                        }
                    }
                });
            }
            if (this.valueYFields) {
                each(this.valueYFields, function (key) {
                    var field = _this.get((key + "Field"));
                    if (field) {
                        _this._valueYFields.push(key);
                        var field_2 = _this.get((key + "Show"));
                        _this.__valueYShowFields.push(field_2);
                        if (field_2.indexOf("Working") != -1) {
                            _this._valueYShowFields.push(field_2.split("Working")[0]);
                        }
                        else {
                            _this._valueYShowFields.push(field_2);
                        }
                    }
                });
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_dispose", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._dispose.call(this);
            var chart = this.chart;
            if (chart) {
                chart.series.removeValue(this);
            }
            removeFirst(this.get("xAxis").series, this);
            removeFirst(this.get("yAxis").series, this);
        }
    });
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    Object.defineProperty(XYSeries.prototype, "_min", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var newValue = min(this.getPrivate(key), value);
            this.setPrivate(key, newValue);
        }
    });
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    Object.defineProperty(XYSeries.prototype, "_max", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (key, value) {
            var newValue = max(this.getPrivate(key), value);
            this.setPrivate(key, newValue);
        }
    });
    Object.defineProperty(XYSeries.prototype, "_shouldMakeBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            if (!this.get("xAxis").inited || !this.get("yAxis").inited) {
                return false;
            }
            if (dataItem.get(this._xField) != null && dataItem.get(this._yField) != null) {
                return true;
            }
            return false;
        }
    });
    Object.defineProperty(XYSeries.prototype, "_makeFieldNames", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var xName = xAxis.getPrivate("name");
            var xCapName = capitalizeFirst(xName);
            var yName = yAxis.getPrivate("name");
            var yCapName = capitalizeFirst(yName);
            var xLetter = xAxis.get("renderer").getPrivate("letter");
            var yLetter = yAxis.get("renderer").getPrivate("letter");
            var open = "open";
            var low = "low";
            var high = "high";
            var show = "Show";
            if (xAxis.className === "ValueAxis") {
                this._xField = this.get((xName + xLetter + show));
                this._xOpenField = this.get((open + xCapName + xLetter + show));
                this._xLowField = this.get((low + xCapName + xLetter + show));
                this._xHighField = this.get((high + xCapName + xLetter + show));
            }
            else {
                this._xField = (xName + xLetter);
                this._xOpenField = (open + xCapName + xLetter);
                this._xLowField = (low + xCapName + xLetter);
                this._xHighField = (high + xCapName + xLetter);
            }
            if (yAxis.className === "ValueAxis") {
                this._yField = this.get((yName + yLetter + show));
                this._yOpenField = this.get((open + yCapName + yLetter + show));
                this._yLowField = this.get((low + yCapName + yLetter + show));
                this._yHighField = this.get((high + yCapName + yLetter + show));
            }
            else {
                this._yField = (yName + yLetter);
                this._yOpenField = (open + yCapName + yLetter);
                this._yLowField = (low + yCapName + yLetter);
                this._yHighField = (high + yCapName + yLetter);
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_fixVC", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var baseAxis = this.get("baseAxis");
            var hiddenState = this.states.lookup("hidden");
            var sequencedInterpolation = this.get("sequencedInterpolation");
            if (hiddenState) {
                var value = 0;
                if (sequencedInterpolation) {
                    value = 0.999999999999; // makes animate, good for stacked
                }
                if (xAxis === baseAxis) {
                    hiddenState.set("vcy", value);
                }
                else if (yAxis === baseAxis) {
                    hiddenState.set("vcx", value);
                }
                else {
                    hiddenState.set("vcy", value);
                    hiddenState.set("vcx", value);
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_handleMaskBullets", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.isDirty("maskBullets")) {
                this.bulletsContainer.set("maskContent", this.get("maskBullets"));
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._prepareChildren.call(this);
            this.set("width", this.get("xAxis").width());
            this.set("height", this.get("yAxis").height());
            this._handleMaskBullets();
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var baseAxis = this.get("baseAxis");
            var tooltipPositionX = this.get("tooltipPositionX");
            var tooltipFieldX;
            switch (tooltipPositionX) {
                case "open":
                    tooltipFieldX = this._xOpenField;
                    break;
                case "low":
                    tooltipFieldX = this._xLowField;
                    break;
                case "high":
                    tooltipFieldX = this._xHighField;
                    break;
                default:
                    tooltipFieldX = this._xField;
            }
            this._tooltipFieldX = tooltipFieldX;
            var tooltipPositionY = this.get("tooltipPositionY");
            var tooltipFieldY;
            switch (tooltipPositionY) {
                case "open":
                    tooltipFieldY = this._yOpenField;
                    break;
                case "low":
                    tooltipFieldY = this._yLowField;
                    break;
                case "high":
                    tooltipFieldY = this._yHighField;
                    break;
                default:
                    tooltipFieldY = this._yField;
            }
            this._tooltipFieldY = tooltipFieldY;
            if (this.isDirty("baseAxis")) {
                this._fixVC();
            }
            if (xAxis === baseAxis) {
                this.set("y", yAxis.y() - relativeToValue(yAxis.get("centerY", 0), yAxis.height()) - yAxis.parent.get("paddingTop", 0));
                this.bulletsContainer.set("y", this.y());
            }
            else if (yAxis === baseAxis) {
                this.set("x", xAxis.x() - relativeToValue(xAxis.get("centerX", 0), xAxis.width()) - xAxis.parent.get("paddingLeft", 0));
                this.bulletsContainer.set("x", this.x());
            }
            var stacked = this.get("stacked");
            if (this.isDirty("stacked")) {
                if (stacked) {
                    if (this._valuesDirty && !this._dataProcessed) {
                    }
                    else {
                        this._stack();
                    }
                }
                else {
                    this._unstack();
                }
            }
            if (this._valuesDirty && !this._dataProcessed) {
                this._dataProcessed = true;
                if (stacked) {
                    this._stack();
                }
                each(this.dataItems, function (dataItem) {
                    each(_this._valueXShowFields, function (key) {
                        var value = dataItem.get(key);
                        if (value != null) {
                            if (stacked) {
                                value += _this.getStackedXValue(dataItem, key);
                            }
                            _this._min("minX", value);
                            _this._max("maxX", value);
                        }
                    });
                    each(_this._valueYShowFields, function (key) {
                        var value = dataItem.get(key);
                        if (value != null) {
                            if (stacked) {
                                value += _this.getStackedYValue(dataItem, key);
                            }
                            _this._min("minY", value);
                            _this._max("maxY", value);
                        }
                    });
                    xAxis.processSeriesDataItem(dataItem, _this._valueXFields);
                    yAxis.processSeriesDataItem(dataItem, _this._valueYFields);
                });
                xAxis._seriesValuesDirty = true;
                yAxis._seriesValuesDirty = true;
                if (!this.get("ignoreMinMax")) {
                    if (this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) {
                        xAxis.markDirtyExtremes();
                    }
                    if (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) {
                        yAxis.markDirtyExtremes();
                    }
                }
                this._markStakedDirtyStack();
                //this.updateLegendMarker(undefined); // causes legend marker to change color instantly when on
                this.updateLegendValue(undefined);
            }
            if (this.isDirty("vcx") || this.isDirty("vcy")) {
                this._markStakedDirtyStack();
            }
            if (!this._dataGrouped) {
                xAxis._groupSeriesData(this);
                yAxis._groupSeriesData(this);
                this._dataGrouped = true;
            }
            if ((this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty)) {
                var startIndex = this.startIndex();
                var endIndex = this.endIndex();
                var minBulletDistance = this.get("minBulletDistance", 0);
                if (minBulletDistance > 0 && baseAxis) {
                    if (baseAxis.get("renderer").axisLength() / (endIndex - startIndex) > minBulletDistance) {
                        this._showBullets = true;
                    }
                    else {
                        this._showBullets = false;
                    }
                }
                if ((this._psi != startIndex || this._pei != endIndex || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
                    this._selectionProcessed = true;
                    var vcx = this.get("vcx", 1);
                    var vcy = this.get("vcy", 1);
                    var stacked_1 = this.get("stacked", false);
                    if (baseAxis === xAxis) {
                        yAxis._calculateTotals();
                        this.setPrivateRaw("selectionMinY", undefined);
                        this.setPrivateRaw("selectionMaxY", undefined);
                        for (var i = startIndex; i < endIndex; i++) {
                            this.processYSelectionDataItem(this.dataItems[i], vcy, stacked_1);
                        }
                    }
                    else if (baseAxis === yAxis) {
                        xAxis._calculateTotals();
                        this.setPrivateRaw("selectionMinX", undefined);
                        this.setPrivateRaw("selectionMaxX", undefined);
                        for (var i = startIndex; i < endIndex; i++) {
                            this.processXSelectionDataItem(this.dataItems[i], vcx, stacked_1);
                        }
                    }
                    if (baseAxis === xAxis) {
                        if (this.get("valueYShow") !== "valueYWorking") {
                            this.setPrivateRaw("minY", this.getPrivate("selectionMinY"));
                            this.setPrivateRaw("maxY", this.getPrivate("selectionMaxY"));
                            yAxis.markDirtyExtremes();
                        }
                    }
                    else if (baseAxis === yAxis) {
                        if (this.get("valueXShow") !== "valueXWorking") {
                            this.setPrivateRaw("minX", this.getPrivate("selectionMinX"));
                            this.setPrivateRaw("maxX", this.getPrivate("selectionMaxX"));
                            xAxis.markDirtyExtremes();
                        }
                    }
                    if (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) {
                        xAxis.markDirtySelectionExtremes();
                    }
                    if (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) {
                        yAxis.markDirtySelectionExtremes();
                    }
                    // this.updateLegendValue(undefined); flickers while panning
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_makeRangeMask", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            if (this.axisRanges.length > 0) {
                var mainContainerMask_1 = this._mainContainerMask;
                if (mainContainerMask_1 == null) {
                    mainContainerMask_1 = this.children.push(Graphics.new(this._root, {}));
                    this._mainContainerMask = mainContainerMask_1;
                    mainContainerMask_1.set("draw", function (display, target) {
                        var parent = _this.parent;
                        if (parent) {
                            var w = _this._root.container.width();
                            var h = _this._root.container.height();
                            display.moveTo(-w, -h);
                            display.lineTo(-w, h * 2);
                            display.lineTo(w * 2, h * 2);
                            display.lineTo(w * 2, -h);
                            display.lineTo(-w, -h);
                            _this.axisRanges.each(function (axisRange) {
                                var fill = axisRange.axisDataItem.get("axisFill");
                                if (parent) {
                                    if (fill) {
                                        var draw = fill.get("draw");
                                        if (draw) {
                                            draw(display, target);
                                        }
                                    }
                                }
                            });
                        }
                        _this.mainContainer._display.mask = mainContainerMask_1._display;
                    });
                }
                mainContainerMask_1.markDirty();
                mainContainerMask_1._markDirtyKey("fill");
            }
            else {
                this.mainContainer._display.mask = null;
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._updateChildren.call(this);
            // save for performance
            this._x = this.x();
            this._y = this.y();
            this._makeRangeMask();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_stack", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var chart = this.chart;
            if (chart) {
                var seriesIndex = chart.series.indexOf(this);
                this._couldStackTo = [];
                if (seriesIndex > 0) {
                    var series = void 0;
                    for (var i = seriesIndex - 1; i >= 0; i--) {
                        series = chart.series.getIndex(i);
                        if (series.get("xAxis") === this.get("xAxis") && series.get("yAxis") === this.get("yAxis") && series.className === this.className) {
                            this._couldStackTo.push(series);
                            if (!series.get("stacked")) {
                                break;
                            }
                        }
                    }
                }
                this._stackDataItems();
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_unstack", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            Object_each(this._reallyStackedTo, function (_key, value) {
                delete (value._stackedSeries[_this.uid]);
            });
            this._reallyStackedTo = {};
            each(this.dataItems, function (dataItem) {
                dataItem.setRaw("stackToItemY", undefined);
                dataItem.setRaw("stackToItemX", undefined);
            });
        }
    });
    Object.defineProperty(XYSeries.prototype, "_stackDataItems", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            // this works only with the same number of data @todo: search by date/category?
            var baseAxis = this.get("baseAxis");
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var field;
            var stackToItemKey;
            if (baseAxis === xAxis) {
                field = "valueY";
                stackToItemKey = "stackToItemY";
            }
            else if (baseAxis === yAxis) {
                field = "valueX";
                stackToItemKey = "stackToItemX";
            }
            var len = this._couldStackTo.length;
            var index = 0;
            var stackToNegative = this.get("stackToNegative");
            this._reallyStackedTo = {};
            each(this.dataItems, function (dataItem) {
                for (var s = 0; s < len; s++) {
                    var stackToSeries = _this._couldStackTo[s];
                    var stackToItem = stackToSeries.dataItems[index];
                    var value = dataItem.get(field);
                    if (stackToItem) {
                        var stackValue = stackToItem.get(field);
                        if (stackToNegative) {
                            if (isNumber(value)) {
                                if (isNumber(stackValue)) {
                                    if (value >= 0 && stackValue >= 0) {
                                        dataItem.setRaw(stackToItemKey, stackToItem);
                                        _this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                        stackToSeries._stackedSeries[_this.uid] = _this;
                                        break;
                                    }
                                    if (value < 0 && stackValue < 0) {
                                        dataItem.setRaw(stackToItemKey, stackToItem);
                                        _this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                        stackToSeries._stackedSeries[_this.uid] = _this;
                                        break;
                                    }
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            if (isNumber(value) && isNumber(stackValue)) {
                                dataItem.setRaw(stackToItemKey, stackToItem);
                                _this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                stackToSeries._stackedSeries[_this.uid] = _this;
                                break;
                            }
                        }
                    }
                }
                index++;
            });
        }
    });
    Object.defineProperty(XYSeries.prototype, "processXSelectionDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, vcx, stacked) {
            var _this = this;
            each(this.__valueXShowFields, function (key) {
                var value = dataItem.get(key);
                if (value != null) {
                    if (stacked) {
                        value += _this.getStackedXValueWorking(dataItem, key);
                    }
                    _this._min("selectionMinX", value);
                    _this._max("selectionMaxX", value * vcx);
                }
            });
        }
    });
    Object.defineProperty(XYSeries.prototype, "processYSelectionDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, vcy, stacked) {
            var _this = this;
            each(this.__valueYShowFields, function (key) {
                var value = dataItem.get(key);
                if (value != null) {
                    if (stacked) {
                        value += _this.getStackedYValueWorking(dataItem, key);
                    }
                    _this._min("selectionMinY", value);
                    _this._max("selectionMaxY", value * vcy);
                }
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "getStackedYValueWorking", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, key) {
            var stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                var stackedToSeries = stackToItem.component;
                return stackToItem.get(key, 0) * stackedToSeries.get("vcy", 1) + this.getStackedYValueWorking(stackToItem, key);
            }
            return 0;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "getStackedXValueWorking", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, key) {
            var stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                var stackedToSeries = stackToItem.component;
                return stackToItem.get(key, 0) * stackedToSeries.get("vcx", 1) + this.getStackedXValueWorking(stackToItem, key);
            }
            return 0;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "getStackedYValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, key) {
            var stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                return stackToItem.get(key, 0) + this.getStackedYValue(stackToItem, key);
            }
            return 0;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "getStackedXValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, key) {
            var stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                return stackToItem.get(key, 0) + this.getStackedXValue(stackToItem, key);
            }
            return 0;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "createLegendMarker", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_dataItem) {
            this.updateLegendMarker();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_markDirtyAxes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._axesDirty = true;
            this.markDirty();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_markDataSetDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._afterDataChange();
            this._valuesDirty = true;
            this._dataProcessed = false;
            this._aggregatesCalculated = false;
            this.markDirty();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._axesDirty = false;
            this._selectionProcessed = false;
            this._stackDirty = false;
            this._dataProcessed = false;
        }
    });
    Object.defineProperty(XYSeries.prototype, "_positionBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (bullet) {
            var sprite = bullet.get("sprite");
            if (sprite) {
                var dataItem = sprite.dataItem;
                var locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
                var locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
                var xAxis = this.get("xAxis");
                var yAxis = this.get("yAxis");
                var positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));
                var positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));
                var point = this.getPoint(positionX, positionY);
                var left = dataItem.get("left", point.x);
                var right = dataItem.get("right", point.x);
                var top_1 = dataItem.get("top", point.y);
                var bottom = dataItem.get("bottom", point.y);
                if (this._shouldShowBullet(positionX, positionY)) {
                    if (!bullet.getPrivate("hidden")) {
                        sprite.setPrivate("visible", true);
                    }
                    else {
                        sprite.setPrivate("visible", false);
                    }
                    var w = right - left;
                    var h = bottom - top_1;
                    if (sprite.isType("Label")) {
                        sprite.set("maxWidth", Math.abs(w));
                        sprite.set("maxHeight", Math.abs(h));
                    }
                    var x = left + w * locationX;
                    var y = bottom - h * locationY;
                    sprite.set("x", x);
                    sprite.set("y", y);
                }
                else {
                    sprite.setPrivate("visible", false);
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_shouldShowBullet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_positionX, _positionY) {
            return this._showBullets;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "setDataSet", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (id) {
            if (this._dataSets[id]) {
                this._handleDataSetChange();
                this._dataItems = this._dataSets[id];
                this._markDataSetDirty();
                this._dataSetId = id;
                var type = "datasetchanged";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this, id: id });
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_handleDataSetChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            if (this.bullets.length > 0) {
                each(this._dataItems, function (dataItem) {
                    var bullets = dataItem.bullets;
                    if (bullets) {
                        each(bullets, function (bullet) {
                            var sprite = bullet.get("sprite");
                            if (sprite) {
                                sprite.setPrivate("visible", false);
                            }
                        });
                    }
                });
            }
        }
    });
    /**
     * Shows hidden series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    Object.defineProperty(XYSeries.prototype, "show", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._fixVC();
                            promises = [];
                            promises.push(_super.prototype.show.call(this, duration).then(function () {
                                _this._isShowing = false;
                                var xAxis = _this.get("xAxis");
                                var yAxis = _this.get("yAxis");
                                var baseAxis = _this.get("baseAxis");
                                if (yAxis !== baseAxis) {
                                    yAxis.markDirtySelectionExtremes();
                                }
                                if (xAxis !== baseAxis) {
                                    xAxis.markDirtySelectionExtremes();
                                }
                            }));
                            promises.push(this.bulletsContainer.show(duration));
                            promises.push(this._sequencedShowHide(true, duration));
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Hides series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    Object.defineProperty(XYSeries.prototype, "hide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._fixVC();
                            promises = [];
                            promises.push(_super.prototype.hide.call(this, duration).then(function () {
                                _this._isHiding = false;
                            }));
                            promises.push(this.bulletsContainer.hide(duration));
                            promises.push(this._sequencedShowHide(false, duration));
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(XYSeries.prototype, "showDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, easing;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.showDataItem.call(this, dataItem, duration)];
                            if (!isNumber(duration)) {
                                duration = this.get("stateAnimationDuration", 0);
                            }
                            easing = this.get("stateAnimationEasing");
                            each(this._valueFields, function (key) {
                                promises.push(dataItem.animate({ key: key + "Working", to: dataItem.get(key), duration: duration, easing: easing }).waitForStop());
                            });
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(XYSeries.prototype, "hideDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, hiddenState, easing, xAxis, yAxis, baseAxis, stacked, min_1, baseValue_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.hideDataItem.call(this, dataItem, duration)];
                            hiddenState = this.states.create("hidden", {});
                            if (!isNumber(duration)) {
                                duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));
                            }
                            easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));
                            xAxis = this.get("xAxis");
                            yAxis = this.get("yAxis");
                            baseAxis = this.get("baseAxis");
                            stacked = this.get("stacked");
                            if (baseAxis === xAxis || !baseAxis) {
                                each(this._valueYFields, function (key) {
                                    var min = yAxis.getPrivate("min");
                                    var baseValue = yAxis.baseValue();
                                    if (isNumber(min) && min > baseValue) {
                                        baseValue = min;
                                    }
                                    if (stacked) {
                                        baseValue = 0;
                                    }
                                    promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                                });
                            }
                            if (baseAxis === yAxis || !baseAxis) {
                                min_1 = xAxis.getPrivate("min");
                                baseValue_1 = xAxis.baseValue();
                                if (isNumber(min_1) && min_1 > baseValue_1) {
                                    baseValue_1 = min_1;
                                }
                                if (stacked) {
                                    baseValue_1 = 0;
                                }
                                each(this._valueXFields, function (key) {
                                    promises.push(dataItem.animate({ key: key + "Working", to: baseValue_1, duration: duration, easing: easing }).waitForStop());
                                });
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    Object.defineProperty(XYSeries.prototype, "_markDirtyStack", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this._stackDirty = true;
            this.markDirty();
            this._markStakedDirtyStack();
        }
    });
    Object.defineProperty(XYSeries.prototype, "_markStakedDirtyStack", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var stackedSeries = this._stackedSeries;
            if (stackedSeries) {
                Object_each(stackedSeries, function (_key, value) {
                    if (!value._stackDirty) {
                        value._markDirtyStack();
                    }
                });
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_afterChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterChanged.call(this);
            if (this._skipped) {
                this._markDirtyAxes();
                this._skipped = false;
            }
        }
    });
    /**
     * Shows a tooltip for specific data item.
     *
     * @param  dataItem  Data item
     */
    Object.defineProperty(XYSeries.prototype, "showDataItemTooltip", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            this.updateLegendMarker(dataItem);
            this.updateLegendValue(dataItem);
            if (this.get("tooltip")) {
                if (!this.isHidden()) {
                    var tooltip = this.get("tooltip");
                    if (tooltip) {
                        tooltip._setDataItem(dataItem);
                        if (dataItem) {
                            var locationX = this.get("locationX", 0);
                            var locationY = this.get("locationY", 1);
                            var itemLocationX = dataItem.get("locationX", locationX);
                            var itemLocationY = dataItem.get("locationY", locationY);
                            var xAxis = this.get("xAxis");
                            var yAxis = this.get("yAxis");
                            var vcx = this.get("vcx", 1);
                            var vcy = this.get("vcy", 1);
                            var xPos = xAxis.getDataItemPositionX(dataItem, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * itemLocationX, vcx);
                            var yPos = yAxis.getDataItemPositionY(dataItem, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * itemLocationY, vcy);
                            var point = this.getPoint(xPos, yPos);
                            var show_1 = true;
                            each(this._valueFields, function (field) {
                                if (dataItem.get(field) == null) {
                                    show_1 = false;
                                }
                            });
                            if (show_1) {
                                var chart = this.chart;
                                if (chart && chart.inPlot(point)) {
                                    tooltip.label.text.markDirtyText();
                                    tooltip.set("tooltipTarget", this._getTooltipTarget(dataItem));
                                    tooltip.set("pointTo", this._display.toGlobal({ x: point.x, y: point.y }));
                                }
                                else {
                                    tooltip._setDataItem(undefined);
                                }
                            }
                            else {
                                tooltip._setDataItem(undefined);
                            }
                        }
                    }
                }
                else {
                    this.hideTooltip();
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_getTooltipTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            if (this.get("seriesTooltipTarget") == "bullet") {
                var bullets = dataItem.bullets;
                if (bullets && bullets.length > 0) {
                    var bullet = bullets[0];
                    var sprite = bullet.get("sprite");
                    if (sprite) {
                        return sprite;
                    }
                }
            }
            return this;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "updateLegendValue", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                var label = legendDataItem.get("label");
                if (label) {
                    var txt = "";
                    if (dataItem) {
                        label._setDataItem(dataItem);
                        txt = this.get("legendLabelText", label.get("text", this.get("name", "")));
                    }
                    else {
                        label._setDataItem(this._emptyDataItem);
                        txt = this.get("legendRangeLabelText", this.get("legendLabelText", label.get("text", this.get("name", ""))));
                    }
                    label.set("text", txt);
                }
                var valueLabel = legendDataItem.get("valueLabel");
                if (valueLabel) {
                    var txt = "";
                    if (dataItem) {
                        valueLabel._setDataItem(dataItem);
                        txt = this.get("legendValueText", valueLabel.get("text", ""));
                    }
                    else {
                        valueLabel._setDataItem(this._emptyDataItem);
                        txt = this.get("legendRangeValueText", valueLabel.get("text", ""));
                    }
                    valueLabel.set("text", txt);
                }
            }
        }
    });
    Object.defineProperty(XYSeries.prototype, "_getItemReaderLabel", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var text = "X: {" + this._xField;
            if (this.get("xAxis").isType("DateAxis")) {
                text += ".formatDate()";
            }
            text += "}; Y: {" + this._yField;
            if (this.get("yAxis").isType("DateAxis")) {
                text += ".formatDate()";
            }
            text += "}";
            return text;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "getPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (positionX, positionY) {
            var x = this.get("xAxis").get("renderer").positionToCoordinate(positionX);
            var y = this.get("yAxis").get("renderer").positionToCoordinate(positionY);
            return { x: x, y: y };
        }
    });
    Object.defineProperty(XYSeries.prototype, "_shouldInclude", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (_position) {
            return true;
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(XYSeries.prototype, "handleCursorHide", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.hideTooltip();
            this.updateLegendValue(undefined);
            this.updateLegendMarker(undefined);
        }
    });
    Object.defineProperty(XYSeries.prototype, "_afterDataChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._afterDataChange.call(this);
            this.resetExtremes();
        }
    });
    // todo description
    Object.defineProperty(XYSeries.prototype, "resetExtremes", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.setPrivate("selectionMinX", undefined);
            this.setPrivate("selectionMaxX", undefined);
            this.setPrivate("selectionMinY", undefined);
            this.setPrivate("selectionMaxY", undefined);
            this.setPrivate("minX", undefined);
            this.setPrivate("minY", undefined);
            this.setPrivate("maxX", undefined);
            this.setPrivate("maxY", undefined);
        }
    });
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    Object.defineProperty(XYSeries.prototype, "createAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axisDataItem) {
            return this.axisRanges.push({
                axisDataItem: axisDataItem
            });
        }
    });
    Object.defineProperty(XYSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYSeries"
    });
    Object.defineProperty(XYSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Series.classNames.concat([XYSeries.className])
    });
    return XYSeries;
}(Series));

//# sourceMappingURL=XYSeries.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js






/**
 * Base class for all "column-based" series
 */
var BaseColumnSeries = /** @class */ (function (_super) {
    __extends(BaseColumnSeries, _super);
    function BaseColumnSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_ph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(_this, "_pw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        return _this;
    }
    Object.defineProperty(BaseColumnSeries.prototype, "_makeGraphics", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (listTemplate, dataItem) {
            return this.makeColumn(dataItem, listTemplate);
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_makeFieldNames", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._makeFieldNames.call(this);
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var categoryAxis = "CategoryAxis";
            var valueAxis = "ValueAxis";
            if (xAxis.isType(categoryAxis)) {
                if (!this.get("openCategoryXField")) {
                    this._xOpenField = this._xField;
                }
            }
            if (xAxis.isType(valueAxis)) {
                if (!this.get("openValueXField")) {
                    this._xOpenField = this._xField;
                }
            }
            if (yAxis.isType(categoryAxis)) {
                if (!this.get("openCategoryYField")) {
                    this._yOpenField = this._yField;
                }
            }
            if (yAxis.isType(valueAxis)) {
                if (!this.get("openValueYField")) {
                    this._yOpenField = this._yField;
                }
            }
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_prepareChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._prepareChildren.call(this);
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var len = this.dataItems.length;
            var startIndex = Math.max(0, this.startIndex() - 2);
            var endIndex = Math.min(this.endIndex() + 2, len - 1);
            if (xAxis.inited && yAxis.inited) {
                for (var i = startIndex; i <= endIndex; i++) {
                    var dataItem = this.dataItems[i];
                    this._createGraphics(dataItem);
                }
            }
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_updateChildren", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            var chart = this.chart;
            if (chart) {
                this._ph = chart.plotContainer.height();
                this._pw = chart.plotContainer.width();
            }
            var xAxis = this.get("xAxis");
            var yAxis = this.get("yAxis");
            var baseAxis = this.get("baseAxis");
            var columnsTemplate = this.columns.template;
            if (this.isDirty("fill")) {
                if (columnsTemplate.get("fill") == null) {
                    columnsTemplate.set("fill", this.get("fill"));
                }
            }
            if (this.isDirty("stroke")) {
                if (columnsTemplate.get("stroke") == null) {
                    columnsTemplate.set("stroke", this.get("stroke"));
                }
            }
            var index = 0;
            var clusterCount = 0;
            var i = 0;
            each(baseAxis.series, function (series) {
                if (series instanceof BaseColumnSeries) {
                    var stacked = series.get("stacked");
                    if (stacked && i == 0) {
                        clusterCount++;
                    }
                    if (!stacked && series.get("clustered")) {
                        clusterCount++;
                    }
                }
                if (series === _this) {
                    index = clusterCount - 1;
                }
                i++;
            });
            if (!this.get("clustered")) {
                index = 0;
                clusterCount = 1;
            }
            if (clusterCount === 0) {
                clusterCount = 1;
                index = 0;
            }
            var xRenderer = xAxis.get("renderer");
            var yRenderer = yAxis.get("renderer");
            var cellStartLocation = "cellStartLocation";
            var cellEndLocation = "cellEndLocation";
            var cellLocationX0 = xRenderer.get(cellStartLocation, 0);
            var cellLocationX1 = xRenderer.get(cellEndLocation, 1);
            var cellLocationY0 = yRenderer.get(cellStartLocation, 0);
            var cellLocationY1 = yRenderer.get(cellEndLocation, 1);
            this._aLocationX0 = cellLocationX0 + (index / clusterCount) * (cellLocationX1 - cellLocationX0);
            this._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);
            ;
            this._aLocationY0 = cellLocationY0 + (index / clusterCount) * (cellLocationY1 - cellLocationY0);
            this._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);
            if (xAxis.inited && yAxis.inited) {
                if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
                    var len = this.dataItems.length;
                    var startIndex = Math.max(0, this.startIndex() - 2);
                    var endIndex = Math.min(this.endIndex() + 2, len - 1);
                    for (var i_1 = 0; i_1 < startIndex; i_1++) {
                        this._toggleColumn(this.dataItems[i_1], false);
                    }
                    var previous = this.dataItems[startIndex];
                    for (var i_2 = startIndex; i_2 <= endIndex; i_2++) {
                        var dataItem = this.dataItems[i_2];
                        if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                            previous = dataItem;
                            if (i_2 > 0 && startIndex > 0) {
                                for (var j = i_2 - 1; j >= 0; j--) {
                                    var dataItem_1 = this.dataItems[j];
                                    if (dataItem_1.get("valueX") != null && dataItem_1.get("valueY") != null) {
                                        previous = dataItem_1;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    for (var i_3 = startIndex; i_3 <= endIndex; i_3++) {
                        var dataItem = this.dataItems[i_3];
                        this._updateGraphics(dataItem, previous);
                        if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                            previous = dataItem;
                        }
                    }
                    for (var i_4 = endIndex + 1; i_4 < len; i_4++) {
                        this._toggleColumn(this.dataItems[i_4], false);
                    }
                }
            }
            else {
                this._skipped = true;
            }
            _super.prototype._updateChildren.call(this);
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_createGraphics", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var _this = this;
            var graphics = dataItem.get("graphics");
            if (!graphics) {
                graphics = this._makeGraphics(this.columns, dataItem);
                dataItem.set("graphics", graphics);
                graphics._setDataItem(dataItem);
                var legendDataItem = dataItem.get("legendDataItem");
                if (legendDataItem) {
                    var markerRectangle = legendDataItem.get("markerRectangle");
                    if (markerRectangle) {
                        markerRectangle.setAll({ fill: graphics.get("fill"), stroke: graphics.get("stroke") });
                    }
                }
                this.axisRanges.each(function (axisRange) {
                    var container = axisRange.container;
                    var graphicsArray = dataItem.get("rangeGraphics", []);
                    dataItem.set("rangeGraphics", graphicsArray);
                    var rangeGraphics = _this._makeGraphics(axisRange.columns, dataItem);
                    graphicsArray.push(rangeGraphics);
                    rangeGraphics.setPrivate("list", axisRange.columns);
                    container.children.push(rangeGraphics);
                });
            }
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_updateGraphics", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, previousDataItem) {
            var _this = this;
            var graphics = dataItem.get("graphics");
            //if (!graphics) {
            //	this._createGraphics(dataItem);
            //	graphics = dataItem.get("graphics")!;
            //}
            var xField = this._xField;
            var yField = this._yField;
            var valueX = dataItem.get(xField);
            var valueY = dataItem.get(yField);
            if (valueX != null && valueY != null) {
                var xOpenField = this._xOpenField;
                var yOpenField = this._yOpenField;
                var locationX = this.get("locationX", dataItem.get("locationX", 0.5));
                var locationY = this.get("locationY", dataItem.get("locationY", 0.5));
                var openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
                var openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
                var width = graphics.get("width");
                var height = graphics.get("height");
                var stacked = this.get("stacked");
                var xAxis = this.get("xAxis");
                var yAxis = this.get("yAxis");
                var baseAxis = this.get("baseAxis");
                var xStart = xAxis.get("start");
                var xEnd = xAxis.get("end");
                var yStart = yAxis.get("start");
                var yEnd = yAxis.get("end");
                var l_1;
                var r_1;
                var t_1;
                var b_1;
                var vcy = this.get("vcy", 1);
                var vcx = this.get("vcx", 1);
                var fitW_1 = false;
                var fitH_1 = false;
                if (yAxis.isType("CategoryAxis") && xAxis.isType("CategoryAxis")) {
                    var startLocation = this._aLocationX0 + openLocationX - 0.5;
                    var endLocation = this._aLocationX1 + locationX - 0.5;
                    if (width instanceof Percent) {
                        var offset = (endLocation - startLocation) * (1 - width.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    l_1 = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                    r_1 = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                    startLocation = this._aLocationY0 + openLocationY - 0.5;
                    endLocation = this._aLocationY1 + locationY - 0.5;
                    if (height instanceof Percent) {
                        var offset = (endLocation - startLocation) * (1 - height.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    t_1 = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                    b_1 = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                    dataItem.setRaw("point", { x: l_1 + (r_1 - l_1) / 2, y: t_1 + (b_1 - t_1) / 2 });
                }
                else if (xAxis === baseAxis) {
                    var startLocation = this._aLocationX0 + openLocationX - 0.5;
                    var endLocation = this._aLocationX1 + locationX - 0.5;
                    if (width instanceof Percent) {
                        var offset = (endLocation - startLocation) * (1 - width.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    l_1 = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                    r_1 = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                    t_1 = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);
                    if (this._yOpenField !== this._yField) {
                        b_1 = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);
                    }
                    else {
                        if (stacked) {
                            var stackToItemY = dataItem.get("stackToItemY");
                            if (stackToItemY) {
                                b_1 = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, stackToItemY.component.get("vcy"));
                            }
                            else {
                                b_1 = yAxis.basePosition();
                            }
                        }
                        else {
                            b_1 = yAxis.basePosition();
                        }
                    }
                    dataItem.setRaw("point", { x: l_1 + (r_1 - l_1) / 2, y: t_1 });
                    fitH_1 = true;
                }
                else if (yAxis === baseAxis) {
                    var startLocation = this._aLocationY0 + openLocationY - 0.5;
                    var endLocation = this._aLocationY1 + locationY - 0.5;
                    if (height instanceof Percent) {
                        var offset = (endLocation - startLocation) * (1 - height.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    t_1 = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                    b_1 = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                    r_1 = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx);
                    if (this._xOpenField !== this._xField) {
                        l_1 = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx);
                    }
                    else {
                        if (stacked) {
                            var stackToItemX = dataItem.get("stackToItemX");
                            if (stackToItemX) {
                                l_1 = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, stackToItemX.component.get("vcx"));
                            }
                            else {
                                l_1 = xAxis.basePosition();
                            }
                        }
                        else {
                            l_1 = xAxis.basePosition();
                        }
                    }
                    fitW_1 = true;
                    dataItem.setRaw("point", { x: r_1, y: t_1 + (b_1 - t_1) / 2 });
                }
                this._updateSeriesGraphics(dataItem, graphics, l_1, r_1, t_1, b_1, fitW_1, fitH_1);
                if ((l_1 < xStart && r_1 < xStart) || (l_1 > xEnd && r_1 > xEnd) || (t_1 < yStart && b_1 < yStart) || (t_1 > yEnd && b_1 > yEnd)) {
                    this._toggleColumn(dataItem, false);
                }
                else {
                    this._toggleColumn(dataItem, true);
                }
                var rangeGraphics = dataItem.get("rangeGraphics");
                if (rangeGraphics) {
                    each(rangeGraphics, function (graphics) {
                        _this._updateSeriesGraphics(dataItem, graphics, l_1, r_1, t_1, b_1, fitW_1, fitH_1);
                    });
                }
                this._applyGraphicsStates(dataItem, previousDataItem);
            }
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_updateSeriesGraphics", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, graphics, l, r, t, b, fitW, fitH) {
            var width = graphics.get("width");
            var height = graphics.get("height");
            var maxWidth = graphics.get("maxWidth");
            var maxHeight = graphics.get("maxHeight");
            var ptl = this.getPoint(l, t);
            var pbr = this.getPoint(r, b);
            var tooltipPoint = dataItem.get("point");
            if (tooltipPoint) {
                var point = this.getPoint(tooltipPoint.x, tooltipPoint.y);
                tooltipPoint.x = point.x + this._x;
                tooltipPoint.y = point.y + this._y;
            }
            l = ptl.x;
            r = pbr.x;
            t = ptl.y;
            b = pbr.y;
            if (isNumber(width)) {
                var offset = ((r - l) - width) / 2;
                l += offset;
                r -= offset;
            }
            if (isNumber(maxWidth) && maxWidth < Math.abs(r - l)) {
                var offset = ((r - l) - maxWidth) / 2;
                l += offset;
                r -= offset;
            }
            if (isNumber(height)) {
                var offset = ((b - t) - height) / 2;
                t += offset;
                b -= offset;
            }
            if (isNumber(maxHeight) && maxHeight < Math.abs(b - t)) {
                var offset = ((b - t) - maxHeight) / 2;
                t += offset;
                b -= offset;
            }
            if (this.get("adjustBulletPosition")) {
                if (fitW) {
                    r = Math.min(Math.max(0, r), this._pw);
                    l = Math.min(Math.max(0, l), this._pw);
                }
                if (fitH) {
                    t = Math.min(Math.max(0, t), this._ph);
                    b = Math.min(Math.max(0, b), this._ph);
                }
            }
            dataItem.setRaw("left", l);
            dataItem.setRaw("right", r);
            dataItem.setRaw("top", t);
            dataItem.setRaw("bottom", b);
            graphics.setPrivate("width", r - l);
            graphics.setPrivate("height", b - t);
            graphics.set("x", l);
            graphics.set("y", b - (b - t));
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_handleDataSetChange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._handleDataSetChange.call(this);
            each(this._dataItems, function (dataItem) {
                _this._toggleColumn(dataItem, false);
            });
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_applyGraphicsStates", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, previousDataItem) {
            var graphics = dataItem.get("graphics");
            var dropFromOpen = graphics.states.lookup("dropFromOpen");
            var riseFromOpen = graphics.states.lookup("riseFromOpen");
            var dropFromPrevious = graphics.states.lookup("dropFromPrevious");
            var riseFromPrevious = graphics.states.lookup("riseFromPrevious");
            if (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {
                var xAxis = this.get("xAxis");
                var yAxis = this.get("yAxis");
                var baseAxis = this.get("baseAxis");
                var open_1;
                var close_1;
                var previousClose = void 0;
                if (baseAxis === xAxis && yAxis.isType("ValueAxis")) {
                    open_1 = dataItem.get(this._yOpenField);
                    close_1 = dataItem.get(this._yField);
                    previousClose = previousDataItem.get(this._yField);
                }
                else if (baseAxis === yAxis && xAxis.isType("ValueAxis")) {
                    open_1 = dataItem.get(this._xOpenField);
                    close_1 = dataItem.get(this._xField);
                    previousClose = previousDataItem.get(this._xField);
                }
                if (isNumber(open_1) && isNumber(close_1)) {
                    if (close_1 < open_1) {
                        if (dropFromOpen) {
                            dropFromOpen.apply();
                        }
                    }
                    else {
                        if (riseFromOpen) {
                            riseFromOpen.apply();
                        }
                    }
                    if (isNumber(previousClose)) {
                        if (close_1 < previousClose) {
                            if (dropFromPrevious) {
                                dropFromPrevious.apply();
                            }
                        }
                        else {
                            if (riseFromPrevious) {
                                riseFromPrevious.apply();
                            }
                        }
                    }
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(BaseColumnSeries.prototype, "disposeDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            _super.prototype.disposeDataItem.call(this, dataItem);
            var graphics = dataItem.get("graphics");
            if (graphics) {
                this.columns.removeValue(graphics);
                graphics.dispose();
            }
            var rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                each(rangeGraphics, function (graphics) {
                    var list = graphics.getPrivate("list");
                    if (list) {
                        list.removeValue(graphics);
                    }
                    graphics.dispose();
                });
            }
        }
    });
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(BaseColumnSeries.prototype, "hideDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, graphics, rangeGraphics;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.hideDataItem.call(this, dataItem, duration)];
                            graphics = dataItem.get("graphics");
                            if (graphics) {
                                promises.push(graphics.hide(duration));
                            }
                            rangeGraphics = dataItem.get("rangeGraphics");
                            if (rangeGraphics) {
                                each(rangeGraphics, function (graphics) {
                                    promises.push(graphics.hide(duration));
                                });
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_toggleColumn", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, visible) {
            var graphics = dataItem.get("graphics");
            if (graphics) {
                graphics.setPrivate("visible", visible);
            }
            var rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                each(rangeGraphics, function (graphics) {
                    graphics.setPrivate("visible", visible);
                });
            }
            var bullets = dataItem.bullets;
            if (bullets) {
                each(bullets, function (bullet) {
                    bullet.setPrivate("hidden", !visible);
                });
            }
        }
    });
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    Object.defineProperty(BaseColumnSeries.prototype, "showDataItem", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, duration) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, graphics, rangeGraphics;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            promises = [_super.prototype.showDataItem.call(this, dataItem, duration)];
                            graphics = dataItem.get("graphics");
                            if (graphics) {
                                promises.push(graphics.show(duration));
                            }
                            rangeGraphics = dataItem.get("rangeGraphics");
                            if (rangeGraphics) {
                                each(rangeGraphics, function (graphics) {
                                    promises.push(graphics.show(duration));
                                });
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(BaseColumnSeries.prototype, "updateLegendMarker", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            var _this = this;
            var legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                var graphics_1 = this.columns.template;
                if (dataItem) {
                    var column = dataItem.get("graphics");
                    if (column) {
                        graphics_1 = column;
                    }
                }
                var markerRectangle_1 = legendDataItem.get("markerRectangle");
                if (markerRectangle_1) {
                    if (!legendDataItem.get("itemContainer").get("disabled")) {
                        each(visualSettings, function (setting) {
                            markerRectangle_1.set(setting, graphics_1.get(setting, _this.get(setting)));
                        });
                    }
                }
            }
        }
    });
    Object.defineProperty(BaseColumnSeries.prototype, "_getTooltipTarget", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem) {
            if (this.get("seriesTooltipTarget") == "bullet") {
                return _super.prototype._getTooltipTarget.call(this, dataItem);
            }
            var column = dataItem.get("graphics");
            if (column) {
                return column;
            }
            return this;
        }
    });
    Object.defineProperty(BaseColumnSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseColumnSeries"
    });
    Object.defineProperty(BaseColumnSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: XYSeries.classNames.concat([BaseColumnSeries.className])
    });
    return BaseColumnSeries;
}(XYSeries));

//# sourceMappingURL=BaseColumnSeries.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js






var ColumnSeries = /** @class */ (function (_super) {
    __extends(ColumnSeries, _super);
    function ColumnSeries() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A [[TemplateList]] of all columns in series.
         *
         * `columns.template` can be used to set default settings for all columns,
         * or to change on existing ones.
         */
        Object.defineProperty(_this, "columns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new ListTemplate(Template.new({}), function () { return RoundedRectangle._new(_this._root, {
                position: "absolute",
                themeTags: mergeTags(_this.columns.template.get("themeTags", []), ["series", "column"])
            }, [_this.columns.template]); })
        });
        return _this;
    }
    /**
     * @ignore
     */
    Object.defineProperty(ColumnSeries.prototype, "makeColumn", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (dataItem, listTemplate) {
            var column = this.mainContainer.children.push(listTemplate.make());
            column._setDataItem(dataItem);
            listTemplate.push(column);
            return column;
        }
    });
    Object.defineProperty(ColumnSeries.prototype, "_processAxisRange", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (axisRange) {
            var _this = this;
            _super.prototype._processAxisRange.call(this, axisRange);
            axisRange.columns = new ListTemplate(Template.new({}), function () { return RoundedRectangle._new(_this._root, {
                position: "absolute",
                themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["series", "column"]),
            }, [_this.columns.template, axisRange.columns.template]); });
        }
    });
    Object.defineProperty(ColumnSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ColumnSeries"
    });
    Object.defineProperty(ColumnSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: BaseColumnSeries.classNames.concat([ColumnSeries.className])
    });
    return ColumnSeries;
}(BaseColumnSeries));

//# sourceMappingURL=ColumnSeries.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js


/**
 * @ignore
 */
var AnimatedTheme = /** @class */ (function (_super) {
    __extends(AnimatedTheme, _super);
    function AnimatedTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(AnimatedTheme.prototype, "setupDefaultRules", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype.setupDefaultRules.call(this);
            this.rule("Component").setAll({
                interpolationDuration: 600
            });
            this.rule("Hierarchy").set("animationDuration", 600);
            this.rule("Scrollbar").set("animationDuration", 600);
            this.rule("Tooltip").set("animationDuration", 300);
            this.rule("MapChart").set("animationDuration", 1000);
            this.rule("MapChart").set("wheelDuration", 300);
            this.rule("Entity").setAll({
                stateAnimationDuration: 600
            });
            this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 });
            this.rule("Tooltip", ["axis"]).setAll({
                animationDuration: 200
            });
            this.rule("WordCloud").set("animationDuration", 500);
        }
    });
    return AnimatedTheme;
}(Theme));

//# sourceMappingURL=AnimatedTheme.js.map
;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/themes/Animated.js

/* harmony default export */ var Animated = (AnimatedTheme);
//# sourceMappingURL=Animated.js.map
;// CONCATENATED MODULE: ./src/app/pages/radio/radio.component.ts






class RadioComponent {
    // @ts-ignore
    constructor(platformId, zone) {
        this.platformId = platformId;
        this.zone = zone;
    }
    // Run the function only in the browser
    browserOnly(f) {
        if ((0,common/* isPlatformBrowser */.NF)(this.platformId)) {
            this.zone.runOutsideAngular(() => {
                f();
            });
        }
    }
    ngAfterViewInit() {
        /* Chart code */
        // Data
        let allData = {
            "2002": {
                "Friendster": 0,
                "Facebook": 0,
                "Flickr": 0,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 0,
                "Instagram": 0,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 0
            },
            "2003": {
                "Friendster": 4470000,
                "Facebook": 0,
                "Flickr": 0,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 0,
                "Instagram": 0,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 0
            },
            "2004": {
                "Friendster": 5970054,
                "Facebook": 0,
                "Flickr": 3675135,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 0,
                "Instagram": 0,
                "MySpace": 980036,
                "Orkut": 4900180,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 0
            },
            "2005": {
                "Friendster": 7459742,
                "Facebook": 0,
                "Flickr": 7399354,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 9731610,
                "Instagram": 0,
                "MySpace": 19490059,
                "Orkut": 9865805,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 1946322
            },
            "2006": {
                "Friendster": 8989854,
                "Facebook": 0,
                "Flickr": 14949270,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 19932360,
                "Instagram": 0,
                "MySpace": 54763260,
                "Orkut": 14966180,
                "Pinterest": 0,
                "Reddit": 248309,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 19878248
            },
            "2007": {
                "Friendster": 24253200,
                "Facebook": 0,
                "Flickr": 29299875,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 29533250,
                "Instagram": 0,
                "MySpace": 69299875,
                "Orkut": 26916562,
                "Pinterest": 0,
                "Reddit": 488331,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 143932250
            },
            "2008": {
                "Friendster": 51008911,
                "Facebook": 100000000,
                "Flickr": 30000000,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 55045618,
                "Instagram": 0,
                "MySpace": 72408233,
                "Orkut": 44357628,
                "Pinterest": 0,
                "Reddit": 1944940,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 294493950
            },
            "2009": {
                "Friendster": 28804331,
                "Facebook": 276000000,
                "Flickr": 41834525,
                "Google Buzz": 0,
                "Google+": 0,
                "Hi5": 57893524,
                "Instagram": 0,
                "MySpace": 70133095,
                "Orkut": 47366905,
                "Pinterest": 0,
                "Reddit": 3893524,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 0,
                "WeChat": 0,
                "Weibo": 0,
                "Whatsapp": 0,
                "YouTube": 413611440
            },
            "2010": {
                "Friendster": 0,
                "Facebook": 517750000,
                "Flickr": 54708063,
                "Google Buzz": 166029650,
                "Google+": 0,
                "Hi5": 59953290,
                "Instagram": 0,
                "MySpace": 68046710,
                "Orkut": 49941613,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 43250000,
                "WeChat": 0,
                "Weibo": 19532900,
                "Whatsapp": 0,
                "YouTube": 480551990
            },
            "2011": {
                "Friendster": 0,
                "Facebook": 766000000,
                "Flickr": 66954600,
                "Google Buzz": 170000000,
                "Google+": 0,
                "Hi5": 46610848,
                "Instagram": 0,
                "MySpace": 46003536,
                "Orkut": 47609080,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 0,
                "Twitter": 92750000,
                "WeChat": 47818400,
                "Weibo": 48691040,
                "Whatsapp": 0,
                "YouTube": 642669824
            },
            "2012": {
                "Friendster": 0,
                "Facebook": 979750000,
                "Flickr": 79664888,
                "Google Buzz": 170000000,
                "Google+": 107319100,
                "Hi5": 0,
                "Instagram": 0,
                "MySpace": 0,
                "Orkut": 45067022,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 146890156,
                "Twitter": 160250000,
                "WeChat": 118123370,
                "Weibo": 79195730,
                "Whatsapp": 0,
                "YouTube": 844638200
            },
            "2013": {
                "Friendster": 0,
                "Facebook": 1170500000,
                "Flickr": 80000000,
                "Google Buzz": 170000000,
                "Google+": 205654700,
                "Hi5": 0,
                "Instagram": 117500000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 0,
                "Reddit": 0,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 293482050,
                "Twitter": 223675000,
                "WeChat": 196523760,
                "Weibo": 118261880,
                "Whatsapp": 300000000,
                "YouTube": 1065223075
            },
            "2014": {
                "Friendster": 0,
                "Facebook": 1334000000,
                "Flickr": 0,
                "Google Buzz": 170000000,
                "Google+": 254859015,
                "Hi5": 0,
                "Instagram": 250000000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 0,
                "Reddit": 135786956,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 388721163,
                "Twitter": 223675000,
                "WeChat": 444232415,
                "Weibo": 154890345,
                "Whatsapp": 498750000,
                "YouTube": 1249451725
            },
            "2015": {
                "Friendster": 0,
                "Facebook": 1516750000,
                "Flickr": 0,
                "Google Buzz": 170000000,
                "Google+": 298950015,
                "Hi5": 0,
                "Instagram": 400000000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 0,
                "Reddit": 163346676,
                "Snapchat": 0,
                "TikTok": 0,
                "Tumblr": 475923363,
                "Twitter": 304500000,
                "WeChat": 660843407,
                "Weibo": 208716685,
                "Whatsapp": 800000000,
                "YouTube": 1328133360
            },
            "2016": {
                "Friendster": 0,
                "Facebook": 1753500000,
                "Flickr": 0,
                "Google Buzz": 0,
                "Google+": 398648000,
                "Hi5": 0,
                "Instagram": 550000000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 143250000,
                "Reddit": 238972480,
                "Snapchat": 238648000,
                "TikTok": 0,
                "Tumblr": 565796720,
                "Twitter": 314500000,
                "WeChat": 847512320,
                "Weibo": 281026560,
                "Whatsapp": 1000000000,
                "YouTube": 1399053600
            },
            "2017": {
                "Friendster": 0,
                "Facebook": 2035750000,
                "Flickr": 0,
                "Google Buzz": 0,
                "Google+": 495657000,
                "Hi5": 0,
                "Instagram": 750000000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 195000000,
                "Reddit": 297394200,
                "Snapchat": 0,
                "TikTok": 239142500,
                "Tumblr": 593783960,
                "Twitter": 328250000,
                "WeChat": 921742750,
                "Weibo": 357569030,
                "Whatsapp": 1333333333,
                "YouTube": 1495657000
            },
            "2018": {
                "Friendster": 0,
                "Facebook": 2255250000,
                "Flickr": 0,
                "Google Buzz": 0,
                "Google+": 430000000,
                "Hi5": 0,
                "Instagram": 1000000000,
                "MySpace": 0,
                "Orkut": 0,
                "Pinterest": 246500000,
                "Reddit": 355000000,
                "Snapchat": 0,
                "TikTok": 500000000,
                "Tumblr": 624000000,
                "Twitter": 329500000,
                "WeChat": 1000000000,
                "Weibo": 431000000,
                "Whatsapp": 1433333333,
                "YouTube": 1900000000
            }
        };
        // Create root element
        // https://www.amcharts.com/docs/v5/getting-started/#Root_element
        let root = Root.new("chartdiv");
        root.numberFormatter.setAll({
            numberFormat: "#a",
            // Group only into M (millions), and B (billions)
            bigNumberPrefixes: [
                { number: 1e6, suffix: "M" },
                { number: 1e9, suffix: "B" }
            ],
            // Do not use small number prefixes at all
            smallNumberPrefixes: []
        });
        //vece=sporije
        let stepDuration = 2000;
        // Set themes
        // https://www.amcharts.com/docs/v5/concepts/themes/
        root.setThemes([Animated.new(root)]);
        // Create chart
        // https://www.amcharts.com/docs/v5/charts/xy-chart/
        let chart = root.container.children.push(XYChart.new(root, {
            panX: true,
            panY: true,
            wheelX: "none",
            wheelY: "none"
        }));
        // We don't want zoom-out button to appear while animating, so we hide it at all
        chart.zoomOutButton.set("forceHidden", true);
        // Create axes
        // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/
        let yRenderer = AxisRendererY.new(root, {
            minGridDistance: 20,
            inversed: true
        });
        // hide grid
        yRenderer.grid.template.set("visible", false);
        let yAxis = chart.yAxes.push(CategoryAxis.new(root, {
            maxDeviation: 0,
            categoryField: "network",
            renderer: yRenderer
        }));
        let xAxis = chart.xAxes.push(ValueAxis.new(root, {
            maxDeviation: 0,
            min: 0,
            strictMinMax: true,
            extraMax: 0.1,
            renderer: AxisRendererX.new(root, {})
        }));
        xAxis.set("interpolationDuration", stepDuration / 10);
        xAxis.set("interpolationEasing", linear);
        // Add series
        // https://www.amcharts.com/docs/v5/charts/xy-chart/series/
        let series = chart.series.push(ColumnSeries.new(root, {
            xAxis: xAxis,
            yAxis: yAxis,
            valueXField: "value",
            categoryYField: "network"
        }));
        // Rounded corners for columns
        series.columns.template.setAll({ cornerRadiusBR: 5, cornerRadiusTR: 5 });
        // Make each column to be of a different color
        series.columns.template.adapters.add("fill", function (fill, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        series.columns.template.adapters.add("stroke", function (stroke, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        // Add label bullet
        series.bullets.push(function () {
            return Bullet.new(root, {
                locationX: 1,
                sprite: Label.new(root, {
                    text: "{valueXWorking.formatNumber('#.# a')}",
                    fill: root.interfaceColors.get("alternativeText"),
                    centerX: p100,
                    centerY: p50,
                    populateText: true
                })
            });
        });
        let label = chart.plotContainer.children.push(Label.new(root, {
            text: "2002",
            fontSize: "8em",
            opacity: 0.2,
            x: p100,
            y: p100,
            centerY: p100,
            centerX: p100
        }));
        // Get series item by category
        function getSeriesItem(category) {
            for (var i = 0; i < series.dataItems.length; i++) {
                let dataItem = series.dataItems[i];
                if (dataItem.get("categoryY") == category) {
                    return dataItem;
                }
            }
            return null;
        }
        // Axis sorting
        function sortCategoryAxis() {
            // sort by value
            series.dataItems.sort(function (x, y) {
                // @ts-ignore
                return y.get("valueX") - x.get("valueX"); // descending
                //return x.get("valueX") - y.get("valueX"); // ascending
            });
            // go through each axis item
            each(yAxis.dataItems, function (dataItem) {
                // get corresponding series item
                let seriesDataItem = getSeriesItem(dataItem.get("category"));
                if (seriesDataItem) {
                    // get index of series data item
                    let index = series.dataItems.indexOf(seriesDataItem);
                    // calculate delta position
                    let deltaPosition = (index - dataItem.get("index", 0)) / series.dataItems.length;
                    // set index to be the same as series data item index
                    if (dataItem.get("index") != index) {
                        dataItem.set("index", index);
                        // set deltaPosition instanlty
                        dataItem.set("deltaPosition", -deltaPosition);
                        // animate delta position to 0
                        dataItem.animate({
                            key: "deltaPosition",
                            to: 0,
                            duration: stepDuration / 2,
                            easing: out(cubic)
                        });
                    }
                }
            });
            // sort axis items by index.
            // This changes the order instantly, but as deltaPosition is set, they keep in the same places and then animate to true positions.
            yAxis.dataItems.sort(function (x, y) {
                // @ts-ignore
                return x.get("index") - y.get("index");
            });
        }
        let year = 2002;
        // update data with values each 1.5 sec
        let interval = setInterval(function () {
            year++;
            if (year > 2018) {
                clearInterval(interval);
                clearInterval(sortInterval);
            }
            updateData();
        }, stepDuration);
        let sortInterval = setInterval(function () {
            sortCategoryAxis();
        }, 100);
        function setInitialData() {
            // @ts-ignore
            let d = allData[year];
            for (var n in d) {
                series.data.push({ network: n, value: d[n] });
                yAxis.data.push({ network: n });
            }
        }
        function updateData() {
            let itemsWithNonZero = 0;
            // @ts-ignore
            if (allData[year]) {
                label.set("text", year.toString());
                each(series.dataItems, function (dataItem) {
                    let category = dataItem.get("categoryY");
                    // @ts-ignore
                    let value = allData[year][category];
                    if (value > 0) {
                        itemsWithNonZero++;
                    }
                    dataItem.animate({
                        key: "valueX",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                    dataItem.animate({
                        key: "valueXWorking",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                });
                yAxis.zoom(0, itemsWithNonZero / yAxis.dataItems.length);
            }
        }
        setInitialData();
        setTimeout(function () {
            year++;
            updateData();
        }, 50);
        // Make stuff animate on load
        // https://www.amcharts.com/docs/v5/concepts/animations/
        series.appear(1000);
        chart.appear(1000, 100);
    }
    ngOnDestroy() {
        // Clean up chart when the component is removed
        this.browserOnly(() => {
            if (this.root) {
                this.root.dispose();
            }
        });
    }
}
RadioComponent.ɵfac = function RadioComponent_Factory(t) { return new (t || RadioComponent)(core/* ɵɵdirectiveInject */.Y36(core/* PLATFORM_ID */.Lbi), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b)); };
RadioComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: RadioComponent, selectors: [["app-radio-cmp"]], decls: 1, vars: 0, consts: [["id", "chartdiv", 2, "width", "100%", "height", "500px"]], template: function RadioComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelement */._UZ(0, "div", 0);
    } }, encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/icons/icons.component.ts

class IconsComponent {
}
IconsComponent.ɵfac = function IconsComponent_Factory(t) { return new (t || IconsComponent)(); };
IconsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: IconsComponent, selectors: [["icons-cmp"]], decls: 414, vars: 0, consts: [[1, "row"], [1, "col-md-12"], [1, "card", "demo-icons"], [1, "card-header"], [1, "card-title"], [1, "card-category"], ["href", "https://nucleoapp.com/?ref=1712"], [1, "card-body", "all-icons"], ["id", "icons-wrapper"], [1, "nc-icon", "nc-air-baloon"], [1, "nc-icon", "nc-album-2"], [1, "nc-icon", "nc-alert-circle-i"], [1, "nc-icon", "nc-align-center"], [1, "nc-icon", "nc-align-left-2"], [1, "nc-icon", "nc-ambulance"], [1, "nc-icon", "nc-app"], [1, "nc-icon", "nc-atom"], [1, "nc-icon", "nc-badge"], [1, "nc-icon", "nc-bag-16"], [1, "nc-icon", "nc-bank"], [1, "nc-icon", "nc-basket"], [1, "nc-icon", "nc-bell-55"], [1, "nc-icon", "nc-bold"], [1, "nc-icon", "nc-book-bookmark"], [1, "nc-icon", "nc-bookmark-2"], [1, "nc-icon", "nc-box-2"], [1, "nc-icon", "nc-box"], [1, "nc-icon", "nc-briefcase-24"], [1, "nc-icon", "nc-bulb-63"], [1, "nc-icon", "nc-bullet-list-67"], [1, "nc-icon", "nc-bus-front-12"], [1, "nc-icon", "nc-button-pause"], [1, "nc-icon", "nc-button-play"], [1, "nc-icon", "nc-button-power"], [1, "nc-icon", "nc-calendar-60"], [1, "nc-icon", "nc-camera-compact"], [1, "nc-icon", "nc-caps-small"], [1, "nc-icon", "nc-cart-simple"], [1, "nc-icon", "nc-chart-bar-32"], [1, "nc-icon", "nc-chart-pie-36"], [1, "nc-icon", "nc-chat-33"], [1, "nc-icon", "nc-check-2"], [1, "nc-icon", "nc-circle-10"], [1, "nc-icon", "nc-cloud-download-93"], [1, "nc-icon", "nc-cloud-upload-94"], [1, "nc-icon", "nc-compass-05"], [1, "nc-icon", "nc-controller-modern"], [1, "nc-icon", "nc-credit-card"], [1, "nc-icon", "nc-delivery-fast"], [1, "nc-icon", "nc-diamond"], [1, "nc-icon", "nc-email-85"], [1, "nc-icon", "nc-favourite-28"], [1, "nc-icon", "nc-glasses-2"], [1, "nc-icon", "nc-globe-2"], [1, "nc-icon", "nc-globe"], [1, "nc-icon", "nc-hat-3"], [1, "nc-icon", "nc-headphones"], [1, "nc-icon", "nc-html5"], [1, "nc-icon", "nc-image"], [1, "nc-icon", "nc-istanbul"], [1, "nc-icon", "nc-key-25"], [1, "nc-icon", "nc-laptop"], [1, "nc-icon", "nc-layout-11"], [1, "nc-icon", "nc-lock-circle-open"], [1, "nc-icon", "nc-map-big"], [1, "nc-icon", "nc-minimal-down"], [1, "nc-icon", "nc-minimal-left"], [1, "nc-icon", "nc-minimal-right"], [1, "nc-icon", "nc-minimal-up"], [1, "nc-icon", "nc-mobile"], [1, "nc-icon", "nc-money-coins"], [1, "nc-icon", "nc-note-03"], [1, "nc-icon", "nc-palette"], [1, "nc-icon", "nc-paper"], [1, "nc-icon", "nc-pin-3"], [1, "nc-icon", "nc-planet"], [1, "nc-icon", "nc-refresh-69"], [1, "nc-icon", "nc-ruler-pencil"], [1, "nc-icon", "nc-satisfied"], [1, "nc-icon", "nc-scissors"], [1, "nc-icon", "nc-send"], [1, "nc-icon", "nc-settings-gear-65"], [1, "nc-icon", "nc-settings"], [1, "nc-icon", "nc-share-66"], [1, "nc-icon", "nc-shop"], [1, "nc-icon", "nc-simple-add"], [1, "nc-icon", "nc-simple-delete"], [1, "nc-icon", "nc-simple-remove"], [1, "nc-icon", "nc-single-02"], [1, "nc-icon", "nc-single-copy-04"], [1, "nc-icon", "nc-sound-wave"], [1, "nc-icon", "nc-spaceship"], [1, "nc-icon", "nc-sun-fog-29"], [1, "nc-icon", "nc-support-17"], [1, "nc-icon", "nc-tablet-2"], [1, "nc-icon", "nc-tag-content"], [1, "nc-icon", "nc-tap-01"], [1, "nc-icon", "nc-tie-bow"], [1, "nc-icon", "nc-tile-56"], [1, "nc-icon", "nc-time-alarm"], [1, "nc-icon", "nc-touch-id"], [1, "nc-icon", "nc-trophy"], [1, "nc-icon", "nc-tv-2"], [1, "nc-icon", "nc-umbrella-13"], [1, "nc-icon", "nc-user-run"], [1, "nc-icon", "nc-vector"], [1, "nc-icon", "nc-watch-time"], [1, "nc-icon", "nc-world-2"], [1, "nc-icon", "nc-zoom-split"]], template: function IconsComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1);
        core/* ɵɵelementStart */.TgZ(2, "div", 2);
        core/* ɵɵelementStart */.TgZ(3, "div", 3);
        core/* ɵɵelementStart */.TgZ(4, "h5", 4);
        core/* ɵɵtext */._uU(5, "100 Awesome Nucleo Icons");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(6, "p", 5);
        core/* ɵɵtext */._uU(7, "Handcrafted by our friends from ");
        core/* ɵɵelementStart */.TgZ(8, "a", 6);
        core/* ɵɵtext */._uU(9, "NucleoApp");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(10, "div", 7);
        core/* ɵɵelementStart */.TgZ(11, "div", 8);
        core/* ɵɵelementStart */.TgZ(12, "section");
        core/* ɵɵelementStart */.TgZ(13, "ul");
        core/* ɵɵelementStart */.TgZ(14, "li");
        core/* ɵɵelement */._UZ(15, "i", 9);
        core/* ɵɵelementStart */.TgZ(16, "p");
        core/* ɵɵtext */._uU(17, "nc-air-baloon");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(18, "li");
        core/* ɵɵelement */._UZ(19, "i", 10);
        core/* ɵɵelementStart */.TgZ(20, "p");
        core/* ɵɵtext */._uU(21, "nc-album-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(22, "li");
        core/* ɵɵelement */._UZ(23, "i", 11);
        core/* ɵɵelementStart */.TgZ(24, "p");
        core/* ɵɵtext */._uU(25, "nc-alert-circle-i");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(26, "li");
        core/* ɵɵelement */._UZ(27, "i", 12);
        core/* ɵɵelementStart */.TgZ(28, "p");
        core/* ɵɵtext */._uU(29, "nc-align-center");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(30, "li");
        core/* ɵɵelement */._UZ(31, "i", 13);
        core/* ɵɵelementStart */.TgZ(32, "p");
        core/* ɵɵtext */._uU(33, "nc-align-left-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(34, "li");
        core/* ɵɵelement */._UZ(35, "i", 14);
        core/* ɵɵelementStart */.TgZ(36, "p");
        core/* ɵɵtext */._uU(37, "nc-ambulance");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(38, "li");
        core/* ɵɵelement */._UZ(39, "i", 15);
        core/* ɵɵelementStart */.TgZ(40, "p");
        core/* ɵɵtext */._uU(41, "nc-app");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(42, "li");
        core/* ɵɵelement */._UZ(43, "i", 16);
        core/* ɵɵelementStart */.TgZ(44, "p");
        core/* ɵɵtext */._uU(45, "nc-atom");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(46, "li");
        core/* ɵɵelement */._UZ(47, "i", 17);
        core/* ɵɵelementStart */.TgZ(48, "p");
        core/* ɵɵtext */._uU(49, "nc-badge");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(50, "li");
        core/* ɵɵelement */._UZ(51, "i", 18);
        core/* ɵɵelementStart */.TgZ(52, "p");
        core/* ɵɵtext */._uU(53, "nc-bag-16");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(54, "li");
        core/* ɵɵelement */._UZ(55, "i", 19);
        core/* ɵɵelementStart */.TgZ(56, "p");
        core/* ɵɵtext */._uU(57, "nc-bank");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(58, "li");
        core/* ɵɵelement */._UZ(59, "i", 20);
        core/* ɵɵelementStart */.TgZ(60, "p");
        core/* ɵɵtext */._uU(61, "nc-basket");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(62, "li");
        core/* ɵɵelement */._UZ(63, "i", 21);
        core/* ɵɵelementStart */.TgZ(64, "p");
        core/* ɵɵtext */._uU(65, "nc-bell-55");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(66, "li");
        core/* ɵɵelement */._UZ(67, "i", 22);
        core/* ɵɵelementStart */.TgZ(68, "p");
        core/* ɵɵtext */._uU(69, "nc-bold");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(70, "li");
        core/* ɵɵelement */._UZ(71, "i", 23);
        core/* ɵɵelementStart */.TgZ(72, "p");
        core/* ɵɵtext */._uU(73, "nc-book-bookmark");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(74, "li");
        core/* ɵɵelement */._UZ(75, "i", 24);
        core/* ɵɵelementStart */.TgZ(76, "p");
        core/* ɵɵtext */._uU(77, "nc-bookmark-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(78, "li");
        core/* ɵɵelement */._UZ(79, "i", 25);
        core/* ɵɵelementStart */.TgZ(80, "p");
        core/* ɵɵtext */._uU(81, "nc-box-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(82, "li");
        core/* ɵɵelement */._UZ(83, "i", 26);
        core/* ɵɵelementStart */.TgZ(84, "p");
        core/* ɵɵtext */._uU(85, "nc-box");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(86, "li");
        core/* ɵɵelement */._UZ(87, "i", 27);
        core/* ɵɵelementStart */.TgZ(88, "p");
        core/* ɵɵtext */._uU(89, "nc-briefcase-24");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(90, "li");
        core/* ɵɵelement */._UZ(91, "i", 28);
        core/* ɵɵelementStart */.TgZ(92, "p");
        core/* ɵɵtext */._uU(93, "nc-bulb-63");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(94, "li");
        core/* ɵɵelement */._UZ(95, "i", 29);
        core/* ɵɵelementStart */.TgZ(96, "p");
        core/* ɵɵtext */._uU(97, "nc-bullet-list-67");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(98, "li");
        core/* ɵɵelement */._UZ(99, "i", 30);
        core/* ɵɵelementStart */.TgZ(100, "p");
        core/* ɵɵtext */._uU(101, "nc-bus-front-12");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(102, "li");
        core/* ɵɵelement */._UZ(103, "i", 31);
        core/* ɵɵelementStart */.TgZ(104, "p");
        core/* ɵɵtext */._uU(105, "nc-button-pause");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(106, "li");
        core/* ɵɵelement */._UZ(107, "i", 32);
        core/* ɵɵelementStart */.TgZ(108, "p");
        core/* ɵɵtext */._uU(109, "nc-button-play");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(110, "li");
        core/* ɵɵelement */._UZ(111, "i", 33);
        core/* ɵɵelementStart */.TgZ(112, "p");
        core/* ɵɵtext */._uU(113, "nc-button-power");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(114, "li");
        core/* ɵɵelement */._UZ(115, "i", 34);
        core/* ɵɵelementStart */.TgZ(116, "p");
        core/* ɵɵtext */._uU(117, "nc-calendar-60");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(118, "li");
        core/* ɵɵelement */._UZ(119, "i", 35);
        core/* ɵɵelementStart */.TgZ(120, "p");
        core/* ɵɵtext */._uU(121, "nc-camera-compact");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(122, "li");
        core/* ɵɵelement */._UZ(123, "i", 36);
        core/* ɵɵelementStart */.TgZ(124, "p");
        core/* ɵɵtext */._uU(125, "nc-caps-small");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(126, "li");
        core/* ɵɵelement */._UZ(127, "i", 37);
        core/* ɵɵelementStart */.TgZ(128, "p");
        core/* ɵɵtext */._uU(129, "nc-cart-simple");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(130, "li");
        core/* ɵɵelement */._UZ(131, "i", 38);
        core/* ɵɵelementStart */.TgZ(132, "p");
        core/* ɵɵtext */._uU(133, "nc-chart-bar-32");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(134, "li");
        core/* ɵɵelement */._UZ(135, "i", 39);
        core/* ɵɵelementStart */.TgZ(136, "p");
        core/* ɵɵtext */._uU(137, "nc-chart-pie-36");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(138, "li");
        core/* ɵɵelement */._UZ(139, "i", 40);
        core/* ɵɵelementStart */.TgZ(140, "p");
        core/* ɵɵtext */._uU(141, "nc-chat-33");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(142, "li");
        core/* ɵɵelement */._UZ(143, "i", 41);
        core/* ɵɵelementStart */.TgZ(144, "p");
        core/* ɵɵtext */._uU(145, "nc-check-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(146, "li");
        core/* ɵɵelement */._UZ(147, "i", 42);
        core/* ɵɵelementStart */.TgZ(148, "p");
        core/* ɵɵtext */._uU(149, "nc-circle-10");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(150, "li");
        core/* ɵɵelement */._UZ(151, "i", 43);
        core/* ɵɵelementStart */.TgZ(152, "p");
        core/* ɵɵtext */._uU(153, "nc-cloud-download-93");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(154, "li");
        core/* ɵɵelement */._UZ(155, "i", 44);
        core/* ɵɵelementStart */.TgZ(156, "p");
        core/* ɵɵtext */._uU(157, "nc-cloud-upload-94");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(158, "li");
        core/* ɵɵelement */._UZ(159, "i", 45);
        core/* ɵɵelementStart */.TgZ(160, "p");
        core/* ɵɵtext */._uU(161, "nc-compass-05");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(162, "li");
        core/* ɵɵelement */._UZ(163, "i", 46);
        core/* ɵɵelementStart */.TgZ(164, "p");
        core/* ɵɵtext */._uU(165, "nc-controller-modern");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(166, "li");
        core/* ɵɵelement */._UZ(167, "i", 47);
        core/* ɵɵelementStart */.TgZ(168, "p");
        core/* ɵɵtext */._uU(169, "nc-credit-card");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(170, "li");
        core/* ɵɵelement */._UZ(171, "i", 48);
        core/* ɵɵelementStart */.TgZ(172, "p");
        core/* ɵɵtext */._uU(173, "nc-delivery-fast");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(174, "li");
        core/* ɵɵelement */._UZ(175, "i", 49);
        core/* ɵɵelementStart */.TgZ(176, "p");
        core/* ɵɵtext */._uU(177, "nc-diamond");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(178, "li");
        core/* ɵɵelement */._UZ(179, "i", 50);
        core/* ɵɵelementStart */.TgZ(180, "p");
        core/* ɵɵtext */._uU(181, "nc-email-85");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(182, "li");
        core/* ɵɵelement */._UZ(183, "i", 51);
        core/* ɵɵelementStart */.TgZ(184, "p");
        core/* ɵɵtext */._uU(185, "nc-favourite-28");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(186, "li");
        core/* ɵɵelement */._UZ(187, "i", 52);
        core/* ɵɵelementStart */.TgZ(188, "p");
        core/* ɵɵtext */._uU(189, "nc-glasses-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(190, "li");
        core/* ɵɵelement */._UZ(191, "i", 53);
        core/* ɵɵelementStart */.TgZ(192, "p");
        core/* ɵɵtext */._uU(193, "nc-globe-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(194, "li");
        core/* ɵɵelement */._UZ(195, "i", 54);
        core/* ɵɵelementStart */.TgZ(196, "p");
        core/* ɵɵtext */._uU(197, "nc-globe");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(198, "li");
        core/* ɵɵelement */._UZ(199, "i", 55);
        core/* ɵɵelementStart */.TgZ(200, "p");
        core/* ɵɵtext */._uU(201, "nc-hat-3");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(202, "li");
        core/* ɵɵelement */._UZ(203, "i", 56);
        core/* ɵɵelementStart */.TgZ(204, "p");
        core/* ɵɵtext */._uU(205, "nc-headphones");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(206, "li");
        core/* ɵɵelement */._UZ(207, "i", 57);
        core/* ɵɵelementStart */.TgZ(208, "p");
        core/* ɵɵtext */._uU(209, "nc-html5");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(210, "li");
        core/* ɵɵelement */._UZ(211, "i", 58);
        core/* ɵɵelementStart */.TgZ(212, "p");
        core/* ɵɵtext */._uU(213, "nc-image");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(214, "li");
        core/* ɵɵelement */._UZ(215, "i", 59);
        core/* ɵɵelementStart */.TgZ(216, "p");
        core/* ɵɵtext */._uU(217, "nc-istanbul");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(218, "li");
        core/* ɵɵelement */._UZ(219, "i", 60);
        core/* ɵɵelementStart */.TgZ(220, "p");
        core/* ɵɵtext */._uU(221, "nc-key-25");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(222, "li");
        core/* ɵɵelement */._UZ(223, "i", 61);
        core/* ɵɵelementStart */.TgZ(224, "p");
        core/* ɵɵtext */._uU(225, "nc-laptop");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(226, "li");
        core/* ɵɵelement */._UZ(227, "i", 62);
        core/* ɵɵelementStart */.TgZ(228, "p");
        core/* ɵɵtext */._uU(229, "nc-layout-11");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(230, "li");
        core/* ɵɵelement */._UZ(231, "i", 63);
        core/* ɵɵelementStart */.TgZ(232, "p");
        core/* ɵɵtext */._uU(233, "nc-lock-circle-open");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(234, "li");
        core/* ɵɵelement */._UZ(235, "i", 64);
        core/* ɵɵelementStart */.TgZ(236, "p");
        core/* ɵɵtext */._uU(237, "nc-map-big");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(238, "li");
        core/* ɵɵelement */._UZ(239, "i", 65);
        core/* ɵɵelementStart */.TgZ(240, "p");
        core/* ɵɵtext */._uU(241, "nc-minimal-down");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(242, "li");
        core/* ɵɵelement */._UZ(243, "i", 66);
        core/* ɵɵelementStart */.TgZ(244, "p");
        core/* ɵɵtext */._uU(245, "nc-minimal-left");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(246, "li");
        core/* ɵɵelement */._UZ(247, "i", 67);
        core/* ɵɵelementStart */.TgZ(248, "p");
        core/* ɵɵtext */._uU(249, "nc-minimal-right");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(250, "li");
        core/* ɵɵelement */._UZ(251, "i", 68);
        core/* ɵɵelementStart */.TgZ(252, "p");
        core/* ɵɵtext */._uU(253, "nc-minimal-up");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(254, "li");
        core/* ɵɵelement */._UZ(255, "i", 69);
        core/* ɵɵelementStart */.TgZ(256, "p");
        core/* ɵɵtext */._uU(257, "nc-mobile");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(258, "li");
        core/* ɵɵelement */._UZ(259, "i", 70);
        core/* ɵɵelementStart */.TgZ(260, "p");
        core/* ɵɵtext */._uU(261, "nc-money-coins");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(262, "li");
        core/* ɵɵelement */._UZ(263, "i", 71);
        core/* ɵɵelementStart */.TgZ(264, "p");
        core/* ɵɵtext */._uU(265, "nc-note-03");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(266, "li");
        core/* ɵɵelement */._UZ(267, "i", 72);
        core/* ɵɵelementStart */.TgZ(268, "p");
        core/* ɵɵtext */._uU(269, "nc-palette");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(270, "li");
        core/* ɵɵelement */._UZ(271, "i", 73);
        core/* ɵɵelementStart */.TgZ(272, "p");
        core/* ɵɵtext */._uU(273, "nc-paper");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(274, "li");
        core/* ɵɵelement */._UZ(275, "i", 74);
        core/* ɵɵelementStart */.TgZ(276, "p");
        core/* ɵɵtext */._uU(277, "nc-pin-3");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(278, "li");
        core/* ɵɵelement */._UZ(279, "i", 75);
        core/* ɵɵelementStart */.TgZ(280, "p");
        core/* ɵɵtext */._uU(281, "nc-planet");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(282, "li");
        core/* ɵɵelement */._UZ(283, "i", 76);
        core/* ɵɵelementStart */.TgZ(284, "p");
        core/* ɵɵtext */._uU(285, "nc-refresh-69");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(286, "li");
        core/* ɵɵelement */._UZ(287, "i", 77);
        core/* ɵɵelementStart */.TgZ(288, "p");
        core/* ɵɵtext */._uU(289, "nc-ruler-pencil");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(290, "li");
        core/* ɵɵelement */._UZ(291, "i", 78);
        core/* ɵɵelementStart */.TgZ(292, "p");
        core/* ɵɵtext */._uU(293, "nc-satisfied");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(294, "li");
        core/* ɵɵelement */._UZ(295, "i", 79);
        core/* ɵɵelementStart */.TgZ(296, "p");
        core/* ɵɵtext */._uU(297, "nc-scissors");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(298, "li");
        core/* ɵɵelement */._UZ(299, "i", 80);
        core/* ɵɵelementStart */.TgZ(300, "p");
        core/* ɵɵtext */._uU(301, "nc-send");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(302, "li");
        core/* ɵɵelement */._UZ(303, "i", 81);
        core/* ɵɵelementStart */.TgZ(304, "p");
        core/* ɵɵtext */._uU(305, "nc-settings-gear-65");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(306, "li");
        core/* ɵɵelement */._UZ(307, "i", 82);
        core/* ɵɵelementStart */.TgZ(308, "p");
        core/* ɵɵtext */._uU(309, "nc-settings");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(310, "li");
        core/* ɵɵelement */._UZ(311, "i", 83);
        core/* ɵɵelementStart */.TgZ(312, "p");
        core/* ɵɵtext */._uU(313, "nc-share-66");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(314, "li");
        core/* ɵɵelement */._UZ(315, "i", 84);
        core/* ɵɵelementStart */.TgZ(316, "p");
        core/* ɵɵtext */._uU(317, "nc-shop");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(318, "li");
        core/* ɵɵelement */._UZ(319, "i", 85);
        core/* ɵɵelementStart */.TgZ(320, "p");
        core/* ɵɵtext */._uU(321, "nc-simple-add");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(322, "li");
        core/* ɵɵelement */._UZ(323, "i", 86);
        core/* ɵɵelementStart */.TgZ(324, "p");
        core/* ɵɵtext */._uU(325, "nc-simple-delete");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(326, "li");
        core/* ɵɵelement */._UZ(327, "i", 87);
        core/* ɵɵelementStart */.TgZ(328, "p");
        core/* ɵɵtext */._uU(329, "nc-simple-remove");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(330, "li");
        core/* ɵɵelement */._UZ(331, "i", 88);
        core/* ɵɵelementStart */.TgZ(332, "p");
        core/* ɵɵtext */._uU(333, "nc-single-02");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(334, "li");
        core/* ɵɵelement */._UZ(335, "i", 89);
        core/* ɵɵelementStart */.TgZ(336, "p");
        core/* ɵɵtext */._uU(337, "nc-single-copy-04");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(338, "li");
        core/* ɵɵelement */._UZ(339, "i", 90);
        core/* ɵɵelementStart */.TgZ(340, "p");
        core/* ɵɵtext */._uU(341, "nc-sound-wave");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(342, "li");
        core/* ɵɵelement */._UZ(343, "i", 91);
        core/* ɵɵelementStart */.TgZ(344, "p");
        core/* ɵɵtext */._uU(345, "nc-spaceship");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(346, "li");
        core/* ɵɵelement */._UZ(347, "i", 92);
        core/* ɵɵelementStart */.TgZ(348, "p");
        core/* ɵɵtext */._uU(349, "nc-sun-fog-29");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(350, "li");
        core/* ɵɵelement */._UZ(351, "i", 93);
        core/* ɵɵelementStart */.TgZ(352, "p");
        core/* ɵɵtext */._uU(353, "nc-support-17");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(354, "li");
        core/* ɵɵelement */._UZ(355, "i", 94);
        core/* ɵɵelementStart */.TgZ(356, "p");
        core/* ɵɵtext */._uU(357, "nc-tablet-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(358, "li");
        core/* ɵɵelement */._UZ(359, "i", 95);
        core/* ɵɵelementStart */.TgZ(360, "p");
        core/* ɵɵtext */._uU(361, "nc-tag-content");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(362, "li");
        core/* ɵɵelement */._UZ(363, "i", 96);
        core/* ɵɵelementStart */.TgZ(364, "p");
        core/* ɵɵtext */._uU(365, "nc-tap-01");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(366, "li");
        core/* ɵɵelement */._UZ(367, "i", 97);
        core/* ɵɵelementStart */.TgZ(368, "p");
        core/* ɵɵtext */._uU(369, "nc-tie-bow");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(370, "li");
        core/* ɵɵelement */._UZ(371, "i", 98);
        core/* ɵɵelementStart */.TgZ(372, "p");
        core/* ɵɵtext */._uU(373, "nc-tile-56");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(374, "li");
        core/* ɵɵelement */._UZ(375, "i", 99);
        core/* ɵɵelementStart */.TgZ(376, "p");
        core/* ɵɵtext */._uU(377, "nc-time-alarm");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(378, "li");
        core/* ɵɵelement */._UZ(379, "i", 100);
        core/* ɵɵelementStart */.TgZ(380, "p");
        core/* ɵɵtext */._uU(381, "nc-touch-id");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(382, "li");
        core/* ɵɵelement */._UZ(383, "i", 101);
        core/* ɵɵelementStart */.TgZ(384, "p");
        core/* ɵɵtext */._uU(385, "nc-trophy");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(386, "li");
        core/* ɵɵelement */._UZ(387, "i", 102);
        core/* ɵɵelementStart */.TgZ(388, "p");
        core/* ɵɵtext */._uU(389, "nc-tv-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(390, "li");
        core/* ɵɵelement */._UZ(391, "i", 103);
        core/* ɵɵelementStart */.TgZ(392, "p");
        core/* ɵɵtext */._uU(393, "nc-umbrella-13");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(394, "li");
        core/* ɵɵelement */._UZ(395, "i", 104);
        core/* ɵɵelementStart */.TgZ(396, "p");
        core/* ɵɵtext */._uU(397, "nc-user-run");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(398, "li");
        core/* ɵɵelement */._UZ(399, "i", 105);
        core/* ɵɵelementStart */.TgZ(400, "p");
        core/* ɵɵtext */._uU(401, "nc-vector");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(402, "li");
        core/* ɵɵelement */._UZ(403, "i", 106);
        core/* ɵɵelementStart */.TgZ(404, "p");
        core/* ɵɵtext */._uU(405, "nc-watch-time");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(406, "li");
        core/* ɵɵelement */._UZ(407, "i", 107);
        core/* ɵɵelementStart */.TgZ(408, "p");
        core/* ɵɵtext */._uU(409, "nc-world-2");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(410, "li");
        core/* ɵɵelement */._UZ(411, "i", 108);
        core/* ɵɵelementStart */.TgZ(412, "p");
        core/* ɵɵtext */._uU(413, "nc-zoom-split");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } }, encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/overlay.js + 1 modules
var overlay = __webpack_require__(625);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js
var portal = __webpack_require__(7636);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js
var defer = __webpack_require__(1439);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js
var a11y = __webpack_require__(9238);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js
var keycodes = __webpack_require__(6461);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/dialog.js













/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Configuration for opening a modal dialog with the MatDialog service.
 */






function MatDialogContainer_ng_template_0_Template(rf, ctx) { }
class MatDialogConfig {
    constructor() {
        /** The ARIA role of the dialog element. */
        this.role = 'dialog';
        /** Custom class for the overlay pane. */
        this.panelClass = '';
        /** Whether the dialog has a backdrop. */
        this.hasBackdrop = true;
        /** Custom class for the backdrop. */
        this.backdropClass = '';
        /** Whether the user can use escape or clicking on the backdrop to close the modal. */
        this.disableClose = false;
        /** Width of the dialog. */
        this.width = '';
        /** Height of the dialog. */
        this.height = '';
        /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */
        this.maxWidth = '80vw';
        /** Data being injected into the child component. */
        this.data = null;
        /** ID of the element that describes the dialog. */
        this.ariaDescribedBy = null;
        /** ID of the element that labels the dialog. */
        this.ariaLabelledBy = null;
        /** Aria label to assign to the dialog element. */
        this.ariaLabel = null;
        /** Whether the dialog should focus the first focusable element on open. */
        this.autoFocus = true;
        /**
         * Whether the dialog should restore focus to the
         * previously-focused element, after it's closed.
         */
        this.restoreFocus = true;
        /**
         * Whether the dialog should close when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.closeOnNavigation = true;
        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
    }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Animations used by MatDialog.
 * @docs-private
 */
const matDialogAnimations = {
    /** Animation that is applied on the dialog container by default. */
    dialogContainer: (0,animations/* trigger */.X$)('dialogContainer', [
        // Note: The `enter` animation transitions to `transform: none`, because for some reason
        // specifying the transform explicitly, causes IE both to blur the dialog content and
        // decimate the animation performance. Leaving it as `none` solves both issues.
        (0,animations/* state */.SB)('void, exit', (0,animations/* style */.oB)({ opacity: 0, transform: 'scale(0.7)' })),
        (0,animations/* state */.SB)('enter', (0,animations/* style */.oB)({ transform: 'none' })),
        (0,animations/* transition */.eR)('* => enter', (0,animations/* animate */.jt)('150ms cubic-bezier(0, 0, 0.2, 1)', (0,animations/* style */.oB)({ transform: 'none', opacity: 1 }))),
        (0,animations/* transition */.eR)('* => void, * => exit', (0,animations/* animate */.jt)('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', (0,animations/* style */.oB)({ opacity: 0 }))),
    ])
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Throws an exception for the case when a ComponentPortal is
 * attached to a DomPortalOutlet without an origin.
 * @docs-private
 */
function throwMatDialogContentAlreadyAttachedError() {
    throw Error('Attempting to attach dialog content after content is already attached');
}
/**
 * Base class for the `MatDialogContainer`. The base class does not implement
 * animations as these are left to implementers of the dialog container.
 */
class _MatDialogContainerBase extends portal/* BasePortalOutlet */.en {
    constructor(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, 
    /** The dialog configuration. */
    _config, _focusMonitor) {
        super();
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._changeDetectorRef = _changeDetectorRef;
        this._config = _config;
        this._focusMonitor = _focusMonitor;
        /** Emits when an animation state changes. */
        this._animationStateChanged = new core/* EventEmitter */.vpe();
        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
        this._elementFocusedBeforeDialogWasOpened = null;
        /**
         * Type of interaction that led to the dialog being closed. This is used to determine
         * whether the focus style will be applied when returning focus to its original location
         * after the dialog is closed.
         */
        this._closeInteractionType = null;
        /**
         * Attaches a DOM portal to the dialog container.
         * @param portal Portal to be attached.
         * @deprecated To be turned into a method.
         * @breaking-change 10.0.0
         */
        this.attachDomPortal = (portal) => {
            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throwMatDialogContentAlreadyAttachedError();
            }
            return this._portalOutlet.attachDomPortal(portal);
        };
        this._ariaLabelledBy = _config.ariaLabelledBy || null;
        this._document = _document;
    }
    /** Initializes the dialog container with the attached content. */
    _initializeWithAttachedContent() {
        this._setupFocusTrap();
        // Save the previously focused element. This element will be re-focused
        // when the dialog closes.
        this._capturePreviouslyFocusedElement();
        // Move focus onto the dialog immediately in order to prevent the user
        // from accidentally opening multiple dialogs at the same time.
        this._focusDialogContainer();
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throwMatDialogContentAlreadyAttachedError();
        }
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throwMatDialogContentAlreadyAttachedError();
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /** Moves focus back into the dialog if it was moved out. */
    _recaptureFocus() {
        if (!this._containsFocus()) {
            const focusContainer = !this._config.autoFocus || !this._focusTrap.focusInitialElement();
            if (focusContainer) {
                this._elementRef.nativeElement.focus();
            }
        }
    }
    /** Moves the focus inside the focus trap. */
    _trapFocus() {
        // If we were to attempt to focus immediately, then the content of the dialog would not yet be
        // ready in instances where change detection has to run first. To deal with this, we simply
        // wait for the microtask queue to be empty.
        if (this._config.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
        else if (!this._containsFocus()) {
            // Otherwise ensure that focus is on the dialog container. It's possible that a different
            // component tried to move focus while the open animation was running. See:
            // https://github.com/angular/components/issues/16215. Note that we only want to do this
            // if the focus isn't inside the dialog already, because it's possible that the consumer
            // turned off `autoFocus` in order to move focus themselves.
            this._elementRef.nativeElement.focus();
        }
    }
    /** Restores focus to the element that was focused before the dialog opened. */
    _restoreFocus() {
        const previousElement = this._elementFocusedBeforeDialogWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this._config.restoreFocus && previousElement &&
            typeof previousElement.focus === 'function') {
            const activeElement = (0,platform/* _getFocusedElementPierceShadowDom */.ht)();
            const element = this._elementRef.nativeElement;
            // Make sure that focus is still inside the dialog or is on the body (usually because a
            // non-focusable element like the backdrop was clicked) before moving it. It's possible that
            // the consumer moved it themselves before the animation was done, in which case we shouldn't
            // do anything.
            if (!activeElement || activeElement === this._document.body || activeElement === element ||
                element.contains(activeElement)) {
                if (this._focusMonitor) {
                    this._focusMonitor.focusVia(previousElement, this._closeInteractionType);
                    this._closeInteractionType = null;
                }
                else {
                    previousElement.focus();
                }
            }
        }
        if (this._focusTrap) {
            this._focusTrap.destroy();
        }
    }
    /** Sets up the focus trap. */
    _setupFocusTrap() {
        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
    }
    /** Captures the element that was focused before the dialog was opened. */
    _capturePreviouslyFocusedElement() {
        if (this._document) {
            this._elementFocusedBeforeDialogWasOpened = (0,platform/* _getFocusedElementPierceShadowDom */.ht)();
        }
    }
    /** Focuses the dialog container. */
    _focusDialogContainer() {
        // Note that there is no focus method when rendering on the server.
        if (this._elementRef.nativeElement.focus) {
            this._elementRef.nativeElement.focus();
        }
    }
    /** Returns whether focus is inside the dialog. */
    _containsFocus() {
        const element = this._elementRef.nativeElement;
        const activeElement = (0,platform/* _getFocusedElementPierceShadowDom */.ht)();
        return element === activeElement || element.contains(activeElement);
    }
}
_MatDialogContainerBase.ɵfac = function _MatDialogContainerBase_Factory(t) { return new (t || _MatDialogContainerBase)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusTrapFactory */.qV), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0, 8), core/* ɵɵdirectiveInject */.Y36(MatDialogConfig), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusMonitor */.tE)); };
_MatDialogContainerBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatDialogContainerBase, viewQuery: function _MatDialogContainerBase_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(portal/* CdkPortalOutlet */.Pl, 7);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._portalOutlet = _t.first);
    } }, features: [core/* ɵɵInheritDefinitionFeature */.qOj] });
_MatDialogContainerBase.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: a11y/* FocusTrapFactory */.qV },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] },
    { type: MatDialogConfig },
    { type: a11y/* FocusMonitor */.tE }
];
_MatDialogContainerBase.propDecorators = {
    _portalOutlet: [{ type: core/* ViewChild */.i9L, args: [portal/* CdkPortalOutlet */.Pl, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatDialogContainerBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: a11y/* FocusTrapFactory */.qV }, { type: core/* ChangeDetectorRef */.sBO }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }, { type: MatDialogConfig }, { type: a11y/* FocusMonitor */.tE }]; }, { _portalOutlet: [{
            type: core/* ViewChild */.i9L,
            args: [portal/* CdkPortalOutlet */.Pl, { static: true }]
        }] }); })();
/**
 * Internal component that wraps user-provided dialog content.
 * Animation is based on https://material.io/guidelines/motion/choreography.html.
 * @docs-private
 */
class MatDialogContainer extends _MatDialogContainerBase {
    constructor() {
        super(...arguments);
        /** State of the dialog animation. */
        this._state = 'enter';
    }
    /** Callback, invoked whenever an animation on the host completes. */
    _onAnimationDone({ toState, totalTime }) {
        if (toState === 'enter') {
            this._trapFocus();
            this._animationStateChanged.next({ state: 'opened', totalTime });
        }
        else if (toState === 'exit') {
            this._restoreFocus();
            this._animationStateChanged.next({ state: 'closed', totalTime });
        }
    }
    /** Callback, invoked when an animation on the host starts. */
    _onAnimationStart({ toState, totalTime }) {
        if (toState === 'enter') {
            this._animationStateChanged.next({ state: 'opening', totalTime });
        }
        else if (toState === 'exit' || toState === 'void') {
            this._animationStateChanged.next({ state: 'closing', totalTime });
        }
    }
    /** Starts the dialog exit animation. */
    _startExitAnimation() {
        this._state = 'exit';
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this._changeDetectorRef.markForCheck();
    }
}
MatDialogContainer.ɵfac = /*@__PURE__*/ function () { let ɵMatDialogContainer_BaseFactory; return function MatDialogContainer_Factory(t) { return (ɵMatDialogContainer_BaseFactory || (ɵMatDialogContainer_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatDialogContainer)))(t || MatDialogContainer); }; }();
MatDialogContainer.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatDialogContainer, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function MatDialogContainer_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵsyntheticHostListener */.WFA("@dialogContainer.start", function MatDialogContainer_animation_dialogContainer_start_HostBindingHandler($event) { return ctx._onAnimationStart($event); })("@dialogContainer.done", function MatDialogContainer_animation_dialogContainer_done_HostBindingHandler($event) { return ctx._onAnimationDone($event); });
    } if (rf & 2) {
        core/* ɵɵhostProperty */.Ikx("id", ctx._id);
        core/* ɵɵattribute */.uIk("role", ctx._config.role)("aria-labelledby", ctx._config.ariaLabel ? null : ctx._ariaLabelledBy)("aria-label", ctx._config.ariaLabel)("aria-describedby", ctx._config.ariaDescribedBy || null);
        core/* ɵɵsyntheticHostProperty */.d8E("@dialogContainer", ctx._state);
    } }, features: [core/* ɵɵInheritDefinitionFeature */.qOj], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function MatDialogContainer_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵtemplate */.YNc(0, MatDialogContainer_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [portal/* CdkPortalOutlet */.Pl], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [matDialogAnimations.dialogContainer] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogContainer, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-dialog-container',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                // tslint:disable-next-line:validate-decorators
                changeDetection: core/* ChangeDetectionStrategy.Default */.n4l.Default,
                animations: [matDialogAnimations.dialogContainer],
                host: {
                    'class': 'mat-dialog-container',
                    'tabindex': '-1',
                    'aria-modal': 'true',
                    '[id]': '_id',
                    '[attr.role]': '_config.role',
                    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                    '[attr.aria-label]': '_config.ariaLabel',
                    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                    '[@dialogContainer]': '_state',
                    '(@dialogContainer.start)': '_onAnimationStart($event)',
                    '(@dialogContainer.done)': '_onAnimationDone($event)'
                },
                styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// TODO(jelbourn): resizing
// Counter for unique dialog ids.
let uniqueId = 0;
/**
 * Reference to a dialog opened via the MatDialog service.
 */
class MatDialogRef {
    constructor(_overlayRef, _containerInstance, 
    /** Id of the dialog. */
    id = `mat-dialog-${uniqueId++}`) {
        this._overlayRef = _overlayRef;
        this._containerInstance = _containerInstance;
        this.id = id;
        /** Whether the user is allowed to close the dialog. */
        this.disableClose = this._containerInstance._config.disableClose;
        /** Subject for notifying the user that the dialog has finished opening. */
        this._afterOpened = new Subject/* Subject */.xQ();
        /** Subject for notifying the user that the dialog has finished closing. */
        this._afterClosed = new Subject/* Subject */.xQ();
        /** Subject for notifying the user that the dialog has started closing. */
        this._beforeClosed = new Subject/* Subject */.xQ();
        /** Current state of the dialog. */
        this._state = 0 /* OPEN */;
        // Pass the id along to the container.
        _containerInstance._id = id;
        // Emit when opening animation completes
        _containerInstance._animationStateChanged.pipe((0,filter/* filter */.h)(event => event.state === 'opened'), (0,take/* take */.q)(1))
            .subscribe(() => {
            this._afterOpened.next();
            this._afterOpened.complete();
        });
        // Dispose overlay when closing animation is complete
        _containerInstance._animationStateChanged.pipe((0,filter/* filter */.h)(event => event.state === 'closed'), (0,take/* take */.q)(1)).subscribe(() => {
            clearTimeout(this._closeFallbackTimeout);
            this._finishDialogClose();
        });
        _overlayRef.detachments().subscribe(() => {
            this._beforeClosed.next(this._result);
            this._beforeClosed.complete();
            this._afterClosed.next(this._result);
            this._afterClosed.complete();
            this.componentInstance = null;
            this._overlayRef.dispose();
        });
        _overlayRef.keydownEvents()
            .pipe((0,filter/* filter */.h)(event => {
            return event.keyCode === keycodes/* ESCAPE */.hY && !this.disableClose && !(0,keycodes/* hasModifierKey */.Vb)(event);
        }))
            .subscribe(event => {
            event.preventDefault();
            _closeDialogVia(this, 'keyboard');
        });
        _overlayRef.backdropClick().subscribe(() => {
            if (this.disableClose) {
                this._containerInstance._recaptureFocus();
            }
            else {
                _closeDialogVia(this, 'mouse');
            }
        });
    }
    /**
     * Close the dialog.
     * @param dialogResult Optional result to return to the dialog opener.
     */
    close(dialogResult) {
        this._result = dialogResult;
        // Transition the backdrop in parallel to the dialog.
        this._containerInstance._animationStateChanged.pipe((0,filter/* filter */.h)(event => event.state === 'closing'), (0,take/* take */.q)(1))
            .subscribe(event => {
            this._beforeClosed.next(dialogResult);
            this._beforeClosed.complete();
            this._overlayRef.detachBackdrop();
            // The logic that disposes of the overlay depends on the exit animation completing, however
            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
            // timeout which will clean everything up if the animation hasn't fired within the specified
            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
            // vast majority of cases the timeout will have been cleared before it has the chance to fire.
            this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), event.totalTime + 100);
        });
        this._state = 1 /* CLOSING */;
        this._containerInstance._startExitAnimation();
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    afterOpened() {
        return this._afterOpened;
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    afterClosed() {
        return this._afterClosed;
    }
    /**
     * Gets an observable that is notified when the dialog has started closing.
     */
    beforeClosed() {
        return this._beforeClosed;
    }
    /**
     * Gets an observable that emits when the overlay's backdrop has been clicked.
     */
    backdropClick() {
        return this._overlayRef.backdropClick();
    }
    /**
     * Gets an observable that emits when keydown events are targeted on the overlay.
     */
    keydownEvents() {
        return this._overlayRef.keydownEvents();
    }
    /**
     * Updates the dialog's position.
     * @param position New dialog position.
     */
    updatePosition(position) {
        let strategy = this._getPositionStrategy();
        if (position && (position.left || position.right)) {
            position.left ? strategy.left(position.left) : strategy.right(position.right);
        }
        else {
            strategy.centerHorizontally();
        }
        if (position && (position.top || position.bottom)) {
            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
        }
        else {
            strategy.centerVertically();
        }
        this._overlayRef.updatePosition();
        return this;
    }
    /**
     * Updates the dialog's width and height.
     * @param width New width of the dialog.
     * @param height New height of the dialog.
     */
    updateSize(width = '', height = '') {
        this._overlayRef.updateSize({ width, height });
        this._overlayRef.updatePosition();
        return this;
    }
    /** Add a CSS class or an array of classes to the overlay pane. */
    addPanelClass(classes) {
        this._overlayRef.addPanelClass(classes);
        return this;
    }
    /** Remove a CSS class or an array of classes from the overlay pane. */
    removePanelClass(classes) {
        this._overlayRef.removePanelClass(classes);
        return this;
    }
    /** Gets the current state of the dialog's lifecycle. */
    getState() {
        return this._state;
    }
    /**
     * Finishes the dialog close by updating the state of the dialog
     * and disposing the overlay.
     */
    _finishDialogClose() {
        this._state = 2 /* CLOSED */;
        this._overlayRef.dispose();
    }
    /** Fetches the position strategy object from the overlay ref. */
    _getPositionStrategy() {
        return this._overlayRef.getConfig().positionStrategy;
    }
}
/**
 * Closes the dialog with the specified interaction type. This is currently not part of
 * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.
 * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.
 */
// TODO: TODO: Move this back into `MatDialogRef` when we provide an official mock dialog ref.
function _closeDialogVia(ref, interactionType, result) {
    // Some mock dialog ref instances in tests do not have the `_containerInstance` property.
    // For those, we keep the behavior as is and do not deal with the interaction type.
    if (ref._containerInstance !== undefined) {
        ref._containerInstance._closeInteractionType = interactionType;
    }
    return ref.close(result);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token that can be used to access the data that was passed in to a dialog. */
const MAT_DIALOG_DATA = new core/* InjectionToken */.OlP('MatDialogData');
/** Injection token that can be used to specify default dialog options. */
const MAT_DIALOG_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('mat-dialog-default-options');
/** Injection token that determines the scroll handling while the dialog is open. */
const MAT_DIALOG_SCROLL_STRATEGY = new core/* InjectionToken */.OlP('mat-dialog-scroll-strategy');
/** @docs-private */
function MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {
    return () => overlay.scrollStrategies.block();
}
/** @docs-private */
function MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.block();
}
/** @docs-private */
const MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {
    provide: MAT_DIALOG_SCROLL_STRATEGY,
    deps: [overlay/* Overlay */.aV],
    useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
/**
 * Base class for dialog services. The base dialog service allows
 * for arbitrary dialog refs and dialog container components.
 */
class _MatDialogBase {
    constructor(_overlay, _injector, _defaultOptions, _parentDialog, _overlayContainer, scrollStrategy, _dialogRefConstructor, _dialogContainerType, _dialogDataToken) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._defaultOptions = _defaultOptions;
        this._parentDialog = _parentDialog;
        this._overlayContainer = _overlayContainer;
        this._dialogRefConstructor = _dialogRefConstructor;
        this._dialogContainerType = _dialogContainerType;
        this._dialogDataToken = _dialogDataToken;
        this._openDialogsAtThisLevel = [];
        this._afterAllClosedAtThisLevel = new Subject/* Subject */.xQ();
        this._afterOpenedAtThisLevel = new Subject/* Subject */.xQ();
        this._ariaHiddenElements = new Map();
        // TODO (jelbourn): tighten the typing right-hand side of this expression.
        /**
         * Stream that emits when all open dialog have finished closing.
         * Will emit on subscribe if there are no open dialogs to begin with.
         */
        this.afterAllClosed = (0,defer/* defer */.P)(() => this.openDialogs.length ?
            this._getAfterAllClosed() :
            this._getAfterAllClosed().pipe((0,startWith/* startWith */.O)(undefined)));
        this._scrollStrategy = scrollStrategy;
    }
    /** Keeps track of the currently-open dialogs. */
    get openDialogs() {
        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
    }
    /** Stream that emits when a dialog has been opened. */
    get afterOpened() {
        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
    }
    _getAfterAllClosed() {
        const parent = this._parentDialog;
        return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
    }
    open(componentOrTemplateRef, config) {
        config = _applyConfigDefaults(config, this._defaultOptions || new MatDialogConfig());
        if (config.id && this.getDialogById(config.id) &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
        }
        const overlayRef = this._createOverlay(config);
        const dialogContainer = this._attachDialogContainer(overlayRef, config);
        const dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
        // If this is the first dialog that we're opening, hide all the non-overlay content.
        if (!this.openDialogs.length) {
            this._hideNonDialogContentFromAssistiveTechnology();
        }
        this.openDialogs.push(dialogRef);
        dialogRef.afterClosed().subscribe(() => this._removeOpenDialog(dialogRef));
        this.afterOpened.next(dialogRef);
        // Notify the dialog container that the content has been attached.
        dialogContainer._initializeWithAttachedContent();
        return dialogRef;
    }
    /**
     * Closes all of the currently-open dialogs.
     */
    closeAll() {
        this._closeDialogs(this.openDialogs);
    }
    /**
     * Finds an open dialog by its id.
     * @param id ID to use when looking up the dialog.
     */
    getDialogById(id) {
        return this.openDialogs.find(dialog => dialog.id === id);
    }
    ngOnDestroy() {
        // Only close the dialogs at this level on destroy
        // since the parent service may still be active.
        this._closeDialogs(this._openDialogsAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Creates the overlay into which the dialog will be loaded.
     * @param config The dialog configuration.
     * @returns A promise resolving to the OverlayRef for the created overlay.
     */
    _createOverlay(config) {
        const overlayConfig = this._getOverlayConfig(config);
        return this._overlay.create(overlayConfig);
    }
    /**
     * Creates an overlay config from a dialog config.
     * @param dialogConfig The dialog configuration.
     * @returns The overlay configuration.
     */
    _getOverlayConfig(dialogConfig) {
        const state = new overlay/* OverlayConfig */.X_({
            positionStrategy: this._overlay.position().global(),
            scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
            panelClass: dialogConfig.panelClass,
            hasBackdrop: dialogConfig.hasBackdrop,
            direction: dialogConfig.direction,
            minWidth: dialogConfig.minWidth,
            minHeight: dialogConfig.minHeight,
            maxWidth: dialogConfig.maxWidth,
            maxHeight: dialogConfig.maxHeight,
            disposeOnNavigation: dialogConfig.closeOnNavigation
        });
        if (dialogConfig.backdropClass) {
            state.backdropClass = dialogConfig.backdropClass;
        }
        return state;
    }
    /**
     * Attaches a dialog container to a dialog's already-created overlay.
     * @param overlay Reference to the dialog's underlying overlay.
     * @param config The dialog configuration.
     * @returns A promise resolving to a ComponentRef for the attached container.
     */
    _attachDialogContainer(overlay, config) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const injector = core/* Injector.create */.zs3.create({
            parent: userInjector || this._injector,
            providers: [{ provide: MatDialogConfig, useValue: config }]
        });
        const containerPortal = new portal/* ComponentPortal */.C5(this._dialogContainerType, config.viewContainerRef, injector, config.componentFactoryResolver);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Attaches the user-provided component to the already-created dialog container.
     * @param componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param dialogContainer Reference to the wrapping dialog container.
     * @param overlayRef Reference to the overlay in which the dialog resides.
     * @param config The dialog configuration.
     * @returns A promise resolving to the MatDialogRef that should be returned to the user.
     */
    _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {
        // Create a reference to the dialog we're creating in order to give the user a handle
        // to modify and close it.
        const dialogRef = new this._dialogRefConstructor(overlayRef, dialogContainer, config.id);
        if (componentOrTemplateRef instanceof core/* TemplateRef */.Rgc) {
            dialogContainer.attachTemplatePortal(new portal/* TemplatePortal */.UE(componentOrTemplateRef, null, { $implicit: config.data, dialogRef }));
        }
        else {
            const injector = this._createInjector(config, dialogRef, dialogContainer);
            const contentRef = dialogContainer.attachComponentPortal(new portal/* ComponentPortal */.C5(componentOrTemplateRef, config.viewContainerRef, injector));
            dialogRef.componentInstance = contentRef.instance;
        }
        dialogRef
            .updateSize(config.width, config.height)
            .updatePosition(config.position);
        return dialogRef;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     * @param config Config object that is used to construct the dialog.
     * @param dialogRef Reference to the dialog.
     * @param dialogContainer Dialog container element that wraps all of the contents.
     * @returns The custom injector that can be used inside the dialog.
     */
    _createInjector(config, dialogRef, dialogContainer) {
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        // The dialog container should be provided as the dialog container and the dialog's
        // content are created out of the same `ViewContainerRef` and as such, are siblings
        // for injector purposes. To allow the hierarchy that is expected, the dialog
        // container is explicitly provided in the injector.
        const providers = [
            { provide: this._dialogContainerType, useValue: dialogContainer },
            { provide: this._dialogDataToken, useValue: config.data },
            { provide: this._dialogRefConstructor, useValue: dialogRef }
        ];
        if (config.direction && (!userInjector ||
            !userInjector.get(bidi/* Directionality */.Is, null, core/* InjectFlags.Optional */.XFs.Optional))) {
            providers.push({
                provide: bidi/* Directionality */.Is,
                useValue: { value: config.direction, change: (0,of.of)() }
            });
        }
        return core/* Injector.create */.zs3.create({ parent: userInjector || this._injector, providers });
    }
    /**
     * Removes a dialog from the array of open dialogs.
     * @param dialogRef Dialog to be removed.
     */
    _removeOpenDialog(dialogRef) {
        const index = this.openDialogs.indexOf(dialogRef);
        if (index > -1) {
            this.openDialogs.splice(index, 1);
            // If all the dialogs were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openDialogs.length) {
                this._ariaHiddenElements.forEach((previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                });
                this._ariaHiddenElements.clear();
                this._getAfterAllClosed().next();
            }
        }
    }
    /**
     * Hides all of the content that isn't an overlay from assistive technology.
     */
    _hideNonDialogContentFromAssistiveTechnology() {
        const overlayContainer = this._overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                let sibling = siblings[i];
                if (sibling !== overlayContainer &&
                    sibling.nodeName !== 'SCRIPT' &&
                    sibling.nodeName !== 'STYLE' &&
                    !sibling.hasAttribute('aria-live')) {
                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    /** Closes all of the dialogs in an array. */
    _closeDialogs(dialogs) {
        let i = dialogs.length;
        while (i--) {
            // The `_openDialogs` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            dialogs[i].close();
        }
    }
}
_MatDialogBase.ɵfac = function _MatDialogBase_Factory(t) { return new (t || _MatDialogBase)(core/* ɵɵdirectiveInject */.Y36(overlay/* Overlay */.aV), core/* ɵɵdirectiveInject */.Y36(core/* Injector */.zs3), core/* ɵɵdirectiveInject */.Y36(undefined), core/* ɵɵdirectiveInject */.Y36(undefined), core/* ɵɵdirectiveInject */.Y36(overlay/* OverlayContainer */.Xj), core/* ɵɵdirectiveInject */.Y36(undefined), core/* ɵɵdirectiveInject */.Y36(core/* Type */.DyG), core/* ɵɵdirectiveInject */.Y36(core/* Type */.DyG), core/* ɵɵdirectiveInject */.Y36(core/* InjectionToken */.OlP)); };
_MatDialogBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatDialogBase });
_MatDialogBase.ctorParameters = () => [
    { type: overlay/* Overlay */.aV },
    { type: core/* Injector */.zs3 },
    { type: undefined },
    { type: undefined },
    { type: overlay/* OverlayContainer */.Xj },
    { type: undefined },
    { type: core/* Type */.DyG },
    { type: core/* Type */.DyG },
    { type: core/* InjectionToken */.OlP }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatDialogBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: overlay/* Overlay */.aV }, { type: core/* Injector */.zs3 }, { type: undefined }, { type: undefined }, { type: overlay/* OverlayContainer */.Xj }, { type: undefined }, { type: core/* Type */.DyG }, { type: core/* Type */.DyG }, { type: core/* InjectionToken */.OlP }]; }, null); })();
/**
 * Service to open Material Design modal dialogs.
 */
class MatDialog extends _MatDialogBase {
    constructor(overlay, injector, 
    /**
     * @deprecated `_location` parameter to be removed.
     * @breaking-change 10.0.0
     */
    location, defaultOptions, scrollStrategy, parentDialog, overlayContainer) {
        super(overlay, injector, defaultOptions, parentDialog, overlayContainer, scrollStrategy, MatDialogRef, MatDialogContainer, MAT_DIALOG_DATA);
    }
}
MatDialog.ɵfac = function MatDialog_Factory(t) { return new (t || MatDialog)(core/* ɵɵinject */.LFG(overlay/* Overlay */.aV), core/* ɵɵinject */.LFG(core/* Injector */.zs3), core/* ɵɵinject */.LFG(common/* Location */.Ye, 8), core/* ɵɵinject */.LFG(MAT_DIALOG_DEFAULT_OPTIONS, 8), core/* ɵɵinject */.LFG(MAT_DIALOG_SCROLL_STRATEGY), core/* ɵɵinject */.LFG(MatDialog, 12), core/* ɵɵinject */.LFG(overlay/* OverlayContainer */.Xj)); };
MatDialog.ɵprov = /*@__PURE__*/ core/* ɵɵdefineInjectable */.Yz7({ token: MatDialog, factory: MatDialog.ɵfac });
MatDialog.ctorParameters = () => [
    { type: overlay/* Overlay */.aV },
    { type: core/* Injector */.zs3 },
    { type: common/* Location */.Ye, decorators: [{ type: core/* Optional */.FiY }] },
    { type: MatDialogConfig, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_DIALOG_DEFAULT_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_DIALOG_SCROLL_STRATEGY,] }] },
    { type: MatDialog, decorators: [{ type: core/* Optional */.FiY }, { type: core/* SkipSelf */.tp0 }] },
    { type: overlay/* OverlayContainer */.Xj }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialog, [{
        type: core/* Injectable */.GSi
    }], function () { return [{ type: overlay/* Overlay */.aV }, { type: core/* Injector */.zs3 }, { type: common/* Location */.Ye, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: MatDialogConfig, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_DIALOG_DEFAULT_OPTIONS]
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_DIALOG_SCROLL_STRATEGY]
            }] }, { type: MatDialog, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* SkipSelf */.tp0
            }] }, { type: overlay/* OverlayContainer */.Xj }]; }, null); })();
/**
 * Applies default options to the dialog config.
 * @param config Config to be modified.
 * @param defaultOptions Default options provided.
 * @returns The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return Object.assign(Object.assign({}, defaultOptions), config);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Counter used to generate unique IDs for dialog elements. */
let dialogElementUid = 0;
/**
 * Button that will close the current dialog.
 */
class MatDialogClose {
    constructor(
    /**
     * Reference to the containing dialog.
     * @deprecated `dialogRef` property to become private.
     * @breaking-change 13.0.0
     */
    // The dialog title directive is always used in combination with a `MatDialogRef`.
    // tslint:disable-next-line: lightweight-tokens
    dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        /** Default to "button" to prevents accidental form submits. */
        this.type = 'button';
    }
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
        }
    }
    ngOnChanges(changes) {
        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
    _onButtonClick(event) {
        // Determinate the focus origin using the click event, because using the FocusMonitor will
        // result in incorrect origins. Most of the time, close buttons will be auto focused in the
        // dialog, and therefore clicking the button won't result in a focus change. This means that
        // the FocusMonitor won't detect any origin change, and will always output `program`.
        _closeDialogVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse', this.dialogResult);
    }
}
MatDialogClose.ɵfac = function MatDialogClose_Factory(t) { return new (t || MatDialogClose)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef, 8), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
MatDialogClose.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatDialogClose, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function MatDialogClose_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("click", function MatDialogClose_click_HostBindingHandler($event) { return ctx._onButtonClick($event); });
    } if (rf & 2) {
        core/* ɵɵattribute */.uIk("aria-label", ctx.ariaLabel || null)("type", ctx.type);
    } }, inputs: { type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], ariaLabel: ["aria-label", "ariaLabel"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [core/* ɵɵNgOnChangesFeature */.TTD] });
MatDialogClose.ctorParameters = () => [
    { type: MatDialogRef, decorators: [{ type: core/* Optional */.FiY }] },
    { type: core/* ElementRef */.SBq },
    { type: MatDialog }
];
MatDialogClose.propDecorators = {
    ariaLabel: [{ type: core/* Input */.IIB, args: ['aria-label',] }],
    type: [{ type: core/* Input */.IIB }],
    dialogResult: [{ type: core/* Input */.IIB, args: ['mat-dialog-close',] }],
    _matDialogClose: [{ type: core/* Input */.IIB, args: ['matDialogClose',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogClose, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-dialog-close], [matDialogClose]',
                exportAs: 'matDialogClose',
                host: {
                    '(click)': '_onButtonClick($event)',
                    '[attr.aria-label]': 'ariaLabel || null',
                    '[attr.type]': 'type'
                }
            }]
    }], function () { return [{ type: MatDialogRef, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: core/* ElementRef */.SBq }, { type: MatDialog }]; }, { type: [{
            type: core/* Input */.IIB
        }], dialogResult: [{
            type: core/* Input */.IIB,
            args: ['mat-dialog-close']
        }], ariaLabel: [{
            type: core/* Input */.IIB,
            args: ['aria-label']
        }], _matDialogClose: [{
            type: core/* Input */.IIB,
            args: ['matDialogClose']
        }] }); })();
/**
 * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
 */
class MatDialogTitle {
    constructor(
    // The dialog title directive is always used in combination with a `MatDialogRef`.
    // tslint:disable-next-line: lightweight-tokens
    _dialogRef, _elementRef, _dialog) {
        this._dialogRef = _dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        /** Unique id for the dialog title. If none is supplied, it will be auto-generated. */
        this.id = `mat-dialog-title-${dialogElementUid++}`;
    }
    ngOnInit() {
        if (!this._dialogRef) {
            this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
        }
        if (this._dialogRef) {
            Promise.resolve().then(() => {
                const container = this._dialogRef._containerInstance;
                if (container && !container._ariaLabelledBy) {
                    container._ariaLabelledBy = this.id;
                }
            });
        }
    }
}
MatDialogTitle.ɵfac = function MatDialogTitle_Factory(t) { return new (t || MatDialogTitle)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef, 8), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
MatDialogTitle.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatDialogTitle, selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]], hostAttrs: [1, "mat-dialog-title"], hostVars: 1, hostBindings: function MatDialogTitle_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵhostProperty */.Ikx("id", ctx.id);
    } }, inputs: { id: "id" }, exportAs: ["matDialogTitle"] });
MatDialogTitle.ctorParameters = () => [
    { type: MatDialogRef, decorators: [{ type: core/* Optional */.FiY }] },
    { type: core/* ElementRef */.SBq },
    { type: MatDialog }
];
MatDialogTitle.propDecorators = {
    id: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogTitle, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-dialog-title], [matDialogTitle]',
                exportAs: 'matDialogTitle',
                host: {
                    'class': 'mat-dialog-title',
                    '[id]': 'id'
                }
            }]
    }], function () { return [{ type: MatDialogRef, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: core/* ElementRef */.SBq }, { type: MatDialog }]; }, { id: [{
            type: core/* Input */.IIB
        }] }); })();
/**
 * Scrollable content container of a dialog.
 */
class MatDialogContent {
}
MatDialogContent.ɵfac = function MatDialogContent_Factory(t) { return new (t || MatDialogContent)(); };
MatDialogContent.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatDialogContent, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-dialog-content"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogContent, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,
                host: { 'class': 'mat-dialog-content' }
            }]
    }], null, null); })();
/**
 * Container for the bottom action buttons in a dialog.
 * Stays fixed to the bottom when scrolling.
 */
class MatDialogActions {
}
MatDialogActions.ɵfac = function MatDialogActions_Factory(t) { return new (t || MatDialogActions)(); };
MatDialogActions.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatDialogActions, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-dialog-actions"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogActions, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,
                host: { 'class': 'mat-dialog-actions' }
            }]
    }], null, null); })();
/**
 * Finds the closest MatDialogRef to an element by looking at the DOM.
 * @param element Element relative to which to look for a dialog.
 * @param openDialogs References to the currently-open dialogs.
 */
function getClosestDialog(element, openDialogs) {
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('mat-dialog-container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find(dialog => dialog.id === parent.id) : null;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatDialogModule {
}
MatDialogModule.ɵfac = function MatDialogModule_Factory(t) { return new (t || MatDialogModule)(); };
MatDialogModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatDialogModule });
MatDialogModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [
        MatDialog,
        MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,
    ], imports: [[
            overlay/* OverlayModule */.U8,
            portal/* PortalModule */.eL,
            fesm2015_core/* MatCommonModule */.BQ,
        ], fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatDialogModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [
                    overlay/* OverlayModule */.U8,
                    portal/* PortalModule */.eL,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                exports: [
                    MatDialogContainer,
                    MatDialogClose,
                    MatDialogTitle,
                    MatDialogContent,
                    MatDialogActions,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                declarations: [
                    MatDialogContainer,
                    MatDialogClose,
                    MatDialogTitle,
                    MatDialogActions,
                    MatDialogContent,
                ],
                providers: [
                    MatDialog,
                    MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,
                ],
                entryComponents: [MatDialogContainer]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatDialogModule, { declarations: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogActions, MatDialogContent]; }, imports: function () { return [overlay/* OverlayModule */.U8,
        portal/* PortalModule */.eL,
        fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=dialog.js.map
;// CONCATENATED MODULE: ./src/app/shared/dialog/single-column-table-with-event-dialog.component.ts






function SingleColumnTableWithEventDialogComponent_div_1_tr_12_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 6);
    core/* ɵɵlistener */.NdJ("click", function SingleColumnTableWithEventDialogComponent_div_1_tr_12_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const row_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(2); return ctx_r4.selectRow(row_r3); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(row_r3);
} }
function SingleColumnTableWithEventDialogComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "mat-form-field");
    core/* ɵɵelementStart */.TgZ(2, "mat-label");
    core/* ɵɵtext */._uU(3, "Filter");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "input", 1, 2);
    core/* ɵɵlistener */.NdJ("keyup", function SingleColumnTableWithEventDialogComponent_div_1_Template_input_keyup_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.filterRows($event); });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "table", 3);
    core/* ɵɵelementStart */.TgZ(7, "thead");
    core/* ɵɵelementStart */.TgZ(8, "tr", 4);
    core/* ɵɵelementStart */.TgZ(9, "th");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "tbody");
    core/* ɵɵtemplate */.YNc(12, SingleColumnTableWithEventDialogComponent_div_1_tr_12_Template, 3, 1, "tr", 5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.rows);
} }
class SingleColumnTableWithEventDialogComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
        this.rows = [];
        this.fullRows = [];
    }
    init(title, rows) {
        this.title = title;
        this.rows = rows;
        this.fullRows = rows;
    }
    filterRows(event) {
        const filterValue = event.target.value.trim().toLowerCase();
        this.rows = this.fullRows.filter(entry => entry.toLowerCase().indexOf(filterValue) > -1);
    }
    selectRow(value) {
        this.dialogRef.close(value);
    }
}
SingleColumnTableWithEventDialogComponent.ɵfac = function SingleColumnTableWithEventDialogComponent_Factory(t) { return new (t || SingleColumnTableWithEventDialogComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
SingleColumnTableWithEventDialogComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SingleColumnTableWithEventDialogComponent, selectors: [["app-single-column-table-with-event-dialog"]], decls: 2, vars: 1, consts: [[4, "ngIf"], ["matInput", "", 3, "keyup"], ["input", ""], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"]], template: function SingleColumnTableWithEventDialogComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵtemplate */.YNc(1, SingleColumnTableWithEventDialogComponent_div_1_Template, 13, 2, "div", 0);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.rows !== undefined);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, MatFormField, MatLabel, MatInput, common/* NgForOf */.sg], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/ngx-toastr/__ivy_ngcc__/fesm2015/ngx-toastr.js
var ngx_toastr = __webpack_require__(9344);
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tabs.js
var tabs = __webpack_require__(5939);
;// CONCATENATED MODULE: ./src/app/pages/socials/social.component.ts
















function SocialComponent_ng_template_2_div_0_tr_11_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r20 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_button_2_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r20); const row_r10 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r18 = core/* ɵɵnextContext */.oxw(3); return ctx_r18.changeStatus(row_r10, 4); });
    core/* ɵɵtext */._uU(1, "Funny ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_2_div_0_tr_11_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r23 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_button_3_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r23); const row_r10 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r21 = core/* ɵɵnextContext */.oxw(3); return ctx_r21.changeStatus(row_r10, 5); });
    core/* ɵɵtext */._uU(1, "Cool ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_2_div_0_tr_11_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r26 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 24);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_button_4_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r26); const row_r10 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r24 = core/* ɵɵnextContext */.oxw(3); return ctx_r24.changeStatus(row_r10, 7); });
    core/* ɵɵtext */._uU(1, "Reject ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_2_div_0_tr_11_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r29 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 25);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_button_5_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r29); const row_r10 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r27 = core/* ɵɵnextContext */.oxw(3); return ctx_r27.changeStatus(row_r10, 1); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r10 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r10.status);
} }
function SocialComponent_ng_template_2_div_0_tr_11_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r33 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 26);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_button_6_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r33); const row_r10 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r31 = core/* ɵɵnextContext */.oxw(3); return ctx_r31.changeStatus(row_r10, 1); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r10 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r10.status);
} }
function SocialComponent_ng_template_2_div_0_tr_11_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r10 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r10.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_2_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r37 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_2_div_0_tr_11_button_2_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_2_div_0_tr_11_button_3_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_2_div_0_tr_11_button_4_Template, 2, 0, "button", 17);
    core/* ɵɵtemplate */.YNc(5, SocialComponent_ng_template_2_div_0_tr_11_button_5_Template, 2, 1, "button", 18);
    core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_2_div_0_tr_11_button_6_Template, 2, 1, "button", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtemplate */.YNc(8, SocialComponent_ng_template_2_div_0_tr_11_img_8_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "textarea", 21);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_2_div_0_tr_11_Template_textarea_ngModelChange_11_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r37); const row_r10 = restoredCtx.$implicit; return row_r10.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "div");
    core/* ɵɵelementStart */.TgZ(13, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_div_0_tr_11_Template_button_click_13_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r37); const row_r10 = restoredCtx.$implicit; const ctx_r38 = core/* ɵɵnextContext */.oxw(3); return ctx_r38.openPopup(row_r10); });
    core/* ɵɵtext */._uU(14, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r10 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 4 || row_r10.status == 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 7);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r10.status == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r10.tags);
} }
function SocialComponent_ng_template_2_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_2_div_0_tr_11_Template, 15, 7, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r7.status1Data);
} }
function SocialComponent_ng_template_2_tr_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const value_r39 = ctx.$implicit;
    const i_r40 = ctx.index;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(i_r40 + 1);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(value_r39);
} }
function SocialComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r42 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_2_div_0_Template, 12, 1, "div", 8);
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵelementStart */.TgZ(3, "table", 9);
    core/* ɵɵelementStart */.TgZ(4, "thead");
    core/* ɵɵelementStart */.TgZ(5, "tr", 10);
    core/* ɵɵelementStart */.TgZ(6, "th", 11);
    core/* ɵɵelementStart */.TgZ(7, "button", 12);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_Template_button_click_7_listener() { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r41 = core/* ɵɵnextContext */.oxw(); return ctx_r41.loadSumData(); });
    core/* ɵɵtext */._uU(8, "Load data");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 13);
    core/* ɵɵelementStart */.TgZ(10, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_2_Template_button_click_10_listener() { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r43 = core/* ɵɵnextContext */.oxw(); return ctx_r43.save(1); });
    core/* ɵɵtext */._uU(11, "Save");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "tbody");
    core/* ɵɵtemplate */.YNc(13, SocialComponent_ng_template_2_tr_13_Template, 5, 2, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.status1Data != null);
    core/* ɵɵadvance */.xp6(13);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.sumData);
} }
function SocialComponent_ng_template_4_div_0_tr_11_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r54 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_4_div_0_tr_11_button_2_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r54); const row_r46 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r52 = core/* ɵɵnextContext */.oxw(3); return ctx_r52.changeStatus(row_r46, 6); });
    core/* ɵɵtext */._uU(1, "Convert ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_4_div_0_tr_11_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r57 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 24);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_4_div_0_tr_11_button_3_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r57); const row_r46 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r55 = core/* ɵɵnextContext */.oxw(3); return ctx_r55.changeStatus(row_r46, 7); });
    core/* ɵɵtext */._uU(1, "Reject ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_4_div_0_tr_11_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r60 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 25);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_4_div_0_tr_11_button_4_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r60); const row_r46 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r58 = core/* ɵɵnextContext */.oxw(3); return ctx_r58.changeStatus(row_r46, 2); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r46 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r46.status);
} }
function SocialComponent_ng_template_4_div_0_tr_11_img_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r46 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r46.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_4_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r64 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_4_div_0_tr_11_button_2_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_4_div_0_tr_11_button_3_Template, 2, 0, "button", 17);
    core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_4_div_0_tr_11_button_4_Template, 2, 1, "button", 18);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_4_div_0_tr_11_img_6_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵelementStart */.TgZ(8, "div");
    core/* ɵɵelementStart */.TgZ(9, "input", 28);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_4_div_0_tr_11_Template_input_ngModelChange_9_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r64); const row_r46 = restoredCtx.$implicit; return row_r46.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_4_div_0_tr_11_Template_button_click_11_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r64); const row_r46 = restoredCtx.$implicit; const ctx_r65 = core/* ɵɵnextContext */.oxw(3); return ctx_r65.openPopup(row_r46); });
    core/* ɵɵtext */._uU(12, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r46 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r46.status == 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r46.status == 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r46.status == 6);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r46.status == 2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r46.tags);
} }
function SocialComponent_ng_template_4_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r67 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_4_div_0_tr_11_Template, 13, 5, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_4_div_0_Template_button_click_12_listener() { core/* ɵɵrestoreView */.CHM(_r67); const ctx_r66 = core/* ɵɵnextContext */.oxw(2); return ctx_r66.save(2); });
    core/* ɵɵtext */._uU(13, "Save");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r44 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r44.status2Data);
} }
function SocialComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_4_div_0_Template, 14, 1, "div", 8);
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.status2Data != null);
} }
function SocialComponent_ng_template_6_div_0_tr_11_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r80 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_button_2_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r80); const row_r70 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r78 = core/* ɵɵnextContext */.oxw(3); return ctx_r78.changeStatus(row_r70, 4); });
    core/* ɵɵtext */._uU(1, "Funny ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_6_div_0_tr_11_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r83 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_button_3_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r83); const row_r70 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r81 = core/* ɵɵnextContext */.oxw(3); return ctx_r81.changeStatus(row_r70, 5); });
    core/* ɵɵtext */._uU(1, "Cool ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_6_div_0_tr_11_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r86 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 24);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_button_4_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r86); const row_r70 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r84 = core/* ɵɵnextContext */.oxw(3); return ctx_r84.changeStatus(row_r70, 7); });
    core/* ɵɵtext */._uU(1, "Reject ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_6_div_0_tr_11_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r89 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 25);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_button_5_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r89); const row_r70 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r87 = core/* ɵɵnextContext */.oxw(3); return ctx_r87.changeStatus(row_r70, 3); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r70 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r70.status);
} }
function SocialComponent_ng_template_6_div_0_tr_11_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r93 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 26);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_button_6_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r93); const row_r70 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r91 = core/* ɵɵnextContext */.oxw(3); return ctx_r91.changeStatus(row_r70, 3); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r70 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r70.status);
} }
function SocialComponent_ng_template_6_div_0_tr_11_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r70 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r70.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_6_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r97 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_6_div_0_tr_11_button_2_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_6_div_0_tr_11_button_3_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_6_div_0_tr_11_button_4_Template, 2, 0, "button", 17);
    core/* ɵɵtemplate */.YNc(5, SocialComponent_ng_template_6_div_0_tr_11_button_5_Template, 2, 1, "button", 18);
    core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_6_div_0_tr_11_button_6_Template, 2, 1, "button", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtemplate */.YNc(8, SocialComponent_ng_template_6_div_0_tr_11_img_8_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "textarea", 21);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_6_div_0_tr_11_Template_textarea_ngModelChange_11_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r97); const row_r70 = restoredCtx.$implicit; return row_r70.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "div");
    core/* ɵɵelementStart */.TgZ(13, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_tr_11_Template_button_click_13_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r97); const row_r70 = restoredCtx.$implicit; const ctx_r98 = core/* ɵɵnextContext */.oxw(3); return ctx_r98.openPopup(row_r70); });
    core/* ɵɵtext */._uU(14, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r70 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 4 || row_r70.status == 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 7);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r70.status == 3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r70.tags);
} }
function SocialComponent_ng_template_6_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r100 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_6_div_0_tr_11_Template, 15, 7, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_6_div_0_Template_button_click_12_listener() { core/* ɵɵrestoreView */.CHM(_r100); const ctx_r99 = core/* ɵɵnextContext */.oxw(2); return ctx_r99.save(3); });
    core/* ɵɵtext */._uU(13, "Save");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r68 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r68.status3Data);
} }
function SocialComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_6_div_0_Template, 14, 1, "div", 8);
    core/* ɵɵelement */._UZ(1, "div");
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.status3Data != null);
} }
function SocialComponent_ng_template_8_div_0_tr_11_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r111 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_8_div_0_tr_11_button_2_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r111); const row_r103 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r109 = core/* ɵɵnextContext */.oxw(3); return ctx_r109.changeStatus(row_r103, 6); });
    core/* ɵɵtext */._uU(1, "Convert ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_8_div_0_tr_11_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r114 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 24);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_8_div_0_tr_11_button_3_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r114); const row_r103 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r112 = core/* ɵɵnextContext */.oxw(3); return ctx_r112.changeStatus(row_r103, 7); });
    core/* ɵɵtext */._uU(1, "Reject ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_8_div_0_tr_11_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r117 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 25);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_8_div_0_tr_11_button_4_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r117); const row_r103 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r115 = core/* ɵɵnextContext */.oxw(3); return ctx_r115.changeStatus(row_r103, 4); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r103 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r103.status);
} }
function SocialComponent_ng_template_8_div_0_tr_11_img_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r103 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r103.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_8_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r121 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_8_div_0_tr_11_button_2_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_8_div_0_tr_11_button_3_Template, 2, 0, "button", 17);
    core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_8_div_0_tr_11_button_4_Template, 2, 1, "button", 18);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_8_div_0_tr_11_img_6_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵelementStart */.TgZ(8, "div");
    core/* ɵɵelementStart */.TgZ(9, "textarea", 21);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_8_div_0_tr_11_Template_textarea_ngModelChange_9_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r121); const row_r103 = restoredCtx.$implicit; return row_r103.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_8_div_0_tr_11_Template_button_click_11_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r121); const row_r103 = restoredCtx.$implicit; const ctx_r122 = core/* ɵɵnextContext */.oxw(3); return ctx_r122.openPopup(row_r103); });
    core/* ɵɵtext */._uU(12, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r103 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r103.status == 4);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r103.status == 4);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r103.status == 6);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r103.status == 4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r103.tags);
} }
function SocialComponent_ng_template_8_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r124 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_8_div_0_tr_11_Template, 13, 5, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_8_div_0_Template_button_click_12_listener() { core/* ɵɵrestoreView */.CHM(_r124); const ctx_r123 = core/* ɵɵnextContext */.oxw(2); return ctx_r123.save(4); });
    core/* ɵɵtext */._uU(13, "Save");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r101 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r101.status4Data);
} }
function SocialComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_8_div_0_Template, 14, 1, "div", 8);
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.status4Data != null);
} }
function SocialComponent_ng_template_10_div_0_tr_11_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r135 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 23);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_10_div_0_tr_11_button_2_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r135); const row_r127 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r133 = core/* ɵɵnextContext */.oxw(3); return ctx_r133.changeStatus(row_r127, 6); });
    core/* ɵɵtext */._uU(1, "Convert ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_10_div_0_tr_11_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r138 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 24);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_10_div_0_tr_11_button_3_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r138); const row_r127 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r136 = core/* ɵɵnextContext */.oxw(3); return ctx_r136.changeStatus(row_r127, 7); });
    core/* ɵɵtext */._uU(1, "Reject ");
    core/* ɵɵelementEnd */.qZA();
} }
function SocialComponent_ng_template_10_div_0_tr_11_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r141 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 25);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_10_div_0_tr_11_button_4_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r141); const row_r127 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r139 = core/* ɵɵnextContext */.oxw(3); return ctx_r139.changeStatus(row_r127, 5); });
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r127 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(row_r127.status);
} }
function SocialComponent_ng_template_10_div_0_tr_11_img_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r127 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r127.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_10_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r145 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_10_div_0_tr_11_button_2_Template, 2, 0, "button", 16);
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_10_div_0_tr_11_button_3_Template, 2, 0, "button", 17);
    core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_10_div_0_tr_11_button_4_Template, 2, 1, "button", 18);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_10_div_0_tr_11_img_6_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵelementStart */.TgZ(8, "div");
    core/* ɵɵelementStart */.TgZ(9, "textarea", 21);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_10_div_0_tr_11_Template_textarea_ngModelChange_9_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r145); const row_r127 = restoredCtx.$implicit; return row_r127.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_10_div_0_tr_11_Template_button_click_11_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r145); const row_r127 = restoredCtx.$implicit; const ctx_r146 = core/* ɵɵnextContext */.oxw(3); return ctx_r146.openPopup(row_r127); });
    core/* ɵɵtext */._uU(12, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r127 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r127.status == 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r127.status == 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", row_r127.status == 6);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", row_r127.status == 5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r127.tags);
} }
function SocialComponent_ng_template_10_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r148 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_10_div_0_tr_11_Template, 13, 5, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_10_div_0_Template_button_click_12_listener() { core/* ɵɵrestoreView */.CHM(_r148); const ctx_r147 = core/* ɵɵnextContext */.oxw(2); return ctx_r147.save(5); });
    core/* ɵɵtext */._uU(13, "Save");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r125 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r125.status5Data);
} }
function SocialComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_10_div_0_Template, 14, 1, "div", 8);
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r4.status5Data != null);
} }
function SocialComponent_ng_template_12_div_0_tr_11_img_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r151 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r151.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_12_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r156 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelement */._UZ(1, "td");
    core/* ɵɵelementStart */.TgZ(2, "td");
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_12_div_0_tr_11_img_3_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "td");
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵelementStart */.TgZ(6, "textarea", 21);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_12_div_0_tr_11_Template_textarea_ngModelChange_6_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r156); const row_r151 = restoredCtx.$implicit; return row_r151.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵelementStart */.TgZ(8, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_12_div_0_tr_11_Template_button_click_8_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r156); const row_r151 = restoredCtx.$implicit; const ctx_r157 = core/* ɵɵnextContext */.oxw(3); return ctx_r157.openPopup(row_r151); });
    core/* ɵɵtext */._uU(9, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r151 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", row_r151.status == 6);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r151.tags);
} }
function SocialComponent_ng_template_12_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r159 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_12_div_0_tr_11_Template, 10, 2, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "button", 14);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_12_div_0_Template_button_click_12_listener() { core/* ɵɵrestoreView */.CHM(_r159); const ctx_r158 = core/* ɵɵnextContext */.oxw(2); return ctx_r158.clear(6); });
    core/* ɵɵtext */._uU(13, "Clear");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r149 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r149.status6Data);
} }
function SocialComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_12_div_0_Template, 14, 1, "div", 8);
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r5.status6Data != null);
} }
function SocialComponent_ng_template_14_div_0_tr_11_img_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 27);
} if (rf & 2) {
    const row_r162 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", row_r162.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SocialComponent_ng_template_14_div_0_tr_11_Template(rf, ctx) { if (rf & 1) {
    const _r167 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelement */._UZ(1, "td");
    core/* ɵɵelementStart */.TgZ(2, "td");
    core/* ɵɵtemplate */.YNc(3, SocialComponent_ng_template_14_div_0_tr_11_img_3_Template, 1, 1, "img", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "td");
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵelementStart */.TgZ(6, "input", 28);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SocialComponent_ng_template_14_div_0_tr_11_Template_input_ngModelChange_6_listener($event) { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r167); const row_r162 = restoredCtx.$implicit; return row_r162.tags = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵelementStart */.TgZ(8, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function SocialComponent_ng_template_14_div_0_tr_11_Template_button_click_8_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r167); const row_r162 = restoredCtx.$implicit; const ctx_r168 = core/* ɵɵnextContext */.oxw(3); return ctx_r168.openPopup(row_r162); });
    core/* ɵɵtext */._uU(9, "X");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r162 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", row_r162.status == 8);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", row_r162.tags);
} }
function SocialComponent_ng_template_14_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 9);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 10);
    core/* ɵɵelementStart */.TgZ(4, "th", 11);
    core/* ɵɵtext */._uU(5, "Action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 13);
    core/* ɵɵtext */._uU(7, "Image");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 13);
    core/* ɵɵtext */._uU(9, "Tags");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tbody");
    core/* ɵɵtemplate */.YNc(11, SocialComponent_ng_template_14_div_0_tr_11_Template, 10, 2, "tr", 15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r160 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r160.status8Data);
} }
function SocialComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SocialComponent_ng_template_14_div_0_Template, 12, 1, "div", 8);
} if (rf & 2) {
    const ctx_r6 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r6.status8Data != null);
} }
class SocialComponent {
    constructor(toastr, restService, dialog, utilityService) {
        this.toastr = toastr;
        this.restService = restService;
        this.dialog = dialog;
        this.utilityService = utilityService;
        this.sumData = [];
        this.myControl = new fesm2015_forms/* FormControl */.NI('');
        this.username = localStorage.getItem('f1-chosen-nickname');
        this.utilityService.setTitle(12, 'Socials');
        this.getData();
    }
    handleInstagramTags(data) {
        let instagramTags = [];
        let instagramTagsMap = new Map();
        data.forEach(person => {
            instagramTags.push(person.key);
            instagramTagsMap.set(person.key, person.value);
        });
        this.instagramTags = instagramTags;
        this.instagramTagsMap = instagramTagsMap;
    }
    getData() {
        this.restService.getInstagramFollows().subscribe({
            next: data => {
                this.handleInstagramTags(data);
                return data;
            }
        });
        this.restService.getChanPostsByStatus(1, this.username).subscribe({
            next: data => {
                this.status1Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(2, this.username).subscribe({
            next: data => {
                this.status2Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(3, this.username).subscribe({
            next: data => {
                this.status3Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(4, this.username).subscribe({
            next: data => {
                this.status4Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(5, this.username).subscribe({
            next: data => {
                this.status5Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(6, this.username).subscribe({
            next: data => {
                this.status6Data = data;
                return data;
            }
        });
        this.restService.getChanPostsByStatus(6, this.username).subscribe({
            next: data => {
                this.status8Data = data;
                return data;
            }
        });
    }
    loadSumData() {
        this.restService.getChanPostsSums(this.username).subscribe({
            next: data => {
                this.sumData = data;
                return data;
            }
        });
    }
    ngOnInit() {
        this.filteredInstagramTags = this.myControl.valueChanges.pipe((0,startWith/* startWith */.O)(''), (0,operators_map/* map */.U)(value => this._filter(value || '')));
    }
    _filter(value) {
        const filterValue = value.toLowerCase();
        return this.instagramTags.filter(option => option.toLowerCase().includes(filterValue));
    }
    changeStatus(row, status) {
        row.status = status;
    }
    clear(table) {
        if (table == 6) {
            this.status6Data.forEach(entry => {
                entry.status = 7;
            });
            this.restService.saveChanPosts(this.status6Data, this.username).subscribe({
                next: data => {
                    this.restService.getChanPostsByStatus(6, this.username).subscribe({
                        next: data => {
                            this.status6Data = data;
                            return data;
                        }
                    });
                    this.toastr.info('Cleared', '');
                    return data;
                }
            });
        }
    }
    save(table) {
        if (table == 1) {
            this.status1Data.forEach(entry => {
                if (entry.status == 1) {
                    entry.status = 7;
                }
            });
            this.restService.saveChanPosts(this.status1Data, this.username).subscribe({
                next: data => {
                    this.status1Data = data;
                    this.toastr.info('Saved', '');
                    return data;
                }
            });
        }
        if (table == 2) {
            this.status2Data.forEach(entry => {
                if (entry.status == 2) {
                    entry.status = 7;
                }
            });
            this.restService.saveChanPosts(this.status2Data, this.username).subscribe({
                next: data => {
                    this.restService.getChanPostsByStatus(2, this.username).subscribe({
                        next: data => {
                            this.status2Data = data;
                            return data;
                        }
                    });
                    this.toastr.info('Saved', '');
                    return data;
                }
            });
        }
        if (table == 3) {
            this.status3Data.forEach(entry => {
                if (entry.status == 3) {
                    entry.status = 7;
                }
            });
            this.restService.saveChanPosts(this.status3Data, this.username).subscribe({
                next: data => {
                    this.restService.getChanPostsByStatus(3, this.username).subscribe({
                        next: data => {
                            this.status3Data = data;
                            return data;
                        }
                    });
                    this.toastr.info('Saved', '');
                    return data;
                }
            });
        }
        if (table == 4) {
            this.restService.saveChanPosts(this.status4Data, this.username).subscribe({
                next: data => {
                    this.restService.getChanPostsByStatus(4, this.username).subscribe({
                        next: data => {
                            this.status4Data = data;
                            return data;
                        }
                    });
                    this.toastr.info('Saved', '');
                    return data;
                }
            });
        }
        if (table == 5) {
            this.restService.saveChanPosts(this.status5Data, this.username).subscribe({
                next: data => {
                    this.restService.getChanPostsByStatus(5, this.username).subscribe({
                        next: data => {
                            this.status5Data = data;
                            return data;
                        }
                    });
                    this.toastr.info('Saved', '');
                    return data;
                }
            });
        }
    }
    openPopup(row) {
        const dialogRef = this.dialog.open(SingleColumnTableWithEventDialogComponent);
        dialogRef.componentInstance.init('Tag', this.instagramTags);
        dialogRef.afterClosed().subscribe(selectedTag => {
            if (selectedTag != null) {
                if (row.tags == null) {
                    row.tags = 'Thank you ' + '@' + selectedTag + ', very cool! \r\n\n' + this.instagramTagsMap.get(selectedTag);
                }
                else {
                    row.tags = row.tags + '@' + selectedTag + ' ' + this.instagramTagsMap.get(selectedTag);
                }
            }
        });
    }
}
SocialComponent.ɵfac = function SocialComponent_Factory(t) { return new (t || SocialComponent)(core/* ɵɵdirectiveInject */.Y36(ngx_toastr/* ToastrService */._W), core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(MatDialog), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t)); };
SocialComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SocialComponent, selectors: [["socials-cmp"]], decls: 15, vars: 0, consts: [["label", "Status 1 (jpg)"], ["matTabContent", ""], ["label", "Status 2 (png)"], ["label", "Status 3 (imported)"], ["label", "Status 4 (memes)"], ["label", "Status 5  (serious)"], ["label", "Status 6  (toConvert)"], ["label", "Status 8 (Posted)"], [4, "ngIf"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["scope", "col", 1, "width-100-px"], ["color", "accent", "mat-raised-button", "", 1, "width-100-px", 3, "click"], ["scope", "col"], ["color", "primary", "mat-raised-button", "", 1, "width-100", 3, "click"], [4, "ngFor", "ngForOf"], ["class", "width-100-px div-height-70 mt-4", "color", "primary", "mat-raised-button", "", 3, "click", 4, "ngIf"], ["class", "width-100-px div-height-70 mt-4", "color", "warn", "mat-raised-button", "", 3, "click", 4, "ngIf"], ["class", "width-100-px", "color", "primary", "mat-raised-button", "", 3, "click", 4, "ngIf"], ["class", "width-100-px", "color", "warn", "mat-raised-button", "", 3, "click", 4, "ngIf"], ["alt", "image", "style", "max-height:50vh", 3, "src", 4, "ngIf"], ["rows", "5", "type", "text", 1, "width-100", 3, "ngModel", "ngModelChange"], ["color", "primary", "mat-flat-button", "", 3, "click"], ["color", "primary", "mat-raised-button", "", 1, "width-100-px", "div-height-70", "mt-4", 3, "click"], ["color", "warn", "mat-raised-button", "", 1, "width-100-px", "div-height-70", "mt-4", 3, "click"], ["color", "primary", "mat-raised-button", "", 1, "width-100-px", 3, "click"], ["color", "warn", "mat-raised-button", "", 1, "width-100-px", 3, "click"], ["alt", "image", 2, "max-height", "50vh", 3, "src"], ["type", "text", 3, "ngModel", "ngModelChange"]], template: function SocialComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-tab-group");
        core/* ɵɵelementStart */.TgZ(1, "mat-tab", 0);
        core/* ɵɵtemplate */.YNc(2, SocialComponent_ng_template_2_Template, 14, 2, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(3, "mat-tab", 2);
        core/* ɵɵtemplate */.YNc(4, SocialComponent_ng_template_4_Template, 1, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(5, "mat-tab", 3);
        core/* ɵɵtemplate */.YNc(6, SocialComponent_ng_template_6_Template, 2, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "mat-tab", 4);
        core/* ɵɵtemplate */.YNc(8, SocialComponent_ng_template_8_Template, 1, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(9, "mat-tab", 5);
        core/* ɵɵtemplate */.YNc(10, SocialComponent_ng_template_10_Template, 1, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "mat-tab", 6);
        core/* ɵɵtemplate */.YNc(12, SocialComponent_ng_template_12_Template, 1, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(13, "mat-tab", 7);
        core/* ɵɵtemplate */.YNc(14, SocialComponent_ng_template_14_Template, 1, 1, "ng-template", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } }, directives: [tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, common/* NgIf */.O5, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/snackbar/snackbar.component.ts



class SnackbarComponent {
    constructor(utilityService) {
        this.utilityService = utilityService;
        this.displayText = 'I don\'t even know what to say...';
        this.displayText = localStorage.getItem('f1-vote-message');
    }
}
SnackbarComponent.ɵfac = function SnackbarComponent_Factory(t) { return new (t || SnackbarComponent)(core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t)); };
SnackbarComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SnackbarComponent, selectors: [["app-snackbar-component-default"]], decls: 2, vars: 1, template: function SnackbarComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "span");
        core/* ɵɵtext */._uU(1);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵtextInterpolate1 */.hij(" ", ctx.displayText, "\n");
    } }, styles: [".hotpink-css[_ngcontent-%COMP%]{background-color:hotpink}"] });

// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/snack-bar.js
var snack_bar = __webpack_require__(7001);
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/button-toggle.js
var button_toggle = __webpack_require__(2542);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/card.js




/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Content of a card, needed as it's used as a selector in the API.
 * @docs-private
 */


const card_c0 = ["*", [["mat-card-footer"]]];
const card_c1 = ["*", "mat-card-footer"];
const card_c2 = [[["", "mat-card-avatar", ""], ["", "matCardAvatar", ""]], [["mat-card-title"], ["mat-card-subtitle"], ["", "mat-card-title", ""], ["", "mat-card-subtitle", ""], ["", "matCardTitle", ""], ["", "matCardSubtitle", ""]], "*"];
const card_c3 = ["[mat-card-avatar], [matCardAvatar]", "mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]", "*"];
const card_c4 = [[["mat-card-title"], ["mat-card-subtitle"], ["", "mat-card-title", ""], ["", "mat-card-subtitle", ""], ["", "matCardTitle", ""], ["", "matCardSubtitle", ""]], [["img"]], "*"];
const card_c5 = ["mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]", "img", "*"];
class MatCardContent {
}
MatCardContent.ɵfac = function MatCardContent_Factory(t) { return new (t || MatCardContent)(); };
MatCardContent.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardContent, selectors: [["mat-card-content"], ["", "mat-card-content", ""], ["", "matCardContent", ""]], hostAttrs: [1, "mat-card-content"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardContent, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-card-content, [mat-card-content], [matCardContent]',
                host: { 'class': 'mat-card-content' }
            }]
    }], null, null); })();
/**
 * Title of a card, needed as it's used as a selector in the API.
 * @docs-private
 */
class MatCardTitle {
}
MatCardTitle.ɵfac = function MatCardTitle_Factory(t) { return new (t || MatCardTitle)(); };
MatCardTitle.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardTitle, selectors: [["mat-card-title"], ["", "mat-card-title", ""], ["", "matCardTitle", ""]], hostAttrs: [1, "mat-card-title"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardTitle, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `mat-card-title, [mat-card-title], [matCardTitle]`,
                host: {
                    'class': 'mat-card-title'
                }
            }]
    }], null, null); })();
/**
 * Sub-title of a card, needed as it's used as a selector in the API.
 * @docs-private
 */
class MatCardSubtitle {
}
MatCardSubtitle.ɵfac = function MatCardSubtitle_Factory(t) { return new (t || MatCardSubtitle)(); };
MatCardSubtitle.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardSubtitle, selectors: [["mat-card-subtitle"], ["", "mat-card-subtitle", ""], ["", "matCardSubtitle", ""]], hostAttrs: [1, "mat-card-subtitle"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardSubtitle, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]`,
                host: {
                    'class': 'mat-card-subtitle'
                }
            }]
    }], null, null); })();
/**
 * Action section of a card, needed as it's used as a selector in the API.
 * @docs-private
 */
class MatCardActions {
    constructor() {
        /** Position of the actions inside the card. */
        this.align = 'start';
    }
}
MatCardActions.ɵfac = function MatCardActions_Factory(t) { return new (t || MatCardActions)(); };
MatCardActions.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardActions, selectors: [["mat-card-actions"]], hostAttrs: [1, "mat-card-actions"], hostVars: 2, hostBindings: function MatCardActions_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵclassProp */.ekj("mat-card-actions-align-end", ctx.align === "end");
    } }, inputs: { align: "align" }, exportAs: ["matCardActions"] });
MatCardActions.propDecorators = {
    align: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardActions, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-card-actions',
                exportAs: 'matCardActions',
                host: {
                    'class': 'mat-card-actions',
                    '[class.mat-card-actions-align-end]': 'align === "end"'
                }
            }]
    }], function () { return []; }, { align: [{
            type: core/* Input */.IIB
        }] }); })();
/**
 * Footer of a card, needed as it's used as a selector in the API.
 * @docs-private
 */
class MatCardFooter {
}
MatCardFooter.ɵfac = function MatCardFooter_Factory(t) { return new (t || MatCardFooter)(); };
MatCardFooter.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardFooter, selectors: [["mat-card-footer"]], hostAttrs: [1, "mat-card-footer"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardFooter, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-card-footer',
                host: { 'class': 'mat-card-footer' }
            }]
    }], null, null); })();
/**
 * Image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardImage {
}
MatCardImage.ɵfac = function MatCardImage_Factory(t) { return new (t || MatCardImage)(); };
MatCardImage.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardImage, selectors: [["", "mat-card-image", ""], ["", "matCardImage", ""]], hostAttrs: [1, "mat-card-image"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardImage, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-image], [matCardImage]',
                host: { 'class': 'mat-card-image' }
            }]
    }], null, null); })();
/**
 * Image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardSmImage {
}
MatCardSmImage.ɵfac = function MatCardSmImage_Factory(t) { return new (t || MatCardSmImage)(); };
MatCardSmImage.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardSmImage, selectors: [["", "mat-card-sm-image", ""], ["", "matCardImageSmall", ""]], hostAttrs: [1, "mat-card-sm-image"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardSmImage, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-sm-image], [matCardImageSmall]',
                host: { 'class': 'mat-card-sm-image' }
            }]
    }], null, null); })();
/**
 * Image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardMdImage {
}
MatCardMdImage.ɵfac = function MatCardMdImage_Factory(t) { return new (t || MatCardMdImage)(); };
MatCardMdImage.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardMdImage, selectors: [["", "mat-card-md-image", ""], ["", "matCardImageMedium", ""]], hostAttrs: [1, "mat-card-md-image"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardMdImage, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-md-image], [matCardImageMedium]',
                host: { 'class': 'mat-card-md-image' }
            }]
    }], null, null); })();
/**
 * Image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardLgImage {
}
MatCardLgImage.ɵfac = function MatCardLgImage_Factory(t) { return new (t || MatCardLgImage)(); };
MatCardLgImage.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardLgImage, selectors: [["", "mat-card-lg-image", ""], ["", "matCardImageLarge", ""]], hostAttrs: [1, "mat-card-lg-image"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardLgImage, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-lg-image], [matCardImageLarge]',
                host: { 'class': 'mat-card-lg-image' }
            }]
    }], null, null); })();
/**
 * Large image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardXlImage {
}
MatCardXlImage.ɵfac = function MatCardXlImage_Factory(t) { return new (t || MatCardXlImage)(); };
MatCardXlImage.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardXlImage, selectors: [["", "mat-card-xl-image", ""], ["", "matCardImageXLarge", ""]], hostAttrs: [1, "mat-card-xl-image"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardXlImage, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-xl-image], [matCardImageXLarge]',
                host: { 'class': 'mat-card-xl-image' }
            }]
    }], null, null); })();
/**
 * Avatar image used in a card, needed to add the mat- CSS styling.
 * @docs-private
 */
class MatCardAvatar {
}
MatCardAvatar.ɵfac = function MatCardAvatar_Factory(t) { return new (t || MatCardAvatar)(); };
MatCardAvatar.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatCardAvatar, selectors: [["", "mat-card-avatar", ""], ["", "matCardAvatar", ""]], hostAttrs: [1, "mat-card-avatar"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardAvatar, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-card-avatar], [matCardAvatar]',
                host: { 'class': 'mat-card-avatar' }
            }]
    }], null, null); })();
/**
 * A basic content container component that adds the styles of a Material design card.
 *
 * While this component can be used alone, it also provides a number
 * of preset styles for common card sections, including:
 * - mat-card-title
 * - mat-card-subtitle
 * - mat-card-content
 * - mat-card-actions
 * - mat-card-footer
 */
class MatCard {
    // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
    constructor(_animationMode) {
        this._animationMode = _animationMode;
    }
}
MatCard.ɵfac = function MatCard_Factory(t) { return new (t || MatCard)(core/* ɵɵdirectiveInject */.Y36(fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb, 8)); };
MatCard.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatCard, selectors: [["mat-card"]], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function MatCard_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵclassProp */.ekj("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
    } }, exportAs: ["matCard"], ngContentSelectors: card_c1, decls: 2, vars: 0, template: function MatCard_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(card_c0);
        core/* ɵɵprojection */.Hsn(0);
        core/* ɵɵprojection */.Hsn(1, 1);
    } }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 });
MatCard.ctorParameters = () => [
    { type: String, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCard, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-card',
                exportAs: 'matCard',
                template: "<ng-content></ng-content>\n<ng-content select=\"mat-card-footer\"></ng-content>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                host: {
                    'class': 'mat-card mat-focus-indicator',
                    '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"'
                },
                styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb]
            }] }]; }, null); })();
/**
 * Component intended to be used within the `<mat-card>` component. It adds styles for a
 * preset header section (i.e. a title, subtitle, and avatar layout).
 * @docs-private
 */
class MatCardHeader {
}
MatCardHeader.ɵfac = function MatCardHeader_Factory(t) { return new (t || MatCardHeader)(); };
MatCardHeader.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatCardHeader, selectors: [["mat-card-header"]], hostAttrs: [1, "mat-card-header"], ngContentSelectors: card_c3, decls: 4, vars: 0, consts: [[1, "mat-card-header-text"]], template: function MatCardHeader_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(card_c2);
        core/* ɵɵprojection */.Hsn(0);
        core/* ɵɵelementStart */.TgZ(1, "div", 0);
        core/* ɵɵprojection */.Hsn(2, 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵprojection */.Hsn(3, 2);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardHeader, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-card-header',
                template: "<ng-content select=\"[mat-card-avatar], [matCardAvatar]\"></ng-content>\n<div class=\"mat-card-header-text\">\n  <ng-content\n      select=\"mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]\"></ng-content>\n</div>\n<ng-content></ng-content>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                host: { 'class': 'mat-card-header' }
            }]
    }], null, null); })();
/**
 * Component intended to be used within the `<mat-card>` component. It adds styles for a preset
 * layout that groups an image with a title section.
 * @docs-private
 */
class MatCardTitleGroup {
}
MatCardTitleGroup.ɵfac = function MatCardTitleGroup_Factory(t) { return new (t || MatCardTitleGroup)(); };
MatCardTitleGroup.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatCardTitleGroup, selectors: [["mat-card-title-group"]], hostAttrs: [1, "mat-card-title-group"], ngContentSelectors: card_c5, decls: 4, vars: 0, template: function MatCardTitleGroup_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(card_c4);
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵprojection */.Hsn(1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵprojection */.Hsn(2, 1);
        core/* ɵɵprojection */.Hsn(3, 2);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardTitleGroup, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-card-title-group',
                template: "<div>\n  <ng-content\n      select=\"mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]\"></ng-content>\n</div>\n<ng-content select=\"img\"></ng-content>\n<ng-content></ng-content>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                host: { 'class': 'mat-card-title-group' }
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatCardModule {
}
MatCardModule.ɵfac = function MatCardModule_Factory(t) { return new (t || MatCardModule)(); };
MatCardModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatCardModule });
MatCardModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[fesm2015_core/* MatCommonModule */.BQ], fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCardModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [fesm2015_core/* MatCommonModule */.BQ],
                exports: [
                    MatCard,
                    MatCardHeader,
                    MatCardTitleGroup,
                    MatCardContent,
                    MatCardTitle,
                    MatCardSubtitle,
                    MatCardActions,
                    MatCardFooter,
                    MatCardSmImage,
                    MatCardMdImage,
                    MatCardLgImage,
                    MatCardImage,
                    MatCardXlImage,
                    MatCardAvatar,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                declarations: [
                    MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,
                    MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,
                    MatCardXlImage, MatCardAvatar,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatCardModule, { declarations: function () { return [MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage, MatCardXlImage, MatCardAvatar]; }, imports: function () { return [fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage, MatCardXlImage, MatCardAvatar, fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=card.js.map
// EXTERNAL MODULE: ./node_modules/ngx-countdown/fesm2015/ngx-countdown.js
var ngx_countdown = __webpack_require__(8591);
;// CONCATENATED MODULE: ./src/app/pages/exposure/exposure.component.ts


















function ExposureComponent_div_0_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 17);
    core/* ɵɵelementStart */.TgZ(2, "div", 18);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(2); return ctx_r7.utilityService.replyingTo(comment_r6.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 19);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r9 = core/* ɵɵnextContext */.oxw(2); return ctx_r9.utilityService.replyingTo(comment_r6.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 20);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r6 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.comment);
} }
function ExposureComponent_div_0_div_20_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r13 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 23);
    core/* ɵɵelementStart */.TgZ(1, "div", 24);
    core/* ɵɵelementStart */.TgZ(2, "mat-button-toggle", 25);
    core/* ɵɵlistener */.NdJ("change", function ExposureComponent_div_0_div_20_div_1_Template_mat_button_toggle_change_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r13); const ctx_r12 = core/* ɵɵnextContext */.oxw(3); return ctx_r12.onValChange($event.value); });
    core/* ɵɵelementStart */.TgZ(3, "div", 26);
    core/* ɵɵelement */._UZ(4, "img", 27);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 28);
    core/* ɵɵelementStart */.TgZ(6, "div", 29);
    core/* ɵɵelementStart */.TgZ(7, "p", 30);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const driver_r11 = ctx.$implicit;
    const ctx_r10 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("value", driver_r11.code);
    core/* ɵɵproperty */.Q6J("checked", ctx_r10.myFlagForButtonToggle);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("alt", driver_r11.name);
    core/* ɵɵpropertyInterpolate */.s9C("src", "assets/img/drivers/" + ctx_r10.exposureResponse.year + "/" + driver_r11.code + ".png", core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij("", driver_r11.fullName, " ");
} }
function ExposureComponent_div_0_div_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 21);
    core/* ɵɵtemplate */.YNc(1, ExposureComponent_div_0_div_20_div_1_Template, 9, 5, "div", 22);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r3.exposureResponse.drivers);
} }
function ExposureComponent_div_0_div_21_Template(rf, ctx) { if (rf & 1) {
    const _r15 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 5);
    core/* ɵɵelementStart */.TgZ(1, "button", 31);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_div_21_Template_button_click_1_listener() { core/* ɵɵrestoreView */.CHM(_r15); const ctx_r14 = core/* ɵɵnextContext */.oxw(2); return ctx_r14.expose(); });
    core/* ɵɵtext */._uU(2, " EXPOSE ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
const exposure_component_c0 = function (a0) { return { leftTime: a0 }; };
function ExposureComponent_div_0_div_22_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 32);
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 33);
    core/* ɵɵtext */._uU(3, " Exposure live in: ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "h1");
    core/* ɵɵelementStart */.TgZ(5, "span");
    core/* ɵɵelement */._UZ(6, "countdown", 34, 35);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(8, "br");
    core/* ɵɵelement */._UZ(9, "br");
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
    core/* ɵɵelement */._UZ(15, "br");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(1, exposure_component_c0, ctx_r5.exposureCountdown));
} }
function ExposureComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r18 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 2);
    core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 3, 4);
    core/* ɵɵlistener */.NdJ("openedChange", function ExposureComponent_div_0_Template_mat_drawer_openedChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r18); const ctx_r17 = core/* ɵɵnextContext */.oxw(); return ctx_r17.utilityService.setSidebarStatus($event); });
    core/* ɵɵelementStart */.TgZ(4, "div", 5);
    core/* ɵɵelementStart */.TgZ(5, "div", 6);
    core/* ɵɵelementStart */.TgZ(6, "div");
    core/* ɵɵelementStart */.TgZ(7, "textarea", 7);
    core/* ɵɵlistener */.NdJ("ngModelChange", function ExposureComponent_div_0_Template_textarea_ngModelChange_7_listener($event) { core/* ɵɵrestoreView */.CHM(_r18); const ctx_r19 = core/* ɵɵnextContext */.oxw(); return ctx_r19.utilityService.postText = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "div", 8);
    core/* ɵɵelementStart */.TgZ(9, "button", 9);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_Template_button_click_9_listener() { core/* ɵɵrestoreView */.CHM(_r18); const ctx_r20 = core/* ɵɵnextContext */.oxw(); return ctx_r20.utilityService.postComment(2); });
    core/* ɵɵtext */._uU(10, "Post");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "button", 9);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_Template_button_click_11_listener() { core/* ɵɵrestoreView */.CHM(_r18); const ctx_r21 = core/* ɵɵnextContext */.oxw(); return ctx_r21.utilityService.reloadPosts(2); });
    core/* ɵɵtext */._uU(12, "Reload ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(13, ExposureComponent_div_0_div_13_Template, 8, 3, "div", 10);
    core/* ɵɵelementStart */.TgZ(14, "div", 11);
    core/* ɵɵelementStart */.TgZ(15, "button", 12);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r18); const _r1 = core/* ɵɵreference */.MAs(3); const ctx_r22 = core/* ɵɵnextContext */.oxw(); return ctx_r22.utilityService.drawerToggle(_r1); });
    core/* ɵɵelement */._UZ(16, "i", 13);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "div", 11);
    core/* ɵɵelementStart */.TgZ(18, "button", 12);
    core/* ɵɵlistener */.NdJ("click", function ExposureComponent_div_0_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r18); const _r1 = core/* ɵɵreference */.MAs(3); const ctx_r23 = core/* ɵɵnextContext */.oxw(); return ctx_r23.utilityService.drawerToggle(_r1); });
    core/* ɵɵelement */._UZ(19, "i", 13);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(20, ExposureComponent_div_0_div_20_Template, 2, 1, "div", 14);
    core/* ɵɵtemplate */.YNc(21, ExposureComponent_div_0_div_21_Template, 3, 0, "div", 15);
    core/* ɵɵtemplate */.YNc(22, ExposureComponent_div_0_div_22_Template, 16, 3, "div", 16);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("opened", ctx_r0.utilityService.getSidebarStatus());
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.utilityService.postText);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.utilityService.comments);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.exposureResponse.status == "ACTIVE");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.exposureResponse.status == "ACTIVE");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.exposureResponse.status == "SOON");
} }
class ExposureComponent {
    constructor(restService, snackBar, router, utilityService) {
        this.restService = restService;
        this.snackBar = snackBar;
        this.router = router;
        this.utilityService = utilityService;
        this.exposedDrivers = [];
        this.exposureCountdown = 0;
        this.restService.getExposureDriverList().subscribe({
            next: data => {
                this.exposureResponse = data;
                if (localStorage.getItem('f1-vote-status') == this.exposureResponse.title + this.exposureResponse.year) {
                    this.redirectToExposedResults();
                }
                this.utilityService.setTitle(8, 'Who got exposed? - /' + this.exposureResponse.title + '/ edition');
                switch (this.exposureResponse.status) {
                    case 'OVER': {
                        this.redirectToExposedResults();
                        break;
                    }
                    case 'SOON': {
                        this.exposureCountdown = ~~((new Date(this.exposureResponse.exposureTime).getTime() - new Date().getTime()) / 1000);
                        break;
                    }
                    default: {
                        break;
                    }
                }
                return data;
            }
        });
    }
    expose() {
        this.restService.exposeDrivers(this.exposedDrivers).subscribe({
            next: data => {
                this.openSnackBar(data);
                localStorage.setItem('f1-vote-status', this.exposureResponse.title + this.exposureResponse.year);
                this.redirectToExposedResults();
                return data;
            }
        });
    }
    openSnackBar(success) {
        if (success) {
            localStorage.setItem('f1-vote-message', 'You\'ve exposed them');
        }
        else {
            localStorage.setItem('f1-vote-message', 'Rejected, you\'ve already voted');
        }
        this.snackBar.openFromComponent(SnackbarComponent, {
            duration: 4000,
        });
    }
    redirectToExposedResults() {
        this.router.navigate(['exposure/results']);
    }
    onValChange(driverCode) {
        if (!this.exposedDrivers.includes(driverCode)) {
            this.exposedDrivers.push(driverCode);
        }
        else {
            this.exposedDrivers = this.exposedDrivers.filter(item => item !== driverCode);
        }
    }
}
ExposureComponent.ɵfac = function ExposureComponent_Factory(t) { return new (t || ExposureComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(snack_bar/* MatSnackBar */.ux), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t)); };
ExposureComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ExposureComponent, selectors: [["app-exposure-cmp"]], decls: 1, vars: 1, consts: [["class", "div-padded", 4, "ngIf"], [1, "div-padded"], ["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "row div-padded-1rem", 4, "ngIf"], ["class", "row", 4, "ngIf"], ["class", "div-height-100a", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "row", "div-padded-1rem"], ["class", "col-lg-2 col-md-2 col-6", 4, "ngFor", "ngForOf"], [1, "col-lg-2", "col-md-2", "col-6"], [1, "card"], [3, "checked", "value", "change"], [1, "card-body"], ["mat-card-image", "", 3, "alt", "src"], [1, "card-footer"], [1, "stats"], [1, "card-title"], ["color", "primary", "mat-raised-button", "", 1, "width-100", 3, "click"], [1, "div-height-100a"], [1, "countdown-desc"], [3, "config"], ["cd", ""]], template: function ExposureComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵtemplate */.YNc(0, ExposureComponent_div_0_Template, 23, 6, "div", 0);
    } if (rf & 2) {
        core/* ɵɵproperty */.Q6J("ngIf", ctx.exposureResponse !== undefined);
    } }, directives: [common/* NgIf */.O5, sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, button_toggle/* MatButtonToggle */.Yi, MatCardImage, ngx_countdown/* CountdownComponent */.MR], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/utility/chart-utility.ts
function openInfo() {
}
class ChartUtility {
}
ChartUtility.defaultToolbar = {
    export: {
        csv: {
            filename: 'F1Exposure.com_' + new Date().toISOString(),
            columnDelimiter: ',',
            headerCategory: 'category',
            headerValue: 'value',
            dateFormatter(timestamp) {
                return new Date(timestamp).toDateString();
            }
        },
        svg: {
            filename: 'F1Exposure.com_' + new Date().toISOString(),
        },
        png: {
            filename: 'F1Exposure.com_' + new Date().toISOString(),
        }
    }
};
ChartUtility.f1exposureTitle = {
    text: "F1exposure.com",
    align: 'right',
    offsetX: 0
};

// EXTERNAL MODULE: ./src/environments/environment.ts
var environment = __webpack_require__(2340);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/progress-spinner.js







/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Base reference size of the spinner.
 * @docs-private
 */




function MatProgressSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵnamespaceSVG */.O4$();
    core/* ɵɵelement */._UZ(0, "circle", 3);
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r0._spinnerAnimationLabel)("stroke-dashoffset", ctx_r0._getStrokeDashOffset(), "px")("stroke-dasharray", ctx_r0._getStrokeCircumference(), "px")("stroke-width", ctx_r0._getCircleStrokeWidth(), "%");
    core/* ɵɵattribute */.uIk("r", ctx_r0._getCircleRadius());
} }
function MatProgressSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵnamespaceSVG */.O4$();
    core/* ɵɵelement */._UZ(0, "circle", 3);
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("stroke-dashoffset", ctx_r1._getStrokeDashOffset(), "px")("stroke-dasharray", ctx_r1._getStrokeCircumference(), "px")("stroke-width", ctx_r1._getCircleStrokeWidth(), "%");
    core/* ɵɵattribute */.uIk("r", ctx_r1._getCircleRadius());
} }
function MatSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵnamespaceSVG */.O4$();
    core/* ɵɵelement */._UZ(0, "circle", 3);
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r0._spinnerAnimationLabel)("stroke-dashoffset", ctx_r0._getStrokeDashOffset(), "px")("stroke-dasharray", ctx_r0._getStrokeCircumference(), "px")("stroke-width", ctx_r0._getCircleStrokeWidth(), "%");
    core/* ɵɵattribute */.uIk("r", ctx_r0._getCircleRadius());
} }
function MatSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵnamespaceSVG */.O4$();
    core/* ɵɵelement */._UZ(0, "circle", 3);
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("stroke-dashoffset", ctx_r1._getStrokeDashOffset(), "px")("stroke-dasharray", ctx_r1._getStrokeCircumference(), "px")("stroke-width", ctx_r1._getCircleStrokeWidth(), "%");
    core/* ɵɵattribute */.uIk("r", ctx_r1._getCircleRadius());
} }
const progress_spinner_c0 = ".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor;stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n";
const BASE_SIZE = 100;
/**
 * Base reference stroke width of the spinner.
 * @docs-private
 */
const BASE_STROKE_WIDTH = 10;
// Boilerplate for applying mixins to MatProgressSpinner.
/** @docs-private */
const _MatProgressSpinnerBase = (0,fesm2015_core/* mixinColor */.pj)(class {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}, 'primary');
/** Injection token to be used to override the default options for `mat-progress-spinner`. */
const MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('mat-progress-spinner-default-options', {
    providedIn: 'root',
    factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,
});
/** @docs-private */
function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
    return { diameter: BASE_SIZE };
}
// .0001 percentage difference is necessary in order to avoid unwanted animation frames
// for example because the animation duration is 4 seconds, .1% accounts to 4ms
// which are enough to see the flicker described in
// https://github.com/angular/components/issues/8984
const INDETERMINATE_ANIMATION_TEMPLATE = `
 @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {
    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }
    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }
    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }
    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }

    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }
    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }
    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }
    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }

    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }
    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }
    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }
    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }

    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }
    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }
    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }
    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }
  }
`;
/**
 * `<mat-progress-spinner>` component.
 */
class MatProgressSpinner extends _MatProgressSpinnerBase {
    constructor(elementRef, platform, _document, animationMode, defaults) {
        super(elementRef);
        this._document = _document;
        this._diameter = BASE_SIZE;
        this._value = 0;
        this._fallbackAnimation = false;
        /** Mode of the progress circle */
        this.mode = 'determinate';
        const trackedDiameters = MatProgressSpinner._diameters;
        this._spinnerAnimationLabel = this._getSpinnerAnimationLabel();
        // The base size is already inserted via the component's structural styles. We still
        // need to track it so we don't end up adding the same styles again.
        if (!trackedDiameters.has(_document.head)) {
            trackedDiameters.set(_document.head, new Set([BASE_SIZE]));
        }
        this._fallbackAnimation = platform.EDGE || platform.TRIDENT;
        this._noopAnimations = animationMode === 'NoopAnimations' &&
            (!!defaults && !defaults._forceAnimations);
        if (defaults) {
            if (defaults.diameter) {
                this.diameter = defaults.diameter;
            }
            if (defaults.strokeWidth) {
                this.strokeWidth = defaults.strokeWidth;
            }
        }
    }
    /** The diameter of the progress spinner (will set width and height of svg). */
    get diameter() { return this._diameter; }
    set diameter(size) {
        this._diameter = (0,coercion/* coerceNumberProperty */.su)(size);
        this._spinnerAnimationLabel = this._getSpinnerAnimationLabel();
        // If this is set before `ngOnInit`, the style root may not have been resolved yet.
        if (!this._fallbackAnimation && this._styleRoot) {
            this._attachStyleNode();
        }
    }
    /** Stroke width of the progress spinner. */
    get strokeWidth() {
        return this._strokeWidth || this.diameter / 10;
    }
    set strokeWidth(value) {
        this._strokeWidth = (0,coercion/* coerceNumberProperty */.su)(value);
    }
    /** Value of the progress circle. */
    get value() {
        return this.mode === 'determinate' ? this._value : 0;
    }
    set value(newValue) {
        this._value = Math.max(0, Math.min(100, (0,coercion/* coerceNumberProperty */.su)(newValue)));
    }
    ngOnInit() {
        const element = this._elementRef.nativeElement;
        // Note that we need to look up the root node in ngOnInit, rather than the constructor, because
        // Angular seems to create the element outside the shadow root and then moves it inside, if the
        // node is inside an `ngIf` and a ShadowDom-encapsulated component.
        this._styleRoot = (0,platform/* _getShadowRoot */.kV)(element) || this._document.head;
        this._attachStyleNode();
        // On IE and Edge, we can't animate the `stroke-dashoffset`
        // reliably so we fall back to a non-spec animation.
        const animationClass = `mat-progress-spinner-indeterminate${this._fallbackAnimation ? '-fallback' : ''}-animation`;
        element.classList.add(animationClass);
    }
    /** The radius of the spinner, adjusted for stroke width. */
    _getCircleRadius() {
        return (this.diameter - BASE_STROKE_WIDTH) / 2;
    }
    /** The view box of the spinner's svg element. */
    _getViewBox() {
        const viewBox = this._getCircleRadius() * 2 + this.strokeWidth;
        return `0 0 ${viewBox} ${viewBox}`;
    }
    /** The stroke circumference of the svg circle. */
    _getStrokeCircumference() {
        return 2 * Math.PI * this._getCircleRadius();
    }
    /** The dash offset of the svg circle. */
    _getStrokeDashOffset() {
        if (this.mode === 'determinate') {
            return this._getStrokeCircumference() * (100 - this._value) / 100;
        }
        // In fallback mode set the circle to 80% and rotate it with CSS.
        if (this._fallbackAnimation && this.mode === 'indeterminate') {
            return this._getStrokeCircumference() * 0.2;
        }
        return null;
    }
    /** Stroke width of the circle in percent. */
    _getCircleStrokeWidth() {
        return this.strokeWidth / this.diameter * 100;
    }
    /** Dynamically generates a style tag containing the correct animation for this diameter. */
    _attachStyleNode() {
        const styleRoot = this._styleRoot;
        const currentDiameter = this._diameter;
        const diameters = MatProgressSpinner._diameters;
        let diametersForElement = diameters.get(styleRoot);
        if (!diametersForElement || !diametersForElement.has(currentDiameter)) {
            const styleTag = this._document.createElement('style');
            styleTag.setAttribute('mat-spinner-animation', this._spinnerAnimationLabel);
            styleTag.textContent = this._getAnimationText();
            styleRoot.appendChild(styleTag);
            if (!diametersForElement) {
                diametersForElement = new Set();
                diameters.set(styleRoot, diametersForElement);
            }
            diametersForElement.add(currentDiameter);
        }
    }
    /** Generates animation styles adjusted for the spinner's diameter. */
    _getAnimationText() {
        const strokeCircumference = this._getStrokeCircumference();
        return INDETERMINATE_ANIMATION_TEMPLATE
            // Animation should begin at 5% and end at 80%
            .replace(/START_VALUE/g, `${0.95 * strokeCircumference}`)
            .replace(/END_VALUE/g, `${0.2 * strokeCircumference}`)
            .replace(/DIAMETER/g, `${this._spinnerAnimationLabel}`);
    }
    /** Returns the circle diameter formatted for use with the animation-name CSS property. */
    _getSpinnerAnimationLabel() {
        // The string of a float point number will include a period ‘.’ character,
        // which is not valid for a CSS animation-name.
        return this.diameter.toString().replace('.', '_');
    }
}
MatProgressSpinner.ɵfac = function MatProgressSpinner_Factory(t) { return new (t || MatProgressSpinner)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb, 8), core/* ɵɵdirectiveInject */.Y36(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatProgressSpinner.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatProgressSpinner, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", "tabindex", "-1", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function MatProgressSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵattribute */.uIk("aria-valuemin", ctx.mode === "determinate" ? 0 : null)("aria-valuemax", ctx.mode === "determinate" ? 100 : null)("aria-valuenow", ctx.mode === "determinate" ? ctx.value : null)("mode", ctx.mode);
        core/* ɵɵstyleProp */.Udp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        core/* ɵɵclassProp */.ekj("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color", mode: "mode", diameter: "diameter", strokeWidth: "strokeWidth", value: "value" }, exportAs: ["matProgressSpinner"], features: [core/* ɵɵInheritDefinitionFeature */.qOj], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", "aria-hidden", "true", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatProgressSpinner_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵnamespaceSVG */.O4$();
        core/* ɵɵelementStart */.TgZ(0, "svg", 0);
        core/* ɵɵtemplate */.YNc(1, MatProgressSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        core/* ɵɵtemplate */.YNc(2, MatProgressSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵstyleProp */.Udp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        core/* ɵɵproperty */.Q6J("ngSwitch", ctx.mode === "indeterminate");
        core/* ɵɵattribute */.uIk("viewBox", ctx._getViewBox());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", true);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", false);
    } }, directives: [common/* NgSwitch */.RF, common/* NgSwitchCase */.n9], styles: [progress_spinner_c0], encapsulation: 2, changeDetection: 0 });
/**
 * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).
 * We need to keep track of which elements the diameters were attached to, because for
 * elements in the Shadow DOM the style tags are attached to the shadow root, rather
 * than the document head.
 */
MatProgressSpinner._diameters = new WeakMap();
MatProgressSpinner.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: platform/* Platform */.t4 },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] },
    { type: String, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb,] }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
];
MatProgressSpinner.propDecorators = {
    diameter: [{ type: core/* Input */.IIB }],
    strokeWidth: [{ type: core/* Input */.IIB }],
    mode: [{ type: core/* Input */.IIB }],
    value: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatProgressSpinner, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-progress-spinner',
                exportAs: 'matProgressSpinner',
                host: {
                    'role': 'progressbar',
                    'class': 'mat-progress-spinner',
                    // set tab index to -1 so screen readers will read the aria-label
                    // Note: there is a known issue with JAWS that does not read progressbar aria labels on FireFox
                    'tabindex': '-1',
                    '[class._mat-animation-noopable]': `_noopAnimations`,
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter',
                    '[attr.aria-valuemin]': 'mode === "determinate" ? 0 : null',
                    '[attr.aria-valuemax]': 'mode === "determinate" ? 100 : null',
                    '[attr.aria-valuenow]': 'mode === "determinate" ? value : null',
                    '[attr.mode]': 'mode'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n<!--\n  All children need to be hidden for screen readers in order to support ChromeVox.\n  More context in the issue: https://github.com/angular/components/issues/22165.\n-->\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_getViewBox()\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\"\n  aria-hidden=\"true\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_getCircleRadius()\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + _spinnerAnimationLabel\"\n    [style.stroke-dashoffset.px]=\"_getStrokeDashOffset()\"\n    [style.stroke-dasharray.px]=\"_getStrokeCircumference()\"\n    [style.stroke-width.%]=\"_getCircleStrokeWidth()\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_getCircleRadius()\"\n    [style.stroke-dashoffset.px]=\"_getStrokeDashOffset()\"\n    [style.stroke-dasharray.px]=\"_getStrokeCircumference()\"\n    [style.stroke-width.%]=\"_getCircleStrokeWidth()\"></circle>\n</svg>\n",
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                styles: [".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor;stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: platform/* Platform */.t4 }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }, { type: String, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb]
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, { mode: [{
            type: core/* Input */.IIB
        }], diameter: [{
            type: core/* Input */.IIB
        }], strokeWidth: [{
            type: core/* Input */.IIB
        }], value: [{
            type: core/* Input */.IIB
        }] }); })();
/**
 * `<mat-spinner>` component.
 *
 * This is a component definition to be used as a convenience reference to create an
 * indeterminate `<mat-progress-spinner>` instance.
 */
class MatSpinner extends MatProgressSpinner {
    constructor(elementRef, platform, document, animationMode, defaults) {
        super(elementRef, platform, document, animationMode, defaults);
        this.mode = 'indeterminate';
    }
}
MatSpinner.ɵfac = function MatSpinner_Factory(t) { return new (t || MatSpinner)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb, 8), core/* ɵɵdirectiveInject */.Y36(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatSpinner.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatSpinner, selectors: [["mat-spinner"]], hostAttrs: ["role", "progressbar", "mode", "indeterminate", 1, "mat-spinner", "mat-progress-spinner"], hostVars: 6, hostBindings: function MatSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵstyleProp */.Udp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        core/* ɵɵclassProp */.ekj("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color" }, features: [core/* ɵɵInheritDefinitionFeature */.qOj], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", "aria-hidden", "true", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatSpinner_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵnamespaceSVG */.O4$();
        core/* ɵɵelementStart */.TgZ(0, "svg", 0);
        core/* ɵɵtemplate */.YNc(1, MatSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        core/* ɵɵtemplate */.YNc(2, MatSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵstyleProp */.Udp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        core/* ɵɵproperty */.Q6J("ngSwitch", ctx.mode === "indeterminate");
        core/* ɵɵattribute */.uIk("viewBox", ctx._getViewBox());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", true);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", false);
    } }, directives: [common/* NgSwitch */.RF, common/* NgSwitchCase */.n9], styles: [progress_spinner_c0], encapsulation: 2, changeDetection: 0 });
MatSpinner.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: platform/* Platform */.t4 },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] },
    { type: String, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb,] }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSpinner, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-spinner',
                host: {
                    'role': 'progressbar',
                    'mode': 'indeterminate',
                    'class': 'mat-spinner mat-progress-spinner',
                    '[class._mat-animation-noopable]': `_noopAnimations`,
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n<!--\n  All children need to be hidden for screen readers in order to support ChromeVox.\n  More context in the issue: https://github.com/angular/components/issues/22165.\n-->\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_getViewBox()\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\"\n  aria-hidden=\"true\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_getCircleRadius()\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + _spinnerAnimationLabel\"\n    [style.stroke-dashoffset.px]=\"_getStrokeDashOffset()\"\n    [style.stroke-dasharray.px]=\"_getStrokeCircumference()\"\n    [style.stroke-width.%]=\"_getCircleStrokeWidth()\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_getCircleRadius()\"\n    [style.stroke-dashoffset.px]=\"_getStrokeDashOffset()\"\n    [style.stroke-dasharray.px]=\"_getStrokeCircumference()\"\n    [style.stroke-width.%]=\"_getCircleStrokeWidth()\"></circle>\n</svg>\n",
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                styles: [".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor;stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: platform/* Platform */.t4 }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }, { type: String, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb]
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatProgressSpinnerModule {
}
MatProgressSpinnerModule.ɵfac = function MatProgressSpinnerModule_Factory(t) { return new (t || MatProgressSpinnerModule)(); };
MatProgressSpinnerModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatProgressSpinnerModule });
MatProgressSpinnerModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[fesm2015_core/* MatCommonModule */.BQ, common/* CommonModule */.ez], fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatProgressSpinnerModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [fesm2015_core/* MatCommonModule */.BQ, common/* CommonModule */.ez],
                exports: [
                    MatProgressSpinner,
                    MatSpinner,
                    fesm2015_core/* MatCommonModule */.BQ
                ],
                declarations: [
                    MatProgressSpinner,
                    MatSpinner
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatProgressSpinnerModule, { declarations: function () { return [MatProgressSpinner, MatSpinner]; }, imports: function () { return [fesm2015_core/* MatCommonModule */.BQ, common/* CommonModule */.ez]; }, exports: function () { return [MatProgressSpinner, MatSpinner, fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=progress-spinner.js.map
// EXTERNAL MODULE: ./node_modules/ng-apexcharts/__ivy_ngcc__/fesm2015/ng-apexcharts.js
var ng_apexcharts = __webpack_require__(4256);
;// CONCATENATED MODULE: ./src/app/pages/exposureResults/exposure-result.component.ts








function ExposureResultComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelement */._UZ(1, "mat-spinner");
    core/* ɵɵelementEnd */.qZA();
} }
function ExposureResultComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 2);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 5);
    core/* ɵɵelement */._UZ(4, "apx-chart", 6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r1.exposedChartOptions.chart)("dataLabels", ctx_r1.exposedChartOptions.dataLabels)("plotOptions", ctx_r1.exposedChartOptions.plotOptions)("series", ctx_r1.exposedChartOptions.series)("title", ctx_r1.exposedChartOptions.title)("xaxis", ctx_r1.exposedChartOptions.xaxis)("yaxis", ctx_r1.exposedChartOptions.yaxis);
} }
class ExposureResultComponent {
    constructor(restService) {
        this.restService = restService;
        this.loading = true;
    }
    getData(season, round, title) {
        this.loading = true;
        this.restService.getSingleExposureResult(season, round).subscribe({
            next: data => {
                this.data = data;
                this.setupChart(title);
                this.loading = false;
            }
        });
    }
    setupChart(title) {
        this.exposedChartOptions = {
            chart: {
                type: 'bar',
                height: 500,
                toolbar: ChartUtility.defaultToolbar
            },
            plotOptions: {
                bar: {
                    horizontal: true,
                }
            },
            dataLabels: {
                enabled: true
            },
            yaxis: {
                min: 0,
                max: 100,
                tickAmount: 20,
                axisTicks: {
                    show: true
                },
                axisBorder: {
                    show: true,
                    color: '#008FFB'
                }
            },
            series: [
                {
                    name: 'Exposure',
                    data: this.data.exposure
                }
            ],
            xaxis: {
                categories: this.data.driverNames,
                offsetX: 200
            },
            title: {
                text: title,
                align: 'center'
            }
        };
    }
}
ExposureResultComponent.ɵfac = function ExposureResultComponent_Factory(t) { return new (t || ExposureResultComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v)); };
ExposureResultComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ExposureResultComponent, selectors: [["app-exposure-result-cmp"]], decls: 4, vars: 2, consts: [[4, "ngIf"], ["style", "width:60vw", 4, "ngIf"], [2, "width", "60vw"], [1, "px-lg-2"], [1, "card", "card-stats"], [1, "card-body", "px-2"], [3, "chart", "dataLabels", "plotOptions", "series", "title", "xaxis", "yaxis"]], template: function ExposureResultComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵelementStart */.TgZ(1, "div");
        core/* ɵɵtemplate */.YNc(2, ExposureResultComponent_div_2_Template, 2, 0, "div", 0);
        core/* ɵɵtemplate */.YNc(3, ExposureResultComponent_div_3_Template, 5, 7, "div", 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.loading);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.loading);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, MatSpinner, ng_apexcharts/* ChartComponent */.x], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js + 10 modules
var scrolling = __webpack_require__(9243);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js
var collections = __webpack_require__(8345);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/select.js
















/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The following are all the animations for the mat-select component, with each
 * const containing the metadata for one animation.
 *
 * The values below match the implementation of the AngularJS Material mat-select animation.
 * @docs-private
 */










const select_c0 = ["trigger"];
const select_c1 = ["panel"];
function MatSelect_span_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span", 8);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.placeholder);
} }
function MatSelect_span_5_span_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span", 12);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r5.triggerValue);
} }
function MatSelect_span_5_ng_content_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵprojection */.Hsn(0, 0, ["*ngSwitchCase", "true"]);
} }
function MatSelect_span_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span", 9);
    core/* ɵɵtemplate */.YNc(1, MatSelect_span_5_span_1_Template, 2, 1, "span", 10);
    core/* ɵɵtemplate */.YNc(2, MatSelect_span_5_ng_content_2_Template, 1, 0, "ng-content", 11);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngSwitch", !!ctx_r3.customTrigger);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", true);
} }
function MatSelect_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r9 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 13);
    core/* ɵɵelementStart */.TgZ(1, "div", 14, 15);
    core/* ɵɵlistener */.NdJ("@transformPanel.done", function MatSelect_ng_template_8_Template_div_animation_transformPanel_done_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const ctx_r8 = core/* ɵɵnextContext */.oxw(); return ctx_r8._panelDoneAnimatingStream.next($event.toState); })("keydown", function MatSelect_ng_template_8_Template_div_keydown_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const ctx_r10 = core/* ɵɵnextContext */.oxw(); return ctx_r10._handleKeydown($event); });
    core/* ɵɵprojection */.Hsn(3, 1);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("@transformPanelWrap", undefined);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵclassMapInterpolate1 */.Gre("mat-select-panel ", ctx_r4._getPanelTheme(), "");
    core/* ɵɵstyleProp */.Udp("transform-origin", ctx_r4._transformOrigin)("font-size", ctx_r4._triggerFontSize, "px");
    core/* ɵɵproperty */.Q6J("ngClass", ctx_r4.panelClass)("@transformPanel", ctx_r4.multiple ? "showing-multiple" : "showing");
    core/* ɵɵattribute */.uIk("id", ctx_r4.id + "-panel")("aria-multiselectable", ctx_r4.multiple)("aria-label", ctx_r4.ariaLabel || null)("aria-labelledby", ctx_r4._getPanelAriaLabelledby());
} }
const select_c2 = [[["mat-select-trigger"]], "*"];
const select_c3 = ["mat-select-trigger", "*"];
const matSelectAnimations = {
    /**
     * This animation ensures the select's overlay panel animation (transformPanel) is called when
     * closing the select.
     * This is needed due to https://github.com/angular/angular/issues/23302
     */
    transformPanelWrap: (0,animations/* trigger */.X$)('transformPanelWrap', [
        (0,animations/* transition */.eR)('* => void', (0,animations/* query */.IO)('@transformPanel', [(0,animations/* animateChild */.pV)()], { optional: true }))
    ]),
    /**
     * This animation transforms the select's overlay panel on and off the page.
     *
     * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it
     * up to 100% on the Y axis, fades in its border, and translates slightly up and to the
     * side to ensure the option text correctly overlaps the trigger text.
     *
     * When the panel is removed from the DOM, it simply fades out linearly.
     */
    transformPanel: (0,animations/* trigger */.X$)('transformPanel', [
        (0,animations/* state */.SB)('void', (0,animations/* style */.oB)({
            transform: 'scaleY(0.8)',
            minWidth: '100%',
            opacity: 0
        })),
        (0,animations/* state */.SB)('showing', (0,animations/* style */.oB)({
            opacity: 1,
            minWidth: 'calc(100% + 32px)',
            transform: 'scaleY(1)'
        })),
        (0,animations/* state */.SB)('showing-multiple', (0,animations/* style */.oB)({
            opacity: 1,
            minWidth: 'calc(100% + 64px)',
            transform: 'scaleY(1)'
        })),
        (0,animations/* transition */.eR)('void => *', (0,animations/* animate */.jt)('120ms cubic-bezier(0, 0, 0.2, 1)')),
        (0,animations/* transition */.eR)('* => void', (0,animations/* animate */.jt)('100ms 25ms linear', (0,animations/* style */.oB)({ opacity: 0 })))
    ])
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Returns an exception to be thrown when attempting to change a select's `multiple` option
 * after initialization.
 * @docs-private
 */
function getMatSelectDynamicMultipleError() {
    return Error('Cannot change `multiple` mode of select after initialization.');
}
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * @docs-private
 */
function getMatSelectNonArrayValueError() {
    return Error('Value must be an array in multiple-selection mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 */
function getMatSelectNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let select_nextUniqueId = 0;
/**
 * The following style constants are necessary to save here in order
 * to properly calculate the alignment of the selected option over
 * the trigger element.
 */
/** The max height of the select's overlay panel. */
const SELECT_PANEL_MAX_HEIGHT = 256;
/** The panel's padding on the x-axis. */
const SELECT_PANEL_PADDING_X = 16;
/** The panel's x axis padding if it is indented (e.g. there is an option group). */
const SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;
/** The height of the select items in `em` units. */
const SELECT_ITEM_HEIGHT_EM = 3;
// TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.
/**
 * Distance between the panel edge and the option text in
 * multi-selection mode.
 *
 * Calculated as:
 * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40
 * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.
 * The checkbox width is 16px.
 */
const SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 16;
/**
 * The select panel will only "fit" inside the viewport if it is positioned at
 * this value or more away from the viewport boundary.
 */
const SELECT_PANEL_VIEWPORT_PADDING = 8;
/** Injection token that determines the scroll handling while a select is open. */
const MAT_SELECT_SCROLL_STRATEGY = new core/* InjectionToken */.OlP('mat-select-scroll-strategy');
/** @docs-private */
function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** Injection token that can be used to provide the default options the select module. */
const MAT_SELECT_CONFIG = new core/* InjectionToken */.OlP('MAT_SELECT_CONFIG');
/** @docs-private */
const MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {
    provide: MAT_SELECT_SCROLL_STRATEGY,
    deps: [overlay/* Overlay */.aV],
    useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
/** Change event object that is emitted when the select value has changed. */
class MatSelectChange {
    constructor(
    /** Reference to the select that emitted the change event. */
    source, 
    /** Current value of the select that emitted the event. */
    value) {
        this.source = source;
        this.value = value;
    }
}
// Boilerplate for applying mixins to MatSelect.
/** @docs-private */
const _MatSelectMixinBase = (0,fesm2015_core/* mixinDisableRipple */.Kr)((0,fesm2015_core/* mixinTabIndex */.sb)((0,fesm2015_core/* mixinDisabled */.Id)((0,fesm2015_core/* mixinErrorState */.FD)(class {
    constructor(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
        this._elementRef = _elementRef;
        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.ngControl = ngControl;
    }
}))));
/**
 * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as
 * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary
 * retention of the class and its directive metadata.
 */
const MAT_SELECT_TRIGGER = new core/* InjectionToken */.OlP('MatSelectTrigger');
/**
 * Allows the user to customize the trigger that is displayed when the select has a value.
 */
class MatSelectTrigger {
}
MatSelectTrigger.ɵfac = function MatSelectTrigger_Factory(t) { return new (t || MatSelectTrigger)(); };
MatSelectTrigger.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatSelectTrigger, selectors: [["mat-select-trigger"]], features: [core/* ɵɵProvidersFeature */._Bn([{ provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger }])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSelectTrigger, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-select-trigger',
                providers: [{ provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger }]
            }]
    }], null, null); })();
/** Base class with all of the `MatSelect` functionality. */
class _MatSelectBase extends _MatSelectMixinBase {
    constructor(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, scrollStrategyFactory, _liveAnnouncer, _defaultOptions) {
        var _a, _b, _c;
        super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);
        this._viewportRuler = _viewportRuler;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._dir = _dir;
        this._parentFormField = _parentFormField;
        this._liveAnnouncer = _liveAnnouncer;
        this._defaultOptions = _defaultOptions;
        /** Whether or not the overlay panel is open. */
        this._panelOpen = false;
        /** Comparison function to specify which option is displayed. Defaults to object equality. */
        this._compareWith = (o1, o2) => o1 === o2;
        /** Unique id for this input. */
        this._uid = `mat-select-${select_nextUniqueId++}`;
        /** Current `ariar-labelledby` value for the select trigger. */
        this._triggerAriaLabelledBy = null;
        /** Emits whenever the component is destroyed. */
        this._destroy = new Subject/* Subject */.xQ();
        /** `View -> model callback called when value changes` */
        this._onChange = () => { };
        /** `View -> model callback called when select has been touched` */
        this._onTouched = () => { };
        /** ID for the DOM node containing the select's value. */
        this._valueId = `mat-select-value-${select_nextUniqueId++}`;
        /** Emits when the panel element is finished transforming in. */
        this._panelDoneAnimatingStream = new Subject/* Subject */.xQ();
        this._overlayPanelClass = ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.overlayPanelClass) || '';
        this._focused = false;
        /** A name for this control that can be used by `mat-form-field`. */
        this.controlType = 'mat-select';
        this._required = false;
        this._multiple = false;
        this._disableOptionCentering = (_c = (_b = this._defaultOptions) === null || _b === void 0 ? void 0 : _b.disableOptionCentering) !== null && _c !== void 0 ? _c : false;
        /** Aria label of the select. */
        this.ariaLabel = '';
        /** Combined stream of all of the child options' change events. */
        this.optionSelectionChanges = (0,defer/* defer */.P)(() => {
            const options = this.options;
            if (options) {
                return options.changes.pipe((0,startWith/* startWith */.O)(options), (0,switchMap/* switchMap */.w)(() => (0,merge/* merge */.T)(...options.map(option => option.onSelectionChange))));
            }
            return this._ngZone.onStable
                .pipe((0,take/* take */.q)(1), (0,switchMap/* switchMap */.w)(() => this.optionSelectionChanges));
        });
        /** Event emitted when the select panel has been toggled. */
        this.openedChange = new core/* EventEmitter */.vpe();
        /** Event emitted when the select has been opened. */
        this._openedStream = this.openedChange.pipe((0,filter/* filter */.h)(o => o), (0,operators_map/* map */.U)(() => { }));
        /** Event emitted when the select has been closed. */
        this._closedStream = this.openedChange.pipe((0,filter/* filter */.h)(o => !o), (0,operators_map/* map */.U)(() => { }));
        /** Event emitted when the selected value has been changed by the user. */
        this.selectionChange = new core/* EventEmitter */.vpe();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * @docs-private
         */
        this.valueChange = new core/* EventEmitter */.vpe();
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        // Note that we only want to set this when the defaults pass it in, otherwise it should
        // stay as `undefined` so that it falls back to the default in the key manager.
        if ((_defaultOptions === null || _defaultOptions === void 0 ? void 0 : _defaultOptions.typeaheadDebounceInterval) != null) {
            this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;
        }
        this._scrollStrategyFactory = scrollStrategyFactory;
        this._scrollStrategy = this._scrollStrategyFactory();
        this.tabIndex = parseInt(tabIndex) || 0;
        // Force setter to be called in case id was not specified.
        this.id = this.id;
    }
    /** Whether the select is focused. */
    get focused() {
        return this._focused || this._panelOpen;
    }
    /** Placeholder to be shown if no value has been selected. */
    get placeholder() { return this._placeholder; }
    set placeholder(value) {
        this._placeholder = value;
        this.stateChanges.next();
    }
    /** Whether the component is required. */
    get required() { return this._required; }
    set required(value) {
        this._required = (0,coercion/* coerceBooleanProperty */.Ig)(value);
        this.stateChanges.next();
    }
    /** Whether the user should be allowed to select multiple options. */
    get multiple() { return this._multiple; }
    set multiple(value) {
        if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatSelectDynamicMultipleError();
        }
        this._multiple = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /** Whether to center the active option over the trigger. */
    get disableOptionCentering() { return this._disableOptionCentering; }
    set disableOptionCentering(value) {
        this._disableOptionCentering = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     */
    get compareWith() { return this._compareWith; }
    set compareWith(fn) {
        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatSelectNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /** Value of the select control. */
    get value() { return this._value; }
    set value(newValue) {
        // Always re-assign an array, because it might have been mutated.
        if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {
            if (this.options) {
                this._setSelectionByValue(newValue);
            }
            this._value = newValue;
        }
    }
    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */
    get typeaheadDebounceInterval() { return this._typeaheadDebounceInterval; }
    set typeaheadDebounceInterval(value) {
        this._typeaheadDebounceInterval = (0,coercion/* coerceNumberProperty */.su)(value);
    }
    /** Unique id of the element. */
    get id() { return this._id; }
    set id(value) {
        this._id = value || this._uid;
        this.stateChanges.next();
    }
    ngOnInit() {
        this._selectionModel = new collections/* SelectionModel */.Ov(this.multiple);
        this.stateChanges.next();
        // We need `distinctUntilChanged` here, because some browsers will
        // fire the animation end event twice for the same animation. See:
        // https://github.com/angular/angular/issues/24084
        this._panelDoneAnimatingStream
            .pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,takeUntil/* takeUntil */.R)(this._destroy))
            .subscribe(() => this._panelDoneAnimating(this.panelOpen));
    }
    ngAfterContentInit() {
        this._initKeyManager();
        this._selectionModel.changed.pipe((0,takeUntil/* takeUntil */.R)(this._destroy)).subscribe(event => {
            event.added.forEach(option => option.select());
            event.removed.forEach(option => option.deselect());
        });
        this.options.changes.pipe((0,startWith/* startWith */.O)(null), (0,takeUntil/* takeUntil */.R)(this._destroy)).subscribe(() => {
            this._resetOptions();
            this._initializeSelection();
        });
    }
    ngDoCheck() {
        const newAriaLabelledby = this._getTriggerAriaLabelledby();
        // We have to manage setting the `aria-labelledby` ourselves, because part of its value
        // is computed as a result of a content query which can cause this binding to trigger a
        // "changed after checked" error.
        if (newAriaLabelledby !== this._triggerAriaLabelledBy) {
            const element = this._elementRef.nativeElement;
            this._triggerAriaLabelledBy = newAriaLabelledby;
            if (newAriaLabelledby) {
                element.setAttribute('aria-labelledby', newAriaLabelledby);
            }
            else {
                element.removeAttribute('aria-labelledby');
            }
        }
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    ngOnChanges(changes) {
        // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let
        // the parent form field know to run change detection when the disabled state changes.
        if (changes['disabled']) {
            this.stateChanges.next();
        }
        if (changes['typeaheadDebounceInterval'] && this._keyManager) {
            this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);
        }
    }
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
        this.stateChanges.complete();
    }
    /** Toggles the overlay panel open or closed. */
    toggle() {
        this.panelOpen ? this.close() : this.open();
    }
    /** Opens the overlay panel. */
    open() {
        if (this._canOpen()) {
            this._panelOpen = true;
            this._keyManager.withHorizontalOrientation(null);
            this._highlightCorrectOption();
            this._changeDetectorRef.markForCheck();
        }
    }
    /** Closes the overlay panel and focuses the host element. */
    close() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
        }
    }
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param value New value to be written to the model.
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Saves a callback function to be invoked when the select's value
     * changes from user input. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the value changes.
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * Saves a callback function to be invoked when the select is blurred
     * by the user. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param fn Callback to be triggered when the component has been touched.
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /** Whether or not the overlay panel is open. */
    get panelOpen() {
        return this._panelOpen;
    }
    /** The currently selected option. */
    get selected() {
        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /** The value displayed in the trigger. */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this._multiple) {
            const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);
            if (this._isRtl()) {
                selectedOptions.reverse();
            }
            // TODO(crisbeto): delimiter should be configurable for proper localization.
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /** Whether the element is in RTL mode. */
    _isRtl() {
        return this._dir ? this._dir.value === 'rtl' : false;
    }
    /** Handles all keydown events on the select. */
    _handleKeydown(event) {
        if (!this.disabled) {
            this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
        }
    }
    /** Handles keyboard events while the select is closed. */
    _handleClosedKeydown(event) {
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === keycodes/* DOWN_ARROW */.JH || keyCode === keycodes/* UP_ARROW */.LH ||
            keyCode === keycodes/* LEFT_ARROW */.oh || keyCode === keycodes/* RIGHT_ARROW */.SV;
        const isOpenKey = keyCode === keycodes/* ENTER */.K5 || keyCode === keycodes/* SPACE */.L_;
        const manager = this._keyManager;
        // Open the select on ALT + arrow key to match the native <select>
        if (!manager.isTyping() && (isOpenKey && !(0,keycodes/* hasModifierKey */.Vb)(event)) ||
            ((this.multiple || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.open();
        }
        else if (!this.multiple) {
            const previouslySelectedOption = this.selected;
            manager.onKeydown(event);
            const selectedOption = this.selected;
            // Since the value has changed, we need to announce it ourselves.
            if (selectedOption && previouslySelectedOption !== selectedOption) {
                // We set a duration on the live announcement, because we want the live element to be
                // cleared after a while so that users can't navigate to it using the arrow keys.
                this._liveAnnouncer.announce(selectedOption.viewValue, 10000);
            }
        }
    }
    /** Handles keyboard events when the selected is open. */
    _handleOpenKeydown(event) {
        const manager = this._keyManager;
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === keycodes/* DOWN_ARROW */.JH || keyCode === keycodes/* UP_ARROW */.LH;
        const isTyping = manager.isTyping();
        if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.close();
            // Don't do anything in this case if the user is typing,
            // because the typing sequence can include the space key.
        }
        else if (!isTyping && (keyCode === keycodes/* ENTER */.K5 || keyCode === keycodes/* SPACE */.L_) && manager.activeItem &&
            !(0,keycodes/* hasModifierKey */.Vb)(event)) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (!isTyping && this._multiple && keyCode === keycodes.A && event.ctrlKey) {
            event.preventDefault();
            const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);
            this.options.forEach(option => {
                if (!option.disabled) {
                    hasDeselectedOptions ? option.select() : option.deselect();
                }
            });
        }
        else {
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     */
    _onBlur() {
        this._focused = false;
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    _onAttached() {
        this._overlayDir.positionChange.pipe((0,take/* take */.q)(1)).subscribe(() => {
            this._changeDetectorRef.detectChanges();
            this._positioningSettled();
        });
    }
    /** Returns the theme to be used on the panel. */
    _getPanelTheme() {
        return this._parentFormField ? `mat-${this._parentFormField.color}` : '';
    }
    /** Whether the select has a value. */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then(() => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
            this.stateChanges.next();
        });
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    _setSelectionByValue(value) {
        this._selectionModel.selected.forEach(option => option.setInactiveStyles());
        this._selectionModel.clear();
        if (this.multiple && value) {
            if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw getMatSelectNonArrayValueError();
            }
            value.forEach((currentValue) => this._selectValue(currentValue));
            this._sortValues();
        }
        else {
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.updateActiveItem(correspondingOption);
            }
            else if (!this.panelOpen) {
                // Otherwise reset the highlighted option. Note that we only want to do this while
                // closed, because doing it while open can shift the user's focus unnecessarily.
                this._keyManager.updateActiveItem(-1);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @returns Option that has the corresponding value.
     */
    _selectValue(value) {
        const correspondingOption = this.options.find((option) => {
            // Skip options that are already in the model. This allows us to handle cases
            // where the same primitive value is selected multiple times.
            if (this._selectionModel.isSelected(option)) {
                return false;
            }
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (typeof ngDevMode === 'undefined' || ngDevMode) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        });
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    _initKeyManager() {
        this._keyManager = new a11y/* ActiveDescendantKeyManager */.s1(this.options)
            .withTypeAhead(this._typeaheadDebounceInterval)
            .withVerticalOrientation()
            .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')
            .withHomeAndEnd()
            .withAllowedModifierKeys(['shiftKey']);
        this._keyManager.tabOut.pipe((0,takeUntil/* takeUntil */.R)(this._destroy)).subscribe(() => {
            if (this.panelOpen) {
                // Select the active item when tabbing away. This is consistent with how the native
                // select behaves. Note that we only want to do this in single selection mode.
                if (!this.multiple && this._keyManager.activeItem) {
                    this._keyManager.activeItem._selectViaInteraction();
                }
                // Restore focus to the trigger before closing. Ensures that the focus
                // position won't be lost if the user got focus into the overlay.
                this.focus();
                this.close();
            }
        });
        this._keyManager.change.pipe((0,takeUntil/* takeUntil */.R)(this._destroy)).subscribe(() => {
            if (this._panelOpen && this.panel) {
                this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);
            }
            else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        });
    }
    /** Drops current option subscriptions and IDs and resets from scratch. */
    _resetOptions() {
        const changedOrDestroyed = (0,merge/* merge */.T)(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe((0,takeUntil/* takeUntil */.R)(changedOrDestroyed)).subscribe(event => {
            this._onSelect(event.source, event.isUserInput);
            if (event.isUserInput && !this.multiple && this._panelOpen) {
                this.close();
                this.focus();
            }
        });
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        (0,merge/* merge */.T)(...this.options.map(option => option._stateChanges))
            .pipe((0,takeUntil/* takeUntil */.R)(changedOrDestroyed))
            .subscribe(() => {
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        });
    }
    /** Invoked when an option is clicked. */
    _onSelect(option, isUserInput) {
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this._multiple) {
            option.deselect();
            this._selectionModel.clear();
            if (this.value != null) {
                this._propagateChanges(option.value);
            }
        }
        else {
            if (wasSelected !== option.selected) {
                option.selected ? this._selectionModel.select(option) :
                    this._selectionModel.deselect(option);
            }
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.multiple) {
                this._sortValues();
                if (isUserInput) {
                    // In case the user selected the option with their mouse, we
                    // want to restore focus back to the trigger, in order to
                    // prevent the select keyboard controls from clashing with
                    // the ones from `mat-option`.
                    this.focus();
                }
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /** Sorts the selected values in the selected based on their order in the panel. */
    _sortValues() {
        if (this.multiple) {
            const options = this.options.toArray();
            this._selectionModel.sort((a, b) => {
                return this.sortComparator ? this.sortComparator(a, b, options) :
                    options.indexOf(a) - options.indexOf(b);
            });
            this.stateChanges.next();
        }
    }
    /** Emits change event to set the model value. */
    _propagateChanges(fallbackValue) {
        let valueToEmit = null;
        if (this.multiple) {
            valueToEmit = this.selected.map(option => option.value);
        }
        else {
            valueToEmit = this.selected ? this.selected.value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(this._getChangeEvent(valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /** Whether the panel is allowed to open. */
    _canOpen() {
        var _a;
        return !this._panelOpen && !this.disabled && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    /** Focuses the select element. */
    focus(options) {
        this._elementRef.nativeElement.focus(options);
    }
    /** Gets the aria-labelledby for the select panel. */
    _getPanelAriaLabelledby() {
        var _a;
        if (this.ariaLabel) {
            return null;
        }
        const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();
        const labelExpression = (labelId ? labelId + ' ' : '');
        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;
    }
    /** Determines the `aria-activedescendant` to be set on the host. */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
    /** Gets the aria-labelledby of the select component trigger. */
    _getTriggerAriaLabelledby() {
        var _a;
        if (this.ariaLabel) {
            return null;
        }
        const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();
        let value = (labelId ? labelId + ' ' : '') + this._valueId;
        if (this.ariaLabelledby) {
            value += ' ' + this.ariaLabelledby;
        }
        return value;
    }
    /** Called when the overlay panel is done animating. */
    _panelDoneAnimating(isOpen) {
        this.openedChange.emit(isOpen);
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    setDescribedByIds(ids) {
        this._ariaDescribedby = ids.join(' ');
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    onContainerClick() {
        this.focus();
        this.open();
    }
    /**
     * Implemented as part of MatFormFieldControl.
     * @docs-private
     */
    get shouldLabelFloat() {
        return this._panelOpen || !this.empty || (this._focused && !!this._placeholder);
    }
}
_MatSelectBase.ɵfac = function _MatSelectBase_Factory(t) { return new (t || _MatSelectBase)(core/* ɵɵdirectiveInject */.Y36(scrolling/* ViewportRuler */.rL), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(fesm2015_core/* ErrorStateMatcher */.rD), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* NgForm */.F, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* FormGroupDirective */.sg, 8), core/* ɵɵdirectiveInject */.Y36(MAT_FORM_FIELD, 8), core/* ɵɵdirectiveInject */.Y36(fesm2015_forms/* NgControl */.a5, 10), core/* ɵɵinjectAttribute */.$8M('tabindex'), core/* ɵɵdirectiveInject */.Y36(MAT_SELECT_SCROLL_STRATEGY), core/* ɵɵdirectiveInject */.Y36(a11y/* LiveAnnouncer */.Kd), core/* ɵɵdirectiveInject */.Y36(MAT_SELECT_CONFIG, 8)); };
_MatSelectBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatSelectBase, viewQuery: function _MatSelectBase_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(select_c0, 5);
        core/* ɵɵviewQuery */.Gf(select_c1, 5);
        core/* ɵɵviewQuery */.Gf(overlay/* CdkConnectedOverlay */.pI, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.trigger = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.panel = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._overlayDir = _t.first);
    } }, inputs: { ariaLabel: ["aria-label", "ariaLabel"], id: "id", placeholder: "placeholder", required: "required", multiple: "multiple", disableOptionCentering: "disableOptionCentering", compareWith: "compareWith", value: "value", typeaheadDebounceInterval: "typeaheadDebounceInterval", panelClass: "panelClass", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], errorStateMatcher: "errorStateMatcher", sortComparator: "sortComparator" }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, features: [core/* ɵɵInheritDefinitionFeature */.qOj, core/* ɵɵNgOnChangesFeature */.TTD] });
_MatSelectBase.ctorParameters = () => [
    { type: scrolling/* ViewportRuler */.rL },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: core/* NgZone */.R0b },
    { type: fesm2015_core/* ErrorStateMatcher */.rD },
    { type: core/* ElementRef */.SBq },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] },
    { type: fesm2015_forms/* NgForm */.F, decorators: [{ type: core/* Optional */.FiY }] },
    { type: fesm2015_forms/* FormGroupDirective */.sg, decorators: [{ type: core/* Optional */.FiY }] },
    { type: MatFormField, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_FORM_FIELD,] }] },
    { type: fesm2015_forms/* NgControl */.a5, decorators: [{ type: core/* Self */.PiD }, { type: core/* Optional */.FiY }] },
    { type: String, decorators: [{ type: core/* Attribute */.ahi, args: ['tabindex',] }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_SELECT_SCROLL_STRATEGY,] }] },
    { type: a11y/* LiveAnnouncer */.Kd },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_SELECT_CONFIG,] }] }
];
_MatSelectBase.propDecorators = {
    trigger: [{ type: core/* ViewChild */.i9L, args: ['trigger',] }],
    panel: [{ type: core/* ViewChild */.i9L, args: ['panel',] }],
    _overlayDir: [{ type: core/* ViewChild */.i9L, args: [overlay/* CdkConnectedOverlay */.pI,] }],
    panelClass: [{ type: core/* Input */.IIB }],
    placeholder: [{ type: core/* Input */.IIB }],
    required: [{ type: core/* Input */.IIB }],
    multiple: [{ type: core/* Input */.IIB }],
    disableOptionCentering: [{ type: core/* Input */.IIB }],
    compareWith: [{ type: core/* Input */.IIB }],
    value: [{ type: core/* Input */.IIB }],
    ariaLabel: [{ type: core/* Input */.IIB, args: ['aria-label',] }],
    ariaLabelledby: [{ type: core/* Input */.IIB, args: ['aria-labelledby',] }],
    errorStateMatcher: [{ type: core/* Input */.IIB }],
    typeaheadDebounceInterval: [{ type: core/* Input */.IIB }],
    sortComparator: [{ type: core/* Input */.IIB }],
    id: [{ type: core/* Input */.IIB }],
    openedChange: [{ type: core/* Output */.r_U }],
    _openedStream: [{ type: core/* Output */.r_U, args: ['opened',] }],
    _closedStream: [{ type: core/* Output */.r_U, args: ['closed',] }],
    selectionChange: [{ type: core/* Output */.r_U }],
    valueChange: [{ type: core/* Output */.r_U }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatSelectBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: scrolling/* ViewportRuler */.rL }, { type: core/* ChangeDetectorRef */.sBO }, { type: core/* NgZone */.R0b }, { type: fesm2015_core/* ErrorStateMatcher */.rD }, { type: core/* ElementRef */.SBq }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: fesm2015_forms/* NgForm */.F, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: fesm2015_forms/* FormGroupDirective */.sg, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: MatFormField, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_FORM_FIELD]
            }] }, { type: fesm2015_forms/* NgControl */.a5, decorators: [{
                type: core/* Self */.PiD
            }, {
                type: core/* Optional */.FiY
            }] }, { type: String, decorators: [{
                type: core/* Attribute */.ahi,
                args: ['tabindex']
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_SELECT_SCROLL_STRATEGY]
            }] }, { type: a11y/* LiveAnnouncer */.Kd }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_SELECT_CONFIG]
            }] }]; }, { ariaLabel: [{
            type: core/* Input */.IIB,
            args: ['aria-label']
        }], openedChange: [{
            type: core/* Output */.r_U
        }], _openedStream: [{
            type: core/* Output */.r_U,
            args: ['opened']
        }], _closedStream: [{
            type: core/* Output */.r_U,
            args: ['closed']
        }], selectionChange: [{
            type: core/* Output */.r_U
        }], valueChange: [{
            type: core/* Output */.r_U
        }], id: [{
            type: core/* Input */.IIB
        }], placeholder: [{
            type: core/* Input */.IIB
        }], required: [{
            type: core/* Input */.IIB
        }], multiple: [{
            type: core/* Input */.IIB
        }], disableOptionCentering: [{
            type: core/* Input */.IIB
        }], compareWith: [{
            type: core/* Input */.IIB
        }], value: [{
            type: core/* Input */.IIB
        }], typeaheadDebounceInterval: [{
            type: core/* Input */.IIB
        }], trigger: [{
            type: core/* ViewChild */.i9L,
            args: ['trigger']
        }], panel: [{
            type: core/* ViewChild */.i9L,
            args: ['panel']
        }], _overlayDir: [{
            type: core/* ViewChild */.i9L,
            args: [overlay/* CdkConnectedOverlay */.pI]
        }], panelClass: [{
            type: core/* Input */.IIB
        }], ariaLabelledby: [{
            type: core/* Input */.IIB,
            args: ['aria-labelledby']
        }], errorStateMatcher: [{
            type: core/* Input */.IIB
        }], sortComparator: [{
            type: core/* Input */.IIB
        }] }); })();
class MatSelect extends _MatSelectBase {
    constructor() {
        super(...arguments);
        /** The scroll position of the overlay panel, calculated to center the selected option. */
        this._scrollTop = 0;
        /** The cached font-size of the trigger element. */
        this._triggerFontSize = 0;
        /** The value of the select panel's transform-origin property. */
        this._transformOrigin = 'top';
        /**
         * The y-offset of the overlay panel in relation to the trigger's top start corner.
         * This must be adjusted to align the selected option text over the trigger text.
         * when the panel opens. Will change based on the y-position of the selected option.
         */
        this._offsetY = 0;
        this._positions = [
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom',
            },
        ];
    }
    /**
     * Calculates the scroll position of the select's overlay panel.
     *
     * Attempts to center the selected option in the panel. If the option is
     * too high or too low in the panel to be scrolled to the center, it clamps the
     * scroll position to the min or max scroll positions respectively.
     */
    _calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll) {
        const itemHeight = this._getItemHeight();
        const optionOffsetFromScrollTop = itemHeight * selectedIndex;
        const halfOptionHeight = itemHeight / 2;
        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the
        // scroll container, then subtracts the scroll buffer to scroll the option down to
        // the center of the overlay panel. Half the option height must be re-added to the
        // scrollTop so the option is centered based on its middle, not its top edge.
        const optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
        return Math.min(Math.max(0, optimalScrollPosition), maxScroll);
    }
    ngOnInit() {
        super.ngOnInit();
        this._viewportRuler.change().pipe((0,takeUntil/* takeUntil */.R)(this._destroy)).subscribe(() => {
            if (this.panelOpen) {
                this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
                this._changeDetectorRef.markForCheck();
            }
        });
    }
    open() {
        if (super._canOpen()) {
            super.open();
            this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
            // Note: The computed font-size will be a string pixel value (e.g. "16px").
            // `parseInt` ignores the trailing 'px' and converts this to a number.
            this._triggerFontSize =
                parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || '0');
            this._calculateOverlayPosition();
            // Set the font size on the panel element once it exists.
            this._ngZone.onStable.pipe((0,take/* take */.q)(1)).subscribe(() => {
                if (this._triggerFontSize && this._overlayDir.overlayRef &&
                    this._overlayDir.overlayRef.overlayElement) {
                    this._overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`;
                }
            });
        }
    }
    /** Scrolls the active option into view. */
    _scrollOptionIntoView(index) {
        const labelCount = (0,fesm2015_core/* _countGroupLabelsBeforeOption */.CB)(index, this.options, this.optionGroups);
        const itemHeight = this._getItemHeight();
        if (index === 0 && labelCount === 1) {
            // If we've got one group label before the option and we're at the top option,
            // scroll the list to the top. This is better UX than scrolling the list to the
            // top of the option, because it allows the user to read the top group's label.
            this.panel.nativeElement.scrollTop = 0;
        }
        else {
            this.panel.nativeElement.scrollTop = (0,fesm2015_core/* _getOptionScrollPosition */.jH)((index + labelCount) * itemHeight, itemHeight, this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
        }
    }
    _positioningSettled() {
        this._calculateOverlayOffsetX();
        this.panel.nativeElement.scrollTop = this._scrollTop;
    }
    _panelDoneAnimating(isOpen) {
        if (this.panelOpen) {
            this._scrollTop = 0;
        }
        else {
            this._overlayDir.offsetX = 0;
            this._changeDetectorRef.markForCheck();
        }
        super._panelDoneAnimating(isOpen);
    }
    _getChangeEvent(value) {
        return new MatSelectChange(this, value);
    }
    /**
     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
     * This must be adjusted to align the selected option text over the trigger text when
     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
     * can't be calculated until the panel has been attached, because we need to know the
     * content width in order to constrain the panel within the viewport.
     */
    _calculateOverlayOffsetX() {
        const overlayRect = this._overlayDir.overlayRef.overlayElement.getBoundingClientRect();
        const viewportSize = this._viewportRuler.getViewportSize();
        const isRtl = this._isRtl();
        const paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :
            SELECT_PANEL_PADDING_X * 2;
        let offsetX;
        // Adjust the offset, depending on the option padding.
        if (this.multiple) {
            offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;
        }
        else if (this.disableOptionCentering) {
            offsetX = SELECT_PANEL_PADDING_X;
        }
        else {
            let selected = this._selectionModel.selected[0] || this.options.first;
            offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;
        }
        // Invert the offset in LTR.
        if (!isRtl) {
            offsetX *= -1;
        }
        // Determine how much the select overflows on each side.
        const leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));
        const rightOverflow = overlayRect.right + offsetX - viewportSize.width
            + (isRtl ? 0 : paddingWidth);
        // If the element overflows on either side, reduce the offset to allow it to fit.
        if (leftOverflow > 0) {
            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;
        }
        else if (rightOverflow > 0) {
            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;
        }
        // Set the offset directly in order to avoid having to go through change detection and
        // potentially triggering "changed after it was checked" errors. Round the value to avoid
        // blurry content in some browsers.
        this._overlayDir.offsetX = Math.round(offsetX);
        this._overlayDir.overlayRef.updatePosition();
    }
    /**
     * Calculates the y-offset of the select's overlay panel in relation to the
     * top start corner of the trigger. It has to be adjusted in order for the
     * selected option to be aligned over the trigger when the panel opens.
     */
    _calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll) {
        const itemHeight = this._getItemHeight();
        const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
        const maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);
        let optionOffsetFromPanelTop;
        // Disable offset if requested by user by returning 0 as value to offset
        if (this.disableOptionCentering) {
            return 0;
        }
        if (this._scrollTop === 0) {
            optionOffsetFromPanelTop = selectedIndex * itemHeight;
        }
        else if (this._scrollTop === maxScroll) {
            const firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;
            const selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
            // The first item is partially out of the viewport. Therefore we need to calculate what
            // portion of it is shown in the viewport and account for it in our offset.
            let partialItemHeight = itemHeight - (this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight;
            // Because the panel height is longer than the height of the options alone,
            // there is always extra padding at the top or bottom of the panel. When
            // scrolled to the very bottom, this padding is at the top of the panel and
            // must be added to the offset.
            optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;
        }
        else {
            // If the option was scrolled to the middle of the panel using a scroll buffer,
            // its offset will be the scroll buffer minus the half height that was added to
            // center it.
            optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;
        }
        // The final offset is the option's offset from the top, adjusted for the height difference,
        // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.
        // The value is rounded to prevent some browsers from blurring the content.
        return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);
    }
    /**
     * Checks that the attempted overlay position will fit within the viewport.
     * If it will not fit, tries to adjust the scroll position and the associated
     * y-offset so the panel can open fully on-screen. If it still won't fit,
     * sets the offset back to 0 to allow the fallback position to take over.
     */
    _checkOverlayWithinViewport(maxScroll) {
        const itemHeight = this._getItemHeight();
        const viewportSize = this._viewportRuler.getViewportSize();
        const topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
        const bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
        const panelHeightTop = Math.abs(this._offsetY);
        const totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);
        const panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;
        if (panelHeightBottom > bottomSpaceAvailable) {
            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
        }
        else if (panelHeightTop > topSpaceAvailable) {
            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
        }
        else {
            this._transformOrigin = this._getOriginBasedOnOption();
        }
    }
    /** Adjusts the overlay panel up to fit in the viewport. */
    _adjustPanelUp(panelHeightBottom, bottomSpaceAvailable) {
        // Browsers ignore fractional scroll offsets, so we need to round.
        const distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);
        // Scrolls the panel up by the distance it was extending past the boundary, then
        // adjusts the offset by that amount to move the panel up into the viewport.
        this._scrollTop -= distanceBelowViewport;
        this._offsetY -= distanceBelowViewport;
        this._transformOrigin = this._getOriginBasedOnOption();
        // If the panel is scrolled to the very top, it won't be able to fit the panel
        // by scrolling, so set the offset to 0 to allow the fallback position to take
        // effect.
        if (this._scrollTop <= 0) {
            this._scrollTop = 0;
            this._offsetY = 0;
            this._transformOrigin = `50% bottom 0px`;
        }
    }
    /** Adjusts the overlay panel down to fit in the viewport. */
    _adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll) {
        // Browsers ignore fractional scroll offsets, so we need to round.
        const distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);
        // Scrolls the panel down by the distance it was extending past the boundary, then
        // adjusts the offset by that amount to move the panel down into the viewport.
        this._scrollTop += distanceAboveViewport;
        this._offsetY += distanceAboveViewport;
        this._transformOrigin = this._getOriginBasedOnOption();
        // If the panel is scrolled to the very bottom, it won't be able to fit the
        // panel by scrolling, so set the offset to 0 to allow the fallback position
        // to take effect.
        if (this._scrollTop >= maxScroll) {
            this._scrollTop = maxScroll;
            this._offsetY = 0;
            this._transformOrigin = `50% top 0px`;
            return;
        }
    }
    /** Calculates the scroll position and x- and y-offsets of the overlay panel. */
    _calculateOverlayPosition() {
        const itemHeight = this._getItemHeight();
        const items = this._getItemCount();
        const panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);
        const scrollContainerHeight = items * itemHeight;
        // The farthest the panel can be scrolled before it hits the bottom
        const maxScroll = scrollContainerHeight - panelHeight;
        // If no value is selected we open the popup to the first item.
        let selectedOptionOffset;
        if (this.empty) {
            selectedOptionOffset = 0;
        }
        else {
            selectedOptionOffset =
                Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]), 0);
        }
        selectedOptionOffset += (0,fesm2015_core/* _countGroupLabelsBeforeOption */.CB)(selectedOptionOffset, this.options, this.optionGroups);
        // We must maintain a scroll buffer so the selected option will be scrolled to the
        // center of the overlay panel rather than the top.
        const scrollBuffer = panelHeight / 2;
        this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);
        this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);
        this._checkOverlayWithinViewport(maxScroll);
    }
    /** Sets the transform origin point based on the selected option. */
    _getOriginBasedOnOption() {
        const itemHeight = this._getItemHeight();
        const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
        const originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;
        return `50% ${originY}px 0px`;
    }
    /** Calculates the height of the select's options. */
    _getItemHeight() {
        return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;
    }
    /** Calculates the amount of items in the select. This includes options and group labels. */
    _getItemCount() {
        return this.options.length + this.optionGroups.length;
    }
}
MatSelect.ɵfac = /*@__PURE__*/ function () { let ɵMatSelect_BaseFactory; return function MatSelect_Factory(t) { return (ɵMatSelect_BaseFactory || (ɵMatSelect_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatSelect)))(t || MatSelect); }; }();
MatSelect.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatSelect, selectors: [["mat-select"]], contentQueries: function MatSelect_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, MAT_SELECT_TRIGGER, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, fesm2015_core/* MatOption */.ey, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, fesm2015_core/* MAT_OPTGROUP */.K7, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.customTrigger = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.options = _t);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.optionGroups = _t);
    } }, hostAttrs: ["role", "combobox", "aria-autocomplete", "none", "aria-haspopup", "true", 1, "mat-select"], hostVars: 20, hostBindings: function MatSelect_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("keydown", function MatSelect_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })("focus", function MatSelect_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MatSelect_blur_HostBindingHandler() { return ctx._onBlur(); });
    } if (rf & 2) {
        core/* ɵɵattribute */.uIk("id", ctx.id)("tabindex", ctx.tabIndex)("aria-controls", ctx.panelOpen ? ctx.id + "-panel" : null)("aria-expanded", ctx.panelOpen)("aria-label", ctx.ariaLabel || null)("aria-required", ctx.required.toString())("aria-disabled", ctx.disabled.toString())("aria-invalid", ctx.errorState)("aria-describedby", ctx._ariaDescribedby || null)("aria-activedescendant", ctx._getAriaActiveDescendant());
        core/* ɵɵclassProp */.ekj("mat-select-disabled", ctx.disabled)("mat-select-invalid", ctx.errorState)("mat-select-required", ctx.required)("mat-select-empty", ctx.empty)("mat-select-multiple", ctx.multiple);
    } }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matSelect"], features: [core/* ɵɵProvidersFeature */._Bn([
            { provide: MatFormFieldControl, useExisting: MatSelect },
            { provide: fesm2015_core/* MAT_OPTION_PARENT_COMPONENT */.HF, useExisting: MatSelect }
        ]), core/* ɵɵInheritDefinitionFeature */.qOj], ngContentSelectors: select_c3, decls: 9, vars: 12, consts: [["cdk-overlay-origin", "", 1, "mat-select-trigger", 3, "click"], ["origin", "cdkOverlayOrigin", "trigger", ""], [1, "mat-select-value", 3, "ngSwitch"], ["class", "mat-select-placeholder mat-select-min-line", 4, "ngSwitchCase"], ["class", "mat-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"], [1, "mat-select-arrow-wrapper"], [1, "mat-select-arrow"], ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOffsetY", "backdropClick", "attach", "detach"], [1, "mat-select-placeholder", "mat-select-min-line"], [1, "mat-select-value-text", 3, "ngSwitch"], ["class", "mat-select-min-line", 4, "ngSwitchDefault"], [4, "ngSwitchCase"], [1, "mat-select-min-line"], [1, "mat-select-panel-wrap"], ["role", "listbox", "tabindex", "-1", 3, "ngClass", "keydown"], ["panel", ""]], template: function MatSelect_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(select_c2);
        core/* ɵɵelementStart */.TgZ(0, "div", 0, 1);
        core/* ɵɵlistener */.NdJ("click", function MatSelect_Template_div_click_0_listener() { return ctx.toggle(); });
        core/* ɵɵelementStart */.TgZ(3, "div", 2);
        core/* ɵɵtemplate */.YNc(4, MatSelect_span_4_Template, 2, 1, "span", 3);
        core/* ɵɵtemplate */.YNc(5, MatSelect_span_5_Template, 3, 2, "span", 4);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(6, "div", 5);
        core/* ɵɵelement */._UZ(7, "div", 6);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(8, MatSelect_ng_template_8_Template, 4, 14, "ng-template", 7);
        core/* ɵɵlistener */.NdJ("backdropClick", function MatSelect_Template_ng_template_backdropClick_8_listener() { return ctx.close(); })("attach", function MatSelect_Template_ng_template_attach_8_listener() { return ctx._onAttached(); })("detach", function MatSelect_Template_ng_template_detach_8_listener() { return ctx.close(); });
    } if (rf & 2) {
        const _r0 = core/* ɵɵreference */.MAs(1);
        core/* ɵɵattribute */.uIk("aria-owns", ctx.panelOpen ? ctx.id + "-panel" : null);
        core/* ɵɵadvance */.xp6(3);
        core/* ɵɵproperty */.Q6J("ngSwitch", ctx.empty);
        core/* ɵɵattribute */.uIk("id", ctx._valueId);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", true);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngSwitchCase", false);
        core/* ɵɵadvance */.xp6(3);
        core/* ɵɵproperty */.Q6J("cdkConnectedOverlayPanelClass", ctx._overlayPanelClass)("cdkConnectedOverlayScrollStrategy", ctx._scrollStrategy)("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayOpen", ctx.panelOpen)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayMinWidth", ctx._triggerRect == null ? null : ctx._triggerRect.width)("cdkConnectedOverlayOffsetY", ctx._offsetY);
    } }, directives: [overlay/* CdkOverlayOrigin */.xu, common/* NgSwitch */.RF, common/* NgSwitchCase */.n9, overlay/* CdkConnectedOverlay */.pI, common/* NgSwitchDefault */.ED, common/* NgClass */.mk], styles: [".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\" \";white-space:pre;width:1px;display:inline-block;opacity:0}\n"], encapsulation: 2, data: { animation: [
            matSelectAnimations.transformPanelWrap,
            matSelectAnimations.transformPanel
        ] }, changeDetection: 0 });
MatSelect.propDecorators = {
    options: [{ type: core/* ContentChildren */.AcB, args: [fesm2015_core/* MatOption */.ey, { descendants: true },] }],
    optionGroups: [{ type: core/* ContentChildren */.AcB, args: [fesm2015_core/* MAT_OPTGROUP */.K7, { descendants: true },] }],
    customTrigger: [{ type: core/* ContentChild */.aQ5, args: [MAT_SELECT_TRIGGER,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSelect, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-select',
                exportAs: 'matSelect',
                template: "<!--\n Note that the select trigger element specifies `aria-owns` pointing to the listbox overlay.\n While aria-owns is not required for the ARIA 1.2 `role=\"combobox\"` interaction pattern,\n it fixes an issue with VoiceOver when the select appears inside of an `aria-model=\"true\"`\n element (e.g. a dialog). Without this `aria-owns`, the `aria-modal` on a dialog prevents\n VoiceOver from \"seeing\" the select's listbox overlay for aria-activedescendant.\n Using `aria-owns` re-parents the select overlay so that it works again.\n See https://github.com/angular/components/issues/20694\n-->\n<div cdk-overlay-origin\n     [attr.aria-owns]=\"panelOpen ? id + '-panel' : null\"\n     class=\"mat-select-trigger\"\n     (click)=\"toggle()\"\n     #origin=\"cdkOverlayOrigin\"\n     #trigger>\n  <div class=\"mat-select-value\" [ngSwitch]=\"empty\" [attr.id]=\"_valueId\">\n    <span class=\"mat-select-placeholder mat-select-min-line\" *ngSwitchCase=\"true\">{{placeholder}}</span>\n    <span class=\"mat-select-value-text\" *ngSwitchCase=\"false\" [ngSwitch]=\"!!customTrigger\">\n      <span class=\"mat-select-min-line\" *ngSwitchDefault>{{triggerValue}}</span>\n      <ng-content select=\"mat-select-trigger\" *ngSwitchCase=\"true\"></ng-content>\n    </span>\n  </div>\n\n  <div class=\"mat-select-arrow-wrapper\"><div class=\"mat-select-arrow\"></div></div>\n</div>\n\n<ng-template\n  cdk-connected-overlay\n  cdkConnectedOverlayLockPosition\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayPanelClass]=\"_overlayPanelClass\"\n  [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width!\"\n  [cdkConnectedOverlayOffsetY]=\"_offsetY\"\n  (backdropClick)=\"close()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"close()\">\n  <div class=\"mat-select-panel-wrap\" [@transformPanelWrap]>\n    <div\n      #panel\n      role=\"listbox\"\n      tabindex=\"-1\"\n      class=\"mat-select-panel {{ _getPanelTheme() }}\"\n      [attr.id]=\"id + '-panel'\"\n      [attr.aria-multiselectable]=\"multiple\"\n      [attr.aria-label]=\"ariaLabel || null\"\n      [attr.aria-labelledby]=\"_getPanelAriaLabelledby()\"\n      [ngClass]=\"panelClass\"\n      [@transformPanel]=\"multiple ? 'showing-multiple' : 'showing'\"\n      (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\"\n      [style.transformOrigin]=\"_transformOrigin\"\n      [style.font-size.px]=\"_triggerFontSize\"\n      (keydown)=\"_handleKeydown($event)\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                inputs: ['disabled', 'disableRipple', 'tabIndex'],
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                host: {
                    'role': 'combobox',
                    'aria-autocomplete': 'none',
                    // TODO(crisbeto): the value for aria-haspopup should be `listbox`, but currently it's difficult
                    // to sync into Google, because of an outdated automated a11y check which flags it as an invalid
                    // value. At some point we should try to switch it back to being `listbox`.
                    'aria-haspopup': 'true',
                    'class': 'mat-select',
                    '[attr.id]': 'id',
                    '[attr.tabindex]': 'tabIndex',
                    '[attr.aria-controls]': 'panelOpen ? id + "-panel" : null',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.aria-label]': 'ariaLabel || null',
                    '[attr.aria-required]': 'required.toString()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                    '[attr.aria-invalid]': 'errorState',
                    '[attr.aria-describedby]': '_ariaDescribedby || null',
                    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',
                    '[class.mat-select-disabled]': 'disabled',
                    '[class.mat-select-invalid]': 'errorState',
                    '[class.mat-select-required]': 'required',
                    '[class.mat-select-empty]': 'empty',
                    '[class.mat-select-multiple]': 'multiple',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()'
                },
                animations: [
                    matSelectAnimations.transformPanelWrap,
                    matSelectAnimations.transformPanel
                ],
                providers: [
                    { provide: MatFormFieldControl, useExisting: MatSelect },
                    { provide: fesm2015_core/* MAT_OPTION_PARENT_COMPONENT */.HF, useExisting: MatSelect }
                ],
                styles: [".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\" \";white-space:pre;width:1px;display:inline-block;opacity:0}\n"]
            }]
    }], null, { options: [{
            type: core/* ContentChildren */.AcB,
            args: [fesm2015_core/* MatOption */.ey, { descendants: true }]
        }], optionGroups: [{
            type: core/* ContentChildren */.AcB,
            args: [fesm2015_core/* MAT_OPTGROUP */.K7, { descendants: true }]
        }], customTrigger: [{
            type: core/* ContentChild */.aQ5,
            args: [MAT_SELECT_TRIGGER]
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatSelectModule {
}
MatSelectModule.ɵfac = function MatSelectModule_Factory(t) { return new (t || MatSelectModule)(); };
MatSelectModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatSelectModule });
MatSelectModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER], imports: [[
            common/* CommonModule */.ez,
            overlay/* OverlayModule */.U8,
            fesm2015_core/* MatOptionModule */.Ng,
            fesm2015_core/* MatCommonModule */.BQ,
        ], scrolling/* CdkScrollableModule */.ZD,
        MatFormFieldModule,
        fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSelectModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [
                    common/* CommonModule */.ez,
                    overlay/* OverlayModule */.U8,
                    fesm2015_core/* MatOptionModule */.Ng,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                exports: [
                    scrolling/* CdkScrollableModule */.ZD,
                    MatFormFieldModule,
                    MatSelect,
                    MatSelectTrigger,
                    fesm2015_core/* MatOptionModule */.Ng,
                    fesm2015_core/* MatCommonModule */.BQ
                ],
                declarations: [MatSelect, MatSelectTrigger],
                providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatSelectModule, { declarations: function () { return [MatSelect, MatSelectTrigger]; }, imports: function () { return [common/* CommonModule */.ez,
        overlay/* OverlayModule */.U8,
        fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [scrolling/* CdkScrollableModule */.ZD,
        MatFormFieldModule, MatSelect, MatSelectTrigger, fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=select.js.map
;// CONCATENATED MODULE: ./src/app/pages/exposureResults/exposed.component.ts





















const exposed_component_c0 = ["chart"];
function ExposedComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 14);
    core/* ɵɵelementStart */.TgZ(2, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function ExposedComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 16);
    core/* ɵɵlistener */.NdJ("click", function ExposedComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 17);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function ExposedComponent_div_20_ng_template_3_div_1_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 34);
    core/* ɵɵelementStart */.TgZ(1, "div", 35);
    core/* ɵɵelementStart */.TgZ(2, "mat-button-toggle", 36);
    core/* ɵɵelementStart */.TgZ(3, "div", 27);
    core/* ɵɵelementStart */.TgZ(4, "p", 37);
    core/* ɵɵtext */._uU(5, "KWAB");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "p", 37);
    core/* ɵɵtext */._uU(7, "OF THE DAY");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(8, "img", 38);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "div", 39);
    core/* ɵɵelement */._UZ(10, "img", 40);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵpropertyInterpolate */.s9C("src", "assets/img/drivers/" + ctx_r12.exposureData.currentYear + "/" + ctx_r12.exposureData.activeExposureChart.drivers[0] + ".png", core/* ɵɵsanitizeUrl */.LSH);
} }
function ExposedComponent_div_20_ng_template_3_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 30);
    core/* ɵɵtemplate */.YNc(1, ExposedComponent_div_20_ng_template_3_div_1_div_1_Template, 11, 1, "div", 31);
    core/* ɵɵelementStart */.TgZ(2, "a", 32);
    core/* ɵɵelementStart */.TgZ(3, "button", 33);
    core/* ɵɵtext */._uU(4, " Go to strawpoll ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r11.exposureData.showWinner);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r11.getStrawpollUrl(ctx_r11.exposedChart.strawpoll), core/* ɵɵsanitizeUrl */.LSH);
} }
function ExposedComponent_div_20_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 24);
    core/* ɵɵtemplate */.YNc(1, ExposedComponent_div_20_ng_template_3_div_1_Template, 5, 2, "div", 25);
    core/* ɵɵelementStart */.TgZ(2, "div", 26);
    core/* ɵɵelementStart */.TgZ(3, "div", 27);
    core/* ɵɵelement */._UZ(4, "apx-chart", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 26);
    core/* ɵɵelementStart */.TgZ(6, "div", 27);
    core/* ɵɵelement */._UZ(7, "apx-chart", 29);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r7.exposedChart.strawpoll != null);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r7.defaultChartOptions.chart)("dataLabels", ctx_r7.defaultChartOptions.dataLabels)("plotOptions", ctx_r7.defaultChartOptions.plotOptions)("series", ctx_r7.exposedChartOptions.series)("title", ctx_r7.exposedChartOptions.title)("xaxis", ctx_r7.exposedChartOptions.xaxis)("yaxis", ctx_r7.defaultChartOptions.yaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r7.defaultChartOptions.chart)("dataLabels", ctx_r7.defaultChartOptions.dataLabels)("plotOptions", ctx_r7.defaultChartOptions.plotOptions)("series", ctx_r7.votesChartOptions.series)("title", ctx_r7.votesChartOptions.title)("xaxis", ctx_r7.votesChartOptions.xaxis);
} }
function ExposedComponent_div_20_ng_template_5_div_1_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 52);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 53);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 54);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵpipe */.ALo(9, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r17 = ctx.$implicit;
    const i_r18 = ctx.index;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(i_r18 + 1);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.fullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.id.driver);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(9, 4, standing_r17.exposure));
} }
function ExposedComponent_div_20_ng_template_5_div_1_tr_36_Template(rf, ctx) { if (rf & 1) {
    const _r22 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 55);
    core/* ɵɵlistener */.NdJ("click", function ExposedComponent_div_20_ng_template_5_div_1_tr_36_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r22); const race_r19 = restoredCtx.$implicit; const ctx_r21 = core/* ɵɵnextContext */.oxw(4); return ctx_r21.openExposureResultsDialog(ctx_r21.exposureData.activeExposureChart.season, race_r19.round, race_r19.raceName); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 56);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 56);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(7, "td");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r19 = ctx.$implicit;
    const ctx_r16 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r19.round);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r19.raceName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r19.exposureWinner);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵstyleProp */.Udp("background-color", ctx_r16.getColor(race_r19.round));
} }
function ExposedComponent_div_20_ng_template_5_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 44);
    core/* ɵɵelementStart */.TgZ(1, "div", 26);
    core/* ɵɵelementStart */.TgZ(2, "div", 27);
    core/* ɵɵelementStart */.TgZ(3, "div", 45);
    core/* ɵɵelement */._UZ(4, "img", 46);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "table", 47);
    core/* ɵɵelementStart */.TgZ(6, "thead");
    core/* ɵɵelementStart */.TgZ(7, "tr");
    core/* ɵɵelementStart */.TgZ(8, "th", 48);
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tr", 49);
    core/* ɵɵelement */._UZ(11, "th", 50);
    core/* ɵɵelementStart */.TgZ(12, "th", 50);
    core/* ɵɵtext */._uU(13, "Driver");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Code");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 50);
    core/* ɵɵtext */._uU(17, "Exposure");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, ExposedComponent_div_20_ng_template_5_div_1_tr_19_Template, 10, 6, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "div", 26);
    core/* ɵɵelementStart */.TgZ(21, "div", 27);
    core/* ɵɵelementStart */.TgZ(22, "table", 47);
    core/* ɵɵelementStart */.TgZ(23, "thead");
    core/* ɵɵelementStart */.TgZ(24, "tr");
    core/* ɵɵelementStart */.TgZ(25, "th", 48);
    core/* ɵɵtext */._uU(26);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(27, "tr", 49);
    core/* ɵɵelement */._UZ(28, "th", 50);
    core/* ɵɵelementStart */.TgZ(29, "th", 50);
    core/* ɵɵtext */._uU(30, "Race");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(31, "th", 50);
    core/* ɵɵtext */._uU(32, "Exposed");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(33, "th", 50);
    core/* ɵɵtext */._uU(34, "Color");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(35, "tbody");
    core/* ɵɵtemplate */.YNc(36, ExposedComponent_div_20_ng_template_5_div_1_tr_36_Template, 8, 5, "tr", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("src", ctx_r13.getExposureHeader(), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r13.exposureData.activeExposureChart.season, " Standings ");
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.exposureData.standings);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r13.exposureData.activeExposureChart.season, " races ");
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.exposureData.exposureRaces);
} }
function ExposedComponent_div_20_ng_template_5_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 26);
    core/* ɵɵelementStart */.TgZ(2, "div", 27);
    core/* ɵɵelement */._UZ(3, "apx-chart", 58);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 26);
    core/* ɵɵelementStart */.TgZ(5, "div", 27);
    core/* ɵɵelement */._UZ(6, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 26);
    core/* ɵɵelementStart */.TgZ(8, "div", 27);
    core/* ɵɵelement */._UZ(9, "apx-chart", 60);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 26);
    core/* ɵɵelementStart */.TgZ(11, "div", 27);
    core/* ɵɵelement */._UZ(12, "apx-chart", 61);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r14 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r14.lineChart)("series", ctx_r14.exposureStandingsOptions.series)("stroke", ctx_r14.defStroke)("title", ctx_r14.exposureStandingsOptions.title)("tooltip", ctx_r14.defTooltip)("xaxis", ctx_r14.numericXaxis)("yaxis", ctx_r14.defYaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r14.exposureRoundByRoundOptions.chart)("dataLabels", ctx_r14.exposureRoundByRoundOptions.dataLabels)("fill", ctx_r14.exposureRoundByRoundOptions.fill)("plotOptions", ctx_r14.exposureRoundByRoundOptions.plotOptions)("responsive", ctx_r14.exposureRoundByRoundOptions.responsive)("series", ctx_r14.exposureRoundByRoundOptions.series)("title", ctx_r14.exposureRoundByRoundOptions.title)("xaxis", ctx_r14.exposureRoundByRoundOptions.xaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r14.defaultChartOptions.chart)("colors", ctx_r14.maxExposureColors)("dataLabels", ctx_r14.defaultChartOptions.dataLabels)("legend", ctx_r14.noLegend)("plotOptions", ctx_r14.distributedPlotOptions)("series", ctx_r14.maxExposureOptions.series)("title", ctx_r14.maxExposureOptions.title)("xaxis", ctx_r14.maxExposureOptions.xaxis)("yaxis", ctx_r14.maxExposureOptions.yaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r14.lineChart)("legend", ctx_r14.raceLegend)("series", ctx_r14.votersOptions.series)("stroke", ctx_r14.defStroke)("title", ctx_r14.votersOptions.title)("xaxis", ctx_r14.numericXaxis)("yaxis", ctx_r14.defYaxis);
} }
function ExposedComponent_div_20_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 41);
    core/* ɵɵtemplate */.YNc(1, ExposedComponent_div_20_ng_template_5_div_1_Template, 37, 5, "div", 42);
    core/* ɵɵtemplate */.YNc(2, ExposedComponent_div_20_ng_template_5_div_2_Template, 13, 31, "div", 43);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.exposureData !== undefined);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.exposureData !== undefined);
} }
function ExposedComponent_div_20_ng_template_7_mat_option_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 65);
    core/* ɵɵelementStart */.TgZ(1, "div", 66);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const year_r26 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", year_r26);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", year_r26, " ");
} }
function ExposedComponent_div_20_ng_template_7_div_4_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 52);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 53);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 54);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵpipe */.ALo(9, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r29 = ctx.$implicit;
    const i_r30 = ctx.index;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(i_r30 + 1);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r29.fullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r29.id.driver);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(9, 4, standing_r29.exposure));
} }
function ExposedComponent_div_20_ng_template_7_div_4_tr_35_Template(rf, ctx) { if (rf & 1) {
    const _r34 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 55);
    core/* ɵɵlistener */.NdJ("click", function ExposedComponent_div_20_ng_template_7_div_4_tr_35_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r34); const race_r31 = restoredCtx.$implicit; const ctx_r33 = core/* ɵɵnextContext */.oxw(4); return ctx_r33.openExposureResultsDialog(ctx_r33.exposureArchiveData.currentYear, race_r31.round, race_r31.raceName); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 56);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(5, "td");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r31 = ctx.$implicit;
    const ctx_r28 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r31.round);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r31.raceName);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵstyleProp */.Udp("background-color", ctx_r28.getColor(race_r31.round));
} }
function ExposedComponent_div_20_ng_template_7_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 44);
    core/* ɵɵelementStart */.TgZ(1, "div", 26);
    core/* ɵɵelementStart */.TgZ(2, "div", 27);
    core/* ɵɵelementStart */.TgZ(3, "div", 45);
    core/* ɵɵelement */._UZ(4, "img", 46);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "table", 47);
    core/* ɵɵelementStart */.TgZ(6, "thead");
    core/* ɵɵelementStart */.TgZ(7, "tr");
    core/* ɵɵelementStart */.TgZ(8, "th", 48);
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tr", 49);
    core/* ɵɵelement */._UZ(11, "th", 50);
    core/* ɵɵelementStart */.TgZ(12, "th", 50);
    core/* ɵɵtext */._uU(13, "Driver");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Code");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 50);
    core/* ɵɵtext */._uU(17, "Exposure");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, ExposedComponent_div_20_ng_template_7_div_4_tr_19_Template, 10, 6, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "div", 26);
    core/* ɵɵelementStart */.TgZ(21, "div", 27);
    core/* ɵɵelementStart */.TgZ(22, "table", 47);
    core/* ɵɵelementStart */.TgZ(23, "thead");
    core/* ɵɵelementStart */.TgZ(24, "tr");
    core/* ɵɵelementStart */.TgZ(25, "th", 48);
    core/* ɵɵtext */._uU(26);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(27, "tr", 49);
    core/* ɵɵelementStart */.TgZ(28, "th", 50);
    core/* ɵɵtext */._uU(29, "Round");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(30, "th", 50);
    core/* ɵɵtext */._uU(31, "Race");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(32, "th", 50);
    core/* ɵɵtext */._uU(33, "Color");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(34, "tbody");
    core/* ɵɵtemplate */.YNc(35, ExposedComponent_div_20_ng_template_7_div_4_tr_35_Template, 6, 4, "tr", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r24 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("src", ctx_r24.getExposureHeader(), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r24.exposureArchiveData.currentYear, " Standings ");
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r24.exposureArchiveData.standings);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r24.exposureArchiveData.currentYear, " races ");
    core/* ɵɵadvance */.xp6(9);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r24.exposureArchiveData.exposureRaces);
} }
function ExposedComponent_div_20_ng_template_7_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 26);
    core/* ɵɵelementStart */.TgZ(2, "div", 27);
    core/* ɵɵelement */._UZ(3, "apx-chart", 58);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 26);
    core/* ɵɵelementStart */.TgZ(5, "div", 27);
    core/* ɵɵelement */._UZ(6, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 26);
    core/* ɵɵelementStart */.TgZ(8, "div", 27);
    core/* ɵɵelement */._UZ(9, "apx-chart", 60);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 26);
    core/* ɵɵelementStart */.TgZ(11, "div", 27);
    core/* ɵɵelement */._UZ(12, "apx-chart", 61);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r25 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r25.lineChart)("series", ctx_r25.exposureArchiveDataCharts.exposureStandingsOptions.series)("stroke", ctx_r25.defStroke)("title", ctx_r25.exposureArchiveDataCharts.exposureStandingsOptions.title)("tooltip", ctx_r25.defTooltip)("xaxis", ctx_r25.numericXaxisHistoric)("yaxis", ctx_r25.defYaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.chart)("dataLabels", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.dataLabels)("fill", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.fill)("plotOptions", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.plotOptions)("responsive", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.responsive)("series", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.series)("title", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.title)("xaxis", ctx_r25.exposureArchiveDataCharts.exposureRoundByRoundOptions.xaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r25.defaultChartOptions.chart)("colors", ctx_r25.exposureArchiveDataCharts.maxExposureColors)("dataLabels", ctx_r25.defaultChartOptions.dataLabels)("legend", ctx_r25.noLegend)("plotOptions", ctx_r25.distributedPlotOptions)("series", ctx_r25.exposureArchiveDataCharts.maxExposureOptions.series)("title", ctx_r25.exposureArchiveDataCharts.maxExposureOptions.title)("xaxis", ctx_r25.exposureArchiveDataCharts.maxExposureOptions.xaxis)("yaxis", ctx_r25.exposureArchiveDataCharts.maxExposureOptions.yaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r25.lineChart)("legend", ctx_r25.raceLegend)("series", ctx_r25.exposureArchiveDataCharts.votersOptions.series)("stroke", ctx_r25.defStroke)("title", ctx_r25.exposureArchiveDataCharts.votersOptions.title)("xaxis", ctx_r25.numericXaxisHistoric)("yaxis", ctx_r25.defYaxis);
} }
function ExposedComponent_div_20_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r36 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 62);
    core/* ɵɵelementStart */.TgZ(1, "mat-select", 63);
    core/* ɵɵlistener */.NdJ("selectionChange", function ExposedComponent_div_20_ng_template_7_Template_mat_select_selectionChange_1_listener() { core/* ɵɵrestoreView */.CHM(_r36); const ctx_r35 = core/* ɵɵnextContext */.oxw(2); return ctx_r35.fetchHistoricData(); })("valueChange", function ExposedComponent_div_20_ng_template_7_Template_mat_select_valueChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r36); const ctx_r37 = core/* ɵɵnextContext */.oxw(2); return ctx_r37.selectedYear = $event; });
    core/* ɵɵtemplate */.YNc(2, ExposedComponent_div_20_ng_template_7_mat_option_2_Template, 3, 2, "mat-option", 64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 41);
    core/* ɵɵtemplate */.YNc(4, ExposedComponent_div_20_ng_template_7_div_4_Template, 36, 5, "div", 42);
    core/* ɵɵtemplate */.YNc(5, ExposedComponent_div_20_ng_template_7_div_5_Template, 13, 31, "div", 43);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("value", ctx_r9.selectedYear)("disabled", ctx_r9.historicYears.length < 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r9.historicYears);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.exposureArchiveData !== undefined);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.exposureArchiveData !== undefined);
} }
function ExposedComponent_div_20_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 67);
    core/* ɵɵelementStart */.TgZ(1, "p");
    core/* ɵɵtext */._uU(2, " The real exposure hosted on strawpoll by ");
    core/* ɵɵelementStart */.TgZ(3, "a", 68);
    core/* ɵɵtext */._uU(4, "Vitaly Petrov");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(5, " - and that's not me. This site finds the strawpoll and stores its results. ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 69);
    core/* ɵɵtext */._uU(7, " Exposure formula is ");
    core/* ɵɵelementStart */.TgZ(8, "p");
    core/* ɵɵtext */._uU(9, "exposure = votes/total voters");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "p");
    core/* ɵɵtext */._uU(11, " Example: There are only 2 people voting. One votes HAM and VER, the other votes HAM, BOT and GAS. That's total of 2 voters, and 5 votes. HAM's exposure is 100% ( 2/2, all voters voted for him), VER/BOT/GAS exposure is 50% ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(12, "p");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function ExposedComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 18);
    core/* ɵɵelementStart */.TgZ(1, "mat-tab-group");
    core/* ɵɵelementStart */.TgZ(2, "mat-tab", 19);
    core/* ɵɵtemplate */.YNc(3, ExposedComponent_div_20_ng_template_3_Template, 8, 14, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab", 21);
    core/* ɵɵtemplate */.YNc(5, ExposedComponent_div_20_ng_template_5_Template, 3, 2, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "mat-tab", 22);
    core/* ɵɵtemplate */.YNc(7, ExposedComponent_div_20_ng_template_7_Template, 6, 5, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "mat-tab", 23);
    core/* ɵɵtemplate */.YNc(9, ExposedComponent_div_20_ng_template_9_Template, 13, 0, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function sortByMaxExpoDesc(a, b) {
    if (a.maxExposure > b.maxExposure) {
        return -1;
    }
    if (a.maxExposure < b.maxExposure) {
        return 1;
    }
    return 0;
}
class ExposedComponent {
    constructor(restService, utilityService, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.dialog = dialog;
        this.maxExposureColors = [];
        this.defaultChartOptions = {
            chart: {
                type: 'bar',
                height: 500,
                toolbar: ChartUtility.defaultToolbar
            },
            plotOptions: {
                bar: {
                    horizontal: true,
                }
            },
            dataLabels: {
                enabled: true
            },
            yaxis: {
                min: 0,
                max: 100,
                tickAmount: 20,
                axisTicks: {
                    show: true
                },
                axisBorder: {
                    show: true,
                    color: '#008FFB'
                }
            }
        };
        this.lineChart = {
            animations: {
                enabled: true,
                speed: 1000,
                animateGradually: {
                    enabled: false
                },
            },
            height: 500,
            type: 'line',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.defStroke = {
            width: 3
        };
        this.defTooltip = {
            shared: false,
        };
        this.numericXaxis = {
            type: 'numeric',
            decimalsInFloat: 0,
            min: 1,
            max: 23,
            tickAmount: 11
        };
        this.numericXaxisHistoric = {
            type: 'numeric',
            decimalsInFloat: 0,
            min: 1,
            max: 23,
            tickAmount: 11
        };
        this.defYaxis = {
            decimalsInFloat: 0
        };
        this.raceLegend = {
            position: 'top',
            horizontalAlign: 'left',
            floating: false,
            show: true
        };
        this.noLegend = {
            show: false
        };
        this.distributedPlotOptions = {
            bar: {
                horizontal: true,
                distributed: true
            }
        };
        this.destroyed = false;
        this.getExposureResults();
        this.setHistoricData();
    }
    getColor(number) {
        return utility_service/* UtilityService.colorMap.get */.t.colorMap.get(number);
    }
    postCommentMethod(page) {
        this.utilityService.postComment(page);
    }
    getStrawpollUrl(code) {
        return 'https://strawpoll.com/polls/' + code;
    }
    getExposureHeader() {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/wec_header';
    }
    ngOnDestroy() {
        this.destroyed = true;
    }
    fetchHistoricData() {
        console.log('fetchHistoricData');
        this.getExposureArchivedResults(this.selectedYear);
    }
    openExposureResultsDialog(season, round, title) {
        const dialogRef = this.dialog.open(ExposureResultComponent);
        dialogRef.componentInstance.getData(season, round, title);
    }
    setExposureChampionshipData() {
        let standingSeries = [];
        let roundByRound = [];
        let roundByRoundCategories = [];
        let maxExposureSeries = [];
        let driverNamesSortedByMaxExpo = [];
        let roundByRoundSeriesMap = new Map();
        this.exposureData.exposureChampionshipData.forEach((driverExposure) => {
            standingSeries.push({
                name: driverExposure.code,
                data: driverExposure.scoresThroughRounds,
                color: driverExposure.color
            });
            roundByRoundCategories.push(driverExposure.code);
            driverExposure.scoresByRound.forEach((scoreByRound) => {
                if (!roundByRoundSeriesMap.has(scoreByRound[0])) {
                    roundByRoundSeriesMap.set(scoreByRound[0], []);
                }
                roundByRoundSeriesMap.get(scoreByRound[0]).push(scoreByRound[1]);
            });
        });
        roundByRoundSeriesMap.forEach((value, name) => roundByRound.push({
            name: name + '',
            data: value
        }));
        this.exposureChampionshipDataSortedByMaxExpo.forEach((driverExposure) => {
            maxExposureSeries.push(driverExposure.maxExposure);
            driverNamesSortedByMaxExpo.push(driverExposure.code);
            this.maxExposureColors.push(this.getColor(driverExposure.maxExposureRound));
        });
        this.exposureStandingsOptions = {
            series: standingSeries,
            title: {
                text: 'Exposure through season',
                align: 'center'
            },
        };
        this.votersOptions = {
            series: [
                {
                    name: 'Voters',
                    data: this.exposureData.voters
                }
            ],
            title: {
                text: 'Voters through season',
                align: 'center'
            },
        };
        this.maxExposureOptions = {
            series: [
                {
                    name: 'Max Exposure',
                    data: maxExposureSeries
                }
            ],
            xaxis: {
                categories: driverNamesSortedByMaxExpo
            },
            title: {
                text: 'Highest exposure by driver',
                align: 'center'
            }
        };
        this.exposureRoundByRoundOptions = {
            title: {
                text: 'Round by round',
                align: 'center'
            },
            series: roundByRound,
            chart: {
                type: 'bar',
                height: 500,
                stacked: true,
                toolbar: {
                    show: true
                },
                zoom: {
                    enabled: true
                }
            },
            responsive: [
                {
                    breakpoint: 480,
                    options: {
                        legend: {
                            position: 'bottom',
                            offsetX: -10,
                            offsetY: 0
                        }
                    }
                }
            ],
            plotOptions: {
                bar: {
                    horizontal: false,
                    columnWidth: '75%'
                }
            },
            xaxis: {
                type: 'category',
                categories: roundByRoundCategories
            },
            legend: {
                position: 'right',
                offsetY: 40
            },
            fill: {
                opacity: 1
            },
            dataLabels: {
                enabled: false
            }
        };
    }
    setHistoricExposureChampionshipData() {
        let standingSeries = [];
        let roundByRound = [];
        let roundByRoundCategories = [];
        let maxExposureSeries = [];
        let driverNamesSortedByMaxExpo = [];
        let roundByRoundSeriesMap = new Map();
        this.exposureArchiveData.exposureChampionshipData.forEach((driverExposure) => {
            standingSeries.push({
                name: driverExposure.code,
                data: driverExposure.scoresThroughRounds,
                color: driverExposure.color
            });
            roundByRoundCategories.push(driverExposure.code);
            driverExposure.scoresByRound.forEach((scoreByRound) => {
                if (!roundByRoundSeriesMap.has(scoreByRound[0])) {
                    roundByRoundSeriesMap.set(scoreByRound[0], []);
                }
                roundByRoundSeriesMap.get(scoreByRound[0]).push(scoreByRound[1]);
            });
        });
        roundByRoundSeriesMap.forEach((value, name) => roundByRound.push({
            name: name + '',
            data: value
        }));
        this.exposureArchiveDataCharts.maxExposureColors = [];
        this.exposureArchiveDataCharts.exposureChampionshipDataSortedByMaxExpo.forEach((driverExposure) => {
            maxExposureSeries.push(driverExposure.maxExposure);
            driverNamesSortedByMaxExpo.push(driverExposure.code);
            this.exposureArchiveDataCharts.maxExposureColors.push(this.getColor(driverExposure.maxExposureRound));
        });
        this.exposureArchiveDataCharts.exposureStandingsOptions = {
            series: standingSeries,
            title: {
                text: 'Exposure through season',
                align: 'center'
            },
        };
        this.exposureArchiveDataCharts.votersOptions = {
            series: [
                {
                    name: 'Voters',
                    data: this.exposureArchiveData.voters
                }
            ],
            title: {
                text: 'Voters through season',
                align: 'center'
            },
        };
        this.exposureArchiveDataCharts.maxExposureOptions = {
            series: [
                {
                    name: 'Max Exposure',
                    data: maxExposureSeries
                }
            ],
            xaxis: {
                categories: driverNamesSortedByMaxExpo
            },
            title: {
                text: 'Highest exposure by driver',
                align: 'center'
            }
        };
        this.exposureArchiveDataCharts.exposureRoundByRoundOptions = {
            title: {
                text: 'Round by round',
                align: 'center'
            },
            series: roundByRound,
            chart: {
                type: 'bar',
                height: 500,
                stacked: true,
                toolbar: {
                    show: true
                },
                zoom: {
                    enabled: true
                }
            },
            responsive: [
                {
                    breakpoint: 480,
                    options: {
                        legend: {
                            position: 'bottom',
                            offsetX: -10,
                            offsetY: 0
                        }
                    }
                }
            ],
            plotOptions: {
                bar: {
                    horizontal: false,
                    columnWidth: '75%'
                }
            },
            xaxis: {
                type: 'category',
                categories: roundByRoundCategories
            },
            legend: {
                position: 'right',
                offsetY: 40
            },
            fill: {
                opacity: 1
            },
            dataLabels: {
                enabled: false
            }
        };
        console.log(this.exposureArchiveDataCharts);
    }
    getExposureResults() {
        this.restService.getExposureResults().subscribe({
            next: data => {
                this.exposureData = data;
                this.utilityService.setTitle(8, 'Exposure - /' + this.exposureData.title + '/ edition');
                this.exposedChart = this.exposureData.activeExposureChart;
                let exposureChampionshipData = JSON.parse(JSON.stringify(this.exposureData.exposureChampionshipData));
                this.exposureChampionshipDataSortedByMaxExpo = exposureChampionshipData.sort(sortByMaxExpoDesc);
                this.round = this.exposureData.activeExposureChart.round;
                if (this.round > 0) {
                    this.numericXaxis.max = this.round;
                    this.numericXaxis.tickAmount = (this.round + 1) / 2;
                }
                this.votesChartOptions = {
                    series: [
                        {
                            name: 'Votes',
                            data: this.exposedChart.results
                        }
                    ],
                    xaxis: {
                        categories: this.exposedChart.driverNames
                    },
                    title: {
                        text: 'Total votes',
                        align: 'center'
                    }
                };
                this.exposedChartOptions = {
                    series: [
                        {
                            name: 'Exposure',
                            data: this.exposedChart.exposure
                        }
                    ],
                    xaxis: {
                        categories: this.exposedChart.driverNames
                    },
                    title: {
                        text: 'Exposure (%)',
                        align: 'center'
                    }
                };
                this.setExposureChampionshipData();
                if (this.exposedChart.delay > 1) {
                    setTimeout(() => this.getExposureResultsPeriodically(), this.exposedChart.delay);
                }
                return data;
            }
        });
    }
    getExposureArchivedResults(year) {
        this.restService.getExposureArchivedResults(year).subscribe({
            next: data => {
                console.log(data.json);
                this.exposureArchiveData = data.json;
                this.exposureArchiveDataCharts = {};
                let exposureChampionshipData = JSON.parse(JSON.stringify(this.exposureArchiveData.exposureChampionshipData));
                this.exposureArchiveDataCharts.exposureChampionshipDataSortedByMaxExpo = exposureChampionshipData.sort(sortByMaxExpoDesc);
                let raceCount = this.exposureArchiveData.exposureRaces.length;
                this.numericXaxisHistoric.max = raceCount;
                this.numericXaxisHistoric.tickAmount = (raceCount + 1) / 2;
                this.setHistoricExposureChampionshipData();
                return data;
            }
        });
    }
    getExposureResultsPeriodically() {
        this.restService.getExposureResults().subscribe({
            next: data => {
                this.exposureData = data;
                this.exposedChart = this.exposureData.activeExposureChart;
                this.round = this.exposureData.activeExposureChart.round;
                if (this.round > 0) {
                    this.numericXaxis.max = this.round;
                    this.numericXaxis.tickAmount = (this.round + 1) / 2;
                }
                this.votesChartOptions = {
                    series: [
                        {
                            name: 'Votes',
                            data: this.exposedChart.results
                        }
                    ],
                    xaxis: {
                        categories: this.exposedChart.driverNames
                    },
                    title: {
                        text: 'Total votes',
                        align: 'center'
                    }
                };
                this.exposedChartOptions = {
                    series: [
                        {
                            name: 'Exposure',
                            data: this.exposedChart.exposure
                        }
                    ],
                    xaxis: {
                        categories: this.exposedChart.driverNames
                    },
                    title: {
                        text: 'Exposure (%)',
                        align: 'center'
                    }
                };
                if (this.exposedChart.delay > 1 && !this.destroyed) {
                    setTimeout(() => this.getExposureResultsPeriodically(), this.exposedChart.delay);
                }
                return data;
            }
        });
    }
    setHistoricData() {
        this.historicYears = [];
        let season = environment/* environment.currentSeason */.N.currentSeason;
        do {
            season--;
            this.historicYears.push(season);
        } while (season > 2022);
        this.selectedYear = environment/* environment.currentSeason */.N.currentSeason - 1;
        this.fetchHistoricData();
    }
}
ExposedComponent.ɵfac = function ExposedComponent_Factory(t) { return new (t || ExposedComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
ExposedComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ExposedComponent, selectors: [["app-exposed-cmp"]], viewQuery: function ExposedComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(exposed_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 21, vars: 4, consts: [[1, "div-padded"], ["autosize", ""], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "focus", "focusout", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "div-padded-right bg-white height-fill-screen", "id", "chart1", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], ["id", "chart1", 1, "div-padded-right", "bg-white", "height-fill-screen"], ["label", "Latest race"], ["matTabContent", ""], ["label", "World Exposure Championship"], ["label", "History"], ["label", "Info"], [1, "bg-grey", "px-lg-2"], ["class", "div-padded-always-left-right-1 row", 4, "ngIf"], [1, "card", "card-stats"], [1, "card-body"], [3, "chart", "dataLabels", "plotOptions", "series", "title", "xaxis", "yaxis"], [3, "chart", "dataLabels", "plotOptions", "series", "title", "xaxis"], [1, "div-padded-always-left-right-1", "row"], ["class", "w-75 center-div", 4, "ngIf"], ["target", "_blank", 1, "div-float-right", "py-1", 3, "href"], ["color", "accent", "mat-flat-button", "", 1, "width-100"], [1, "w-75", "center-div"], [1, "max-w-232-px", "card", "center-div"], ["value", "driver.Name", 2, "background-color", "black"], [1, "driver-text-def", "teko-text-color-2"], ["alt", "", "onerror", "this.src='assets/img/drivers/default.png'", 3, "src"], [1, "card-footer"], ["alt", "relentless", "src", "assets/img/relentless.png", 1, "kwab-footer"], [1, "row", "bg-grey"], ["class", "col-lg-4 pt-1 pl-lg-3 col-md-6 col-xs-6 no-right-padding", 4, "ngIf"], ["class", "col-lg-8 pt-1 pr-lg-4 col-md-6 col-xs-6", 4, "ngIf"], [1, "col-lg-4", "pt-1", "pl-lg-3", "col-md-6", "col-xs-6", "no-right-padding"], [1, "w-100", "text-center"], ["alt", "exposure header", 2, "height", "15vh", 3, "src"], [1, "table", "table-striped"], ["colspan", "4", 1, "text-center", "bg-primary", "text-white"], [1, "text-center", "bg-info", "text-white"], ["scope", "col"], ["class", "hover-effects-bold-row", 3, "click", 4, "ngFor", "ngForOf"], ["scope", "row"], [1, "text-center"], [1, "text-right"], [1, "hover-effects-bold-row", 3, "click"], [1, "text-left"], [1, "col-lg-8", "pt-1", "pr-lg-4", "col-md-6", "col-xs-6"], [3, "chart", "series", "stroke", "title", "tooltip", "xaxis", "yaxis"], [3, "chart", "dataLabels", "fill", "plotOptions", "responsive", "series", "title", "xaxis"], [3, "chart", "colors", "dataLabels", "legend", "plotOptions", "series", "title", "xaxis", "yaxis"], [3, "chart", "legend", "series", "stroke", "title", "xaxis", "yaxis"], [1, "row", "px-3", "py-3", "bg-grey", "text-bold", "text-center"], ["panelClass", "mt-4 ml-minus-2", 3, "value", "disabled", "selectionChange", "valueChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "text-center", "text-bold"], [1, "card", "div-padded-2rem", "text-justify"], ["href", "https://strawpoll.com/user/vitaly-petrov"], [1, "text-justify"]], template: function ExposedComponent_Template(rf, ctx) { if (rf & 1) {
        const _r38 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 1);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 2, 3);
        core/* ɵɵlistener */.NdJ("openedChange", function ExposedComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 4);
        core/* ɵɵelementStart */.TgZ(5, "div", 5);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 6);
        core/* ɵɵlistener */.NdJ("focus", function ExposedComponent_Template_textarea_focus_7_listener() { return ctx.utilityService.focusFunction(); })("focusout", function ExposedComponent_Template_textarea_focusout_7_listener() { return ctx.utilityService.focusOutFunction(); })("ngModelChange", function ExposedComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 7);
        core/* ɵɵelementStart */.TgZ(9, "button", 8);
        core/* ɵɵlistener */.NdJ("click", function ExposedComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(3); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 8);
        core/* ɵɵlistener */.NdJ("click", function ExposedComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(3); });
        core/* ɵɵtext */._uU(12, " Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, ExposedComponent_div_13_Template, 8, 3, "div", 9);
        core/* ɵɵelementStart */.TgZ(14, "div", 10);
        core/* ɵɵelementStart */.TgZ(15, "button", 11);
        core/* ɵɵlistener */.NdJ("click", function ExposedComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r38); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 10);
        core/* ɵɵelementStart */.TgZ(18, "button", 11);
        core/* ɵɵlistener */.NdJ("click", function ExposedComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r38); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, ExposedComponent_div_20_Template, 10, 0, "div", 13);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.exposureData != null);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, ng_apexcharts/* ChartComponent */.x, button_toggle/* MatButtonToggle */.Yi, MatSelect, fesm2015_core/* MatOption */.ey], pipes: [common/* DecimalPipe */.JJ], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/table.js + 1 modules
var table = __webpack_require__(2789);
;// CONCATENATED MODULE: ./src/app/model/podium.ts
class Podium {
}

// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/icon.js
var icon = __webpack_require__(6627);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sort.js










/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @docs-private */




const sort_c0 = ["mat-sort-header", ""];
function MatSortHeader_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r2 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 3);
    core/* ɵɵlistener */.NdJ("@arrowPosition.start", function MatSortHeader_div_3_Template_div_animation_arrowPosition_start_0_listener() { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r1 = core/* ɵɵnextContext */.oxw(); return ctx_r1._disableViewStateAnimation = true; })("@arrowPosition.done", function MatSortHeader_div_3_Template_div_animation_arrowPosition_done_0_listener() { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3._disableViewStateAnimation = false; });
    core/* ɵɵelement */._UZ(1, "div", 4);
    core/* ɵɵelementStart */.TgZ(2, "div", 5);
    core/* ɵɵelement */._UZ(3, "div", 6);
    core/* ɵɵelement */._UZ(4, "div", 7);
    core/* ɵɵelement */._UZ(5, "div", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("@arrowOpacity", ctx_r0._getArrowViewState())("@arrowPosition", ctx_r0._getArrowViewState())("@allowChildren", ctx_r0._getArrowDirectionState());
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("@indicator", ctx_r0._getArrowDirectionState());
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("@leftPointer", ctx_r0._getArrowDirectionState());
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("@rightPointer", ctx_r0._getArrowDirectionState());
} }
const sort_c1 = ["*"];
function getSortDuplicateSortableIdError(id) {
    return Error(`Cannot have two MatSortables with the same id (${id}).`);
}
/** @docs-private */
function getSortHeaderNotContainedWithinSortError() {
    return Error(`MatSortHeader must be placed within a parent element with the MatSort directive.`);
}
/** @docs-private */
function getSortHeaderMissingIdError() {
    return Error(`MatSortHeader must be provided with a unique id.`);
}
/** @docs-private */
function getSortInvalidDirectionError(direction) {
    return Error(`${direction} is not a valid sort direction ('asc' or 'desc').`);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token to be used to override the default options for `mat-sort`. */
const MAT_SORT_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('MAT_SORT_DEFAULT_OPTIONS');
// Boilerplate for applying mixins to MatSort.
/** @docs-private */
const _MatSortBase = (0,fesm2015_core/* mixinInitialized */.dB)((0,fesm2015_core/* mixinDisabled */.Id)(class {
}));
/** Container for MatSortables to manage the sort state and provide default sort parameters. */
class MatSort extends _MatSortBase {
    constructor(_defaultOptions) {
        super();
        this._defaultOptions = _defaultOptions;
        /** Collection of all registered sortables that this directive manages. */
        this.sortables = new Map();
        /** Used to notify any child components listening to state changes. */
        this._stateChanges = new Subject/* Subject */.xQ();
        /**
         * The direction to set when an MatSortable is initially sorted.
         * May be overriden by the MatSortable's sort start.
         */
        this.start = 'asc';
        this._direction = '';
        /** Event emitted when the user changes either the active sort or sort direction. */
        this.sortChange = new core/* EventEmitter */.vpe();
    }
    /** The sort direction of the currently active MatSortable. */
    get direction() { return this._direction; }
    set direction(direction) {
        if (direction && direction !== 'asc' && direction !== 'desc' &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getSortInvalidDirectionError(direction);
        }
        this._direction = direction;
    }
    /**
     * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
     * May be overriden by the MatSortable's disable clear input.
     */
    get disableClear() { return this._disableClear; }
    set disableClear(v) { this._disableClear = (0,coercion/* coerceBooleanProperty */.Ig)(v); }
    /**
     * Register function to be used by the contained MatSortables. Adds the MatSortable to the
     * collection of MatSortables.
     */
    register(sortable) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!sortable.id) {
                throw getSortHeaderMissingIdError();
            }
            if (this.sortables.has(sortable.id)) {
                throw getSortDuplicateSortableIdError(sortable.id);
            }
        }
        this.sortables.set(sortable.id, sortable);
    }
    /**
     * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
     * collection of contained MatSortables.
     */
    deregister(sortable) {
        this.sortables.delete(sortable.id);
    }
    /** Sets the active sort id and determines the new sort direction. */
    sort(sortable) {
        if (this.active != sortable.id) {
            this.active = sortable.id;
            this.direction = sortable.start ? sortable.start : this.start;
        }
        else {
            this.direction = this.getNextSortDirection(sortable);
        }
        this.sortChange.emit({ active: this.active, direction: this.direction });
    }
    /** Returns the next sort direction of the active sortable, checking for potential overrides. */
    getNextSortDirection(sortable) {
        var _a, _b, _c;
        if (!sortable) {
            return '';
        }
        // Get the sort direction cycle with the potential sortable overrides.
        const disableClear = (_b = (_a = sortable === null || sortable === void 0 ? void 0 : sortable.disableClear) !== null && _a !== void 0 ? _a : this.disableClear) !== null && _b !== void 0 ? _b : !!((_c = this._defaultOptions) === null || _c === void 0 ? void 0 : _c.disableClear);
        let sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
        // Get and return the next direction in the cycle
        let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    }
    ngOnInit() {
        this._markInitialized();
    }
    ngOnChanges() {
        this._stateChanges.next();
    }
    ngOnDestroy() {
        this._stateChanges.complete();
    }
}
MatSort.ɵfac = function MatSort_Factory(t) { return new (t || MatSort)(core/* ɵɵdirectiveInject */.Y36(MAT_SORT_DEFAULT_OPTIONS, 8)); };
MatSort.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatSort, selectors: [["", "matSort", ""]], hostAttrs: [1, "mat-sort"], inputs: { disabled: ["matSortDisabled", "disabled"], start: ["matSortStart", "start"], direction: ["matSortDirection", "direction"], disableClear: ["matSortDisableClear", "disableClear"], active: ["matSortActive", "active"] }, outputs: { sortChange: "matSortChange" }, exportAs: ["matSort"], features: [core/* ɵɵInheritDefinitionFeature */.qOj, core/* ɵɵNgOnChangesFeature */.TTD] });
MatSort.ctorParameters = () => [
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_SORT_DEFAULT_OPTIONS,] }] }
];
MatSort.propDecorators = {
    active: [{ type: core/* Input */.IIB, args: ['matSortActive',] }],
    start: [{ type: core/* Input */.IIB, args: ['matSortStart',] }],
    direction: [{ type: core/* Input */.IIB, args: ['matSortDirection',] }],
    disableClear: [{ type: core/* Input */.IIB, args: ['matSortDisableClear',] }],
    sortChange: [{ type: core/* Output */.r_U, args: ['matSortChange',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSort, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[matSort]',
                exportAs: 'matSort',
                host: { 'class': 'mat-sort' },
                inputs: ['disabled: matSortDisabled']
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_SORT_DEFAULT_OPTIONS]
            }] }]; }, { start: [{
            type: core/* Input */.IIB,
            args: ['matSortStart']
        }], sortChange: [{
            type: core/* Output */.r_U,
            args: ['matSortChange']
        }], direction: [{
            type: core/* Input */.IIB,
            args: ['matSortDirection']
        }], disableClear: [{
            type: core/* Input */.IIB,
            args: ['matSortDisableClear']
        }], active: [{
            type: core/* Input */.IIB,
            args: ['matSortActive']
        }] }); })();
/** Returns the sort direction cycle to use given the provided parameters of order and clear. */
function getSortDirectionCycle(start, disableClear) {
    let sortOrder = ['asc', 'desc'];
    if (start == 'desc') {
        sortOrder.reverse();
    }
    if (!disableClear) {
        sortOrder.push('');
    }
    return sortOrder;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SORT_ANIMATION_TRANSITION = fesm2015_core/* AnimationDurations.ENTERING */.mZ.ENTERING + ' ' +
    fesm2015_core/* AnimationCurves.STANDARD_CURVE */.yN.STANDARD_CURVE;
/**
 * Animations used by MatSort.
 * @docs-private
 */
const matSortAnimations = {
    /** Animation that moves the sort indicator. */
    indicator: (0,animations/* trigger */.X$)('indicator', [
        (0,animations/* state */.SB)('active-asc, asc', (0,animations/* style */.oB)({ transform: 'translateY(0px)' })),
        // 10px is the height of the sort indicator, minus the width of the pointers
        (0,animations/* state */.SB)('active-desc, desc', (0,animations/* style */.oB)({ transform: 'translateY(10px)' })),
        (0,animations/* transition */.eR)('active-asc <=> active-desc', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION))
    ]),
    /** Animation that rotates the left pointer of the indicator based on the sorting direction. */
    leftPointer: (0,animations/* trigger */.X$)('leftPointer', [
        (0,animations/* state */.SB)('active-asc, asc', (0,animations/* style */.oB)({ transform: 'rotate(-45deg)' })),
        (0,animations/* state */.SB)('active-desc, desc', (0,animations/* style */.oB)({ transform: 'rotate(45deg)' })),
        (0,animations/* transition */.eR)('active-asc <=> active-desc', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION))
    ]),
    /** Animation that rotates the right pointer of the indicator based on the sorting direction. */
    rightPointer: (0,animations/* trigger */.X$)('rightPointer', [
        (0,animations/* state */.SB)('active-asc, asc', (0,animations/* style */.oB)({ transform: 'rotate(45deg)' })),
        (0,animations/* state */.SB)('active-desc, desc', (0,animations/* style */.oB)({ transform: 'rotate(-45deg)' })),
        (0,animations/* transition */.eR)('active-asc <=> active-desc', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION))
    ]),
    /** Animation that controls the arrow opacity. */
    arrowOpacity: (0,animations/* trigger */.X$)('arrowOpacity', [
        (0,animations/* state */.SB)('desc-to-active, asc-to-active, active', (0,animations/* style */.oB)({ opacity: 1 })),
        (0,animations/* state */.SB)('desc-to-hint, asc-to-hint, hint', (0,animations/* style */.oB)({ opacity: .54 })),
        (0,animations/* state */.SB)('hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void', (0,animations/* style */.oB)({ opacity: 0 })),
        // Transition between all states except for immediate transitions
        (0,animations/* transition */.eR)('* => asc, * => desc, * => active, * => hint, * => void', (0,animations/* animate */.jt)('0ms')),
        (0,animations/* transition */.eR)('* <=> *', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION)),
    ]),
    /**
     * Animation for the translation of the arrow as a whole. States are separated into two
     * groups: ones with animations and others that are immediate. Immediate states are asc, desc,
     * peek, and active. The other states define a specific animation (source-to-destination)
     * and are determined as a function of their prev user-perceived state and what the next state
     * should be.
     */
    arrowPosition: (0,animations/* trigger */.X$)('arrowPosition', [
        // Hidden Above => Hint Center
        (0,animations/* transition */.eR)('* => desc-to-hint, * => desc-to-active', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION, (0,animations/* keyframes */.F4)([
            (0,animations/* style */.oB)({ transform: 'translateY(-25%)' }),
            (0,animations/* style */.oB)({ transform: 'translateY(0)' })
        ]))),
        // Hint Center => Hidden Below
        (0,animations/* transition */.eR)('* => hint-to-desc, * => active-to-desc', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION, (0,animations/* keyframes */.F4)([
            (0,animations/* style */.oB)({ transform: 'translateY(0)' }),
            (0,animations/* style */.oB)({ transform: 'translateY(25%)' })
        ]))),
        // Hidden Below => Hint Center
        (0,animations/* transition */.eR)('* => asc-to-hint, * => asc-to-active', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION, (0,animations/* keyframes */.F4)([
            (0,animations/* style */.oB)({ transform: 'translateY(25%)' }),
            (0,animations/* style */.oB)({ transform: 'translateY(0)' })
        ]))),
        // Hint Center => Hidden Above
        (0,animations/* transition */.eR)('* => hint-to-asc, * => active-to-asc', (0,animations/* animate */.jt)(SORT_ANIMATION_TRANSITION, (0,animations/* keyframes */.F4)([
            (0,animations/* style */.oB)({ transform: 'translateY(0)' }),
            (0,animations/* style */.oB)({ transform: 'translateY(-25%)' })
        ]))),
        (0,animations/* state */.SB)('desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active', (0,animations/* style */.oB)({ transform: 'translateY(0)' })),
        (0,animations/* state */.SB)('hint-to-desc, active-to-desc, desc', (0,animations/* style */.oB)({ transform: 'translateY(-25%)' })),
        (0,animations/* state */.SB)('hint-to-asc, active-to-asc, asc', (0,animations/* style */.oB)({ transform: 'translateY(25%)' })),
    ]),
    /** Necessary trigger that calls animate on children animations. */
    allowChildren: (0,animations/* trigger */.X$)('allowChildren', [
        (0,animations/* transition */.eR)('* <=> *', [
            (0,animations/* query */.IO)('@*', (0,animations/* animateChild */.pV)(), { optional: true })
        ])
    ]),
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and
 * include it in a custom provider.
 * @deprecated No longer being used. To be removed.
 * @breaking-change 13.0.0
 */
class MatSortHeaderIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject/* Subject */.xQ();
    }
}
MatSortHeaderIntl.ɵfac = function MatSortHeaderIntl_Factory(t) { return new (t || MatSortHeaderIntl)(); };
MatSortHeaderIntl.ɵprov = core/* ɵɵdefineInjectable */.Yz7({ factory: function MatSortHeaderIntl_Factory() { return new MatSortHeaderIntl(); }, token: MatSortHeaderIntl, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSortHeaderIntl, [{
        type: core/* Injectable */.GSi,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
/** @docs-private */
function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
    return parentIntl || new MatSortHeaderIntl();
}
/** @docs-private */
const MAT_SORT_HEADER_INTL_PROVIDER = {
    // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
    provide: MatSortHeaderIntl,
    deps: [[new core/* Optional */.FiY(), new core/* SkipSelf */.tp0(), MatSortHeaderIntl]],
    useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Boilerplate for applying mixins to the sort header.
/** @docs-private */
const _MatSortHeaderBase = (0,fesm2015_core/* mixinDisabled */.Id)(class {
});
/**
 * Applies sorting behavior (click to change sort) and styles to an element, including an
 * arrow to display the current sort direction.
 *
 * Must be provided with an id and contained within a parent MatSort directive.
 *
 * If used on header cells in a CdkTable, it will automatically default its id from its containing
 * column definition.
 */
class MatSortHeader extends _MatSortHeaderBase {
    constructor(
    /**
     * @deprecated `_intl` parameter isn't being used anymore and it'll be removed.
     * @breaking-change 13.0.0
     */
    _intl, _changeDetectorRef, 
    // `MatSort` is not optionally injected, but just asserted manually w/ better error.
    // tslint:disable-next-line: lightweight-tokens
    _sort, _columnDef, _focusMonitor, _elementRef) {
        // Note that we use a string token for the `_columnDef`, because the value is provided both by
        // `material/table` and `cdk/table` and we can't have the CDK depending on Material,
        // and we want to avoid having the sort header depending on the CDK table because
        // of this single reference.
        super();
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._sort = _sort;
        this._columnDef = _columnDef;
        this._focusMonitor = _focusMonitor;
        this._elementRef = _elementRef;
        /**
         * Flag set to true when the indicator should be displayed while the sort is not active. Used to
         * provide an affordance that the header is sortable by showing on focus and hover.
         */
        this._showIndicatorHint = false;
        /**
         * The view transition state of the arrow (translation/ opacity) - indicates its `from` and `to`
         * position through the animation. If animations are currently disabled, the fromState is removed
         * so that there is no animation displayed.
         */
        this._viewState = {};
        /** The direction the arrow should be facing according to the current state. */
        this._arrowDirection = '';
        /**
         * Whether the view state animation should show the transition between the `from` and `to` states.
         */
        this._disableViewStateAnimation = false;
        /** Sets the position of the arrow that displays when sorted. */
        this.arrowPosition = 'after';
        if (!_sort && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getSortHeaderNotContainedWithinSortError();
        }
        this._handleStateChanges();
    }
    /** Overrides the disable clear value of the containing MatSort for this MatSortable. */
    get disableClear() { return this._disableClear; }
    set disableClear(v) { this._disableClear = (0,coercion/* coerceBooleanProperty */.Ig)(v); }
    ngOnInit() {
        if (!this.id && this._columnDef) {
            this.id = this._columnDef.name;
        }
        // Initialize the direction of the arrow and set the view state to be immediately that state.
        this._updateArrowDirection();
        this._setAnimationTransitionState({ toState: this._isSorted() ? 'active' : this._arrowDirection });
        this._sort.register(this);
    }
    ngAfterViewInit() {
        // We use the focus monitor because we also want to style
        // things differently based on the focus origin.
        this._focusMonitor.monitor(this._elementRef, true).subscribe(origin => {
            const newState = !!origin;
            if (newState !== this._showIndicatorHint) {
                this._setIndicatorHintVisible(newState);
                this._changeDetectorRef.markForCheck();
            }
        });
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
        this._sort.deregister(this);
        this._rerenderSubscription.unsubscribe();
    }
    /**
     * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
     * user showing what the active sort will become. If set to false, the arrow will fade away.
     */
    _setIndicatorHintVisible(visible) {
        // No-op if the sort header is disabled - should not make the hint visible.
        if (this._isDisabled() && visible) {
            return;
        }
        this._showIndicatorHint = visible;
        if (!this._isSorted()) {
            this._updateArrowDirection();
            if (this._showIndicatorHint) {
                this._setAnimationTransitionState({ fromState: this._arrowDirection, toState: 'hint' });
            }
            else {
                this._setAnimationTransitionState({ fromState: 'hint', toState: this._arrowDirection });
            }
        }
    }
    /**
     * Sets the animation transition view state for the arrow's position and opacity. If the
     * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
     * no animation appears.
     */
    _setAnimationTransitionState(viewState) {
        this._viewState = viewState || {};
        // If the animation for arrow position state (opacity/translation) should be disabled,
        // remove the fromState so that it jumps right to the toState.
        if (this._disableViewStateAnimation) {
            this._viewState = { toState: viewState.toState };
        }
    }
    /** Triggers the sort on this sort header and removes the indicator hint. */
    _toggleOnInteraction() {
        this._sort.sort(this);
        // Do not show the animation if the header was already shown in the right position.
        if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
            this._disableViewStateAnimation = true;
        }
    }
    _handleClick() {
        if (!this._isDisabled()) {
            this._sort.sort(this);
        }
    }
    _handleKeydown(event) {
        if (!this._isDisabled() && (event.keyCode === keycodes/* SPACE */.L_ || event.keyCode === keycodes/* ENTER */.K5)) {
            event.preventDefault();
            this._toggleOnInteraction();
        }
    }
    /** Whether this MatSortHeader is currently sorted in either ascending or descending order. */
    _isSorted() {
        return this._sort.active == this.id &&
            (this._sort.direction === 'asc' || this._sort.direction === 'desc');
    }
    /** Returns the animation state for the arrow direction (indicator and pointers). */
    _getArrowDirectionState() {
        return `${this._isSorted() ? 'active-' : ''}${this._arrowDirection}`;
    }
    /** Returns the arrow position state (opacity, translation). */
    _getArrowViewState() {
        const fromState = this._viewState.fromState;
        return (fromState ? `${fromState}-to-` : '') + this._viewState.toState;
    }
    /**
     * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
     * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
     * active sorted direction. The reason this is updated through a function is because the direction
     * should only be changed at specific times - when deactivated but the hint is displayed and when
     * the sort is active and the direction changes. Otherwise the arrow's direction should linger
     * in cases such as the sort becoming deactivated but we want to animate the arrow away while
     * preserving its direction, even though the next sort direction is actually different and should
     * only be changed once the arrow displays again (hint or activation).
     */
    _updateArrowDirection() {
        this._arrowDirection = this._isSorted() ?
            this._sort.direction :
            (this.start || this._sort.start);
    }
    _isDisabled() {
        return this._sort.disabled || this.disabled;
    }
    /**
     * Gets the aria-sort attribute that should be applied to this sort header. If this header
     * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
     * says that the aria-sort property should only be present on one header at a time, so removing
     * ensures this is true.
     */
    _getAriaSortAttribute() {
        if (!this._isSorted()) {
            return 'none';
        }
        return this._sort.direction == 'asc' ? 'ascending' : 'descending';
    }
    /** Whether the arrow inside the sort header should be rendered. */
    _renderArrow() {
        return !this._isDisabled() || this._isSorted();
    }
    /** Handles changes in the sorting state. */
    _handleStateChanges() {
        this._rerenderSubscription =
            (0,merge/* merge */.T)(this._sort.sortChange, this._sort._stateChanges, this._intl.changes).subscribe(() => {
                if (this._isSorted()) {
                    this._updateArrowDirection();
                    // Do not show the animation if the header was already shown in the right position.
                    if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
                        this._disableViewStateAnimation = true;
                    }
                    this._setAnimationTransitionState({ fromState: this._arrowDirection, toState: 'active' });
                    this._showIndicatorHint = false;
                }
                // If this header was recently active and now no longer sorted, animate away the arrow.
                if (!this._isSorted() && this._viewState && this._viewState.toState === 'active') {
                    this._disableViewStateAnimation = false;
                    this._setAnimationTransitionState({ fromState: 'active', toState: this._arrowDirection });
                }
                this._changeDetectorRef.markForCheck();
            });
    }
}
MatSortHeader.ɵfac = function MatSortHeader_Factory(t) { return new (t || MatSortHeader)(core/* ɵɵdirectiveInject */.Y36(MatSortHeaderIntl), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(MatSort, 8), core/* ɵɵdirectiveInject */.Y36('MAT_SORT_HEADER_COLUMN_DEF', 8), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusMonitor */.tE), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq)); };
MatSortHeader.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatSortHeader, selectors: [["", "mat-sort-header", ""]], hostAttrs: [1, "mat-sort-header"], hostVars: 3, hostBindings: function MatSortHeader_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("click", function MatSortHeader_click_HostBindingHandler() { return ctx._handleClick(); })("keydown", function MatSortHeader_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })("mouseenter", function MatSortHeader_mouseenter_HostBindingHandler() { return ctx._setIndicatorHintVisible(true); })("mouseleave", function MatSortHeader_mouseleave_HostBindingHandler() { return ctx._setIndicatorHintVisible(false); });
    } if (rf & 2) {
        core/* ɵɵattribute */.uIk("aria-sort", ctx._getAriaSortAttribute());
        core/* ɵɵclassProp */.ekj("mat-sort-header-disabled", ctx._isDisabled());
    } }, inputs: { disabled: "disabled", arrowPosition: "arrowPosition", disableClear: "disableClear", id: ["mat-sort-header", "id"], start: "start" }, exportAs: ["matSortHeader"], features: [core/* ɵɵInheritDefinitionFeature */.qOj], attrs: sort_c0, ngContentSelectors: sort_c1, decls: 4, vars: 6, consts: [["role", "button", 1, "mat-sort-header-container", "mat-focus-indicator"], [1, "mat-sort-header-content"], ["class", "mat-sort-header-arrow", 4, "ngIf"], [1, "mat-sort-header-arrow"], [1, "mat-sort-header-stem"], [1, "mat-sort-header-indicator"], [1, "mat-sort-header-pointer-left"], [1, "mat-sort-header-pointer-right"], [1, "mat-sort-header-pointer-middle"]], template: function MatSortHeader_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t();
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1);
        core/* ɵɵprojection */.Hsn(2);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(3, MatSortHeader_div_3_Template, 6, 6, "div", 2);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵclassProp */.ekj("mat-sort-header-sorted", ctx._isSorted())("mat-sort-header-position-before", ctx.arrowPosition == "before");
        core/* ɵɵattribute */.uIk("tabindex", ctx._isDisabled() ? null : 0);
        core/* ɵɵadvance */.xp6(3);
        core/* ɵɵproperty */.Q6J("ngIf", ctx._renderArrow());
    } }, directives: [common/* NgIf */.O5], styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-content{text-align:center;display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"], encapsulation: 2, data: { animation: [
            matSortAnimations.indicator,
            matSortAnimations.leftPointer,
            matSortAnimations.rightPointer,
            matSortAnimations.arrowOpacity,
            matSortAnimations.arrowPosition,
            matSortAnimations.allowChildren,
        ] }, changeDetection: 0 });
MatSortHeader.ctorParameters = () => [
    { type: MatSortHeaderIntl },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: MatSort, decorators: [{ type: core/* Optional */.FiY }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: ['MAT_SORT_HEADER_COLUMN_DEF',] }, { type: core/* Optional */.FiY }] },
    { type: a11y/* FocusMonitor */.tE },
    { type: core/* ElementRef */.SBq }
];
MatSortHeader.propDecorators = {
    id: [{ type: core/* Input */.IIB, args: ['mat-sort-header',] }],
    arrowPosition: [{ type: core/* Input */.IIB }],
    start: [{ type: core/* Input */.IIB }],
    disableClear: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSortHeader, [{
        type: core/* Component */.wA2,
        args: [{
                selector: '[mat-sort-header]',
                exportAs: 'matSortHeader',
                template: "<!--\n  We set the `tabindex` on an element inside the table header, rather than the header itself,\n  because of a bug in NVDA where having a `tabindex` on a `th` breaks keyboard navigation in the\n  table (see https://github.com/nvaccess/nvda/issues/7718). This allows for the header to both\n  be focusable, and have screen readers read out its `aria-sort` state. We prefer this approach\n  over having a button with an `aria-label` inside the header, because the button's `aria-label`\n  will be read out as the user is navigating the table's cell (see #13012).\n\n  The approach is based off of: https://dequeuniversity.com/library/aria/tables/sf-sortable-grid\n-->\n<div class=\"mat-sort-header-container mat-focus-indicator\"\n     [class.mat-sort-header-sorted]=\"_isSorted()\"\n     [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\"\n     [attr.tabindex]=\"_isDisabled() ? null : 0\"\n     role=\"button\">\n\n  <!--\n    TODO(crisbeto): this div isn't strictly necessary, but we have to keep it due to a large\n    number of screenshot diff failures. It should be removed eventually. Note that the difference\n    isn't visible with a shorter header, but once it breaks up into multiple lines, this element\n    causes it to be center-aligned, whereas removing it will keep the text to the left.\n  -->\n  <div class=\"mat-sort-header-content\">\n    <ng-content></ng-content>\n  </div>\n\n  <!-- Disable animations while a current animation is running -->\n  <div class=\"mat-sort-header-arrow\"\n       *ngIf=\"_renderArrow()\"\n       [@arrowOpacity]=\"_getArrowViewState()\"\n       [@arrowPosition]=\"_getArrowViewState()\"\n       [@allowChildren]=\"_getArrowDirectionState()\"\n       (@arrowPosition.start)=\"_disableViewStateAnimation = true\"\n       (@arrowPosition.done)=\"_disableViewStateAnimation = false\">\n    <div class=\"mat-sort-header-stem\"></div>\n    <div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\">\n      <div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div>\n      <div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div>\n      <div class=\"mat-sort-header-pointer-middle\"></div>\n    </div>\n  </div>\n</div>\n",
                host: {
                    'class': 'mat-sort-header',
                    '(click)': '_handleClick()',
                    '(keydown)': '_handleKeydown($event)',
                    '(mouseenter)': '_setIndicatorHintVisible(true)',
                    '(mouseleave)': '_setIndicatorHintVisible(false)',
                    '[attr.aria-sort]': '_getAriaSortAttribute()',
                    '[class.mat-sort-header-disabled]': '_isDisabled()'
                },
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                inputs: ['disabled'],
                animations: [
                    matSortAnimations.indicator,
                    matSortAnimations.leftPointer,
                    matSortAnimations.rightPointer,
                    matSortAnimations.arrowOpacity,
                    matSortAnimations.arrowPosition,
                    matSortAnimations.allowChildren,
                ],
                styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-content{text-align:center;display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"]
            }]
    }], function () { return [{ type: MatSortHeaderIntl }, { type: core/* ChangeDetectorRef */.sBO }, { type: MatSort, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: ['MAT_SORT_HEADER_COLUMN_DEF']
            }, {
                type: core/* Optional */.FiY
            }] }, { type: a11y/* FocusMonitor */.tE }, { type: core/* ElementRef */.SBq }]; }, { arrowPosition: [{
            type: core/* Input */.IIB
        }], disableClear: [{
            type: core/* Input */.IIB
        }], id: [{
            type: core/* Input */.IIB,
            args: ['mat-sort-header']
        }], start: [{
            type: core/* Input */.IIB
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatSortModule {
}
MatSortModule.ɵfac = function MatSortModule_Factory(t) { return new (t || MatSortModule)(); };
MatSortModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatSortModule });
MatSortModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [MAT_SORT_HEADER_INTL_PROVIDER], imports: [[common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSortModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ],
                exports: [MatSort, MatSortHeader],
                declarations: [MatSort, MatSortHeader],
                providers: [MAT_SORT_HEADER_INTL_PROVIDER]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatSortModule, { declarations: function () { return [MatSort, MatSortHeader]; }, imports: function () { return [common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatSort, MatSortHeader]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=sort.js.map
;// CONCATENATED MODULE: ./src/app/pages/database/circuit/circuit.component.ts


















function CircuitComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function CircuitComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function CircuitComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function CircuitComponent_div_20_img_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 31);
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r7.circuit.wikiImage, core/* ɵɵsanitizeUrl */.LSH);
} }
function CircuitComponent_div_20_tr_39_Template(rf, ctx) { if (rf & 1) {
    const _r12 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 32);
    core/* ɵɵlistener */.NdJ("click", function CircuitComponent_div_20_tr_39_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r12); const race_r9 = restoredCtx.$implicit; const ctx_r11 = core/* ɵɵnextContext */.oxw(2); return ctx_r11.openRace(race_r9.season, race_r9.round); });
    core/* ɵɵelementStart */.TgZ(1, "th", 33);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 34);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 35);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 36);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵpipe */.ALo(9, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "td", 36);
    core/* ɵɵtext */._uU(11);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "td", 37);
    core/* ɵɵelementStart */.TgZ(13, "a", 24);
    core/* ɵɵelement */._UZ(14, "img", 38);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(i_r10 + 1);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r9.season);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r9.round);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(9, 7, race_r9.date, "YYYY, MMMM d"));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate2 */.AsE("", race_r9.winner.givenName, " ", race_r9.winner.familyName, "");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", race_r9.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function CircuitComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r14 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 17);
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵelementStart */.TgZ(2, "div", 3);
    core/* ɵɵelementStart */.TgZ(3, "div", 18);
    core/* ɵɵelementStart */.TgZ(4, "div", 19);
    core/* ɵɵelementStart */.TgZ(5, "div", 20);
    core/* ɵɵelementStart */.TgZ(6, "button", 21);
    core/* ɵɵlistener */.NdJ("click", function CircuitComponent_div_20_Template_button_click_6_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r13 = core/* ɵɵnextContext */.oxw(); return ctx_r13.openCircuitList(); });
    core/* ɵɵelementStart */.TgZ(7, "mat-icon");
    core/* ɵɵtext */._uU(8, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementStart */.TgZ(10, "mat-icon");
    core/* ɵɵtext */._uU(11, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "div", 20);
    core/* ɵɵelementStart */.TgZ(13, "a", 22);
    core/* ɵɵtemplate */.YNc(14, CircuitComponent_div_20_img_14_Template, 1, 1, "img", 23);
    core/* ɵɵelementStart */.TgZ(15, "p");
    core/* ɵɵtext */._uU(16);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "a", 24);
    core/* ɵɵelementStart */.TgZ(18, "span");
    core/* ɵɵtext */._uU(19, "Location:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "h3");
    core/* ɵɵtext */._uU(21);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(22, "img", 25);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(23, "table", 26);
    core/* ɵɵelementStart */.TgZ(24, "thead");
    core/* ɵɵelementStart */.TgZ(25, "tr", 27);
    core/* ɵɵelementStart */.TgZ(26, "th", 28);
    core/* ɵɵtext */._uU(27, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(28, "th", 28);
    core/* ɵɵtext */._uU(29, "Year");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(30, "th", 28);
    core/* ɵɵtext */._uU(31, "Round");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(32, "th", 29);
    core/* ɵɵtext */._uU(33, "Date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(34, "th", 29);
    core/* ɵɵtext */._uU(35, "Winner");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(36, "th", 29);
    core/* ɵɵtext */._uU(37, "Wiki");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(38, "tbody");
    core/* ɵɵtemplate */.YNc(39, CircuitComponent_div_20_tr_39_Template, 15, 10, "tr", 30);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(9);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r2.circuit.ergastCircuit.circuitName, " ");
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("href", ctx_r2.circuit.ergastCircuit.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.circuit.wikiImage != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r2.circuit.wikiSummary, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵpropertyInterpolate */.s9C("href", "https://www.google.com/maps?q=" + ctx_r2.circuit.ergastCircuit.Location.lat + "," + ctx_r2.circuit.ergastCircuit.Location.long, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate2 */.AsE("", ctx_r2.circuit.ergastCircuit.Location.locality, ", ", ctx_r2.circuit.ergastCircuit.Location.country, "");
    core/* ɵɵadvance */.xp6(18);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r2.circuit.races);
} }
function RacePopupComponent_div_1_tr_17_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 9);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const result_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(result_r2.positionText);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(result_r2.Driver.givenName + " " + result_r2.Driver.familyName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(result_r2.Constructor.name);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(result_r2.points);
} }
function RacePopupComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 1);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 2);
    core/* ɵɵelementStart */.TgZ(4, "th", 3);
    core/* ɵɵelementStart */.TgZ(5, "h3");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "tr", 2);
    core/* ɵɵelementStart */.TgZ(8, "th", 4);
    core/* ɵɵtext */._uU(9, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "th", 4);
    core/* ɵɵtext */._uU(11, "Driver");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 4);
    core/* ɵɵtext */._uU(13, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 4);
    core/* ɵɵtext */._uU(15, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "tbody");
    core/* ɵɵtemplate */.YNc(17, RacePopupComponent_div_1_tr_17_Template, 9, 4, "tr", 5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "div");
    core/* ɵɵelementStart */.TgZ(19, "div", 6);
    core/* ɵɵelementStart */.TgZ(20, "a", 7);
    core/* ɵɵelementStart */.TgZ(21, "button", 8);
    core/* ɵɵtext */._uU(22, "Wikipedia");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(23, "div", 6);
    core/* ɵɵelementStart */.TgZ(24, "a", 7);
    core/* ɵɵelementStart */.TgZ(25, "button", 8);
    core/* ɵɵtext */._uU(26, "Google Maps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.race.raceName + ", " + ctx_r0.race.season);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.race.Results);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", ctx_r0.race.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵpropertyInterpolate */.s9C("href", "https://www.google.com/maps?q=" + ctx_r0.race.Circuit.Location.lat + "," + ctx_r0.race.Circuit.Location.long, core/* ɵɵsanitizeUrl */.LSH);
} }
function CircuitsPopupComponent_tr_15_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 7);
    core/* ɵɵlistener */.NdJ("click", function CircuitsPopupComponent_tr_15_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const circuit_r2 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.selectCircuit(circuit_r2.circuitId); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const circuit_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(circuit_r2.circuitName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(circuit_r2.Location.country);
} }
class CircuitComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.circuitId = this.getSelectedCircuit();
        this.getCircuit(this.circuitId);
        this.getAllCircuits();
    }
    updateUrl() {
        const queryParams = { circuit: this.circuitId };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    openCircuitList() {
        const dialogRef = this.dialog.open(CircuitsPopupComponent);
        dialogRef.componentInstance.setCircuits(this.allCircuits);
        dialogRef.afterClosed().subscribe(circuitId => {
            if (circuitId != null) {
                this.circuitId = circuitId;
                this.getCircuit(this.circuitId);
                this.updateUrl();
            }
        });
    }
    getCircuit(circuitId) {
        this.restService.getCircuit(circuitId).subscribe({
            next: data => {
                this.circuit = data;
                this.utilityService.setTitle(74, this.circuit.ergastCircuit.circuitName);
                this.updateUrl();
            }
        });
    }
    getSelectedTab() {
        const tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == null) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    getSelectedCircuit() {
        const circuit = this.route.snapshot.queryParamMap.get('circuit');
        if (circuit == null) {
            return 'silverstone';
        }
        else {
            return circuit;
        }
    }
    openRace(season, round) {
        this.restService.getRace(season, round).subscribe({
            next: data => {
                const dialogRef = this.dialog.open(RacePopupComponent, {
                    maxWidth: '90vw'
                });
                dialogRef.componentInstance.race = data;
            }
        });
    }
    getAllCircuits() {
        this.restService.getAllCircuits().subscribe({
            next: data => {
                this.allCircuits = data;
            }
        });
    }
}
CircuitComponent.ɵfac = function CircuitComponent_Factory(t) { return new (t || CircuitComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
CircuitComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: CircuitComponent, selectors: [["app-circuit-cmp"]], decls: 21, vars: 4, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "\u201Dmat-content\u201D", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "\u201Dmat-content\u201D"], [1, "col-lg-12", "col-12"], [1, "card", "card-stats"], [1, "div-margin-always-1rem"], ["mat-flat-button", "", 1, "w-100", "active-color-button", 3, "click"], ["target", "_blank", 1, "hidden-link-css", 3, "href"], ["alt", "wikiImage", "class", "float-right pl-2", "mat-card-image", "", 3, "src", 4, "ngIf"], ["target", "_blank", 1, "postLinks", 3, "href"], ["alt", "gmaps", "src", "../../../../assets/img/googleMaps.png", 1, "w-42px"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["scope", "col", 1, "width-50-px", "d-lg-table-cell"], ["scope", "col", 1, "d-lg-table-cell"], ["class", "hover-effects-row", 3, "click", 4, "ngFor", "ngForOf"], ["alt", "wikiImage", "mat-card-image", "", 1, "float-right", "pl-2", 3, "src"], [1, "hover-effects-row", 3, "click"], ["scope", "row", 1, "d-lg-table-cell", "text-right"], [1, "d-lg-table-cell", "text-right"], [1, "d-lg-table-cell", "text-center"], [1, "d-lg-table-cell", "text-left"], [1, "width-60", "d-lg-table-cell", "text-center"], ["alt", "wiki", "src", "../../../../assets/img/Wikipedia-icon.png"]], template: function CircuitComponent_Template(rf, ctx) { if (rf & 1) {
        const _r15 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function CircuitComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function CircuitComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function CircuitComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(11); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function CircuitComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(11); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, CircuitComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function CircuitComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r15); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function CircuitComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r15); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, CircuitComponent_div_20_Template, 40, 8, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.circuit !== undefined);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, icon/* MatIcon */.Hw, MatCardImage], pipes: [common/* DatePipe */.uU], encapsulation: 2 });
class RacePopupComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
}
RacePopupComponent.ɵfac = function RacePopupComponent_Factory(t) { return new (t || RacePopupComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
RacePopupComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: RacePopupComponent, selectors: [["app-race-popup-cmp"]], decls: 2, vars: 1, consts: [[4, "ngIf"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["cdkFocusInitial", "", "colspan", "4"], ["scope", "col"], [4, "ngFor", "ngForOf"], [1, "div-padded-always-0-3rem"], ["target", "_blank", 3, "href"], ["mat-flat-button", "", 1, "active-color-button", "width-100"], [1, "text-right"]], template: function RacePopupComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵtemplate */.YNc(1, RacePopupComponent_div_1_Template, 27, 4, "div", 0);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.race !== undefined);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, common/* NgForOf */.sg, fesm2015_button/* MatButton */.lW], encapsulation: 2 });
class CircuitsPopupComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    sortCircuits(sort) {
        if (sort.direction === 'asc') {
            switch (sort.active) {
                case 'name':
                    this.displayCircuits.sort((a, b) => (a.circuitName.toUpperCase() > b.circuitName.toUpperCase()) ? 1 : -1);
                    break;
                case 'country':
                    this.displayCircuits.sort((a, b) => (a.Location.country > b.Location.country) ? 1 : -1);
                    break;
            }
        }
        if (sort.direction === 'desc') {
            switch (sort.active) {
                case 'name':
                    this.displayCircuits.sort((a, b) => (a.circuitName.toUpperCase() < b.circuitName.toUpperCase()) ? 1 : -1);
                    break;
                case 'country':
                    this.displayCircuits.sort((a, b) => (a.Location.country < b.Location.country) ? 1 : -1);
                    break;
            }
        }
    }
    filterCircuits(event) {
        const filterValue = event.target.value.trim().toLowerCase();
        this.displayCircuits = this.circuits.filter(circuit => (circuit.circuitName).toLowerCase().indexOf(filterValue) > -1);
    }
    selectCircuit(circuitId) {
        this.dialogRef.close(circuitId);
    }
    setCircuits(circuits) {
        this.circuits = circuits;
        this.displayCircuits = circuits;
    }
}
CircuitsPopupComponent.ɵfac = function CircuitsPopupComponent_Factory(t) { return new (t || CircuitsPopupComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
CircuitsPopupComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: CircuitsPopupComponent, selectors: [["app-circuits-popup-cmp"]], decls: 16, vars: 1, consts: [["matInput", "", 3, "keyup"], ["input", ""], ["matSort", "", 1, "table", "table-striped", 3, "matSortChange"], ["cdkFocusInitial", "", 1, "text-center", "bg-primary", "text-white"], ["mat-sort-header", "name", "scope", "col"], ["mat-sort-header", "country", "scope", "col"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"]], template: function CircuitsPopupComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵelementStart */.TgZ(1, "div");
        core/* ɵɵelementStart */.TgZ(2, "mat-form-field");
        core/* ɵɵelementStart */.TgZ(3, "mat-label");
        core/* ɵɵtext */._uU(4, "Filter");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(5, "input", 0, 1);
        core/* ɵɵlistener */.NdJ("keyup", function CircuitsPopupComponent_Template_input_keyup_5_listener($event) { return ctx.filterCircuits($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "table", 2);
        core/* ɵɵlistener */.NdJ("matSortChange", function CircuitsPopupComponent_Template_table_matSortChange_7_listener($event) { return ctx.sortCircuits($event); });
        core/* ɵɵelementStart */.TgZ(8, "thead");
        core/* ɵɵelementStart */.TgZ(9, "tr", 3);
        core/* ɵɵelementStart */.TgZ(10, "th", 4);
        core/* ɵɵtext */._uU(11, "Name");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(12, "th", 5);
        core/* ɵɵtext */._uU(13, "Country");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(14, "tbody");
        core/* ɵɵtemplate */.YNc(15, CircuitsPopupComponent_tr_15_Template, 5, 2, "tr", 6);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(15);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.displayCircuits);
    } }, directives: [MatDialogContent, MatFormField, MatLabel, MatInput, MatSort, MatSortHeader, common/* NgForOf */.sg], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/slide-toggle.js
var slide_toggle = __webpack_require__(5396);
// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/layout.js
var layout = __webpack_require__(5072);
;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tooltip.js
















/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Animations used by MatTooltip.
 * @docs-private
 */








const matTooltipAnimations = {
    /** Animation that transitions a tooltip in and out. */
    tooltipState: (0,animations/* trigger */.X$)('state', [
        (0,animations/* state */.SB)('initial, void, hidden', (0,animations/* style */.oB)({ opacity: 0, transform: 'scale(0)' })),
        (0,animations/* state */.SB)('visible', (0,animations/* style */.oB)({ transform: 'scale(1)' })),
        (0,animations/* transition */.eR)('* => visible', (0,animations/* animate */.jt)('200ms cubic-bezier(0, 0, 0.2, 1)', (0,animations/* keyframes */.F4)([
            (0,animations/* style */.oB)({ opacity: 0, transform: 'scale(0)', offset: 0 }),
            (0,animations/* style */.oB)({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
            (0,animations/* style */.oB)({ opacity: 1, transform: 'scale(1)', offset: 1 })
        ]))),
        (0,animations/* transition */.eR)('* => hidden', (0,animations/* animate */.jt)('100ms cubic-bezier(0, 0, 0.2, 1)', (0,animations/* style */.oB)({ opacity: 0 }))),
    ])
};

/** Time in ms to throttle repositioning after scroll events. */
const SCROLL_THROTTLE_MS = 20;
/**
 * CSS class that will be attached to the overlay panel.
 * @deprecated
 * @breaking-change 13.0.0 remove this variable
 */
const TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';
const PANEL_CLASS = 'tooltip-panel';
/** Options used to bind passive event listeners. */
const passiveListenerOptions = (0,platform/* normalizePassiveListenerOptions */.i$)({ passive: true });
/**
 * Time between the user putting the pointer on a tooltip
 * trigger and the long press event being fired.
 */
const LONGPRESS_DELAY = 500;
/**
 * Creates an error to be thrown if the user supplied an invalid tooltip position.
 * @docs-private
 */
function getMatTooltipInvalidPositionError(position) {
    return Error(`Tooltip position "${position}" is invalid.`);
}
/** Injection token that determines the scroll handling while a tooltip is visible. */
const MAT_TOOLTIP_SCROLL_STRATEGY = new core/* InjectionToken */.OlP('mat-tooltip-scroll-strategy');
/** @docs-private */
function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS });
}
/** @docs-private */
const MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
    provide: MAT_TOOLTIP_SCROLL_STRATEGY,
    deps: [overlay/* Overlay */.aV],
    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,
};
/** Injection token to be used to override the default options for `matTooltip`. */
const MAT_TOOLTIP_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('mat-tooltip-default-options', {
    providedIn: 'root',
    factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
});
/** @docs-private */
function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
    return {
        showDelay: 0,
        hideDelay: 0,
        touchendHideDelay: 1500,
    };
}
class _MatTooltipBase {
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, _document) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._scrollDispatcher = _scrollDispatcher;
        this._viewContainerRef = _viewContainerRef;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._ariaDescriber = _ariaDescriber;
        this._focusMonitor = _focusMonitor;
        this._dir = _dir;
        this._defaultOptions = _defaultOptions;
        this._position = 'below';
        this._disabled = false;
        this._viewInitialized = false;
        this._pointerExitEventsInitialized = false;
        this._viewportMargin = 8;
        this._cssClassPrefix = 'mat';
        /** The default delay in ms before showing the tooltip after show is called */
        this.showDelay = this._defaultOptions.showDelay;
        /** The default delay in ms before hiding the tooltip after hide is called */
        this.hideDelay = this._defaultOptions.hideDelay;
        /**
         * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
         * uses a long press gesture to show and hide, however it can conflict with the native browser
         * gestures. To work around the conflict, Angular Material disables native gestures on the
         * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
         * elements). The different values for this option configure the touch event handling as follows:
         * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
         *   browser gestures on particular elements. In particular, it allows text selection on inputs
         *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
         * - `on` - Enables touch gestures for all elements and disables native
         *   browser gestures with no exceptions.
         * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
         *   showing on touch devices.
         */
        this.touchGestures = 'auto';
        this._message = '';
        /** Manually-bound passive event listeners. */
        this._passiveListeners = [];
        /** Emits when the component is destroyed. */
        this._destroyed = new Subject/* Subject */.xQ();
        /**
         * Handles the keydown events on the host element.
         * Needs to be an arrow function so that we can use it in addEventListener.
         */
        this._handleKeydown = (event) => {
            if (this._isTooltipVisible() && event.keyCode === keycodes/* ESCAPE */.hY && !(0,keycodes/* hasModifierKey */.Vb)(event)) {
                event.preventDefault();
                event.stopPropagation();
                this._ngZone.run(() => this.hide(0));
            }
        };
        this._scrollStrategy = scrollStrategy;
        this._document = _document;
        if (_defaultOptions) {
            if (_defaultOptions.position) {
                this.position = _defaultOptions.position;
            }
            if (_defaultOptions.touchGestures) {
                this.touchGestures = _defaultOptions.touchGestures;
            }
        }
        _dir.change.pipe((0,takeUntil/* takeUntil */.R)(this._destroyed)).subscribe(() => {
            if (this._overlayRef) {
                this._updatePosition(this._overlayRef);
            }
        });
        _ngZone.runOutsideAngular(() => {
            _elementRef.nativeElement.addEventListener('keydown', this._handleKeydown);
        });
    }
    /** Allows the user to define the position of the tooltip relative to the parent element */
    get position() { return this._position; }
    set position(value) {
        var _a;
        if (value !== this._position) {
            this._position = value;
            if (this._overlayRef) {
                this._updatePosition(this._overlayRef);
                (_a = this._tooltipInstance) === null || _a === void 0 ? void 0 : _a.show(0);
                this._overlayRef.updatePosition();
            }
        }
    }
    /** Disables the display of the tooltip. */
    get disabled() { return this._disabled; }
    set disabled(value) {
        this._disabled = (0,coercion/* coerceBooleanProperty */.Ig)(value);
        // If tooltip is disabled, hide immediately.
        if (this._disabled) {
            this.hide(0);
        }
        else {
            this._setupPointerEnterEventsIfNeeded();
        }
    }
    /** The message to be displayed in the tooltip */
    get message() { return this._message; }
    set message(value) {
        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message, 'tooltip');
        // If the message is not a string (e.g. number), convert it to a string and trim it.
        // Must convert with `String(value)`, not `${value}`, otherwise Closure Compiler optimises
        // away the string-conversion: https://github.com/angular/components/issues/20684
        this._message = value != null ? String(value).trim() : '';
        if (!this._message && this._isTooltipVisible()) {
            this.hide(0);
        }
        else {
            this._setupPointerEnterEventsIfNeeded();
            this._updateTooltipMessage();
            this._ngZone.runOutsideAngular(() => {
                // The `AriaDescriber` has some functionality that avoids adding a description if it's the
                // same as the `aria-label` of an element, however we can't know whether the tooltip trigger
                // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the
                // issue by deferring the description by a tick so Angular has time to set the `aria-label`.
                Promise.resolve().then(() => {
                    this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, 'tooltip');
                });
            });
        }
    }
    /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */
    get tooltipClass() { return this._tooltipClass; }
    set tooltipClass(value) {
        this._tooltipClass = value;
        if (this._tooltipInstance) {
            this._setTooltipClass(this._tooltipClass);
        }
    }
    ngAfterViewInit() {
        // This needs to happen after view init so the initial values for all inputs have been set.
        this._viewInitialized = true;
        this._setupPointerEnterEventsIfNeeded();
        this._focusMonitor.monitor(this._elementRef)
            .pipe((0,takeUntil/* takeUntil */.R)(this._destroyed))
            .subscribe(origin => {
            // Note that the focus monitor runs outside the Angular zone.
            if (!origin) {
                this._ngZone.run(() => this.hide(0));
            }
            else if (origin === 'keyboard') {
                this._ngZone.run(() => this.show());
            }
        });
    }
    /**
     * Dispose the tooltip when destroyed.
     */
    ngOnDestroy() {
        const nativeElement = this._elementRef.nativeElement;
        clearTimeout(this._touchstartTimeout);
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._tooltipInstance = null;
        }
        // Clean up the event listeners set in the constructor
        nativeElement.removeEventListener('keydown', this._handleKeydown);
        this._passiveListeners.forEach(([event, listener]) => {
            nativeElement.removeEventListener(event, listener, passiveListenerOptions);
        });
        this._passiveListeners.length = 0;
        this._destroyed.next();
        this._destroyed.complete();
        this._ariaDescriber.removeDescription(nativeElement, this.message, 'tooltip');
        this._focusMonitor.stopMonitoring(nativeElement);
    }
    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
    show(delay = this.showDelay) {
        if (this.disabled || !this.message || (this._isTooltipVisible() &&
            !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId)) {
            return;
        }
        const overlayRef = this._createOverlay();
        this._detach();
        this._portal = this._portal ||
            new portal/* ComponentPortal */.C5(this._tooltipComponent, this._viewContainerRef);
        this._tooltipInstance = overlayRef.attach(this._portal).instance;
        this._tooltipInstance.afterHidden()
            .pipe((0,takeUntil/* takeUntil */.R)(this._destroyed))
            .subscribe(() => this._detach());
        this._setTooltipClass(this._tooltipClass);
        this._updateTooltipMessage();
        this._tooltipInstance.show(delay);
    }
    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
    hide(delay = this.hideDelay) {
        if (this._tooltipInstance) {
            this._tooltipInstance.hide(delay);
        }
    }
    /** Shows/hides the tooltip */
    toggle() {
        this._isTooltipVisible() ? this.hide() : this.show();
    }
    /** Returns true if the tooltip is currently visible to the user */
    _isTooltipVisible() {
        return !!this._tooltipInstance && this._tooltipInstance.isVisible();
    }
    /** Create the overlay config and position strategy */
    _createOverlay() {
        if (this._overlayRef) {
            return this._overlayRef;
        }
        const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this._overlay.position()
            .flexibleConnectedTo(this._elementRef)
            .withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)
            .withFlexibleDimensions(false)
            .withViewportMargin(this._viewportMargin)
            .withScrollableContainers(scrollableAncestors);
        strategy.positionChanges.pipe((0,takeUntil/* takeUntil */.R)(this._destroyed)).subscribe(change => {
            this._updateCurrentPositionClass(change.connectionPair);
            if (this._tooltipInstance) {
                if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {
                    // After position changes occur and the overlay is clipped by
                    // a parent scrollable then close the tooltip.
                    this._ngZone.run(() => this.hide(0));
                }
            }
        });
        this._overlayRef = this._overlay.create({
            direction: this._dir,
            positionStrategy: strategy,
            panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,
            scrollStrategy: this._scrollStrategy()
        });
        this._updatePosition(this._overlayRef);
        this._overlayRef.detachments()
            .pipe((0,takeUntil/* takeUntil */.R)(this._destroyed))
            .subscribe(() => this._detach());
        this._overlayRef.outsidePointerEvents()
            .pipe((0,takeUntil/* takeUntil */.R)(this._destroyed))
            .subscribe(() => { var _a; return (_a = this._tooltipInstance) === null || _a === void 0 ? void 0 : _a._handleBodyInteraction(); });
        return this._overlayRef;
    }
    /** Detaches the currently-attached tooltip. */
    _detach() {
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
        }
        this._tooltipInstance = null;
    }
    /** Updates the position of the current tooltip. */
    _updatePosition(overlayRef) {
        const position = overlayRef.getConfig().positionStrategy;
        const origin = this._getOrigin();
        const overlay = this._getOverlayPosition();
        position.withPositions([
            this._addOffset(Object.assign(Object.assign({}, origin.main), overlay.main)),
            this._addOffset(Object.assign(Object.assign({}, origin.fallback), overlay.fallback))
        ]);
    }
    /** Adds the configured offset to a position. Used as a hook for child classes. */
    _addOffset(position) {
        return position;
    }
    /**
     * Returns the origin position and a fallback position based on the user's position preference.
     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
     */
    _getOrigin() {
        const isLtr = !this._dir || this._dir.value == 'ltr';
        const position = this.position;
        let originPosition;
        if (position == 'above' || position == 'below') {
            originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };
        }
        else if (position == 'before' ||
            (position == 'left' && isLtr) ||
            (position == 'right' && !isLtr)) {
            originPosition = { originX: 'start', originY: 'center' };
        }
        else if (position == 'after' ||
            (position == 'right' && isLtr) ||
            (position == 'left' && !isLtr)) {
            originPosition = { originX: 'end', originY: 'center' };
        }
        else if (typeof ngDevMode === 'undefined' || ngDevMode) {
            throw getMatTooltipInvalidPositionError(position);
        }
        const { x, y } = this._invertPosition(originPosition.originX, originPosition.originY);
        return {
            main: originPosition,
            fallback: { originX: x, originY: y }
        };
    }
    /** Returns the overlay position and a fallback position based on the user's preference */
    _getOverlayPosition() {
        const isLtr = !this._dir || this._dir.value == 'ltr';
        const position = this.position;
        let overlayPosition;
        if (position == 'above') {
            overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
        }
        else if (position == 'below') {
            overlayPosition = { overlayX: 'center', overlayY: 'top' };
        }
        else if (position == 'before' ||
            (position == 'left' && isLtr) ||
            (position == 'right' && !isLtr)) {
            overlayPosition = { overlayX: 'end', overlayY: 'center' };
        }
        else if (position == 'after' ||
            (position == 'right' && isLtr) ||
            (position == 'left' && !isLtr)) {
            overlayPosition = { overlayX: 'start', overlayY: 'center' };
        }
        else if (typeof ngDevMode === 'undefined' || ngDevMode) {
            throw getMatTooltipInvalidPositionError(position);
        }
        const { x, y } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);
        return {
            main: overlayPosition,
            fallback: { overlayX: x, overlayY: y }
        };
    }
    /** Updates the tooltip message and repositions the overlay according to the new message length */
    _updateTooltipMessage() {
        // Must wait for the message to be painted to the tooltip so that the overlay can properly
        // calculate the correct positioning based on the size of the text.
        if (this._tooltipInstance) {
            this._tooltipInstance.message = this.message;
            this._tooltipInstance._markForCheck();
            this._ngZone.onMicrotaskEmpty.pipe((0,take/* take */.q)(1), (0,takeUntil/* takeUntil */.R)(this._destroyed)).subscribe(() => {
                if (this._tooltipInstance) {
                    this._overlayRef.updatePosition();
                }
            });
        }
    }
    /** Updates the tooltip class */
    _setTooltipClass(tooltipClass) {
        if (this._tooltipInstance) {
            this._tooltipInstance.tooltipClass = tooltipClass;
            this._tooltipInstance._markForCheck();
        }
    }
    /** Inverts an overlay position. */
    _invertPosition(x, y) {
        if (this.position === 'above' || this.position === 'below') {
            if (y === 'top') {
                y = 'bottom';
            }
            else if (y === 'bottom') {
                y = 'top';
            }
        }
        else {
            if (x === 'end') {
                x = 'start';
            }
            else if (x === 'start') {
                x = 'end';
            }
        }
        return { x, y };
    }
    /** Updates the class on the overlay panel based on the current position of the tooltip. */
    _updateCurrentPositionClass(connectionPair) {
        const { overlayY, originX, originY } = connectionPair;
        let newPosition;
        // If the overlay is in the middle along the Y axis,
        // it means that it's either before or after.
        if (overlayY === 'center') {
            // Note that since this information is used for styling, we want to
            // resolve `start` and `end` to their real values, otherwise consumers
            // would have to remember to do it themselves on each consumption.
            if (this._dir && this._dir.value === 'rtl') {
                newPosition = originX === 'end' ? 'left' : 'right';
            }
            else {
                newPosition = originX === 'start' ? 'left' : 'right';
            }
        }
        else {
            newPosition = overlayY === 'bottom' && originY === 'top' ? 'above' : 'below';
        }
        if (newPosition !== this._currentPosition) {
            const overlayRef = this._overlayRef;
            if (overlayRef) {
                const classPrefix = `${this._cssClassPrefix}-${PANEL_CLASS}-`;
                overlayRef.removePanelClass(classPrefix + this._currentPosition);
                overlayRef.addPanelClass(classPrefix + newPosition);
            }
            this._currentPosition = newPosition;
        }
    }
    /** Binds the pointer events to the tooltip trigger. */
    _setupPointerEnterEventsIfNeeded() {
        // Optimization: Defer hooking up events if there's no message or the tooltip is disabled.
        if (this._disabled || !this.message || !this._viewInitialized ||
            this._passiveListeners.length) {
            return;
        }
        // The mouse events shouldn't be bound on mobile devices, because they can prevent the
        // first tap from firing its click event or can cause the tooltip to open for clicks.
        if (this._platformSupportsMouseEvents()) {
            this._passiveListeners
                .push(['mouseenter', () => {
                    this._setupPointerExitEventsIfNeeded();
                    this.show();
                }]);
        }
        else if (this.touchGestures !== 'off') {
            this._disableNativeGesturesIfNecessary();
            this._passiveListeners
                .push(['touchstart', () => {
                    // Note that it's important that we don't `preventDefault` here,
                    // because it can prevent click events from firing on the element.
                    this._setupPointerExitEventsIfNeeded();
                    clearTimeout(this._touchstartTimeout);
                    this._touchstartTimeout = setTimeout(() => this.show(), LONGPRESS_DELAY);
                }]);
        }
        this._addListeners(this._passiveListeners);
    }
    _setupPointerExitEventsIfNeeded() {
        if (this._pointerExitEventsInitialized) {
            return;
        }
        this._pointerExitEventsInitialized = true;
        const exitListeners = [];
        if (this._platformSupportsMouseEvents()) {
            exitListeners.push(['mouseleave', () => this.hide()], ['wheel', event => this._wheelListener(event)]);
        }
        else if (this.touchGestures !== 'off') {
            this._disableNativeGesturesIfNecessary();
            const touchendListener = () => {
                clearTimeout(this._touchstartTimeout);
                this.hide(this._defaultOptions.touchendHideDelay);
            };
            exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);
        }
        this._addListeners(exitListeners);
        this._passiveListeners.push(...exitListeners);
    }
    _addListeners(listeners) {
        listeners.forEach(([event, listener]) => {
            this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);
        });
    }
    _platformSupportsMouseEvents() {
        return !this._platform.IOS && !this._platform.ANDROID;
    }
    /** Listener for the `wheel` event on the element. */
    _wheelListener(event) {
        if (this._isTooltipVisible()) {
            const elementUnderPointer = this._document.elementFromPoint(event.clientX, event.clientY);
            const element = this._elementRef.nativeElement;
            // On non-touch devices we depend on the `mouseleave` event to close the tooltip, but it
            // won't fire if the user scrolls away using the wheel without moving their cursor. We
            // work around it by finding the element under the user's cursor and closing the tooltip
            // if it's not the trigger.
            if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {
                this.hide();
            }
        }
    }
    /** Disables the native browser gestures, based on how the tooltip has been configured. */
    _disableNativeGesturesIfNecessary() {
        const gestures = this.touchGestures;
        if (gestures !== 'off') {
            const element = this._elementRef.nativeElement;
            const style = element.style;
            // If gestures are set to `auto`, we don't disable text selection on inputs and
            // textareas, because it prevents the user from typing into them on iOS Safari.
            if (gestures === 'on' || (element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA')) {
                style.userSelect = style.msUserSelect = style.webkitUserSelect =
                    style.MozUserSelect = 'none';
            }
            // If we have `auto` gestures and the element uses native HTML dragging,
            // we don't set `-webkit-user-drag` because it prevents the native behavior.
            if (gestures === 'on' || !element.draggable) {
                style.webkitUserDrag = 'none';
            }
            style.touchAction = 'none';
            style.webkitTapHighlightColor = 'transparent';
        }
    }
}
_MatTooltipBase.ɵfac = function _MatTooltipBase_Factory(t) { return new (t || _MatTooltipBase)(core/* ɵɵdirectiveInject */.Y36(overlay/* Overlay */.aV), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(scrolling/* ScrollDispatcher */.mF), core/* ɵɵdirectiveInject */.Y36(core/* ViewContainerRef */.s_b), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(a11y/* AriaDescriber */.$s), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusMonitor */.tE), core/* ɵɵdirectiveInject */.Y36(undefined), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is), core/* ɵɵdirectiveInject */.Y36(undefined), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0)); };
_MatTooltipBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatTooltipBase, inputs: { showDelay: ["matTooltipShowDelay", "showDelay"], hideDelay: ["matTooltipHideDelay", "hideDelay"], touchGestures: ["matTooltipTouchGestures", "touchGestures"], position: ["matTooltipPosition", "position"], disabled: ["matTooltipDisabled", "disabled"], message: ["matTooltip", "message"], tooltipClass: ["matTooltipClass", "tooltipClass"] } });
_MatTooltipBase.ctorParameters = () => [
    { type: overlay/* Overlay */.aV },
    { type: core/* ElementRef */.SBq },
    { type: scrolling/* ScrollDispatcher */.mF },
    { type: core/* ViewContainerRef */.s_b },
    { type: core/* NgZone */.R0b },
    { type: platform/* Platform */.t4 },
    { type: a11y/* AriaDescriber */.$s },
    { type: a11y/* FocusMonitor */.tE },
    { type: undefined },
    { type: bidi/* Directionality */.Is },
    { type: undefined },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] }
];
_MatTooltipBase.propDecorators = {
    position: [{ type: core/* Input */.IIB, args: ['matTooltipPosition',] }],
    disabled: [{ type: core/* Input */.IIB, args: ['matTooltipDisabled',] }],
    showDelay: [{ type: core/* Input */.IIB, args: ['matTooltipShowDelay',] }],
    hideDelay: [{ type: core/* Input */.IIB, args: ['matTooltipHideDelay',] }],
    touchGestures: [{ type: core/* Input */.IIB, args: ['matTooltipTouchGestures',] }],
    message: [{ type: core/* Input */.IIB, args: ['matTooltip',] }],
    tooltipClass: [{ type: core/* Input */.IIB, args: ['matTooltipClass',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatTooltipBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: overlay/* Overlay */.aV }, { type: core/* ElementRef */.SBq }, { type: scrolling/* ScrollDispatcher */.mF }, { type: core/* ViewContainerRef */.s_b }, { type: core/* NgZone */.R0b }, { type: platform/* Platform */.t4 }, { type: a11y/* AriaDescriber */.$s }, { type: a11y/* FocusMonitor */.tE }, { type: undefined }, { type: bidi/* Directionality */.Is }, { type: undefined }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }]; }, { showDelay: [{
            type: core/* Input */.IIB,
            args: ['matTooltipShowDelay']
        }], hideDelay: [{
            type: core/* Input */.IIB,
            args: ['matTooltipHideDelay']
        }], touchGestures: [{
            type: core/* Input */.IIB,
            args: ['matTooltipTouchGestures']
        }], position: [{
            type: core/* Input */.IIB,
            args: ['matTooltipPosition']
        }], disabled: [{
            type: core/* Input */.IIB,
            args: ['matTooltipDisabled']
        }], message: [{
            type: core/* Input */.IIB,
            args: ['matTooltip']
        }], tooltipClass: [{
            type: core/* Input */.IIB,
            args: ['matTooltipClass']
        }] }); })();
/**
 * Directive that attaches a material design tooltip to the host element. Animates the showing and
 * hiding of a tooltip provided position (defaults to below the element).
 *
 * https://material.io/design/components/tooltips.html
 */
class MatTooltip extends _MatTooltipBase {
    constructor(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document) {
        super(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document);
        this._tooltipComponent = TooltipComponent;
    }
}
MatTooltip.ɵfac = function MatTooltip_Factory(t) { return new (t || MatTooltip)(core/* ɵɵdirectiveInject */.Y36(overlay/* Overlay */.aV), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(scrolling/* ScrollDispatcher */.mF), core/* ɵɵdirectiveInject */.Y36(core/* ViewContainerRef */.s_b), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4), core/* ɵɵdirectiveInject */.Y36(a11y/* AriaDescriber */.$s), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusMonitor */.tE), core/* ɵɵdirectiveInject */.Y36(MAT_TOOLTIP_SCROLL_STRATEGY), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8), core/* ɵɵdirectiveInject */.Y36(MAT_TOOLTIP_DEFAULT_OPTIONS, 8), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0)); };
MatTooltip.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatTooltip, selectors: [["", "matTooltip", ""]], hostAttrs: [1, "mat-tooltip-trigger"], exportAs: ["matTooltip"], features: [core/* ɵɵInheritDefinitionFeature */.qOj] });
MatTooltip.ctorParameters = () => [
    { type: overlay/* Overlay */.aV },
    { type: core/* ElementRef */.SBq },
    { type: scrolling/* ScrollDispatcher */.mF },
    { type: core/* ViewContainerRef */.s_b },
    { type: core/* NgZone */.R0b },
    { type: platform/* Platform */.t4 },
    { type: a11y/* AriaDescriber */.$s },
    { type: a11y/* FocusMonitor */.tE },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatTooltip, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[matTooltip]',
                exportAs: 'matTooltip',
                host: {
                    'class': 'mat-tooltip-trigger'
                }
            }]
    }], function () { return [{ type: overlay/* Overlay */.aV }, { type: core/* ElementRef */.SBq }, { type: scrolling/* ScrollDispatcher */.mF }, { type: core/* ViewContainerRef */.s_b }, { type: core/* NgZone */.R0b }, { type: platform/* Platform */.t4 }, { type: a11y/* AriaDescriber */.$s }, { type: a11y/* FocusMonitor */.tE }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_TOOLTIP_SCROLL_STRATEGY]
            }] }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
            }] }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }]; }, null); })();
class _TooltipComponentBase {
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /** Property watched by the animation framework to show or hide the tooltip */
        this._visibility = 'initial';
        /** Whether interactions on the page should close the tooltip */
        this._closeOnInteraction = false;
        /** Subject for notifying that the tooltip has been hidden from the view */
        this._onHide = new Subject/* Subject */.xQ();
    }
    /**
     * Shows the tooltip with an animation originating from the provided origin
     * @param delay Amount of milliseconds to the delay showing the tooltip.
     */
    show(delay) {
        // Cancel the delayed hide if it is scheduled
        clearTimeout(this._hideTimeoutId);
        // Body interactions should cancel the tooltip if there is a delay in showing.
        this._closeOnInteraction = true;
        this._showTimeoutId = setTimeout(() => {
            this._visibility = 'visible';
            this._showTimeoutId = undefined;
            this._onShow();
            // Mark for check so if any parent component has set the
            // ChangeDetectionStrategy to OnPush it will be checked anyways
            this._markForCheck();
        }, delay);
    }
    /**
     * Begins the animation to hide the tooltip after the provided delay in ms.
     * @param delay Amount of milliseconds to delay showing the tooltip.
     */
    hide(delay) {
        // Cancel the delayed show if it is scheduled
        clearTimeout(this._showTimeoutId);
        this._hideTimeoutId = setTimeout(() => {
            this._visibility = 'hidden';
            this._hideTimeoutId = undefined;
            // Mark for check so if any parent component has set the
            // ChangeDetectionStrategy to OnPush it will be checked anyways
            this._markForCheck();
        }, delay);
    }
    /** Returns an observable that notifies when the tooltip has been hidden from view. */
    afterHidden() {
        return this._onHide;
    }
    /** Whether the tooltip is being displayed. */
    isVisible() {
        return this._visibility === 'visible';
    }
    ngOnDestroy() {
        clearTimeout(this._showTimeoutId);
        clearTimeout(this._hideTimeoutId);
        this._onHide.complete();
    }
    _animationStart() {
        this._closeOnInteraction = false;
    }
    _animationDone(event) {
        const toState = event.toState;
        if (toState === 'hidden' && !this.isVisible()) {
            this._onHide.next();
        }
        if (toState === 'visible' || toState === 'hidden') {
            this._closeOnInteraction = true;
        }
    }
    /**
     * Interactions on the HTML body should close the tooltip immediately as defined in the
     * material design spec.
     * https://material.io/design/components/tooltips.html#behavior
     */
    _handleBodyInteraction() {
        if (this._closeOnInteraction) {
            this.hide(0);
        }
    }
    /**
     * Marks that the tooltip needs to be checked in the next change detection run.
     * Mainly used for rendering the initial text before positioning a tooltip, which
     * can be problematic in components with OnPush change detection.
     */
    _markForCheck() {
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Callback for when the timeout in this.show() gets completed.
     * This method is only needed by the mdc-tooltip, and so it is only implemented
     * in the mdc-tooltip, not here.
     */
    _onShow() { }
}
_TooltipComponentBase.ɵfac = function _TooltipComponentBase_Factory(t) { return new (t || _TooltipComponentBase)(core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO)); };
_TooltipComponentBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _TooltipComponentBase });
_TooltipComponentBase.ctorParameters = () => [
    { type: core/* ChangeDetectorRef */.sBO }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_TooltipComponentBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: core/* ChangeDetectorRef */.sBO }]; }, null); })();
/**
 * Internal component that wraps the tooltip's content.
 * @docs-private
 */
class TooltipComponent extends _TooltipComponentBase {
    constructor(changeDetectorRef, _breakpointObserver) {
        super(changeDetectorRef);
        this._breakpointObserver = _breakpointObserver;
        /** Stream that emits whether the user has a handset-sized display.  */
        this._isHandset = this._breakpointObserver.observe(layout/* Breakpoints.Handset */.u3.Handset);
    }
}
TooltipComponent.ɵfac = function TooltipComponent_Factory(t) { return new (t || TooltipComponent)(core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(layout/* BreakpointObserver */.Yg)); };
TooltipComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: TooltipComponent, selectors: [["mat-tooltip-component"]], hostAttrs: ["aria-hidden", "true"], hostVars: 2, hostBindings: function TooltipComponent_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵstyleProp */.Udp("zoom", ctx._visibility === "visible" ? 1 : null);
    } }, features: [core/* ɵɵInheritDefinitionFeature */.qOj], decls: 3, vars: 7, consts: [[1, "mat-tooltip", 3, "ngClass"]], template: function TooltipComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵlistener */.NdJ("@state.start", function TooltipComponent_Template_div_animation_state_start_0_listener() { return ctx._animationStart(); })("@state.done", function TooltipComponent_Template_div_animation_state_done_0_listener($event) { return ctx._animationDone($event); });
        core/* ɵɵpipe */.ALo(1, "async");
        core/* ɵɵtext */._uU(2);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        let tmp_0_0;
        core/* ɵɵclassProp */.ekj("mat-tooltip-handset", (tmp_0_0 = core/* ɵɵpipeBind1 */.lcZ(1, 5, ctx._isHandset)) == null ? null : tmp_0_0.matches);
        core/* ɵɵproperty */.Q6J("ngClass", ctx.tooltipClass)("@state", ctx._visibility);
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵtextInterpolate */.Oqu(ctx.message);
    } }, directives: [common/* NgClass */.mk], pipes: [common/* AsyncPipe */.Ov], styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"], encapsulation: 2, data: { animation: [matTooltipAnimations.tooltipState] }, changeDetection: 0 });
TooltipComponent.ctorParameters = () => [
    { type: core/* ChangeDetectorRef */.sBO },
    { type: layout/* BreakpointObserver */.Yg }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(TooltipComponent, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-tooltip-component',
                template: "<div class=\"mat-tooltip\"\n     [ngClass]=\"tooltipClass\"\n     [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\"\n     [@state]=\"_visibility\"\n     (@state.start)=\"_animationStart()\"\n     (@state.done)=\"_animationDone($event)\">{{message}}</div>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                animations: [matTooltipAnimations.tooltipState],
                host: {
                    // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                    // won't be rendered if the animations are disabled or there is no web animations polyfill.
                    '[style.zoom]': '_visibility === "visible" ? 1 : null',
                    'aria-hidden': 'true'
                },
                styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"]
            }]
    }], function () { return [{ type: core/* ChangeDetectorRef */.sBO }, { type: layout/* BreakpointObserver */.Yg }]; }, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatTooltipModule {
}
MatTooltipModule.ɵfac = function MatTooltipModule_Factory(t) { return new (t || MatTooltipModule)(); };
MatTooltipModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatTooltipModule });
MatTooltipModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[
            a11y/* A11yModule */.rt,
            common/* CommonModule */.ez,
            overlay/* OverlayModule */.U8,
            fesm2015_core/* MatCommonModule */.BQ,
        ], fesm2015_core/* MatCommonModule */.BQ, scrolling/* CdkScrollableModule */.ZD] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatTooltipModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [
                    a11y/* A11yModule */.rt,
                    common/* CommonModule */.ez,
                    overlay/* OverlayModule */.U8,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                exports: [MatTooltip, TooltipComponent, fesm2015_core/* MatCommonModule */.BQ, scrolling/* CdkScrollableModule */.ZD],
                declarations: [MatTooltip, TooltipComponent],
                entryComponents: [TooltipComponent],
                providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatTooltipModule, { declarations: function () { return [MatTooltip, TooltipComponent]; }, imports: function () { return [a11y/* A11yModule */.rt,
        common/* CommonModule */.ez,
        overlay/* OverlayModule */.U8,
        fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatTooltip, TooltipComponent, fesm2015_core/* MatCommonModule */.BQ, scrolling/* CdkScrollableModule */.ZD]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=tooltip.js.map
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/checkbox.js
var fesm2015_checkbox = __webpack_require__(7539);
;// CONCATENATED MODULE: ./src/app/pages/championship/standings.component.ts



























function StandingsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function StandingsComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function StandingsComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function StandingsComponent_div_20_ng_template_3_tr_18_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr", 32);
    core/* ɵɵelementStart */.TgZ(1, "th", 33);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 34);
    core/* ɵɵelementStart */.TgZ(4, "a", 35);
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 36);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td", 36);
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td", 37);
    core/* ɵɵelementStart */.TgZ(12, "a", 35);
    core/* ɵɵelementStart */.TgZ(13, "div");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td", 38);
    core/* ɵɵtext */._uU(16);
    core/* ɵɵpipe */.ALo(17, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "td");
    core/* ɵɵtext */._uU(19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r14 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", "#/database/drivers?driver=" + standing_r14.id, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r14.name, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.code);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.nationality);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", "#/database/constructors?constructor=" + standing_r14.ergastCode, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r14.car, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(17, 9, standing_r14.points));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.gap);
} }
function StandingsComponent_div_20_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 26);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 27);
    core/* ɵɵelement */._UZ(4, "th", 28);
    core/* ɵɵelementStart */.TgZ(5, "th", 28);
    core/* ɵɵtext */._uU(6, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 29);
    core/* ɵɵtext */._uU(8, "Code");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 29);
    core/* ɵɵtext */._uU(10, "Nationality");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 29);
    core/* ɵɵtext */._uU(12, "Car");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 28);
    core/* ɵɵtext */._uU(14, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 30);
    core/* ɵɵtext */._uU(16, "Gap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "tbody");
    core/* ɵɵtemplate */.YNc(18, StandingsComponent_div_20_ng_template_3_tr_18_Template, 20, 11, "tr", 31);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(18);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r7.standings.driverStandings);
} }
function StandingsComponent_div_20_ng_template_5_div_0_tr_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr", 32);
    core/* ɵɵelementStart */.TgZ(1, "th", 33);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 34);
    core/* ɵɵelementStart */.TgZ(4, "a", 35);
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 38);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵpipe */.ALo(9, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "td");
    core/* ɵɵtext */._uU(11);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r18 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r18.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", "#/database/constructors?constructor=" + standing_r18.id, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r18.name, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(9, 5, standing_r18.points));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(standing_r18.gap);
} }
function StandingsComponent_div_20_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 26);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 27);
    core/* ɵɵelement */._UZ(4, "th", 28);
    core/* ɵɵelementStart */.TgZ(5, "th", 28);
    core/* ɵɵtext */._uU(6, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 28);
    core/* ɵɵtext */._uU(8, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 40);
    core/* ɵɵtext */._uU(10, "Gap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "tbody");
    core/* ɵɵtemplate */.YNc(12, StandingsComponent_div_20_ng_template_5_div_0_tr_12_Template, 12, 7, "tr", 31);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r16 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(12);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r16.standings.constructorStandings);
} }
function StandingsComponent_div_20_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, StandingsComponent_div_20_ng_template_5_div_0_Template, 13, 1, "div", 39);
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.standings !== undefined);
} }
function StandingsComponent_div_20_ng_template_7_div_0_tr_15_div_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 47);
    core/* ɵɵelementStart */.TgZ(1, "div", 48);
    core/* ɵɵelementStart */.TgZ(2, "div", 49);
    core/* ɵɵelement */._UZ(3, "img", 50);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 51);
    core/* ɵɵelementStart */.TgZ(5, "div", 49);
    core/* ɵɵelement */._UZ(6, "img", 52);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 53);
    core/* ɵɵelementStart */.TgZ(8, "div", 49);
    core/* ɵɵelement */._UZ(9, "img", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const i_r23 = core/* ɵɵnextContext */.oxw().index;
    const ctx_r24 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵpropertyInterpolate */.s9C("src", "assets/img/drivers/" + ctx_r24.standings.currentYear + "/" + ctx_r24.podiums[i_r23 + 1][2].name + ".png", core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵpropertyInterpolate */.s9C("src", "assets/img/drivers/" + ctx_r24.standings.currentYear + "/" + ctx_r24.podiums[i_r23 + 1][1].name + ".png", core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵpropertyInterpolate */.s9C("src", "assets/img/drivers/" + ctx_r24.standings.currentYear + "/" + ctx_r24.podiums[i_r23 + 1][3].name + ".png", core/* ɵɵsanitizeUrl */.LSH);
} }
function StandingsComponent_div_20_ng_template_7_div_0_tr_15_Template(rf, ctx) { if (rf & 1) {
    const _r27 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 32);
    core/* ɵɵelementStart */.TgZ(1, "th", 43);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 44);
    core/* ɵɵlistener */.NdJ("click", function StandingsComponent_div_20_ng_template_7_div_0_tr_15_Template_td_click_3_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r27); const race_r22 = restoredCtx.$implicit; const ctx_r26 = core/* ɵɵnextContext */.oxw(4); return ctx_r26.openRace(ctx_r26.standings.currentYear, race_r22.round); });
    core/* ɵɵelementStart */.TgZ(4, "div");
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "td");
    core/* ɵɵtext */._uU(7);
    core/* ɵɵpipe */.ALo(8, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td", 34);
    core/* ɵɵelementStart */.TgZ(10, "a", 35);
    core/* ɵɵelementStart */.TgZ(11, "div");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td", 45);
    core/* ɵɵtemplate */.YNc(14, StandingsComponent_div_20_ng_template_7_div_0_tr_15_div_14_Template, 10, 3, "div", 46);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r22 = ctx.$implicit;
    const i_r23 = ctx.index;
    const ctx_r21 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r22.round);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", race_r22.raceName, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(8, 6, race_r22.date, "MMMM d"));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵpropertyInterpolate */.s9C("href", "#/database/circuit?circuit=" + race_r22.circuitId, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", race_r22.circuitName, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r21.podiums[i_r23 + 1].length > 0);
} }
function StandingsComponent_div_20_ng_template_7_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 26);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 27);
    core/* ɵɵelementStart */.TgZ(4, "th", 41);
    core/* ɵɵtext */._uU(5, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 28);
    core/* ɵɵtext */._uU(7, "Race");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 42);
    core/* ɵɵtext */._uU(9, "Date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "th", 28);
    core/* ɵɵtext */._uU(11, "Circuit");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 28);
    core/* ɵɵtext */._uU(13, "Winner");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "tbody");
    core/* ɵɵtemplate */.YNc(15, StandingsComponent_div_20_ng_template_7_div_0_tr_15_Template, 15, 9, "tr", 31);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r20 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(15);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r20.standings.races);
} }
function StandingsComponent_div_20_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, StandingsComponent_div_20_ng_template_7_div_0_Template, 16, 1, "div", 39);
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.standings !== undefined);
} }
function StandingsComponent_div_20_ng_template_9_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r30 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵelementStart */.TgZ(1, "div", 57);
    core/* ɵɵelementStart */.TgZ(2, "div", 58);
    core/* ɵɵelement */._UZ(3, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 57);
    core/* ɵɵelementStart */.TgZ(5, "div", 58);
    core/* ɵɵelement */._UZ(6, "apx-chart", 60);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 57);
    core/* ɵɵelementStart */.TgZ(8, "div", 58);
    core/* ɵɵelement */._UZ(9, "apx-chart", 61);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 57);
    core/* ɵɵelementStart */.TgZ(11, "div", 58);
    core/* ɵɵelementStart */.TgZ(12, "div", 62);
    core/* ɵɵelementStart */.TgZ(13, "span");
    core/* ɵɵtext */._uU(14, "Exclude DNF results ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "mat-slide-toggle", 63);
    core/* ɵɵlistener */.NdJ("change", function StandingsComponent_div_20_ng_template_9_div_0_Template_mat_slide_toggle_change_15_listener($event) { core/* ɵɵrestoreView */.CHM(_r30); const ctx_r29 = core/* ɵɵnextContext */.oxw(3); return ctx_r29.includeDnf($event); })("ngModelChange", function StandingsComponent_div_20_ng_template_9_div_0_Template_mat_slide_toggle_ngModelChange_15_listener($event) { core/* ɵɵrestoreView */.CHM(_r30); const ctx_r31 = core/* ɵɵnextContext */.oxw(3); return ctx_r31.showDnf = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "span");
    core/* ɵɵtext */._uU(17, " Include DNF results");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(18, "apx-chart", 64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "div", 57);
    core/* ɵɵelementStart */.TgZ(20, "div", 58);
    core/* ɵɵelement */._UZ(21, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r28 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r28.lineChartWithResponsiveWidth)("series", ctx_r28.driverStandingsSeries)("stroke", ctx_r28.defStroke)("title", ctx_r28.titleStandings)("tooltip", ctx_r28.defTooltip)("yaxis", ctx_r28.defYaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r28.driversRoundByRoundOptions.chart)("dataLabels", ctx_r28.driversRoundByRoundOptions.dataLabels)("fill", ctx_r28.driversRoundByRoundOptions.fill)("plotOptions", ctx_r28.driversRoundByRoundOptions.plotOptions)("responsive", ctx_r28.driversRoundByRoundOptions.responsive)("series", ctx_r28.driversRoundByRoundOptions.series)("title", ctx_r28.driversRoundByRoundOptions.title)("xaxis", ctx_r28.driversRoundByRoundOptions.xAxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r28.driversHeatMapChartOptions.chart)("colors", ctx_r28.driversHeatMapChartOptions.colors)("dataLabels", ctx_r28.driversHeatMapChartOptions.dataLabels)("plotOptions", ctx_r28.driversHeatMapChartOptions.plotOptions)("series", ctx_r28.driversHeatMapChartOptions.series)("title", ctx_r28.titleResultsHeatmap)("tooltip", ctx_r28.driversHeatMapChartOptions.tooltip);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r28.showDnf);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r28.scatterChart)("series", ctx_r28.gridToResultSeries)("stroke", ctx_r28.defStroke)("title", ctx_r28.titleResultToGrid)("tooltip", ctx_r28.resultToGridTooltip)("xaxis", ctx_r28.xaxis19)("yaxis", ctx_r28.yAxis19);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r28.lineChartWithoutAnimation)("series", ctx_r28.driverPointsByRoundSeries)("stroke", ctx_r28.defStroke)("title", ctx_r28.titleByRound)("tooltip", ctx_r28.defTooltip)("yaxis", ctx_r28.defYaxis);
} }
function StandingsComponent_div_20_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, StandingsComponent_div_20_ng_template_9_div_0_Template, 22, 35, "div", 55);
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.standings != undefined);
} }
function StandingsComponent_div_20_ng_template_11_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵelementStart */.TgZ(1, "div", 57);
    core/* ɵɵelementStart */.TgZ(2, "div", 58);
    core/* ɵɵelement */._UZ(3, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 57);
    core/* ɵɵelementStart */.TgZ(5, "div", 58);
    core/* ɵɵelement */._UZ(6, "apx-chart", 61);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 57);
    core/* ɵɵelementStart */.TgZ(8, "div", 58);
    core/* ɵɵelement */._UZ(9, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r32 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r32.lineChartWithResponsiveWidth)("series", ctx_r32.constructorStandingsSeries)("stroke", ctx_r32.defStroke)("title", ctx_r32.titleStandings)("tooltip", ctx_r32.defTooltip)("yaxis", ctx_r32.defYaxis);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r32.constructorHeatMapChartOptions.chart)("colors", ctx_r32.constructorHeatMapChartOptions.colors)("dataLabels", ctx_r32.constructorHeatMapChartOptions.dataLabels)("plotOptions", ctx_r32.constructorHeatMapChartOptions.plotOptions)("series", ctx_r32.constructorHeatMapChartOptions.series)("title", ctx_r32.titleByRound)("tooltip", ctx_r32.constructorHeatMapChartOptions.tooltip);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r32.lineChartWithoutAnimation)("series", ctx_r32.constructorRoundsSeries)("stroke", ctx_r32.defStroke)("title", ctx_r32.titleByRound)("tooltip", ctx_r32.defTooltip)("yaxis", ctx_r32.defYaxis);
} }
function StandingsComponent_div_20_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, StandingsComponent_div_20_ng_template_11_div_0_Template, 10, 19, "div", 65);
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r11.standings.constructorStandingByRound != undefined);
} }
function StandingsComponent_div_20_ng_template_13_div_0_mat_option_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 81);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const driver_r37 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", driver_r37);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", driver_r37.name, " ");
} }
function StandingsComponent_div_20_ng_template_13_div_0_mat_option_25_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 81);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const driver_r39 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", driver_r39);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", driver_r39.name, " ");
} }
function StandingsComponent_div_20_ng_template_13_div_0_div_43_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 57);
    core/* ɵɵelementStart */.TgZ(2, "div", 82);
    core/* ɵɵelementStart */.TgZ(3, "span");
    core/* ɵɵtext */._uU(4, "Prediction");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(5, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 58);
    core/* ɵɵelementStart */.TgZ(7, "div", 83);
    core/* ɵɵelementStart */.TgZ(8, "p");
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 84);
    core/* ɵɵelementStart */.TgZ(11, "div", 82);
    core/* ɵɵelementStart */.TgZ(12, "span");
    core/* ɵɵtext */._uU(13, "Current state");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(14, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "div", 58);
    core/* ɵɵelementStart */.TgZ(16, "div", 83);
    core/* ɵɵelementStart */.TgZ(17, "p");
    core/* ɵɵtext */._uU(18);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "p");
    core/* ɵɵtext */._uU(20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(21, "div", 85);
    core/* ɵɵelement */._UZ(22, "apx-chart", 59);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r36 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(9);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r36.calculatorData.resultInfo1);
    core/* ɵɵadvance */.xp6(9);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r36.calculatorData.resultInfo2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r36.calculatorData.resultInfo3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("chart", ctx_r36.lineChartWithResponsiveWidth)("series", ctx_r36.calculatorData.calculatedSeries)("stroke", ctx_r36.defStroke)("title", ctx_r36.predictionChartTitle)("tooltip", ctx_r36.defTooltip)("yaxis", ctx_r36.defYaxis);
} }
function StandingsComponent_div_20_ng_template_13_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r42 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 67);
    core/* ɵɵelementStart */.TgZ(1, "table", 26);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 68);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(6, "th", 69);
    core/* ɵɵelementStart */.TgZ(7, "th", 70);
    core/* ɵɵelementStart */.TgZ(8, "button", 71);
    core/* ɵɵelementStart */.TgZ(9, "mat-icon");
    core/* ɵɵtext */._uU(10, "error_outline");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "tr");
    core/* ɵɵelementStart */.TgZ(12, "th", 72);
    core/* ɵɵtext */._uU(13, "If");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(14, "th", 73);
    core/* ɵɵelementStart */.TgZ(15, "th", 72);
    core/* ɵɵtext */._uU(16, "If");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "tr");
    core/* ɵɵelementStart */.TgZ(18, "th", 74);
    core/* ɵɵelementStart */.TgZ(19, "mat-select", 75);
    core/* ɵɵlistener */.NdJ("valueChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_select_valueChange_19_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r41 = core/* ɵɵnextContext */.oxw(3); return ctx_r41.calculatorData.left.driver = $event; });
    core/* ɵɵtemplate */.YNc(20, StandingsComponent_div_20_ng_template_13_div_0_mat_option_20_Template, 2, 2, "mat-option", 76);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(21, "th", 77);
    core/* ɵɵtext */._uU(22, " and");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(23, "th", 74);
    core/* ɵɵelementStart */.TgZ(24, "mat-select", 75);
    core/* ɵɵlistener */.NdJ("valueChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_select_valueChange_24_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r43 = core/* ɵɵnextContext */.oxw(3); return ctx_r43.calculatorData.right.driver = $event; });
    core/* ɵɵtemplate */.YNc(25, StandingsComponent_div_20_ng_template_13_div_0_mat_option_25_Template, 2, 2, "mat-option", 76);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(26, "tr");
    core/* ɵɵelementStart */.TgZ(27, "td");
    core/* ɵɵtext */._uU(28, " finishes every race P");
    core/* ɵɵelementStart */.TgZ(29, "input", 78);
    core/* ɵɵlistener */.NdJ("ngModelChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_input_ngModelChange_29_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r44 = core/* ɵɵnextContext */.oxw(3); return ctx_r44.calculatorData.left.position = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(30, "mat-checkbox", 63);
    core/* ɵɵlistener */.NdJ("change", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_checkbox_change_30_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r45 = core/* ɵɵnextContext */.oxw(3); return ctx_r45.calculatorCheckbox($event, true); })("ngModelChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_checkbox_ngModelChange_30_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r46 = core/* ɵɵnextContext */.oxw(3); return ctx_r46.calculatorData.left.fastestLap = $event; });
    core/* ɵɵtext */._uU(31, " with fastest lap ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(32, "td");
    core/* ɵɵelementStart */.TgZ(33, "td");
    core/* ɵɵtext */._uU(34, " finishes every race P");
    core/* ɵɵelementStart */.TgZ(35, "input", 78);
    core/* ɵɵlistener */.NdJ("ngModelChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_input_ngModelChange_35_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r47 = core/* ɵɵnextContext */.oxw(3); return ctx_r47.calculatorData.right.position = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(36, "mat-checkbox", 63);
    core/* ɵɵlistener */.NdJ("change", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_checkbox_change_36_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r48 = core/* ɵɵnextContext */.oxw(3); return ctx_r48.calculatorCheckbox($event, false); })("ngModelChange", function StandingsComponent_div_20_ng_template_13_div_0_Template_mat_checkbox_ngModelChange_36_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r49 = core/* ɵɵnextContext */.oxw(3); return ctx_r49.calculatorData.right.fastestLap = $event; });
    core/* ɵɵtext */._uU(37, " with fastest lap ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(38, "tr");
    core/* ɵɵelementStart */.TgZ(39, "td", 79);
    core/* ɵɵelementStart */.TgZ(40, "button", 80);
    core/* ɵɵlistener */.NdJ("click", function StandingsComponent_div_20_ng_template_13_div_0_Template_button_click_40_listener() { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r50 = core/* ɵɵnextContext */.oxw(3); return ctx_r50.executeCalculator(); });
    core/* ɵɵtext */._uU(41, " Calculate ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(42, "tbody");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(43, StandingsComponent_div_20_ng_template_13_div_0_div_43_Template, 23, 9, "div", 39);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r33 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r33.calculatorData.left.header);
    core/* ɵɵadvance */.xp6(14);
    core/* ɵɵproperty */.Q6J("value", ctx_r33.calculatorData.left.driver);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r33.standings.driverStandings);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("value", ctx_r33.calculatorData.right.driver);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r33.standings.driverStandings);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r33.calculatorData.left.position);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r33.calculatorData.left.fastestLap);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r33.calculatorData.right.position);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r33.calculatorData.right.fastestLap);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r33.calculatorData.calculatedSeries != null);
} }
function StandingsComponent_div_20_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, StandingsComponent_div_20_ng_template_13_div_0_Template, 44, 10, "div", 66);
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r12.calculatorData != null && ctx_r12.calculatorData.left != null);
} }
function StandingsComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r52 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 17);
    core/* ɵɵlistener */.NdJ("touchend", function StandingsComponent_div_20_Template_div_touchend_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r52); const ctx_r51 = core/* ɵɵnextContext */.oxw(); return ctx_r51.touchend($event); })("touchstart", function StandingsComponent_div_20_Template_div_touchstart_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r52); const ctx_r53 = core/* ɵɵnextContext */.oxw(); return ctx_r53.touchstart($event); });
    core/* ɵɵelementStart */.TgZ(1, "mat-tab-group", 18);
    core/* ɵɵlistener */.NdJ("selectedTabChange", function StandingsComponent_div_20_Template_mat_tab_group_selectedTabChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r52); const ctx_r54 = core/* ɵɵnextContext */.oxw(); return ctx_r54.tabChanged($event); })("selectedIndexChange", function StandingsComponent_div_20_Template_mat_tab_group_selectedIndexChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r52); const ctx_r55 = core/* ɵɵnextContext */.oxw(); return ctx_r55.selectedTab = $event; });
    core/* ɵɵelementStart */.TgZ(2, "mat-tab", 19);
    core/* ɵɵtemplate */.YNc(3, StandingsComponent_div_20_ng_template_3_Template, 19, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab", 21);
    core/* ɵɵtemplate */.YNc(5, StandingsComponent_div_20_ng_template_5_Template, 1, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "mat-tab", 22);
    core/* ɵɵtemplate */.YNc(7, StandingsComponent_div_20_ng_template_7_Template, 1, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "mat-tab", 23);
    core/* ɵɵtemplate */.YNc(9, StandingsComponent_div_20_ng_template_9_Template, 1, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "mat-tab", 24);
    core/* ɵɵtemplate */.YNc(11, StandingsComponent_div_20_ng_template_11_Template, 1, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "mat-tab", 25);
    core/* ɵɵtemplate */.YNc(13, StandingsComponent_div_20_ng_template_13_Template, 1, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r2.selectedTab);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r2.racesSoFar >= ctx_r2.totalRaces);
} }
class CalculatorData {
}
class CalculatorDataEntry {
}
class StandingsComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.driverStandingsSeries = [];
        this.gridToResultSeries = [];
        this.driverPointsByRoundSeries = [];
        this.constructorStandingsSeries = [];
        this.constructorRoundsSeries = [];
        this.podiums = StandingsComponent.initializeMultidimensionalArray();
        this.raceCount = 0;
        this.selectedTab = 0;
        this.driversHeatMapStandingsSeries = [];
        this.constructorsHeatMapStandingsSeries = [];
        this.driverPositionMap = new Map();
        this.constructorPositionMap = new Map();
        this.calculatorData = {};
        this.chartWidth = '100%';
        this.lineChartWithResponsiveWidth = {
            animations: {
                enabled: true,
                speed: 1000,
                animateGradually: {
                    enabled: false
                },
            },
            height: 500,
            width: this.chartWidth,
            type: 'line',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.lineChartWithoutAnimation = {
            height: 500,
            width: this.chartWidth,
            type: 'line',
            zoom: {
                enabled: false
            },
            animations: {
                enabled: true,
                speed: 1000,
                animateGradually: {
                    enabled: false
                },
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.scatterChart = {
            height: 500,
            type: 'scatter',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.xaxis19 = {
            type: 'numeric',
            tickAmount: 18,
            min: 1,
            max: 19,
            decimalsInFloat: 0,
            title: {
                text: 'Average grid position',
            }
        };
        this.defYaxis = {
            decimalsInFloat: 0
        };
        this.yAxis19 = {
            tickAmount: 18,
            min: 1,
            max: 19,
            decimalsInFloat: 0,
            reversed: true,
            title: {
                text: 'Average result',
            }
        };
        this.titleStandings = {
            text: 'Points through season',
            align: 'center'
        };
        this.predictionChartTitle = {
            text: 'Predicted points through season',
            align: 'center'
        };
        this.titleResultsHeatmap = {
            text: 'Results by race',
            align: 'center'
        };
        this.titleResultToGrid = {
            text: 'Average result and grid position',
            align: 'center'
        };
        this.titleByRound = {
            text: 'Points by race',
            align: 'center'
        };
        this.defStroke = {
            width: 3
        };
        this.defTooltip = {
            shared: false,
        };
        this.resultToGridTooltip = {
            y: {
                formatter: (val, opts) => 'Average race result: ' + val,
                title: {
                    formatter: (seriesName) => seriesName,
                },
            },
            x: {
                formatter: (val, opts) => 'Average grid position: ' + val,
            }
        };
        this.showDnf = false;
        this.restService.getStandings().subscribe({
            next: data => {
                this.standings = data;
                this.utilityService.setTitle(4, this.standings.currentYear + ' Championship');
                this.enrichStandingsGaps();
                this.mapPositions();
                this.setCalculatorData();
                this.standings.driverStandingByRound.forEach((standing) => {
                    this.driverStandingsSeries.push({
                        name: standing.name,
                        data: standing.series,
                        color: standing.color
                    });
                });
                const roundByRound = [];
                const roundByRoundCategories = [];
                const roundByRoundSeriesMap = new Map();
                this.standings.driverPointsByRound.forEach((standing) => {
                    roundByRoundCategories.push(standing.name);
                    let roundCounter = 1;
                    standing.series.forEach((scoreByRound) => {
                        // ako vozač nema unose za ovu (prvu?) rundu
                        do {
                            if (roundCounter < scoreByRound[0]) {
                                if (!roundByRoundSeriesMap.has(roundCounter)) {
                                    roundByRoundSeriesMap.set(roundCounter, []);
                                }
                                roundByRoundSeriesMap.get(roundCounter).push(0);
                                roundCounter++;
                            }
                        } while (roundCounter < scoreByRound[0]);
                        if (!roundByRoundSeriesMap.has(scoreByRound[0])) {
                            roundByRoundSeriesMap.set(scoreByRound[0], []);
                        }
                        if (scoreByRound[1] == null) {
                            scoreByRound[1] = 0;
                        }
                        roundByRoundSeriesMap.get(scoreByRound[0]).push(scoreByRound[1]);
                        roundCounter++;
                    });
                    // delete me?
                    this.driverPointsByRoundSeries.push({
                        name: standing.name,
                        data: standing.series,
                        color: standing.color
                    });
                });
                roundByRoundSeriesMap.forEach((value, name) => roundByRound.push({
                    name: name + '',
                    data: value
                }));
                this.setStackedChart(roundByRound, roundByRoundCategories);
                this.standings.driverResultByRound.forEach((standing) => {
                    this.setPodiums(standing);
                    const copy = JSON.parse(JSON.stringify(standing.series));
                    if (copy.length < this.raceCount) {
                        const array = [];
                        copy.forEach((serie) => {
                            array.push(serie[0]);
                        });
                        for (let i = 1; i <= this.raceCount; i++) {
                            if (array.indexOf(i) < 0) {
                                copy.push([i, null]);
                            }
                        }
                        copy.sort(function (a, b) {
                            if (a[0] < b[0]) {
                                return -1;
                            }
                            if (a[0] > b[0]) {
                                return 1;
                            }
                            return 0;
                        });
                    }
                    copy.forEach((serie) => {
                        if (serie[1] != null && serie[1] != 0) {
                            serie[1] = this.driverCount - serie[1];
                        }
                    });
                    this.driversHeatMapStandingsSeries[this.driverCount - this.driverPositionMap.get(standing.name)] = {
                        name: standing.name,
                        data: copy
                    };
                });
                this.chartWidth = this.calculateChartWidthForMobileDevices(this.raceCount);
                this.standings.gridToResultChartWithoutDnf.forEach((standing) => {
                    this.gridToResultSeries.push({
                        name: standing.name,
                        data: standing.series,
                        color: standing.color
                    });
                });
                this.standings.constructorStandingByRound.forEach((standing) => {
                    this.constructorStandingsSeries.push({
                        name: standing.name,
                        data: standing.series,
                        color: standing.color
                    });
                });
                this.standings.constructorPointsByRound.forEach((standing) => {
                    this.constructorRoundsSeries.push({
                        name: standing.name,
                        data: standing.series,
                        color: standing.color
                    });
                    this.constructorsHeatMapStandingsSeries[this.constructorCount - this.constructorPositionMap.get(standing.name)] = {
                        name: standing.name,
                        data: standing.series,
                    };
                });
                this.setDriversHeatMapChart();
                this.setConstructorHeatMapChart();
                return data;
            }
        });
        this.selectedTab = this.getSelectedTab();
        this.utilityService.setTitle(4, 'Championship');
    }
    static initializeMultidimensionalArray() {
        const podiums = [];
        for (let i = 0; i < 30; i++) {
            podiums[i] = [];
        }
        return podiums;
    }
    touchstart(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        this.swipeCoord = coord;
        this.swipeTime = time;
    }
    touchend(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
        const duration = time - this.swipeTime;
        // if (duration < 1000
        //   && Math.abs(direction[0]) > 30 // Long enough
        //   && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
        //   const swipe = direction[0] < 0 ? 'next' : 'previous';
        //   if(swipe === 'next'){
        //     const isFirst = this.selectedTab === 0;
        //     if(this.selectedTab <= 3){
        //       this.selectedTab = isFirst ? 1 : this.selectedTab + 1;
        //     }
        //   } else if(swipe === 'previous'){
        //     const isLast = this.selectedTab === 4;
        //     if(this.selectedTab >= 1){
        //       this.selectedTab = this.selectedTab - 1;
        //     }
        //   }
        // }
    }
    includeDnf(event) {
        this.gridToResultSeries = [];
        if (event.checked) {
            this.standings.gridToResultChartWithDnf.forEach((standing) => {
                this.gridToResultSeries.push({
                    name: standing.name,
                    data: standing.series,
                    color: standing.color
                });
            });
        }
        else {
            this.standings.gridToResultChartWithoutDnf.forEach((standing) => {
                this.gridToResultSeries.push({
                    name: standing.name,
                    data: standing.series,
                    color: standing.color
                });
            });
        }
    }
    tabChanged(tabChangeEvent) {
        this.updateUrl();
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    openRace(season, round) {
        this.restService.getRace(season, round).subscribe({
            next: data => {
                const dialogRef = this.dialog.open(RacePopupComponent, {
                    maxWidth: '90vw'
                });
                dialogRef.componentInstance.race = data;
            }
        });
    }
    calculatorCheckbox(event, leftOne) {
        if (leftOne) {
            this.calculatorData.right.fastestLap = false;
        }
        else {
            this.calculatorData.left.fastestLap = false;
        }
    }
    setPodiums(standing) {
        standing.series.forEach(item => {
            if (item[1] < 4) {
                const podium = new Podium();
                podium.name = standing.name;
                podium.color = standing.color;
                podium.value = item[1];
                this.podiums[item[0]][item[1]] = podium;
                if (item[0] > this.raceCount) {
                    this.raceCount = item[0];
                }
            }
        });
    }
    setStackedChart(roundByRound, roundByRoundCategories) {
        this.driversRoundByRoundOptions = {
            title: {
                text: 'Round by round',
                align: 'center'
            },
            series: roundByRound,
            chart: {
                type: 'bar',
                height: 500,
                stacked: true,
                zoom: {
                    enabled: true
                },
                toolbar: ChartUtility.defaultToolbar
            },
            responsive: [
                {
                    breakpoint: 480,
                    options: {
                        legend: {
                            position: 'bottom',
                            offsetX: -10,
                            offsetY: 0
                        }
                    }
                }
            ],
            plotOptions: {
                bar: {
                    horizontal: false,
                    columnWidth: '75%'
                }
            },
            xAxis: {
                type: 'category',
                categories: roundByRoundCategories
            },
            legend: {
                position: 'right',
                offsetY: 40
            },
            fill: {
                opacity: 1
            },
            dataLabels: {
                enabled: false
            }
        };
    }
    setDriversHeatMapChart() {
        this.driversHeatMapChartOptions = {
            colors: ['#0000ff'],
            series: this.driversHeatMapStandingsSeries,
            chart: {
                height: 600,
                width: this.chartWidth,
                type: 'heatmap',
                animations: {
                    enabled: false
                },
                zoom: {
                    enabled: false,
                },
                toolbar: ChartUtility.defaultToolbar
            },
            title: ChartUtility.f1exposureTitle,
            dataLabels: {
                enabled: true,
                style: {
                    colors: ['#000000']
                },
                formatter: (val, opts) => {
                    if (val == null) {
                        return '';
                    }
                    if (val == 0) {
                        return 'DNF';
                    }
                    return this.driverCount - val;
                }
            },
            plotOptions: {
                heatmap: {
                    radius: 2,
                    enableShades: true,
                    distributed: false,
                    useFillColorAsStroke: true,
                    reverseNegativeShade: false
                }
            },
            tooltip: {
                y: {
                    formatter: (val, opts) => {
                        return this.standings.races[opts.dataPointIndex].raceName;
                    }
                }
            }
        };
    }
    setConstructorHeatMapChart() {
        this.constructorHeatMapChartOptions = {
            colors: ['#0000ff'],
            series: this.constructorsHeatMapStandingsSeries,
            chart: {
                height: 600,
                width: this.chartWidth,
                type: 'heatmap',
                animations: {
                    enabled: false
                },
                zoom: {
                    enabled: false,
                },
                toolbar: ChartUtility.defaultToolbar
            },
            title: ChartUtility.f1exposureTitle,
            dataLabels: {
                enabled: true,
                style: {
                    colors: ['#000000']
                }
            },
            plotOptions: {
                heatmap: {
                    radius: 2,
                    enableShades: true,
                    distributed: false,
                    useFillColorAsStroke: true,
                    reverseNegativeShade: false
                }
            },
            tooltip: {
                y: {
                    formatter: (val, opts) => {
                        return this.standings.races[opts.dataPointIndex].raceName;
                    }
                }
            }
        };
    }
    mapPositions() {
        for (const standing of this.standings.driverStandings) {
            this.driverPositionMap.set(standing.code, standing.position);
        }
        for (const standing of this.standings.constructorStandings) {
            this.constructorPositionMap.set(standing.name, standing.position);
        }
        this.driverCount = this.driverPositionMap.size;
        this.constructorCount = this.standings.constructorStandings.length;
    }
    getSelectedTab() {
        const tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == null) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    calculateChartWidthForMobileDevices(raceCount) {
        const width = window.screen.width;
        if (width > 1299 || raceCount < 10) {
            return '100%';
        }
        const newWidth = raceCount * 50 + 'px';
        this.lineChartWithResponsiveWidth.width = newWidth;
        this.lineChartWithoutAnimation.width = newWidth;
        return newWidth;
    }
    enrichStandingsGaps() {
        let i;
        for (i = 1; i < this.standings.driverStandings.length; i++) {
            this.standings.driverStandings[i].gap = '+ ' + (this.standings.driverStandings[0].points - this.standings.driverStandings[i].points);
        }
        for (i = 1; i < this.standings.constructorStandings.length; i++) {
            this.standings.constructorStandings[i].gap = '+ ' + (this.standings.constructorStandings[0].points - this.standings.constructorStandings[i].points);
        }
    }
    setCalculatorData() {
        this.calculatorData = {};
        this.calculatorData.left = {};
        this.calculatorData.right = {};
        this.racesSoFar = this.standings.driverStandingByRound[0].series.length;
        this.totalRaces = this.standings.races.length;
        this.calculatorData.left.header = this.racesSoFar + ' races out of ' + this.totalRaces + ' completed.';
        this.calculatorData.right.header = 'Current leader: ' + this.standings.driverStandings[0].name + ' with ' + this.standings.driverStandings[0].points + ' points.';
        this.calculatorData.left.driver = this.standings.driverStandings[0];
        this.calculatorData.right.driver = this.standings.driverStandings[1];
        this.calculatorData.left.position = 2;
        this.calculatorData.right.position = 1;
        this.calculatorData.left.fastestLap = false;
        this.calculatorData.right.fastestLap = false;
    }
    executeCalculator() {
        if (this.calculatorData.left.position == this.calculatorData.right.position) {
            this.calculatorData.right.position++;
        }
        const filtered1 = JSON.parse(JSON.stringify(this.driverStandingsSeries.filter(serie => serie.name == this.calculatorData.left.driver.code)));
        const filtered2 = JSON.parse(JSON.stringify(this.driverStandingsSeries.filter(serie => serie.name == this.calculatorData.right.driver.code)));
        const leftChart = this.calculateDriver(filtered1, this.calculatorData.left);
        const rightChart = this.calculateDriver(filtered2, this.calculatorData.right);
        this.calculateResultString();
        this.calculatorData.calculatedSeries = [];
        this.calculatorData.calculatedSeries.push(...leftChart);
        this.calculatorData.calculatedSeries.push(...rightChart);
    }
    calculateDriver(chartSeries, entry) {
        let gainedPointsPerRace = 0;
        const position = entry.position;
        const fastestLaps = entry.fastestLap;
        const currentPoints = entry.driver.points;
        if (position < 11) {
            gainedPointsPerRace = utility_service/* UtilityService.pointsMap.get */.t.pointsMap.get(position);
            if (fastestLaps) {
                gainedPointsPerRace = gainedPointsPerRace + 1;
            }
        }
        let pointsByRound = currentPoints;
        for (let x = this.racesSoFar + 1; x <= this.totalRaces; x++) {
            pointsByRound = pointsByRound + gainedPointsPerRace;
            const newPush = [x, pointsByRound];
            // @ts-ignore
            chartSeries[0].data.push(newPush);
        }
        entry.predictedPoints = pointsByRound;
        return chartSeries;
    }
    calculateResultString() {
        let result1;
        let result2;
        let result3;
        let firstNameBase;
        let secondNameBase;
        let firstName;
        let secondName;
        let gap;
        let initialGap;
        let averagePointsGain;
        if (this.calculatorData.left.predictedPoints >= this.calculatorData.right.predictedPoints) {
            firstName = this.calculatorData.left.driver.name + ' with ' + this.calculatorData.left.predictedPoints + ' points ';
            secondName = this.calculatorData.right.driver.name + ' with ' + this.calculatorData.right.predictedPoints + ' points, ';
            gap = this.calculatorData.left.predictedPoints - this.calculatorData.right.predictedPoints;
        }
        else {
            secondName = this.calculatorData.left.driver.name + ' with ' + this.calculatorData.left.predictedPoints + ' points, ';
            firstName = this.calculatorData.right.driver.name + ' with ' + this.calculatorData.right.predictedPoints + ' points ';
            gap = this.calculatorData.right.predictedPoints - this.calculatorData.left.predictedPoints;
        }
        result1 = firstName + ' ends season ahead of ' + secondName + 'with a ' + gap + ' points advantage.';
        if (this.calculatorData.left.driver.points >= this.calculatorData.right.driver.points) {
            firstNameBase = this.calculatorData.left.driver.name;
            secondNameBase = this.calculatorData.right.driver.name;
            firstName = firstNameBase + ' at ' + this.calculatorData.left.driver.points + ' points, ';
            secondName = secondNameBase + ' at ' + this.calculatorData.right.driver.points + ' points, ';
            initialGap = this.calculatorData.left.driver.points - this.calculatorData.right.driver.points;
        }
        else {
            firstNameBase = this.calculatorData.right.driver.name;
            secondNameBase = this.calculatorData.left.driver.name;
            firstName = firstNameBase + ' at ' + this.calculatorData.right.driver.points + ' points, ';
            secondName = secondNameBase + ' at ' + this.calculatorData.left.driver.points + ' points, ';
            initialGap = this.calculatorData.right.driver.points - this.calculatorData.left.driver.points;
        }
        averagePointsGain = initialGap / (this.totalRaces - this.racesSoFar);
        result2 = firstName + 'is currently ahead of ' + secondName + ' with a ' + initialGap + ' points advantage.';
        result3 = secondNameBase + ' needs to score atleast ' + averagePointsGain.toFixed(1) + ' points more per race on average, to overtake ' +
            firstNameBase + ' by the end of season.';
        this.calculatorData.resultInfo1 = result1;
        this.calculatorData.resultInfo2 = result2;
        this.calculatorData.resultInfo3 = result3;
    }
}
StandingsComponent.ɵfac = function StandingsComponent_Factory(t) { return new (t || StandingsComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
StandingsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: StandingsComponent, selectors: [["app-standings-cmp"]], viewQuery: function StandingsComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(table/* MatTable */.BZ, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.driverTable = _t.first);
    } }, decls: 21, vars: 4, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "focus", "focusout", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "\u201Dmat-content\u201D", 3, "touchend", "touchstart", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "\u201Dmat-content\u201D", 3, "touchend", "touchstart"], [3, "selectedIndex", "selectedTabChange", "selectedIndexChange"], ["label", "Drivers"], ["matTabContent", ""], ["label", "Constructors"], ["label", "Races"], ["label", "Driver charts"], ["label", "Constructor charts"], ["label", "WDC Calculator", 3, "disabled"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["scope", "col"], ["scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["scope", "col", 1, "width-50-px", "d-sm-none", "d-none", "d-lg-table-cell"], ["class", "hover-effects-row", 4, "ngFor", "ngForOf"], [1, "hover-effects-row"], ["scope", "row"], [1, "cursor-pointer"], [2, "color", "black", 3, "href"], [1, "d-sm-none", "d-none", "d-lg-table-cell", "text-center"], [1, "d-sm-none", "d-none", "d-lg-table-cell", "cursor-pointer"], [1, "text-center"], [4, "ngIf"], [1, "width-50-px", "d-sm-none", "d-none", "d-lg-table-cell"], ["scope", "col", 1, "width-10", "text-left"], ["scope", "col", 1, "text-left"], ["scope", "width-10 row"], [1, "cursor-pointer", 3, "click"], [1, "div-width-300", "no-padding-no-margin-2"], ["class", "event-result", 4, "ngIf"], [1, "event-result"], [1, "display-on-desktop-only", "result-card", "position-1"], [1, "race-card-image-wrapper"], ["alt", "", "mat-card-image", "", "onerror", "this.src='assets/img/drivers/default.png'", 1, "div-height-80", 3, "src"], [1, "result-card", "position-2-on-desktop"], ["alt", "", "mat-card-image", "", "onerror", "this.src='assets/img/drivers/default.png'", 1, "div-height-95px", 3, "src"], [1, "display-on-desktop-only", "result-card", "position-3"], ["alt", "", "mat-card-image", "", "onerror", "this.src='assets/img/drivers/default.png'", 1, "div-height-70", 3, "src"], ["class", " div-padded-2rem", 4, "ngIf"], [1, "div-padded-2rem"], [1, "card", "card-stats", "px-1"], [1, "card-body"], [3, "chart", "series", "stroke", "title", "tooltip", "yaxis"], [3, "chart", "dataLabels", "fill", "plotOptions", "responsive", "series", "title", "xaxis"], [3, "chart", "colors", "dataLabels", "plotOptions", "series", "title", "tooltip"], [1, "px-4", "pt-2"], [3, "ngModel", "change", "ngModelChange"], [3, "chart", "series", "stroke", "title", "tooltip", "xaxis", "yaxis"], ["class", "div-padded-2rem", 4, "ngIf"], ["class", "div-padded-left-2 div-padded-right-2", 4, "ngIf"], [1, "div-padded-left-2", "div-padded-right-2"], ["colspan", "1", "scope", "col", 1, "text-left", "width-40"], ["colspan", "1", "scope", "col", 1, "text-center"], ["colspan", "1", "scope", "col", 1, "text-right", "width-40"], ["aria-label", "Tooltip button", "mat-mini-fab", "", "matTooltip", "Sprint points not included in calculations", 1, "bg-grey"], ["colspan", "1", 1, "text-center", "width-40"], ["colspan", "1", 1, "text-center"], ["colspan", "1", "scope", "col", 1, "custom-mat-select"], ["disableOptionCentering", "", "panelClass", "margin-top-30-px", 3, "value", "valueChange"], [3, "value", 4, "ngFor", "ngForOf"], ["colspan", "1", "scope", "col", 1, "text-center", 2, "width", "35px"], ["max", "20", "min", "1", "required", "", "step", "1", "type", "number", 1, "mx-1", "w-42px", "font-weight-bold", 3, "ngModel", "ngModelChange"], ["colspan", "3", 1, "text-center", "width-40"], ["mat-raised-button", "", 1, "bg-success", "text-white", "width-100", 3, "click"], [3, "value"], [1, "card-header", "font-weight-bold"], [1, "px-3"], [1, "card", "card-stats"], [1, "card"]], template: function StandingsComponent_Template(rf, ctx) { if (rf & 1) {
        const _r56 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function StandingsComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("focus", function StandingsComponent_Template_textarea_focus_7_listener() { return ctx.utilityService.focusFunction(); })("focusout", function StandingsComponent_Template_textarea_focusout_7_listener() { return ctx.utilityService.focusOutFunction(); })("ngModelChange", function StandingsComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function StandingsComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(4); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function StandingsComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(4); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, StandingsComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function StandingsComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r56); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function StandingsComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r56); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, StandingsComponent_div_20_Template, 14, 2, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.standings !== undefined);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, MatCardImage, ng_apexcharts/* ChartComponent */.x, slide_toggle/* MatSlideToggle */.Rr, MatTooltip, icon/* MatIcon */.Hw, MatSelect, fesm2015_forms/* MaxValidator */.Fd, fesm2015_forms/* MinValidator */.qQ, fesm2015_forms/* NumberValueAccessor */.wV, fesm2015_forms/* RequiredValidator */.Q7, fesm2015_checkbox/* MatCheckbox */.oG, fesm2015_core/* MatOption */.ey], pipes: [common/* DecimalPipe */.JJ, common/* DatePipe */.uU], styles: [""] });

;// CONCATENATED MODULE: ./src/app/shared/dialog/simple-input-dialog.component.ts








function SimpleInputDialog_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "mat-form-field");
    core/* ɵɵelementStart */.TgZ(4, "input", 2, 3);
    core/* ɵɵlistener */.NdJ("ngModelChange", function SimpleInputDialog_div_1_Template_input_ngModelChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r3); const ctx_r2 = core/* ɵɵnextContext */.oxw(); return ctx_r2.myInput = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div");
    core/* ɵɵelementStart */.TgZ(7, "button", 4);
    core/* ɵɵlistener */.NdJ("click", function SimpleInputDialog_div_1_Template_button_click_7_listener() { core/* ɵɵrestoreView */.CHM(_r3); const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.executeAction(); });
    core/* ɵɵtext */._uU(8, "Execute ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r0.message, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.myInput);
} }
class SimpleInputDialog {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    executeAction() {
        this.dialogRef.close(this.myInput);
    }
    init(message) {
        this.message = message;
    }
}
SimpleInputDialog.ɵfac = function SimpleInputDialog_Factory(t) { return new (t || SimpleInputDialog)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
SimpleInputDialog.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SimpleInputDialog, selectors: [["simple-input-dialog"]], decls: 2, vars: 1, consts: [["mat-dialog-content", ""], [4, "ngIf"], ["matInput", "", 3, "ngModel", "ngModelChange"], ["input", ""], ["mat-flat-button", "", "color", "primary", 1, "width-100", 3, "click"]], template: function SimpleInputDialog_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵtemplate */.YNc(1, SimpleInputDialog_div_1_Template, 9, 2, "div", 1);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.message != null);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, MatFormField, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(9075);
// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/__ivy_ngcc__/fesm2015/ng-bootstrap.js + 4 modules
var ng_bootstrap = __webpack_require__(9582);
;// CONCATENATED MODULE: ./src/app/pages/videostreams/videostreams.component.ts






















function VideostreamsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 19);
    core/* ɵɵelementStart */.TgZ(2, "div", 20);
    core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.utilityService.replyingTo(comment_r6.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 21);
    core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r9 = core/* ɵɵnextContext */.oxw(); return ctx_r9.utilityService.replyingTo(comment_r6.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 22);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r6 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.comment);
} }
function VideostreamsComponent_ng_template_23_ngb_carousel_1_1_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "iframe", 28);
    core/* ɵɵelementStart */.TgZ(1, "div", 29);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const entity_r13 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", entity_r13.safeUrl, core/* ɵɵsanitizeResourceUrl */.uOi);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(entity_r13.title);
} }
function VideostreamsComponent_ng_template_23_ngb_carousel_1_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, VideostreamsComponent_ng_template_23_ngb_carousel_1_1_ng_template_0_Template, 3, 2, "ng-template", 27);
} }
function VideostreamsComponent_ng_template_23_ngb_carousel_1_Template(rf, ctx) { if (rf & 1) {
    const _r17 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "ngb-carousel", 26);
    core/* ɵɵlistener */.NdJ("slide", function VideostreamsComponent_ng_template_23_ngb_carousel_1_Template_ngb_carousel_slide_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r17); const ctx_r16 = core/* ɵɵnextContext */.oxw(2); return ctx_r16.onSlide($event); });
    core/* ɵɵtemplate */.YNc(1, VideostreamsComponent_ng_template_23_ngb_carousel_1_1_Template, 1, 0, undefined, 8);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r10.videos);
} }
function VideostreamsComponent_ng_template_23_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 30);
} }
function VideostreamsComponent_ng_template_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 23);
    core/* ɵɵtemplate */.YNc(1, VideostreamsComponent_ng_template_23_ngb_carousel_1_Template, 2, 1, "ngb-carousel", 24);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(2, VideostreamsComponent_ng_template_23_div_2_Template, 1, 0, "div", 25);
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.videos);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.activeVideo > -1 && ctx_r2.videos[ctx_r2.activeVideo].status == 4);
} }
function VideostreamsComponent_ng_template_25_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r21 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 12);
    core/* ɵɵelementStart */.TgZ(1, "div", 33);
    core/* ɵɵelementStart */.TgZ(2, "mat-slide-toggle", 34);
    core/* ɵɵlistener */.NdJ("change", function VideostreamsComponent_ng_template_25_div_0_Template_mat_slide_toggle_change_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r21); const ctx_r20 = core/* ɵɵnextContext */.oxw(2); return ctx_r20.saveChoiceToLocalStorage($event); })("ngModelChange", function VideostreamsComponent_ng_template_25_div_0_Template_mat_slide_toggle_ngModelChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r21); const ctx_r22 = core/* ɵɵnextContext */.oxw(2); return ctx_r22.twitchStreamOpened = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r18 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r18.twitchStreamOpened);
} }
function VideostreamsComponent_ng_template_25_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r24 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "button", 7);
    core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_ng_template_25_div_1_Template_button_click_1_listener() { core/* ɵɵrestoreView */.CHM(_r24); const ctx_r23 = core/* ɵɵnextContext */.oxw(2); return ctx_r23.updateStreamer(); });
    core/* ɵɵtext */._uU(2, "Change featured stream ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "mat-slide-toggle", 34);
    core/* ɵɵlistener */.NdJ("change", function VideostreamsComponent_ng_template_25_div_1_Template_mat_slide_toggle_change_3_listener($event) { core/* ɵɵrestoreView */.CHM(_r24); const ctx_r25 = core/* ɵɵnextContext */.oxw(2); return ctx_r25.saveChoiceToLocalStorage($event); })("ngModelChange", function VideostreamsComponent_ng_template_25_div_1_Template_mat_slide_toggle_ngModelChange_3_listener($event) { core/* ɵɵrestoreView */.CHM(_r24); const ctx_r26 = core/* ɵɵnextContext */.oxw(2); return ctx_r26.twitchStreamOpened = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 35);
    core/* ɵɵelement */._UZ(5, "iframe", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r19 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r19.twitchStreamOpened);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r19.twitchUrl, core/* ɵɵsanitizeResourceUrl */.uOi);
} }
function VideostreamsComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, VideostreamsComponent_ng_template_25_div_0_Template, 3, 1, "div", 31);
    core/* ɵɵtemplate */.YNc(1, VideostreamsComponent_ng_template_25_div_1_Template, 6, 2, "div", 32);
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r3.twitchStreamOpened);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.streamer != null && ctx_r3.twitchStreamOpened);
} }
function VideostreamsComponent_ng_template_27_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r30 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 12);
    core/* ɵɵelementStart */.TgZ(1, "div", 33);
    core/* ɵɵelementStart */.TgZ(2, "mat-slide-toggle", 34);
    core/* ɵɵlistener */.NdJ("change", function VideostreamsComponent_ng_template_27_div_0_Template_mat_slide_toggle_change_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r30); const ctx_r29 = core/* ɵɵnextContext */.oxw(2); return ctx_r29.saveChoiceToLocalStorage($event); })("ngModelChange", function VideostreamsComponent_ng_template_27_div_0_Template_mat_slide_toggle_ngModelChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r30); const ctx_r31 = core/* ɵɵnextContext */.oxw(2); return ctx_r31.twitchStreamOpened = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r27 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r27.twitchStreamOpened);
} }
function VideostreamsComponent_ng_template_27_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r33 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "mat-slide-toggle", 34);
    core/* ɵɵlistener */.NdJ("change", function VideostreamsComponent_ng_template_27_div_1_Template_mat_slide_toggle_change_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r33); const ctx_r32 = core/* ɵɵnextContext */.oxw(2); return ctx_r32.saveChoiceToLocalStorage($event); })("ngModelChange", function VideostreamsComponent_ng_template_27_div_1_Template_mat_slide_toggle_ngModelChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r33); const ctx_r34 = core/* ɵɵnextContext */.oxw(2); return ctx_r34.twitchStreamOpened = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(2, "div", 35);
    core/* ɵɵelement */._UZ(3, "iframe", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r28 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r28.twitchStreamOpened);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r28.angelThumpUrl, core/* ɵɵsanitizeResourceUrl */.uOi);
} }
function VideostreamsComponent_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, VideostreamsComponent_ng_template_27_div_0_Template, 3, 1, "div", 31);
    core/* ɵɵtemplate */.YNc(1, VideostreamsComponent_ng_template_27_div_1_Template, 4, 2, "div", 32);
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r4.twitchStreamOpened);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r4.angelThumpUrl != null && ctx_r4.twitchStreamOpened);
} }
function VideostreamsComponent_ng_template_29_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 37);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelement */._UZ(4, "th");
    core/* ɵɵelementStart */.TgZ(5, "th", 38);
    core/* ɵɵtext */._uU(6, "F1Exposure does not stream races. Try these sites:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "tbody");
    core/* ɵɵelementStart */.TgZ(8, "tr", 39);
    core/* ɵɵelement */._UZ(9, "td");
    core/* ɵɵelementStart */.TgZ(10, "td");
    core/* ɵɵelementStart */.TgZ(11, "a", 40);
    core/* ɵɵelementStart */.TgZ(12, "div");
    core/* ɵɵtext */._uU(13, "TWITCH.TV/mda2mjzy9y3lw ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "tr", 39);
    core/* ɵɵelement */._UZ(15, "td");
    core/* ɵɵelementStart */.TgZ(16, "td");
    core/* ɵɵelementStart */.TgZ(17, "a", 41);
    core/* ɵɵelementStart */.TgZ(18, "div");
    core/* ɵɵtext */._uU(19, "SPORTSURGE.CLUB ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "tr", 39);
    core/* ɵɵelement */._UZ(21, "td");
    core/* ɵɵelementStart */.TgZ(22, "td");
    core/* ɵɵelementStart */.TgZ(23, "a", 42);
    core/* ɵɵelementStart */.TgZ(24, "div");
    core/* ɵɵtext */._uU(25, "OVERTAKEFANS.COM ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
class VideostreamsComponent {
    constructor(restService, utilityService, dialog, router, route, sanitizer, config) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.dialog = dialog;
        this.router = router;
        this.route = route;
        this.sanitizer = sanitizer;
        this.selectedTab = 0;
        this.twitchStreamOpened = false;
        config.interval = 0;
        config.wrap = true;
        config.keyboard = true;
        config.showNavigationIndicators = false;
        this.selectedTab = this.getSelectedTab();
        this.utilityService.setTitle(9, 'Videostreams');
        this.getVideos();
        this.getTwitchStream();
        this.twitchStreamOpened = localStorage.getItem('f1-play-twitch') === 'true';
        this.angelThumpUrl = this.sanitizer.bypassSecurityTrustResourceUrl('https://player.angelthump.com/?channel=spf1general');
    }
    getVideos() {
        this.restService.getVideos().subscribe({
            next: data => {
                const tempVideos = data;
                tempVideos.forEach(video => {
                    if (video.url.includes('youtube')) {
                        this.utilityService.setReferrerToOrigin();
                    }
                    video.safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(video.url);
                });
                this.videos = tempVideos;
                if (this.selectedTab === 0) {
                    this.activeVideo = 0;
                }
                return data;
            }
        });
    }
    getTwitchStream() {
        this.restService.getStreamer().subscribe({
            next: data => {
                const streamerName = data;
                const url = 'https://player.twitch.tv/?channel=' + streamerName.message + '&parent=' + environment/* environment.frontUrl */.N.frontUrl;
                this.twitchUrl = this.sanitizer.bypassSecurityTrustResourceUrl(url);
                this.streamer = streamerName.message;
                return data;
            }
        });
    }
    tabChanged(tabChangeEvent) {
        if (this.selectedTab == 0) {
            this.activeVideo = 0;
        }
        else {
            this.activeVideo = -1;
        }
        this.updateUrl();
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    getSelectedTab() {
        const tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == null) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    updateStreamer() {
        const dialogRef = this.dialog.open(SimpleInputDialog);
        dialogRef.componentInstance.init('Enter Twitch stream');
        dialogRef.afterClosed().subscribe(newStreamer => {
            if (newStreamer != null) {
                this.restService.updateStreamer(newStreamer).subscribe({
                    next: data => {
                        if (data === true) {
                            const url = 'https://player.twitch.tv/?channel=' + newStreamer + '&parent=' + environment/* environment.frontUrl */.N.frontUrl;
                            this.twitchUrl = this.sanitizer.bypassSecurityTrustResourceUrl(url);
                            this.streamer = newStreamer;
                        }
                        else {
                            this.utilityService.pushToastrMessage('Stream not found');
                        }
                        return data;
                    }
                });
            }
        });
    }
    ;
    saveChoiceToLocalStorage(event) {
        localStorage.setItem('f1-play-twitch', String(event.checked));
    }
    onSlide(event) {
        if (event.direction === 'left') {
            this.activeVideo++;
        }
        else if (event.direction === 'right') {
            this.activeVideo--;
        }
        if (this.activeVideo >= this.videos.length) {
            this.activeVideo = 0;
        }
        if (this.activeVideo < 0) {
            this.activeVideo = this.videos.length - 1;
        }
    }
}
VideostreamsComponent.ɵfac = function VideostreamsComponent_Factory(t) { return new (t || VideostreamsComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(MatDialog), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7), core/* ɵɵdirectiveInject */.Y36(ng_bootstrap/* NgbCarouselConfig */.Lu)); };
VideostreamsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: VideostreamsComponent, selectors: [["app-videostreams-cmp"]], decls: 30, vars: 4, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [1, "height-fill-screen"], [3, "selectedIndex", "selectedIndexChange", "selectedTabChange"], ["label", "Videos"], ["matTabContent", ""], ["label", "Twitch"], ["label", "Angelthump"], ["label", "Free livestreams"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "bg-black", "videos-carousel"], [3, "slide", 4, "ngIf"], ["class", "chika-div overlay-bottom-div-fixed overlay-animation-1", 4, "ngIf"], [3, "slide"], ["ngbSlide", ""], ["id", "videostream_frame", "frameborder", "0", "scrolling", "no", "allowfullscreen", "", 1, "custom-iframe-fullscreen", 3, "src"], [1, "black-footer", "text-center"], [1, "chika-div", "overlay-bottom-div-fixed", "overlay-animation-1"], ["class", "height-fill-screen", 4, "ngIf"], [4, "ngIf"], [1, "center-and-zoom"], [3, "ngModel", "change", "ngModelChange"], [1, "text-center"], ["frameborder", "0", "scrolling", "no", "width", "None", "height", "None", "allowfullscreen", "", 1, "custom-iframe-fullscreen", 3, "src"], [1, "table", "table-striped"], ["scope", "col", 2, "text-align", "center"], [1, "hover-effects-bold-row"], ["href", "https://www.twitch.tv/mda2mjzy9y3lw", "target", "_blank", 2, "color", "black"], ["href", "https://sportsurge.club/f1streams", "target", "_blank", 2, "color", "black"], ["href", "https://overtakefans.com/", "target", "_blank", 2, "color", "black"]], template: function VideostreamsComponent_Template(rf, ctx) { if (rf & 1) {
        const _r35 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function VideostreamsComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function VideostreamsComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(5); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(5); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, VideostreamsComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r35); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function VideostreamsComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r35); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(20, "div", 12);
        core/* ɵɵelementStart */.TgZ(21, "mat-tab-group", 13);
        core/* ɵɵlistener */.NdJ("selectedIndexChange", function VideostreamsComponent_Template_mat_tab_group_selectedIndexChange_21_listener($event) { return ctx.selectedTab = $event; })("selectedTabChange", function VideostreamsComponent_Template_mat_tab_group_selectedTabChange_21_listener($event) { return ctx.tabChanged($event); });
        core/* ɵɵelementStart */.TgZ(22, "mat-tab", 14);
        core/* ɵɵtemplate */.YNc(23, VideostreamsComponent_ng_template_23_Template, 3, 2, "ng-template", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(24, "mat-tab", 16);
        core/* ɵɵtemplate */.YNc(25, VideostreamsComponent_ng_template_25_Template, 2, 2, "ng-template", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(26, "mat-tab", 17);
        core/* ɵɵtemplate */.YNc(27, VideostreamsComponent_ng_template_27_Template, 2, 2, "ng-template", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(28, "mat-tab", 18);
        core/* ɵɵtemplate */.YNc(29, VideostreamsComponent_ng_template_29_Template, 26, 0, "ng-template", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(8);
        core/* ɵɵproperty */.Q6J("selectedIndex", ctx.selectedTab);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, common/* NgIf */.O5, ng_bootstrap/* NgbCarousel */.uo, ng_bootstrap/* NgbSlide */.xl, slide_toggle/* MatSlideToggle */.Rr], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/upcoming-race-analysis/upcoming-race-analysis.component.ts






















const upcoming_race_analysis_component_c0 = ["chart"];
function UpcomingRaceAnalysisComponent_div_0_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r7 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r7); const comment_r5 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(2); return ctx_r6.utilityService.replyingTo(comment_r5.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r7); const comment_r5 = restoredCtx.$implicit; const ctx_r8 = core/* ɵɵnextContext */.oxw(2); return ctx_r8.utilityService.replyingTo(comment_r5.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r5 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r5.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r5.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r5.comment);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_3_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵelementStart */.TgZ(2, "div", 28);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 29);
    core/* ɵɵelementStart */.TgZ(5, "a", 30);
    core/* ɵɵelement */._UZ(6, "img", 31);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r18 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r18.upcomingRaceAnalysis.circuitName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", ctx_r18.upcomingRaceAnalysis.circuitUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵpropertyInterpolate */.s9C("src", ctx_r18.upcomingRaceAnalysis.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_3_div_0_Template, 7, 3, "div", 0);
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.upcomingRaceAnalysis != null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_div_1_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r24 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r24.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r24.driver);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r24.constructorName);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r27 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 36);
    core/* ɵɵelementStart */.TgZ(1, "div", 37);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_div_1_Template_div_click_1_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r27); const race_r22 = restoredCtx.$implicit; const ctx_r26 = core/* ɵɵnextContext */.oxw(5); return ctx_r26.openRace(race_r22.season, race_r22.round); });
    core/* ɵɵelementStart */.TgZ(2, "div", 38);
    core/* ɵɵelementStart */.TgZ(3, "table", 39);
    core/* ɵɵelementStart */.TgZ(4, "thead");
    core/* ɵɵelementStart */.TgZ(5, "tr");
    core/* ɵɵelementStart */.TgZ(6, "th", 40);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th");
    core/* ɵɵtext */._uU(9);
    core/* ɵɵpipe */.ALo(10, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "tr");
    core/* ɵɵelementStart */.TgZ(12, "th", 41);
    core/* ɵɵtext */._uU(13, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th");
    core/* ɵɵtext */._uU(15, "Driver");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th");
    core/* ɵɵtext */._uU(17, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_div_1_tr_19_Template, 7, 3, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r22 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate2 */.AsE("", race_r22.season, " - round ", race_r22.round, "");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(10, 4, race_r22.date));
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", race_r22.basicResultList);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 34);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_div_1_Template, 20, 6, "div", 35);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r19 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r19.upcomingRaceAnalysis.basicRaces);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 43);
    core/* ɵɵelementStart */.TgZ(1, "div", 44);
    core/* ɵɵelementStart */.TgZ(2, "div", 38);
    core/* ɵɵtext */._uU(3, " No F1 races on ");
    core/* ɵɵelementStart */.TgZ(4, "a", 45);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(6, " in the last 10 years. ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r20 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵpropertyInterpolate */.s9C("href", ctx_r20.upcomingRaceAnalysis.circuitUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r20.upcomingRaceAnalysis.circuitName);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_0_Template, 2, 1, "div", 32);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_div_1_Template, 7, 2, "div", 33);
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.upcomingRaceAnalysis.basicRaces.length > 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.upcomingRaceAnalysis.basicRaces.length == 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_tr_23_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r36 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_tr_23_button_16_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r36); const standing_r31 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r34 = core/* ɵɵnextContext */.oxw(5); return ctx_r34.openRadioDialog(standing_r31.radioData, ctx_r34.upcomingRaceAnalysis.fp1LivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_tr_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td", 56);
    core/* ɵɵtemplate */.YNc(16, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_tr_23_button_16_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r31 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.timingDataF1.BestLapTime.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.timingDataF1.TimeDiffToFastest);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.timingDataF1.TimeDiffToPositionAhead);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r31.timingDataF1.NumberOfLaps);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r31.radioData.length > 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r38 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r38); const ctx_r37 = core/* ɵɵnextContext */.oxw(4); return ctx_r37.sortMainResultData($event, 1); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 53);
    core/* ɵɵtext */._uU(5, "Fastest lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 54);
    core/* ɵɵtext */._uU(16, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 54);
    core/* ɵɵtext */._uU(18, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "th", 54);
    core/* ɵɵtext */._uU(20, "Lap count");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(21, "th", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "tbody");
    core/* ɵɵtemplate */.YNc(23, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_tr_23_Template, 17, 8, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r28 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(23);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r28.upcomingRaceAnalysis.fp1);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r39 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r39.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r39.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r39.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r39.lapNumber);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r42 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_div_0_Template, 24, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 46);
    core/* ɵɵelementStart */.TgZ(2, "div", 47);
    core/* ɵɵelementStart */.TgZ(3, "div", 38);
    core/* ɵɵelementStart */.TgZ(4, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_Template_table_matSortChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r42); const ctx_r41 = core/* ɵɵnextContext */.oxw(3); return ctx_r41.sortResultData($event, 1); });
    core/* ɵɵelementStart */.TgZ(5, "thead");
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 49);
    core/* ɵɵtext */._uU(8, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tr");
    core/* ɵɵelementStart */.TgZ(10, "th", 50);
    core/* ɵɵtext */._uU(11, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 51);
    core/* ɵɵtext */._uU(13, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 52);
    core/* ɵɵtext */._uU(17, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_tr_19_Template, 9, 4, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r11.upcomingRaceAnalysis.fp1 !== null);
    core/* ɵɵadvance */.xp6(19);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r11.upcomingRaceAnalysis.fp1Laps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_tr_23_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r52 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_tr_23_button_16_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r52); const standing_r47 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r50 = core/* ɵɵnextContext */.oxw(6); return ctx_r50.openRadioDialog(standing_r47.radioData, ctx_r50.upcomingRaceAnalysis.fp2LivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_tr_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td", 56);
    core/* ɵɵtemplate */.YNc(16, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_tr_23_button_16_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r47 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.timingDataF1.BestLapTime.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.timingDataF1.TimeDiffToFastest);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.timingDataF1.TimeDiffToPositionAhead);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r47.timingDataF1.NumberOfLaps);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r47.radioData.length > 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r54 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r54); const ctx_r53 = core/* ɵɵnextContext */.oxw(5); return ctx_r53.sortMainResultData($event, 2); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 53);
    core/* ɵɵtext */._uU(5, "Fastest lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 54);
    core/* ɵɵtext */._uU(16, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 54);
    core/* ɵɵtext */._uU(18, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "th", 54);
    core/* ɵɵtext */._uU(20, "Lap count");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(21, "th", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "tbody");
    core/* ɵɵtemplate */.YNc(23, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_tr_23_Template, 17, 8, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r44 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(23);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r44.upcomingRaceAnalysis.fp2);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r55 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r55.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r55.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r55.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r55.lapNumber);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r58 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_div_0_Template, 24, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 46);
    core/* ɵɵelementStart */.TgZ(2, "div", 47);
    core/* ɵɵelementStart */.TgZ(3, "div", 38);
    core/* ɵɵelementStart */.TgZ(4, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_Template_table_matSortChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r58); const ctx_r57 = core/* ɵɵnextContext */.oxw(4); return ctx_r57.sortResultData($event, 2); });
    core/* ɵɵelementStart */.TgZ(5, "thead");
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 49);
    core/* ɵɵtext */._uU(8, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tr");
    core/* ɵɵelementStart */.TgZ(10, "th", 50);
    core/* ɵɵtext */._uU(11, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 51);
    core/* ɵɵtext */._uU(13, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 52);
    core/* ɵɵtext */._uU(17, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_tr_19_Template, 9, 4, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r43 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r43.upcomingRaceAnalysis.fp2 !== null);
    core/* ɵɵadvance */.xp6(19);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r43.upcomingRaceAnalysis.fp2Laps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 59);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_ng_template_1_Template, 20, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r12.upcomingRaceAnalysis.fp2 == null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_tr_23_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r68 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_tr_23_button_16_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r68); const standing_r63 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r66 = core/* ɵɵnextContext */.oxw(6); return ctx_r66.openRadioDialog(standing_r63.radioData, ctx_r66.upcomingRaceAnalysis.fp3LivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_tr_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td", 56);
    core/* ɵɵtemplate */.YNc(16, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_tr_23_button_16_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r63 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.timingDataF1.BestLapTime.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.timingDataF1.TimeDiffToFastest);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.timingDataF1.TimeDiffToPositionAhead);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r63.timingDataF1.NumberOfLaps);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r63.radioData.length > 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r70 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r70); const ctx_r69 = core/* ɵɵnextContext */.oxw(5); return ctx_r69.sortMainResultData($event, 3); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 53);
    core/* ɵɵtext */._uU(5, "Fastest lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 54);
    core/* ɵɵtext */._uU(16, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 54);
    core/* ɵɵtext */._uU(18, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "th", 54);
    core/* ɵɵtext */._uU(20, "Lap count");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(21, "th", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "tbody");
    core/* ɵɵtemplate */.YNc(23, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_tr_23_Template, 17, 8, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r60 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(23);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r60.upcomingRaceAnalysis.fp3);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r71 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r71.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r71.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r71.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r71.lapNumber);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r74 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_div_0_Template, 24, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 46);
    core/* ɵɵelementStart */.TgZ(2, "div", 47);
    core/* ɵɵelementStart */.TgZ(3, "div", 38);
    core/* ɵɵelementStart */.TgZ(4, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_Template_table_matSortChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r74); const ctx_r73 = core/* ɵɵnextContext */.oxw(4); return ctx_r73.sortResultData($event, 3); });
    core/* ɵɵelementStart */.TgZ(5, "thead");
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 49);
    core/* ɵɵtext */._uU(8, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tr");
    core/* ɵɵelementStart */.TgZ(10, "th", 50);
    core/* ɵɵtext */._uU(11, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 51);
    core/* ɵɵtext */._uU(13, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 52);
    core/* ɵɵtext */._uU(17, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_tr_19_Template, 9, 4, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r59 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r59.upcomingRaceAnalysis.fp3 !== null);
    core/* ɵɵadvance */.xp6(19);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r59.upcomingRaceAnalysis.fp3Laps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 60);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_ng_template_1_Template, 20, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r13.upcomingRaceAnalysis.fp3 == null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span", 61);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r88 = core/* ɵɵnextContext */.oxw();
    const i_r85 = ctx_r88.index;
    const lap_r84 = ctx_r88.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu("Q" + (i_r85 + 1) + ": ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", lap_r84.Value, " ");
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2, "-");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_div_1_Template, 4, 2, "div", 0);
    core/* ɵɵtemplate */.YNc(2, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_div_2_Template, 3, 0, "div", 0);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r84 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", lap_r84.Value != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", lap_r84.Value == null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r89 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r89.TimeDiffToFastest);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2, "-");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_div_1_Template, 3, 1, "div", 0);
    core/* ɵɵtemplate */.YNc(2, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_div_2_Template, 3, 0, "div", 0);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r89 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", stat_r89.TimeDiffToFastest != "");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", stat_r89.TimeDiffToFastest == "");
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r93 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r93.TimeDifftoPositionAhead);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2, "-");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_div_1_Template, 3, 1, "div", 0);
    core/* ɵɵtemplate */.YNc(2, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_div_2_Template, 3, 0, "div", 0);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r93 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", stat_r93.TimeDifftoPositionAhead != "");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", stat_r93.TimeDifftoPositionAhead == "");
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_button_18_Template(rf, ctx) { if (rf & 1) {
    const _r99 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_button_18_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r99); const standing_r78 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r97 = core/* ɵɵnextContext */.oxw(5); return ctx_r97.openRadioDialog(standing_r78.radioData, ctx_r97.upcomingRaceAnalysis.qualiLivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtemplate */.YNc(8, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_8_Template, 3, 2, "div", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵtemplate */.YNc(11, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_11_Template, 3, 2, "div", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "td");
    core/* ɵɵtext */._uU(13);
    core/* ɵɵtemplate */.YNc(14, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_div_14_Template, 3, 2, "div", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td");
    core/* ɵɵtext */._uU(16);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "td", 56);
    core/* ɵɵtemplate */.YNc(18, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_button_18_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r78 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r78.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r78.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r78.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", standing_r78.timingDataF1.BestLapTimes);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", standing_r78.timingDataF1.TimeDiffToFastest, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", standing_r78.timingDataF1.Stats);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", standing_r78.timingDataF1.TimeDiffToPositionAhead, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", standing_r78.timingDataF1.Stats);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r78.timingDataF1.NumberOfLaps);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r78.radioData.length > 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r101 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r101); const ctx_r100 = core/* ɵɵnextContext */.oxw(4); return ctx_r100.sortMainResultData($event, 4); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 53);
    core/* ɵɵtext */._uU(5, "Result");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 54);
    core/* ɵɵtext */._uU(16, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 54);
    core/* ɵɵtext */._uU(18, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "th", 54);
    core/* ɵɵtext */._uU(20, "Lap count");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(21, "th", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "tbody");
    core/* ɵɵtemplate */.YNc(23, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_tr_23_Template, 19, 10, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r75 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(23);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r75.upcomingRaceAnalysis.quali);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r102 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r102.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r102.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r102.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r102.lapNumber);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r105 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_div_0_Template, 24, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 46);
    core/* ɵɵelementStart */.TgZ(2, "div", 47);
    core/* ɵɵelementStart */.TgZ(3, "div", 38);
    core/* ɵɵelementStart */.TgZ(4, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_Template_table_matSortChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r105); const ctx_r104 = core/* ɵɵnextContext */.oxw(3); return ctx_r104.sortResultData($event, 4); });
    core/* ɵɵelementStart */.TgZ(5, "thead");
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 49);
    core/* ɵɵtext */._uU(8, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tr");
    core/* ɵɵelementStart */.TgZ(10, "th", 50);
    core/* ɵɵtext */._uU(11, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 51);
    core/* ɵɵtext */._uU(13, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 52);
    core/* ɵɵtext */._uU(17, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_tr_19_Template, 9, 4, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r14 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r14.upcomingRaceAnalysis.quali !== null);
    core/* ɵɵadvance */.xp6(19);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r14.upcomingRaceAnalysis.qualiLaps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_tr_23_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r115 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_tr_23_button_16_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r115); const standing_r110 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r113 = core/* ɵɵnextContext */.oxw(6); return ctx_r113.openRadioDialog(standing_r110.radioData, ctx_r113.upcomingRaceAnalysis.sprintQualiLivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_tr_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td", 56);
    core/* ɵɵtemplate */.YNc(16, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_tr_23_button_16_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r110 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.timingDataF1.BestLapTime.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.timingDataF1.TimeDiffToFastest);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.timingDataF1.TimeDiffToPositionAhead);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r110.timingDataF1.NumberOfLaps);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r110.radioData.length > 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r117 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r117); const ctx_r116 = core/* ɵɵnextContext */.oxw(5); return ctx_r116.sortMainResultData($event, 4); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 53);
    core/* ɵɵtext */._uU(5, "Fastest lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 54);
    core/* ɵɵtext */._uU(16, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 54);
    core/* ɵɵtext */._uU(18, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "th", 54);
    core/* ɵɵtext */._uU(20, "Lap count");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(21, "th", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "tbody");
    core/* ɵɵtemplate */.YNc(23, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_tr_23_Template, 17, 8, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r107 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(23);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r107.upcomingRaceAnalysis.sprintQuali);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_tr_19_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r118 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r118.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r118.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r118.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r118.lapNumber);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r121 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_div_0_Template, 24, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 46);
    core/* ɵɵelementStart */.TgZ(2, "div", 47);
    core/* ɵɵelementStart */.TgZ(3, "div", 38);
    core/* ɵɵelementStart */.TgZ(4, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_Template_table_matSortChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r121); const ctx_r120 = core/* ɵɵnextContext */.oxw(4); return ctx_r120.sortResultData($event, 5); });
    core/* ɵɵelementStart */.TgZ(5, "thead");
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 49);
    core/* ɵɵtext */._uU(8, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tr");
    core/* ɵɵelementStart */.TgZ(10, "th", 50);
    core/* ɵɵtext */._uU(11, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 51);
    core/* ɵɵtext */._uU(13, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 50);
    core/* ɵɵtext */._uU(15, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 52);
    core/* ɵɵtext */._uU(17, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "tbody");
    core/* ɵɵtemplate */.YNc(19, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_tr_19_Template, 9, 4, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r106 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r106.upcomingRaceAnalysis.quali !== null);
    core/* ɵɵadvance */.xp6(19);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r106.upcomingRaceAnalysis.sprintQualiLaps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 62);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_ng_template_1_Template, 20, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r15 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r15.upcomingRaceAnalysis.sprintQuali == null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_tr_21_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r130 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 58);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_tr_21_button_12_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r130); const standing_r125 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r128 = core/* ɵɵnextContext */.oxw(6); return ctx_r128.openRadioDialog(standing_r125.radioData, ctx_r128.upcomingRaceAnalysis.sprintLivetimingUrl); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_tr_21_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 69);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td", 69);
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td", 56);
    core/* ɵɵtemplate */.YNc(12, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_tr_21_button_12_Template, 3, 0, "button", 57);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td", 70);
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r125 = ctx.$implicit;
    const ctx_r124 = core/* ɵɵnextContext */.oxw(6);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r125.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r125.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r125.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r125.finalGap);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r125.fastestLap);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r125.radioData.length > 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵstyleProp */.Udp("color", ctx_r124.getTyresClass(standing_r125.lapByLapData.tyres));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r124.getTyresString(standing_r125.lapByLapData.tyres));
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r132 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r132); const ctx_r131 = core/* ɵɵnextContext */.oxw(5); return ctx_r131.sortMainResultData($event, 6); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 65);
    core/* ɵɵtext */._uU(5, "Results");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tr");
    core/* ɵɵelementStart */.TgZ(7, "th", 50);
    core/* ɵɵtext */._uU(8, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 54);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 66);
    core/* ɵɵtext */._uU(12, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 54);
    core/* ɵɵtext */._uU(14, "Gap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 67);
    core/* ɵɵtext */._uU(16, "Lap time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(17, "th", 55);
    core/* ɵɵelementStart */.TgZ(18, "th", 68);
    core/* ɵɵtext */._uU(19, "Tyre");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "tbody");
    core/* ɵɵtemplate */.YNc(21, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_tr_21_Template, 15, 9, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r123 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(21);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r123.upcomingRaceAnalysis.sprint);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_div_0_Template, 22, 1, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 4);
    core/* ɵɵelementStart */.TgZ(2, "div", 5);
    core/* ɵɵelementStart */.TgZ(3, "div", 44);
    core/* ɵɵelementStart */.TgZ(4, "div", 38);
    core/* ɵɵelement */._UZ(5, "apx-chart", 64);
    core/* ɵɵelement */._UZ(6, "br");
    core/* ɵɵelement */._UZ(7, "br");
    core/* ɵɵelement */._UZ(8, "br");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r122 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r122.upcomingRaceAnalysis.sprint != null);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("chart", ctx_r122.defChart)("dataLabels", ctx_r122.defDataLabels)("grid", ctx_r122.defGrid)("series", ctx_r122.lapPosChart.series)("stroke", ctx_r122.defStroke)("title", ctx_r122.lapPosChart.title)("xaxis", ctx_r122.lapXaxis)("yaxis", ctx_r122.reverseYAxis);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 63);
    core/* ɵɵtemplate */.YNc(1, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_ng_template_1_Template, 9, 9, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r16 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r16.upcomingRaceAnalysis.sprint == null);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_15_tr_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 42);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const lap_r134 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r134.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r134.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r134.lapTime);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r134.lapNumber);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(lap_r134.sessionName);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    const _r137 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 46);
    core/* ɵɵelementStart */.TgZ(1, "div", 47);
    core/* ɵɵelementStart */.TgZ(2, "div", 38);
    core/* ɵɵelementStart */.TgZ(3, "table", 48);
    core/* ɵɵlistener */.NdJ("matSortChange", function UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_15_Template_table_matSortChange_3_listener($event) { core/* ɵɵrestoreView */.CHM(_r137); const ctx_r136 = core/* ɵɵnextContext */.oxw(3); return ctx_r136.sortResultData($event, 7); });
    core/* ɵɵelementStart */.TgZ(4, "thead");
    core/* ɵɵelementStart */.TgZ(5, "tr");
    core/* ɵɵelementStart */.TgZ(6, "th", 49);
    core/* ɵɵtext */._uU(7, "Recorded laps");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "tr");
    core/* ɵɵelementStart */.TgZ(9, "th", 50);
    core/* ɵɵtext */._uU(10, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 51);
    core/* ɵɵtext */._uU(12, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 50);
    core/* ɵɵtext */._uU(14, "Lap Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "th", 52);
    core/* ɵɵtext */._uU(16, "Lap Number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "th", 52);
    core/* ɵɵtext */._uU(18, "Session");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "tbody");
    core/* ɵɵtemplate */.YNc(20, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_15_tr_20_Template, 11, 5, "tr", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r17 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(20);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r17.allLaps);
} }
function UpcomingRaceAnalysisComponent_div_0_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r139 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "mat-tab-group", 17);
    core/* ɵɵlistener */.NdJ("selectedTabChange", function UpcomingRaceAnalysisComponent_div_0_div_20_Template_mat_tab_group_selectedTabChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r139); const ctx_r138 = core/* ɵɵnextContext */.oxw(2); return ctx_r138.tabChanged($event); })("selectedIndexChange", function UpcomingRaceAnalysisComponent_div_0_div_20_Template_mat_tab_group_selectedIndexChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r139); const ctx_r140 = core/* ɵɵnextContext */.oxw(2); return ctx_r140.selectedTab = $event; });
    core/* ɵɵelementStart */.TgZ(2, "mat-tab", 18);
    core/* ɵɵtemplate */.YNc(3, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_3_Template, 1, 1, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab", 20);
    core/* ɵɵtemplate */.YNc(5, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_5_Template, 2, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "mat-tab", 21);
    core/* ɵɵtemplate */.YNc(7, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_7_Template, 20, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(8, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_8_Template, 2, 1, "mat-tab", 22);
    core/* ɵɵtemplate */.YNc(9, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_9_Template, 2, 1, "mat-tab", 23);
    core/* ɵɵelementStart */.TgZ(10, "mat-tab", 24);
    core/* ɵɵtemplate */.YNc(11, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_11_Template, 20, 2, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(12, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_12_Template, 2, 1, "mat-tab", 25);
    core/* ɵɵtemplate */.YNc(13, UpcomingRaceAnalysisComponent_div_0_div_20_mat_tab_13_Template, 2, 1, "mat-tab", 26);
    core/* ɵɵelementStart */.TgZ(14, "mat-tab", 27);
    core/* ɵɵtemplate */.YNc(15, UpcomingRaceAnalysisComponent_div_0_div_20_ng_template_15_Template, 21, 1, "ng-template", 19);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r3.selectedTab);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r3.upcomingRaceAnalysis.basicRaces.length == 0);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r3.upcomingRaceAnalysis.fp1 == null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r3.sprintMode);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r3.sprintMode);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r3.upcomingRaceAnalysis.quali == null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.sprintMode);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.sprintMode);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r3.allLaps.length == 0);
} }
function UpcomingRaceAnalysisComponent_div_0_div_21_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 71);
    core/* ɵɵelement */._UZ(2, "img", 72);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function UpcomingRaceAnalysisComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r142 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 1);
    core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 2, 3);
    core/* ɵɵlistener */.NdJ("openedChange", function UpcomingRaceAnalysisComponent_div_0_Template_mat_drawer_openedChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r141 = core/* ɵɵnextContext */.oxw(); return ctx_r141.utilityService.setSidebarStatus($event); });
    core/* ɵɵelementStart */.TgZ(4, "div", 4);
    core/* ɵɵelementStart */.TgZ(5, "div", 5);
    core/* ɵɵelementStart */.TgZ(6, "div");
    core/* ɵɵelementStart */.TgZ(7, "textarea", 6);
    core/* ɵɵlistener */.NdJ("focus", function UpcomingRaceAnalysisComponent_div_0_Template_textarea_focus_7_listener() { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r143 = core/* ɵɵnextContext */.oxw(); return ctx_r143.utilityService.focusFunction(); })("focusout", function UpcomingRaceAnalysisComponent_div_0_Template_textarea_focusout_7_listener() { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r144 = core/* ɵɵnextContext */.oxw(); return ctx_r144.utilityService.focusOutFunction(); })("ngModelChange", function UpcomingRaceAnalysisComponent_div_0_Template_textarea_ngModelChange_7_listener($event) { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r145 = core/* ɵɵnextContext */.oxw(); return ctx_r145.utilityService.postText = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "div", 7);
    core/* ɵɵelementStart */.TgZ(9, "button", 8);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_Template_button_click_9_listener() { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r146 = core/* ɵɵnextContext */.oxw(); return ctx_r146.utilityService.postComment(11); });
    core/* ɵɵtext */._uU(10, "Post ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "button", 8);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_Template_button_click_11_listener() { core/* ɵɵrestoreView */.CHM(_r142); const ctx_r147 = core/* ɵɵnextContext */.oxw(); return ctx_r147.utilityService.reloadPosts(11); });
    core/* ɵɵtext */._uU(12, "Reload ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(13, UpcomingRaceAnalysisComponent_div_0_div_13_Template, 8, 3, "div", 9);
    core/* ɵɵelementStart */.TgZ(14, "div", 10);
    core/* ɵɵelementStart */.TgZ(15, "button", 11);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r142); const _r1 = core/* ɵɵreference */.MAs(3); const ctx_r148 = core/* ɵɵnextContext */.oxw(); return ctx_r148.utilityService.drawerToggle(_r1); });
    core/* ɵɵelement */._UZ(16, "i", 12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "div", 10);
    core/* ɵɵelementStart */.TgZ(18, "button", 11);
    core/* ɵɵlistener */.NdJ("click", function UpcomingRaceAnalysisComponent_div_0_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r142); const _r1 = core/* ɵɵreference */.MAs(3); const ctx_r149 = core/* ɵɵnextContext */.oxw(); return ctx_r149.utilityService.drawerToggle(_r1); });
    core/* ɵɵelement */._UZ(19, "i", 12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(20, UpcomingRaceAnalysisComponent_div_0_div_20_Template, 16, 9, "div", 0);
    core/* ɵɵtemplate */.YNc(21, UpcomingRaceAnalysisComponent_div_0_div_21_Template, 3, 0, "div", 0);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("opened", ctx_r0.utilityService.getSidebarStatus());
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.utilityService.postText);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.utilityService.comments);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.upcomingRaceAnalysis != undefined);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.upcomingRaceAnalysis == undefined);
} }
function RadioPopupComponent_tr_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵpipe */.ALo(3, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "td");
    core/* ɵɵelementStart */.TgZ(5, "audio", 6);
    core/* ɵɵelement */._UZ(6, "source", 7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const radio_r1 = ctx.$implicit;
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(3, 2, radio_r1.utc, " HH:mm:ss"));
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵpropertyInterpolate */.s9C("src", ctx_r0.baseUrl + radio_r1.path, core/* ɵɵsanitizeUrl */.LSH);
} }
class UpcomingRaceAnalysisComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.sprintMode = true;
        this.selectedTab = 0;
        this.defChart = {
            height: 350,
            type: 'line',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.defDataLabels = {
            enabled: false
        };
        this.defStroke = {
            curve: 'straight'
        };
        this.defGrid = {
            borderColor: '#e7e7e7',
            row: {
                colors: ['#f3f3f3', 'transparent'],
                opacity: 0.5
            }
        };
        this.reverseYAxis = {
            min: 1,
            // tickAmount:6 ,
            decimalsInFloat: 0,
            reversed: true,
            axisTicks: {
                show: true
            },
            axisBorder: {
                show: true,
                color: '#008FFB'
            },
            title: {
                text: 'Position',
            }
        };
        this.lapXaxis = {
            labels: {
                formatter: function (value, timestamp, opts) {
                    var y = +value - 1;
                    return '' + y;
                }
            },
            title: {
                text: 'Lap',
            }
        };
        restService.getUpcomingRaceAnalysis().subscribe({
            next: data => {
                this.upcomingRaceAnalysis = data;
                if (this.upcomingRaceAnalysis != null) {
                    this.setAllLaps();
                    this.utilityService.setTitle(5, this.upcomingRaceAnalysis.title);
                    this.setCharts();
                    this.checkIfSprintMode();
                }
                else {
                    this.utilityService.setTitle(5, 'Season is finished');
                }
                return data;
            }
        });
        this.selectedTab = this.getSelectedTab();
    }
    sortMainResultData(sort, eventNumber) {
        switch (eventNumber) {
            case 1:
                this.upcomingRaceAnalysis.fp1 = this.sortResults(this.upcomingRaceAnalysis.fp1, sort.active, sort.direction);
                break;
            case 2:
                this.upcomingRaceAnalysis.fp2 = this.sortResults(this.upcomingRaceAnalysis.fp2, sort.active, sort.direction);
                break;
            case 3:
                this.upcomingRaceAnalysis.fp3 = this.sortResults(this.upcomingRaceAnalysis.fp3, sort.active, sort.direction);
                break;
            case 4:
                this.upcomingRaceAnalysis.quali = this.sortResults(this.upcomingRaceAnalysis.quali, sort.active, sort.direction);
                break;
            case 5:
                this.upcomingRaceAnalysis.sprintQuali = this.sortResults(this.upcomingRaceAnalysis.sprintQuali, sort.active, sort.direction);
                break;
            case 6:
                this.upcomingRaceAnalysis.sprint = this.sortResults(this.upcomingRaceAnalysis.sprint, sort.active, sort.direction);
                break;
        }
    }
    sortResultData(sort, eventNumber) {
        switch (eventNumber) {
            case 1:
                this.upcomingRaceAnalysis.fp1Laps = this.sortLaps(this.upcomingRaceAnalysis.fp1Laps, sort.active, sort.direction);
                break;
            case 2:
                this.upcomingRaceAnalysis.fp2Laps = this.sortLaps(this.upcomingRaceAnalysis.fp2Laps, sort.active, sort.direction);
                break;
            case 3:
                this.upcomingRaceAnalysis.fp3Laps = this.sortLaps(this.upcomingRaceAnalysis.fp3Laps, sort.active, sort.direction);
                break;
            case 4:
                this.upcomingRaceAnalysis.qualiLaps = this.sortLaps(this.upcomingRaceAnalysis.qualiLaps, sort.active, sort.direction);
                break;
            case 5:
                this.upcomingRaceAnalysis.sprintQualiLaps = this.sortLaps(this.upcomingRaceAnalysis.sprintQualiLaps, sort.active, sort.direction);
                break;
            case 6:
                this.upcomingRaceAnalysis.sprintLaps = this.sortLaps(this.upcomingRaceAnalysis.sprintLaps, sort.active, sort.direction);
                break;
            case 7:
                this.allLaps = this.sortLaps(this.allLaps, sort.active, sort.direction);
                break;
        }
    }
    sortLaps(laps, sortingColumn, direction) {
        let sorted = [];
        if (direction == 'asc') {
            switch (sortingColumn) {
                case 'name':
                    sorted = laps.sort((a, b) => (a.driverName >= b.driverName) ? 1 : -1);
                    return sorted;
                case 'position':
                    sorted = laps.sort((a, b) => (a.lapTimeMs > b.lapTimeMs) ? 1 : -1);
                    return sorted;
                case 'lapNumber':
                    sorted = laps.sort((a, b) => (a.lapNumber > b.lapNumber) ? 1 : -1);
                    return sorted;
            }
        }
        if (direction == 'desc') {
            switch (sortingColumn) {
                case 'name':
                    sorted = laps.sort((a, b) => (a.driverName <= b.driverName) ? 1 : -1);
                    return sorted;
                case 'position':
                    sorted = laps.sort((a, b) => (a.lapTimeMs < b.lapTimeMs) ? 1 : -1);
                    return sorted;
                case 'lapNumber':
                    sorted = laps.sort((a, b) => (a.lapNumber < b.lapNumber) ? 1 : -1);
                    return sorted;
            }
        }
        if (direction == '') {
            sorted = laps.sort((a, b) => (a.lapTimeMs > b.lapTimeMs) ? 1 : -1);
            return sorted;
        }
        return sorted;
    }
    sortResults(drivers, sortingColumn, direction) {
        let sorted = [];
        let ascendingBoolean = null;
        if (direction == 'asc') {
            ascendingBoolean = true;
        }
        else if (direction == 'desc') {
            ascendingBoolean = false;
        }
        sorted = drivers.sort(this.sortNullsLast(ascendingBoolean, sortingColumn));
        return sorted;
    }
    sortNullsLast(ascending, sortingColumn) {
        let columnA;
        let columnB;
        return function (a, b) {
            if (ascending == null) {
                return a.position > b.position ? 1 : -1;
            }
            switch (sortingColumn) {
                case 'position':
                    columnA = a.position;
                    columnB = b.position;
                    break;
                case 'sector1':
                    columnA = a.fastestLapSector1;
                    columnB = b.fastestLapSector1;
                    break;
                case 'sector2':
                    columnA = a.fastestLapSector2;
                    columnB = b.fastestLapSector2;
                    break;
                case 'sector3':
                    columnA = a.fastestLapSector3;
                    columnB = b.fastestLapSector3;
                    break;
                case 'lapTime':
                    columnA = a.fastestLapPosition;
                    columnB = b.fastestLapPosition;
                    break;
            }
            if (columnA == '') {
                return 1;
            }
            else if (columnB == '') {
                return -1;
            }
            else if (ascending) {
                return columnA < columnB ? -1 : 1;
            }
            else {
                return columnA < columnB ? 1 : -1;
            }
        };
    }
    getTyresString(tyres) {
        let response = '';
        tyres.forEach((tyre) => {
            response = response + tyre.type;
        });
        return response;
    }
    getTyresClass(tyres) {
        return RaceAnalysisComponent.getColor(this.getTyresString(tyres));
    }
    touchstart(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        this.swipeCoord = coord;
        this.swipeTime = time;
    }
    touchend(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
        const duration = time - this.swipeTime;
        if (duration < 1000
            && Math.abs(direction[0]) > 30 // Long enough
            && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
            const swipe = direction[0] < 0 ? 'next' : 'previous';
            if (swipe === 'next') {
                const isFirst = this.selectedTab === 0;
                if (this.selectedTab <= 4) {
                    this.selectedTab = isFirst ? 1 : this.selectedTab + 1;
                }
            }
            else if (swipe === 'previous') {
                if (this.selectedTab >= 1) {
                    this.selectedTab = this.selectedTab - 1;
                }
            }
        }
    }
    tabChanged(tabChangeEvent) {
        this.updateUrl();
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    openRace(season, round) {
        this.restService.getRace(season, round).subscribe({
            next: data => {
                const dialogRef = this.dialog.open(RacePopupComponent, {
                    maxWidth: '90vw'
                });
                dialogRef.componentInstance.race = data;
            }
        });
    }
    openRadioDialog(radioData, baseUrl) {
        const dialogRef = this.dialog.open(RadioPopupComponent);
        dialogRef.componentInstance.radioData = radioData;
        dialogRef.componentInstance.baseUrl = baseUrl;
    }
    checkIfSprintMode() {
        if (this.upcomingRaceAnalysis.sprint != null) {
            this.sprintMode = true;
        }
        else if ((this.upcomingRaceAnalysis.fp2 == null || this.upcomingRaceAnalysis.fp3 == null) && this.upcomingRaceAnalysis.quali != null) {
            this.sprintMode = true;
        }
        else {
            this.sprintMode = false;
        }
        // this.ref.detectChanges();
    }
    setCharts() {
        if (this.upcomingRaceAnalysis.sprint == null) {
            return;
        }
        let positionsByLapchartSeries = [];
        for (let driver of this.upcomingRaceAnalysis.sprint) {
            let color = driver.Color;
            if (color == 'FFFFFF') {
                color = '888888';
            }
            positionsByLapchartSeries.push({
                name: driver.Tla,
                data: driver.lapByLapData.positions,
                color: '#' + color
            });
        }
        this.lapPosChart = {
            series: positionsByLapchartSeries,
            title: {
                text: 'Position by lap',
                align: 'center'
            },
        };
    }
    getSelectedTab() {
        let tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == undefined) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    setAllLaps() {
        let laps = [];
        if (this.upcomingRaceAnalysis.fp1Laps != null) {
            laps = laps.concat(this.upcomingRaceAnalysis.fp1Laps);
        }
        if (this.upcomingRaceAnalysis.fp2Laps != null) {
            laps = laps.concat(this.upcomingRaceAnalysis.fp2Laps);
        }
        if (this.upcomingRaceAnalysis.fp3Laps != null) {
            laps = laps.concat(this.upcomingRaceAnalysis.fp3Laps);
        }
        if (this.upcomingRaceAnalysis.qualiLaps != null) {
            laps = laps.concat(this.upcomingRaceAnalysis.qualiLaps);
        }
        let counter = 1;
        laps = this.sortLaps(laps, 'position', 'asc');
        laps.forEach((lap) => {
            lap.position = counter;
            counter++;
        });
        this.allLaps = laps;
    }
}
UpcomingRaceAnalysisComponent.ɵfac = function UpcomingRaceAnalysisComponent_Factory(t) { return new (t || UpcomingRaceAnalysisComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
UpcomingRaceAnalysisComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: UpcomingRaceAnalysisComponent, selectors: [["app-upcoming-race-analysis-cmp"]], viewQuery: function UpcomingRaceAnalysisComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(upcoming_race_analysis_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 1, vars: 1, consts: [[4, "ngIf"], ["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "focus", "focusout", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [3, "selectedIndex", "selectedTabChange", "selectedIndexChange"], ["label", "Circuit"], ["matTabContent", ""], ["label", "Circuit winners", 3, "disabled"], ["label", "Practice 1", 3, "disabled"], ["label", "Practice 2", 3, "disabled", 4, "ngIf"], ["label", "Practice 3", 3, "disabled", 4, "ngIf"], ["label", "Qualifying", 3, "disabled"], ["label", "Sprint SHoOToUt", 3, "disabled", 4, "ngIf"], ["label", "Sprint", 3, "disabled", 4, "ngIf"], ["label", "All laps", 3, "disabled"], [1, "black-footer", "text-center"], [1, "image"], ["target", "_blank", 3, "href"], [3, "src"], ["class", "div-padded-1rem row", 4, "ngIf"], ["class", "div-padded-1rem div-padded-left-2 row", 4, "ngIf"], [1, "div-padded-1rem", "row"], ["class", "col-lg-6 col-12", 4, "ngFor", "ngForOf"], [1, "col-lg-6", "col-12"], [1, "card", "hover-effects-row", 3, "click"], [1, "card-body-padded"], [1, "table", "table-striped"], ["colspan", "2", "scope", "col"], [2, "width", "35px"], ["scope", "row"], [1, "div-padded-1rem", "div-padded-left-2", "row"], [1, "card"], [3, "href"], [1, "div-padded-1rem", "div-padded-left-2", "div-padded-right-2", "row"], [1, "card", "col-lg-12", "col-12"], ["matSort", "", 1, "table", "table-striped", 3, "matSortChange"], ["colspan", "4", 1, "text-center"], ["mat-sort-header", "position", "scope", "col"], ["mat-sort-header", "name", "scope", "col"], ["mat-sort-header", "lapNumber", "scope", "col"], ["colspan", "8", 1, "text-center"], ["scope", "col"], ["scope", "col", 1, "w-20px"], [1, "no-padding-td"], ["color", "primary", "mat-mini-fab", "", 3, "click", 4, "ngIf"], ["color", "primary", "mat-mini-fab", "", 3, "click"], ["label", "Practice 2", 3, "disabled"], ["label", "Practice 3", 3, "disabled"], [1, "font-weight-bold"], ["label", "Sprint SHoOToUt", 3, "disabled"], ["label", "Sprint", 3, "disabled"], [3, "chart", "dataLabels", "grid", "series", "stroke", "title", "xaxis", "yaxis"], ["colspan", "9", 1, "text-center"], ["scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["mat-sort-header", "lapTime", "scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["scope", "col", 1, "text-center"], [1, "d-sm-none", "d-none", "d-lg-table-cell"], [1, "font-weight-bold", "text-center"], [1, "icon-big", "text-center", "icon-warning"], ["src", "assets/img/tifosi/kimi-raikkonen-smile.gif", 1, "div-height-70vh"]], template: function UpcomingRaceAnalysisComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵtemplate */.YNc(0, UpcomingRaceAnalysisComponent_div_0_Template, 22, 5, "div", 0);
    } if (rf & 2) {
        core/* ɵɵproperty */.Q6J("ngIf", ctx.upcomingRaceAnalysis !== undefined);
    } }, directives: [common/* NgIf */.O5, sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, MatSort, MatSortHeader, icon/* MatIcon */.Hw, ng_apexcharts/* ChartComponent */.x], pipes: [common/* DatePipe */.uU], encapsulation: 2 });
class RadioPopupComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
}
RadioPopupComponent.ɵfac = function RadioPopupComponent_Factory(t) { return new (t || RadioPopupComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
RadioPopupComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: RadioPopupComponent, selectors: [["app-radio-popup-cmp"]], decls: 13, vars: 2, consts: [[1, "mat-typography"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["colspan", "2"], ["scope", "col"], [4, "ngFor", "ngForOf"], ["controls", ""], [3, "src"]], template: function RadioPopupComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content", 0);
        core/* ɵɵelementStart */.TgZ(1, "table", 1);
        core/* ɵɵelementStart */.TgZ(2, "thead");
        core/* ɵɵelementStart */.TgZ(3, "tr", 2);
        core/* ɵɵelementStart */.TgZ(4, "th", 3);
        core/* ɵɵtext */._uU(5);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(6, "tr", 2);
        core/* ɵɵelementStart */.TgZ(7, "th", 4);
        core/* ɵɵtext */._uU(8, "Time");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(9, "th", 4);
        core/* ɵɵtext */._uU(10, "Audio");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "tbody");
        core/* ɵɵtemplate */.YNc(12, RadioPopupComponent_tr_12_Template, 7, 5, "tr", 5);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵtextInterpolate */.Oqu(ctx.radioData[0].driverName);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.radioData);
    } }, directives: [MatDialogContent, common/* NgForOf */.sg], pipes: [common/* DatePipe */.uU], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/radio.js
var fesm2015_radio = __webpack_require__(2613);
;// CONCATENATED MODULE: ./src/app/pages/race-analysis/race-analysis.component.ts






















const race_analysis_component_c0 = ["chart"];
function RaceAnalysisComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function RaceAnalysisComponent_div_20_ng_template_3_tr_16_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r22 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 38);
    core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_div_20_ng_template_3_tr_16_button_12_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r22); const standing_r17 = core/* ɵɵnextContext */.oxw().$implicit; const ctx_r20 = core/* ɵɵnextContext */.oxw(3); return ctx_r20.openRadioDialog(standing_r17.radioData); });
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function RaceAnalysisComponent_div_20_ng_template_3_tr_16_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 34);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 35);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td", 36);
    core/* ɵɵtemplate */.YNc(12, RaceAnalysisComponent_div_20_ng_template_3_tr_16_button_12_Template, 3, 0, "button", 37);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r17 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.FullName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.timingDataF1.GapToLeader);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r17.timingDataF1.IntervalToPositionAhead.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r17.radioData.length > 0);
} }
function RaceAnalysisComponent_div_20_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 29);
    core/* ɵɵelementStart */.TgZ(1, "table", 30);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelementStart */.TgZ(4, "th", 31);
    core/* ɵɵtext */._uU(5, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 31);
    core/* ɵɵtext */._uU(7, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 32);
    core/* ɵɵtext */._uU(9, "Team");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "th", 31);
    core/* ɵɵtext */._uU(11, "Gap to leader");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 31);
    core/* ɵɵtext */._uU(13, "Gap to previous");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(14, "th", 33);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "tbody");
    core/* ɵɵtemplate */.YNc(16, RaceAnalysisComponent_div_20_ng_template_3_tr_16_Template, 13, 6, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(16);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r7.drivers);
} }
function RaceAnalysisComponent_div_20_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 3);
    core/* ɵɵelementStart */.TgZ(1, "div", 4);
    core/* ɵɵelementStart */.TgZ(2, "div", 39);
    core/* ɵɵelementStart */.TgZ(3, "div", 40);
    core/* ɵɵelement */._UZ(4, "apx-chart", 41);
    core/* ɵɵelement */._UZ(5, "br");
    core/* ɵɵelement */._UZ(6, "br");
    core/* ɵɵelement */._UZ(7, "br");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "div", 3);
    core/* ɵɵelementStart */.TgZ(9, "div", 4);
    core/* ɵɵelementStart */.TgZ(10, "div", 39);
    core/* ɵɵelementStart */.TgZ(11, "div", 42);
    core/* ɵɵelement */._UZ(12, "apx-chart", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("series", ctx_r8.lapPosChart.series)("chart", ctx_r8.defChartResponsiveWidth)("dataLabels", ctx_r8.defDataLabels)("grid", ctx_r8.defGrid)("stroke", ctx_r8.defStroke)("title", ctx_r8.lapPosChart.title)("yaxis", ctx_r8.reverseYAxis)("xaxis", ctx_r8.lapXaxis);
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵproperty */.Q6J("title", ctx_r8.lapTyreChart.title)("series", ctx_r8.lapTyreChart.series)("chart", ctx_r8.lapTyreChart.chart)("fill", ctx_r8.lapTyreChart.fill)("legend", ctx_r8.lapTyreChart.legend)("plotOptions", ctx_r8.lapTyreChart.plotOptions)("xaxis", ctx_r8.lapTyreChart.xaxis)("tooltip", ctx_r8.lapTyreChart.tooltip);
} }
function RaceAnalysisComponent_div_20_ng_template_7_tr_14_span_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span");
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r25 = core/* ɵɵnextContext */.oxw().$implicit;
    const ctx_r27 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r27.positionChange(standing_r25));
} }
function RaceAnalysisComponent_div_20_ng_template_7_tr_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵelementStart */.TgZ(2, "span");
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, RaceAnalysisComponent_div_20_ng_template_7_tr_14_span_4_Template, 2, 1, "span", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r25 = ctx.$implicit;
    const ctx_r23 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵclassMap */.Tol("text-left " + ctx_r23.standingsChangeClass(standing_r25));
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r25.PredictedPosition);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r25.PredictedPosition != standing_r25.CurrentPosition);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r25.name);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r23.pointsChange(standing_r25));
} }
function RaceAnalysisComponent_div_20_ng_template_7_tr_28_span_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "span");
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r29 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij("'+' ", standing_r29.PredictedPosition - standing_r29.CurrentPosition, "");
} }
function RaceAnalysisComponent_div_20_ng_template_7_tr_28_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td", 52);
    core/* ɵɵelementStart */.TgZ(2, "span");
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, RaceAnalysisComponent_div_20_ng_template_7_tr_28_span_4_Template, 2, 1, "span", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r29 = ctx.$implicit;
    const ctx_r24 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵclassMap */.Tol(ctx_r24.standingsChangeClass(standing_r29));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(standing_r29.PredictedPosition);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", standing_r29.PredictedPosition != standing_r29.CurrentPosition);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r29.TeamName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r24.pointsChange(standing_r29));
} }
function RaceAnalysisComponent_div_20_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 3);
    core/* ɵɵelementStart */.TgZ(1, "div", 44);
    core/* ɵɵelementStart */.TgZ(2, "table", 30);
    core/* ɵɵelementStart */.TgZ(3, "thead");
    core/* ɵɵelementStart */.TgZ(4, "tr", 45);
    core/* ɵɵelementStart */.TgZ(5, "th", 46);
    core/* ɵɵtext */._uU(6, "Drivers");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "tr", 45);
    core/* ɵɵelement */._UZ(8, "th", 47);
    core/* ɵɵelementStart */.TgZ(9, "th", 31);
    core/* ɵɵtext */._uU(10, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 48);
    core/* ɵɵtext */._uU(12, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "tbody");
    core/* ɵɵtemplate */.YNc(14, RaceAnalysisComponent_div_20_ng_template_7_tr_14_Template, 9, 7, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "div", 49);
    core/* ɵɵelementStart */.TgZ(16, "table", 30);
    core/* ɵɵelementStart */.TgZ(17, "thead");
    core/* ɵɵelementStart */.TgZ(18, "tr", 45);
    core/* ɵɵelementStart */.TgZ(19, "th", 46);
    core/* ɵɵtext */._uU(20, "Teams");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(21, "tr", 45);
    core/* ɵɵelement */._UZ(22, "th", 47);
    core/* ɵɵelementStart */.TgZ(23, "th", 31);
    core/* ɵɵtext */._uU(24, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(25, "th", 48);
    core/* ɵɵtext */._uU(26, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(27, "tbody");
    core/* ɵɵtemplate */.YNc(28, RaceAnalysisComponent_div_20_ng_template_7_tr_28_Template, 9, 7, "tr", 50);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(14);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r9.driversChampionshipPrediction);
    core/* ɵɵadvance */.xp6(14);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r9.teamsChampionshipPrediction);
} }
function RaceAnalysisComponent_div_20_ng_template_9_tr_33_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "td");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td");
    core/* ɵɵtext */._uU(16);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "td");
    core/* ɵɵtext */._uU(18);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r34 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.name);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.PersonalBestLapTime.Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.PersonalBestLapTime.Position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[0].Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[0].Position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[1].Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[1].Position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[2].Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r34.BestSectors[2].Position);
} }
function RaceAnalysisComponent_div_20_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r37 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 29);
    core/* ɵɵelementStart */.TgZ(1, "table", 53);
    core/* ɵɵlistener */.NdJ("matSortChange", function RaceAnalysisComponent_div_20_ng_template_9_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r37); const ctx_r36 = core/* ɵɵnextContext */.oxw(2); return ctx_r36.sortTimingStats($event); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelement */._UZ(4, "th", 54);
    core/* ɵɵelementStart */.TgZ(5, "th", 55);
    core/* ɵɵtext */._uU(6, "Best Lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 56);
    core/* ɵɵtext */._uU(8, "Best Sector 1");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 57);
    core/* ɵɵtext */._uU(10, "Best Sector 2");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 58);
    core/* ɵɵtext */._uU(12, "Best Sector 3");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "tr");
    core/* ɵɵelementStart */.TgZ(14, "th", 59);
    core/* ɵɵtext */._uU(15, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "th", 60);
    core/* ɵɵtext */._uU(17, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "th", 61);
    core/* ɵɵtext */._uU(19, "Position");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(20, "th", 62);
    core/* ɵɵtext */._uU(21, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(22, "th", 63);
    core/* ɵɵtext */._uU(23, "Position");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(24, "th", 64);
    core/* ɵɵtext */._uU(25, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(26, "th", 65);
    core/* ɵɵtext */._uU(27, "Position");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(28, "th", 66);
    core/* ɵɵtext */._uU(29, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(30, "th", 67);
    core/* ɵɵtext */._uU(31, "Position");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(32, "tbody");
    core/* ɵɵtemplate */.YNc(33, RaceAnalysisComponent_div_20_ng_template_9_tr_33_Template, 19, 9, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(33);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r10.timingStats);
} }
function RaceAnalysisComponent_div_20_ng_template_11_th_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "th", 70);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const key_r41 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(" " + key_r41);
} }
function RaceAnalysisComponent_div_20_ng_template_11_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "th", 71);
    core/* ɵɵtext */._uU(2, "Speed (km/h)");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "th", 72);
    core/* ɵɵtext */._uU(4, "Position");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
} if (rf & 2) {
    const key_r43 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("mat-sort-header", key_r43);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("mat-sort-header", key_r43);
} }
function RaceAnalysisComponent_div_20_ng_template_11_tr_15_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "td", 73);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 74);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
} if (rf & 2) {
    const key_r48 = ctx.$implicit;
    const stat_r45 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r45.BestSpeeds[key_r48].Value);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r45.BestSpeeds[key_r48].Position);
} }
function RaceAnalysisComponent_div_20_ng_template_11_tr_15_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(3, RaceAnalysisComponent_div_20_ng_template_11_tr_15_ng_container_3_Template, 5, 2, "ng-container", 8);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const stat_r45 = ctx.$implicit;
    const ctx_r40 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(stat_r45.name);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r40.bestSpeedKeys);
} }
function RaceAnalysisComponent_div_20_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r51 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 29);
    core/* ɵɵelementStart */.TgZ(1, "table", 53);
    core/* ɵɵlistener */.NdJ("matSortChange", function RaceAnalysisComponent_div_20_ng_template_11_Template_table_matSortChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r51); const ctx_r50 = core/* ɵɵnextContext */.oxw(2); return ctx_r50.sortTopSpeedTimingStats($event); });
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr");
    core/* ɵɵelement */._UZ(4, "th", 59);
    core/* ɵɵelementStart */.TgZ(5, "th", 68);
    core/* ɵɵtext */._uU(6, "Detection points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "tr");
    core/* ɵɵelement */._UZ(8, "th", 54);
    core/* ɵɵtemplate */.YNc(9, RaceAnalysisComponent_div_20_ng_template_11_th_9_Template, 2, 1, "th", 69);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "tr");
    core/* ɵɵelementStart */.TgZ(11, "th", 54);
    core/* ɵɵtext */._uU(12, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(13, RaceAnalysisComponent_div_20_ng_template_11_ng_container_13_Template, 5, 2, "ng-container", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "tbody");
    core/* ɵɵtemplate */.YNc(15, RaceAnalysisComponent_div_20_ng_template_11_tr_15_Template, 4, 2, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵattribute */.uIk("colspan", ctx_r11.bestSpeedKeys.length * 2 + "");
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r11.bestSpeedKeys);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r11.bestSpeedKeys);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r11.timingStats);
} }
function RaceAnalysisComponent_div_20_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtext */._uU(0, " Radio ");
    core/* ɵɵelementStart */.TgZ(1, "mat-icon");
    core/* ɵɵtext */._uU(2, "volume_up");
    core/* ɵɵelementEnd */.qZA();
} }
function RaceAnalysisComponent_div_20_ng_template_14_tr_10_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r59 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 76);
    core/* ɵɵelementStart */.TgZ(1, "button", 77);
    core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_div_20_ng_template_14_tr_10_div_7_Template_button_click_1_listener() { core/* ɵɵrestoreView */.CHM(_r59); const radio_r53 = core/* ɵɵnextContext */.oxw().$implicit; return radio_r53.active = true; });
    core/* ɵɵelementStart */.TgZ(2, "mat-icon");
    core/* ɵɵtext */._uU(3, "volume_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function RaceAnalysisComponent_div_20_ng_template_14_tr_10_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "audio", 78);
    core/* ɵɵelement */._UZ(2, "source", 79);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const radio_r53 = core/* ɵɵnextContext */.oxw().$implicit;
    const ctx_r56 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("src", ctx_r56.livetimingUrl + radio_r53.path, core/* ɵɵsanitizeUrl */.LSH);
} }
function RaceAnalysisComponent_div_20_ng_template_14_tr_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵpipe */.ALo(3, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "td");
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "td");
    core/* ɵɵtemplate */.YNc(7, RaceAnalysisComponent_div_20_ng_template_14_tr_10_div_7_Template, 4, 0, "div", 75);
    core/* ɵɵtemplate */.YNc(8, RaceAnalysisComponent_div_20_ng_template_14_tr_10_div_8_Template, 3, 1, "div", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const radio_r53 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(3, 4, radio_r53.utc, " HH:mm:ss"));
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(radio_r53.driverName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", !radio_r53.active);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", radio_r53.active);
} }
function RaceAnalysisComponent_div_20_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "table", 30);
    core/* ɵɵelementStart */.TgZ(1, "thead");
    core/* ɵɵelementStart */.TgZ(2, "tr", 45);
    core/* ɵɵelementStart */.TgZ(3, "th", 31);
    core/* ɵɵtext */._uU(4, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "th", 31);
    core/* ɵɵtext */._uU(6, "Driver");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 31);
    core/* ɵɵtext */._uU(8, "Audio");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tbody");
    core/* ɵɵtemplate */.YNc(10, RaceAnalysisComponent_div_20_ng_template_14_tr_10_Template, 9, 7, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.radioData);
} }
function RaceAnalysisComponent_div_20_ng_template_16_tr_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td");
    core/* ɵɵtext */._uU(10);
    core/* ɵɵpipe */.ALo(11, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const message_r62 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(message_r62.Lap);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(message_r62.Category + " " + (message_r62.Flag || ""));
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu((message_r62.Scope || "") + " " + (message_r62.Sector || "") + " " + (message_r62.RacingNumber || ""));
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(message_r62.Message);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(11, 5, message_r62.Utc, " HH:mm:ss"));
} }
function RaceAnalysisComponent_div_20_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "table", 30);
    core/* ɵɵelementStart */.TgZ(1, "thead");
    core/* ɵɵelementStart */.TgZ(2, "tr", 45);
    core/* ɵɵelementStart */.TgZ(3, "th", 31);
    core/* ɵɵtext */._uU(4, "Lap");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "th", 80);
    core/* ɵɵtext */._uU(6, "Category");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 81);
    core/* ɵɵtext */._uU(8, "Scope");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 31);
    core/* ɵɵtext */._uU(10, "Message");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 48);
    core/* ɵɵtext */._uU(12, "Time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "tbody");
    core/* ɵɵtemplate */.YNc(14, RaceAnalysisComponent_div_20_ng_template_16_tr_14_Template, 12, 8, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r14 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(14);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r14.raceControlMessages);
} }
function RaceAnalysisComponent_div_20_ng_template_18_div_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 3);
    core/* ɵɵelementStart */.TgZ(1, "div", 4);
    core/* ɵɵelementStart */.TgZ(2, "div", 39);
    core/* ɵɵelementStart */.TgZ(3, "div", 87);
    core/* ɵɵelement */._UZ(4, "apx-chart", 88);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r64 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("series", ctx_r64.lapsHeatMapChartOptions.series)("chart", ctx_r64.lapsHeatMapChartOptions.chart)("dataLabels", ctx_r64.lapsHeatMapChartOptions.dataLabels)("plotOptions", ctx_r64.lapsHeatMapChartOptions.plotOptions)("colors", ctx_r64.lapsHeatMapChartOptions.colors)("tooltip", ctx_r64.lapsHeatMapChartOptions.tooltip);
} }
function RaceAnalysisComponent_div_20_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    const _r66 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 3);
    core/* ɵɵelementStart */.TgZ(1, "div", 4);
    core/* ɵɵelementStart */.TgZ(2, "div", 39);
    core/* ɵɵelementStart */.TgZ(3, "div");
    core/* ɵɵelementStart */.TgZ(4, "mat-radio-group", 82);
    core/* ɵɵlistener */.NdJ("ngModelChange", function RaceAnalysisComponent_div_20_ng_template_18_Template_mat_radio_group_ngModelChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r66); const ctx_r65 = core/* ɵɵnextContext */.oxw(2); return ctx_r65.selectedHeatmapRadio = $event; });
    core/* ɵɵelementStart */.TgZ(5, "mat-radio-button", 83);
    core/* ɵɵlistener */.NdJ("change", function RaceAnalysisComponent_div_20_ng_template_18_Template_mat_radio_button_change_5_listener($event) { core/* ɵɵrestoreView */.CHM(_r66); const ctx_r67 = core/* ɵɵnextContext */.oxw(2); return ctx_r67.heatRadioChange($event); });
    core/* ɵɵtext */._uU(6, "Lap times ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-radio-button", 84);
    core/* ɵɵlistener */.NdJ("change", function RaceAnalysisComponent_div_20_ng_template_18_Template_mat_radio_button_change_7_listener($event) { core/* ɵɵrestoreView */.CHM(_r66); const ctx_r68 = core/* ɵɵnextContext */.oxw(2); return ctx_r68.heatRadioChange($event); });
    core/* ɵɵtext */._uU(8, "Lap time positions ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(9, "span");
    core/* ɵɵelementStart */.TgZ(10, "mat-radio-button", 85);
    core/* ɵɵlistener */.NdJ("change", function RaceAnalysisComponent_div_20_ng_template_18_Template_mat_radio_button_change_10_listener($event) { core/* ɵɵrestoreView */.CHM(_r66); const ctx_r69 = core/* ɵɵnextContext */.oxw(2); return ctx_r69.heatRadioChange($event); });
    core/* ɵɵtext */._uU(11, "Driver positions ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(12, RaceAnalysisComponent_div_20_ng_template_18_div_12_Template, 5, 6, "div", 86);
} if (rf & 2) {
    const ctx_r15 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r15.selectedHeatmapRadio);
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r15.status == 1);
} }
function RaceAnalysisComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r71 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 17);
    core/* ɵɵelementStart */.TgZ(1, "mat-tab-group", 18);
    core/* ɵɵlistener */.NdJ("selectedIndexChange", function RaceAnalysisComponent_div_20_Template_mat_tab_group_selectedIndexChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r71); const ctx_r70 = core/* ɵɵnextContext */.oxw(); return ctx_r70.selectedTab = $event; })("selectedTabChange", function RaceAnalysisComponent_div_20_Template_mat_tab_group_selectedTabChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r71); const ctx_r72 = core/* ɵɵnextContext */.oxw(); return ctx_r72.tabChanged($event); });
    core/* ɵɵelementStart */.TgZ(2, "mat-tab", 19);
    core/* ɵɵtemplate */.YNc(3, RaceAnalysisComponent_div_20_ng_template_3_Template, 17, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab", 21);
    core/* ɵɵtemplate */.YNc(5, RaceAnalysisComponent_div_20_ng_template_5_Template, 13, 16, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "mat-tab", 22);
    core/* ɵɵtemplate */.YNc(7, RaceAnalysisComponent_div_20_ng_template_7_Template, 29, 2, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "mat-tab", 23);
    core/* ɵɵtemplate */.YNc(9, RaceAnalysisComponent_div_20_ng_template_9_Template, 34, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "mat-tab", 24);
    core/* ɵɵtemplate */.YNc(11, RaceAnalysisComponent_div_20_ng_template_11_Template, 16, 4, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "mat-tab", 25);
    core/* ɵɵtemplate */.YNc(13, RaceAnalysisComponent_div_20_ng_template_13_Template, 3, 0, "ng-template", 26);
    core/* ɵɵtemplate */.YNc(14, RaceAnalysisComponent_div_20_ng_template_14_Template, 11, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "mat-tab", 27);
    core/* ɵɵtemplate */.YNc(16, RaceAnalysisComponent_div_20_ng_template_16_Template, 15, 1, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(17, "mat-tab", 28);
    core/* ɵɵtemplate */.YNc(18, RaceAnalysisComponent_div_20_ng_template_18_Template, 13, 2, "ng-template", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r2.selectedTab);
    core/* ɵɵadvance */.xp6(16);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r2.status == 2);
} }
class RaceAnalysisComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.selectedTab = 0;
        this.driverCodes = [];
        this.chartWidth = '100%';
        this.selectedHeatmapRadio = '1';
        this.slowestLap = 0;
        this.defChartResponsiveWidth = {
            animations: {
                enabled: true,
                easing: 'easeinout',
                speed: 500,
                animateGradually: {
                    enabled: true,
                    delay: 50
                },
            },
            height: 350,
            width: this.chartWidth,
            type: 'line',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.defDataLabels = {
            enabled: false
        };
        this.defGrid = {
            borderColor: '#e7e7e7',
            row: {
                colors: ['#f3f3f3', 'transparent'],
                opacity: 0.5
            }
        };
        this.defStroke = {
            curve: 'straight'
        };
        this.reverseYAxis = {
            min: 1,
            // tickAmount:6 ,
            decimalsInFloat: 0,
            reversed: true,
            axisTicks: {
                show: true
            },
            axisBorder: {
                show: true,
                color: '#008FFB'
            },
            title: {
                text: 'Position',
            }
        };
        this.lapXaxis = {
            labels: {
                formatter: function (value, timestamp, opts) {
                    var y = +value - 1;
                    return '' + y;
                }
            },
            title: {
                text: 'Lap',
            }
        };
        restService.getRaceAnalysis().subscribe({
            next: data => {
                this.title = data.title;
                this.utilityService.setTitle(6, this.title);
                this.livetimingUrl = data.livetimingUrl;
                this.radioData = data.radioData;
                this.status = data.status;
                this.drivers = data.driverData;
                this.driversChampionshipPrediction = data.driversChampionshipPrediction;
                this.teamsChampionshipPrediction = data.teamsChampionshipPrediction;
                this.raceControlMessages = data.raceControlMessages;
                this.timingStats = data.timingStats;
                this.bestSpeedKeys = data.bestSpeedKeys;
                this.lapTimesLowerLimit = this.getLowerLimit();
                this.chartWidth = this.calculateChartWidthForMobileDevices(this.drivers[0].lapByLapData.positions.length);
                this.setDriverCharts();
                this.driversByPositionReverse = this.sortDrivers(this.drivers, 'position', 'desc');
                this.fastestLaps = this.setFastestLaps(this.drivers);
                if (this.status < 2) {
                    this.setLapsHeatMapChart();
                }
                return data;
            }
        });
        this.selectedTab = this.getSelectedTab();
    }
    getLowerLimit() {
        let fastestLap = this.timingStats[0].PersonalBestLapTime.Value;
        this.fastestLap = this.stringToMiliseconds(fastestLap);
        let milisecondsString = '' + this.stringToMiliseconds(fastestLap);
        milisecondsString = milisecondsString.substring(0, milisecondsString.length - 3) + '000';
        return Number(milisecondsString);
    }
    stringToMiliseconds(stringTime) {
        let array1 = stringTime.split(':');
        let miliseconds = +array1[0] * 60000;
        let array2 = array1[1].split('.');
        miliseconds += +array2[0] * 1000;
        miliseconds += +array2[1];
        return miliseconds;
    }
    setFastestLaps(drivers) {
        let fastestLaps = [];
        for (let i = 0; i < this.maxLaps; i++) {
            let fastestLap = 3600000;
            for (let driver of drivers) {
                if (driver.lapByLapData.lapTimesYms[i] < fastestLap) {
                    fastestLap = driver.lapByLapData.lapTimesYms[i];
                }
                if (driver.lapByLapData.lapTimesYms[i] > this.slowestLap) {
                    this.slowestLap = driver.lapByLapData.lapTimesYms[i];
                }
            }
            fastestLaps.push(fastestLap);
        }
        return fastestLaps;
    }
    sortDrivers(drivers, number, direction) {
        let sorted = [];
        let undefineds = 1;
        if (direction == 'asc') {
            switch (number) {
                case 'position':
                    drivers.forEach((driver) => {
                        sorted[driver.position - 1] = driver;
                    });
                    return sorted;
                    break;
                case 'startingPosition':
                    drivers.forEach((driver) => {
                        sorted[driver.startingPosition - 1] = driver;
                    });
                    return sorted;
                    break;
                    return sorted;
                    break;
                case 'standing':
                    let sortByStanding = drivers.slice();
                    sortByStanding.sort(function (a, b) {
                        if (a.TeamName < b.TeamName) {
                            return -1;
                        }
                        if (a.TeamName > b.TeamName) {
                            return 1;
                        }
                        return 0;
                    });
                    return sortByStanding;
                    break;
            }
        }
        if (direction == 'desc') {
            undefineds = 0;
            switch (number) {
                case 'position':
                    drivers.forEach((driver) => {
                        sorted[drivers.length - driver.position] = driver;
                    });
                    return sorted;
                    break;
                case 'startingPosition':
                    drivers.forEach((driver) => {
                        sorted[drivers.length - driver.startingPosition] = driver;
                    });
                    return sorted;
                    break;
                    return sorted;
                    break;
            }
        }
        return drivers;
    }
    getSelectedTab() {
        let tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == undefined) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    tabChanged(tabChangeEvent) {
        this.updateUrl();
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    static getColor(type) {
        switch (type) {
            case 'H':
            case 'HARD':
                // return "#f0f0f0";
                return '#b0b0b0';
            case 'M':
            case 'MEDIUM':
                return '#ffd100';
            case 'S':
            case 'SOFT':
                return '#da291c';
            case 'I':
            case 'INTERMEDIATE':
                return '#43b02a';
            case 'W':
            case 'WET':
                return '#0068ad';
            default:
                return '#000000';
        }
    }
    openRadioDialog(radioData) {
        const dialogRef = this.dialog.open(RadioPopupComponent);
        dialogRef.componentInstance.radioData = radioData;
        dialogRef.componentInstance.baseUrl = this.livetimingUrl;
    }
    setDriverCharts() {
        let positionsByLapchartSeries = [];
        let tyresByLapchartSeries = [];
        for (let driver of this.drivers) {
            let color = driver.TeamColour;
            if (color == 'FFFFFF') {
                color = '888888';
            }
            positionsByLapchartSeries.push({
                name: driver.Tla,
                data: driver.lapByLapData.positions,
                color: '#' + color
            });
            let lowerLimit = 0;
            for (let tyre of driver.lapByLapData.tyres) {
                let duration = tyre.TotalLaps - tyre.StartLaps;
                tyresByLapchartSeries.push({
                    name: duration + ' LAPS ON ('
                        + tyre.Compound + ')',
                    data: [
                        {
                            x: driver.Tla,
                            y: [
                                lowerLimit,
                                lowerLimit + duration
                            ]
                        }
                    ],
                    color: RaceAnalysisComponent.getColor(tyre.Compound)
                });
                lowerLimit = lowerLimit + duration;
            }
            this.driverCodes.push(driver.Tla);
        }
        this.lapPosChart = {
            series: positionsByLapchartSeries,
            title: {
                text: 'Position by lap',
                align: 'center'
            },
        };
        this.lapTyreChart = {
            series: tyresByLapchartSeries,
            title: {
                text: 'Tyres by lap',
                align: 'center'
            },
            chart: {
                height: 500,
                type: 'rangeBar',
                zoom: {
                    enabled: false
                },
                toolbar: ChartUtility.defaultToolbar
            },
            plotOptions: {
                bar: {
                    horizontal: true,
                    borderRadius: 10,
                    barHeight: '90%',
                    rangeBarGroupRows: true
                }
            },
            fill: {
                type: 'solid'
            },
            xaxis: {
                type: 'datetime',
                title: {
                    text: 'Lap',
                }
            },
            legend: {
                show: false,
                position: 'right'
            },
            tooltip: {
                custom: function (opts) {
                    const fromYear = opts.y1;
                    const toYear = opts.y2;
                    const values = opts.ctx.rangeBar.getTooltipValues(opts);
                    return ('<div class="apexcharts-tooltip-rangebar">' +
                        '<div> <span class="series-name" style="color: ' +
                        values.color +
                        '">' + values.seriesName +
                        '</span></div>' +
                        '<div> <span class="category">' +
                        ' </span> <span class="value start-value">' +
                        fromYear +
                        '</span> <span class="separator">-</span> <span class="value end-value">' +
                        toYear +
                        '</span></div>' +
                        '</div>');
                }
            }
        };
    }
    calculateChartWidthForMobileDevices(laps) {
        let width = window.screen.width;
        if (width > 1299 || laps < 15) {
            return '100%';
        }
        let newWidth = laps * 20 + 'px';
        this.defChartResponsiveWidth.width = newWidth;
        return newWidth;
    }
    positionChange(input) {
        if (input.CurrentPosition == input.PredictedPosition || input.CurrentPosition == null) {
            return '';
        }
        if (input.CurrentPosition > input.PredictedPosition) {
            let difference = input.CurrentPosition - input.PredictedPosition;
            let response = ' ';
            for (let i = 0; i < difference; i++) {
                response = response + '↑';
            }
            return response;
        }
        if (input.CurrentPosition < input.PredictedPosition) {
            let difference = input.PredictedPosition - input.CurrentPosition;
            let response = ' ';
            for (let i = 0; i < difference; i++) {
                response = response + '↓';
            }
            return response;
        }
    }
    pointsChange(input) {
        if (input.CurrentPoints == input.PredictedPoints || input.CurrentPosition == null) {
            return input.PredictedPoints;
        }
        else {
            return input.CurrentPoints + ' → ' + input.PredictedPoints;
        }
    }
    standingsChangeClass(input) {
        if (input.CurrentPosition == input.PredictedPosition || input.CurrentPosition == null) {
            return '';
        }
        if (input.CurrentPosition > input.PredictedPosition) {
            let difference = input.CurrentPosition - input.PredictedPosition;
            return 'bg-success';
        }
        if (input.CurrentPosition < input.PredictedPosition) {
            let difference = input.CurrentPosition - input.PredictedPosition;
            return 'bg-danger';
        }
    }
    sortTimingStats(sort) {
        let number = sort.active;
        let direction = sort.direction;
        let sorted = [];
        if (direction == 'asc') {
            switch (number) {
                case '1':
                    this.timingStats.forEach((stat) => {
                        sorted[stat.PersonalBestLapTime.Position - 1] = stat;
                    });
                    break;
                case '2':
                    this.timingStats.forEach((stat) => {
                        sorted[stat.BestSectors[0].Position - 1] = stat;
                    });
                    break;
                case '3':
                    this.timingStats.forEach((stat) => {
                        sorted[stat.BestSectors[1].Position - 1] = stat;
                    });
                    break;
                case '4':
                    this.timingStats.forEach((stat) => {
                        sorted[stat.BestSectors[2].Position - 1] = stat;
                    });
                    break;
                case '4':
                    this.timingStats.forEach((stat) => {
                        sorted[stat.BestSectors[2].Position - 1] = stat;
                    });
                    break;
            }
        }
        else if (direction == 'desc') {
            switch (number) {
                case '1':
                    this.timingStats.forEach((stat) => {
                        sorted[this.timingStats.length - stat.PersonalBestLapTime.Position] = stat;
                    });
                    break;
                case '2':
                    this.timingStats.forEach((stat) => {
                        sorted[this.timingStats.length - stat.BestSectors[0].Position] = stat;
                    });
                    break;
                case '3':
                    this.timingStats.forEach((stat) => {
                        sorted[this.timingStats.length - stat.BestSectors[1].Position] = stat;
                    });
                    break;
                case '4':
                    this.timingStats.forEach((stat) => {
                        sorted[this.timingStats.length - stat.BestSectors[2].Position] = stat;
                    });
                    break;
            }
        }
        else {
            this.timingStats.forEach((stat) => {
                sorted[stat.PersonalBestLapTime.Position - 1] = stat;
            });
        }
        this.timingStats = sorted;
    }
    sortTopSpeedTimingStats(sort) {
        let key = sort.active;
        let direction = sort.direction;
        let sorted = [];
        if (direction == 'asc') {
            this.timingStats.forEach((stat) => {
                sorted[stat.BestSpeeds[key].Position - 1] = stat;
            });
        }
        else if (direction == 'desc') {
            this.timingStats.forEach((stat) => {
                sorted[this.timingStats.length - stat.BestSpeeds[key].Position] = stat;
            });
        }
        else {
            this.timingStats.forEach((stat) => {
                sorted[stat.PersonalBestLapTime.Position - 1] = stat;
            });
        }
        this.timingStats = sorted;
    }
    heatRadioChange(event) {
        this.selectedHeatmapRadio = event.value;
        this.updateLapsHeatMapLabels();
    }
    updateLapsHeatMapLabels() {
        this.lapsHeatMapChartOptions.dataLabels = {
            enabled: true,
            style: {
                colors: ['#000000']
            },
            formatter: (val, opts) => {
                if (val == 0) {
                    return 'PIT';
                }
                switch (this.selectedHeatmapRadio) {
                    case '1':
                        return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.lapTimesY[opts.dataPointIndex];
                        break;
                    case '2':
                        return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.lapTimePositions[opts.dataPointIndex];
                        break;
                    case '3':
                        return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.positions[opts.dataPointIndex];
                        break;
                    default:
                        return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.lapTimesY[opts.dataPointIndex];
                        break;
                }
                return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.lapTimesY[opts.dataPointIndex];
            }
        };
    }
    setLapsHeatMapChart() {
        let lapsHeatMapSeries = [];
        let counter = 0;
        for (let driver of this.driversByPositionReverse) {
            let lapsHeatMapData = [];
            counter = 0;
            for (let lapTime of driver.lapByLapData.lapTimesYms) {
                let y = 0;
                if (driver.pitstops.includes(counter) || driver.pitstops.includes(counter - 1)) {
                    y = 0;
                }
                else {
                    y = (11000 - lapTime + this.fastestLap) / 1000;
                    if (y < 0) {
                        y = 0.1;
                    }
                }
                lapsHeatMapData.push({
                    x: counter,
                    y: y
                });
                counter++;
            }
            lapsHeatMapSeries.push({
                name: driver.BroadcastName,
                data: lapsHeatMapData
            });
        }
        counter = counter * 20;
        console.log(lapsHeatMapSeries);
        this.lapsHeatMapChartOptions = {
            colors: ['#ff0000'],
            series: lapsHeatMapSeries,
            chart: {
                height: 600,
                width: 2600 + counter,
                type: 'heatmap',
                animations: {
                    enabled: false
                },
                zoom: {
                    enabled: false,
                },
                toolbar: ChartUtility.defaultToolbar
            },
            title: ChartUtility.f1exposureTitle,
            dataLabels: {
                enabled: true,
                style: {
                    colors: ['#000000']
                },
                formatter: (val, opts) => {
                    if (val == 0) {
                        return 'PIT';
                    }
                    return this.driversByPositionReverse[opts.seriesIndex].lapByLapData.lapTimesY[opts.dataPointIndex];
                }
            },
            plotOptions: {
                heatmap: {
                    radius: 2,
                    enableShades: true,
                    // shadeIntensity: 1,
                    //    reverseNegativeShade: true,
                    distributed: false,
                    useFillColorAsStroke: true,
                }
            },
            tooltip: {
                y: {
                    formatter: (val, opts) => {
                        let lap = opts.dataPointIndex + 1;
                        return 'Lap ' + lap;
                    }
                }
            }
        };
    }
}
RaceAnalysisComponent.ɵfac = function RaceAnalysisComponent_Factory(t) { return new (t || RaceAnalysisComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
RaceAnalysisComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: RaceAnalysisComponent, selectors: [["app-race-analysis-cmp"]], viewQuery: function RaceAnalysisComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(race_analysis_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 21, vars: 4, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "\u201Dmat-content\u201D", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "\u201Dmat-content\u201D"], [3, "selectedIndex", "selectedIndexChange", "selectedTabChange"], ["label", "Result"], ["matTabContent", ""], ["label", "Lap-by-Lap"], ["label", "New standings"], ["label", "Fastest laps"], ["label", "Top speeds"], ["label", "Radio"], ["mat-tab-label", ""], ["label", "RaceControl Messages"], ["label", "Laps heatmap", 3, "disabled"], [1, "row", "col-padding-1"], [1, "table", "table-striped"], ["scope", "col"], ["scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["scope", "col", 1, "w-20px"], ["scope", "row"], [1, "d-sm-none", "d-none", "d-lg-table-cell"], [1, "no-padding-td"], ["color", "primary", "mat-mini-fab", "", 3, "click", 4, "ngIf"], ["color", "primary", "mat-mini-fab", "", 3, "click"], [1, "card"], [1, "overflowX", "card-body-padded"], [3, "series", "chart", "dataLabels", "grid", "stroke", "title", "yaxis", "xaxis"], [1, "card-body-padded"], [3, "title", "series", "chart", "fill", "legend", "plotOptions", "xaxis", "tooltip"], [1, "col-12", "col-xl-6", "pl-xl-4", "pt-2"], [1, "text-center", "bg-primary", "text-white"], ["colspan", "3"], ["scope", "col", 2, "width", "55px"], ["scope", "col", 2, "width", "100px"], [1, "col-12", "col-xl-6", "px-xl-4", "pt-2"], [3, "class", 4, "ngFor", "ngForOf"], [4, "ngIf"], [1, "text-left"], ["matSort", "", 1, "table", "table-striped", 3, "matSortChange"], ["scope", "col", 1, "bg-grey"], ["mat-sort-header", "1", "colspan", "2", "scope", "col", 1, "text-center"], ["mat-sort-header", "2", "colspan", "2", "scope", "col", 1, "text-center", "bg-grey"], ["mat-sort-header", "3", "colspan", "2", "scope", "col", 1, "text-center"], ["mat-sort-header", "4", "colspan", "2", "scope", "col", 1, "text-center", "bg-grey"], ["scope", "col", 1, "bg-grey", 2, "width", "200px"], ["mat-sort-header", "1", "scope", "col", 2, "width", "70px"], ["mat-sort-header", "1", "scope", "col", 2, "width", "40px"], ["mat-sort-header", "2", "scope", "col", 1, "bg-grey", 2, "width", "70px"], ["mat-sort-header", "2", "scope", "col", 1, "bg-grey", 2, "width", "40px"], ["mat-sort-header", "3", "scope", "col", 2, "width", "70px"], ["mat-sort-header", "3", "scope", "col", 2, "width", "40px"], ["mat-sort-header", "4", "scope", "col", 1, "bg-grey", 2, "width", "70px"], ["mat-sort-header", "4", "scope", "col", 1, "bg-grey", 2, "width", "40px"], ["scope", "col", 1, "text-center"], ["style", "width: 50px", "colspan", "2", "class", "text-center", "scope", "col", 4, "ngFor", "ngForOf"], ["colspan", "2", "scope", "col", 1, "text-center", 2, "width", "50px"], ["scope", "col", 1, "text-center", 2, "width", "90px", 3, "mat-sort-header"], ["scope", "col", 1, "text-center", 2, "width", "40px", 3, "mat-sort-header"], [1, "text-right"], [1, "text-center"], ["class", "div-padded-always-left-right-1", 4, "ngIf"], [1, "div-padded-always-left-right-1"], ["color", "accent", "mat-mini-fab", "", 3, "click"], ["controls", ""], [3, "src"], ["scope", "col", 2, "width", "120px"], ["scope", "col", 2, "width", "110px"], ["aria-label", "Select an option", 3, "ngModel", "ngModelChange"], ["checked", "", "value", "1", 1, "div-padded-always-0-3rem", 3, "change"], ["value", "2", 1, "div-padded-always-0-3rem", 3, "change"], ["value", "3", 1, "div-padded-always-0-3rem", 3, "change"], ["class", "row", 4, "ngIf"], [1, "overflowXAlways", "pr-1"], [3, "series", "chart", "dataLabels", "plotOptions", "colors", "tooltip"]], template: function RaceAnalysisComponent_Template(rf, ctx) { if (rf & 1) {
        const _r73 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function RaceAnalysisComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function RaceAnalysisComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(6); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(6); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, RaceAnalysisComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r73); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function RaceAnalysisComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r73); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, RaceAnalysisComponent_div_20_Template, 19, 2, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.drivers != undefined);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, tabs/* MatTabLabel */.uD, icon/* MatIcon */.Hw, ng_apexcharts/* ChartComponent */.x, MatSort, MatSortHeader, fesm2015_radio/* MatRadioGroup */.VQ, fesm2015_radio/* MatRadioButton */.U0], pipes: [common/* DatePipe */.uU], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/model/TrippleInstagramFeed.ts
class TrippleInstagramFeed {
    constructor() {
        this.first = [];
        this.second = [];
        this.third = [];
    }
}

;// CONCATENATED MODULE: ./src/app/model/trippleTwitterFeed.ts
class TrippleTwitterFeed {
    constructor() {
        this.first = [];
        this.second = [];
        this.third = [];
    }
}

;// CONCATENATED MODULE: ./src/app/model/trippleRedditFeed.ts
class TrippleRedditFeed {
    constructor() {
        this.first = [];
        this.second = [];
        this.third = [];
    }
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(9773);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js
var scheduler_async = __webpack_require__(3637);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttle.js

const defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config = defaultThrottleConfig) {
    return (source) => source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));
}
class ThrottleOperator {
    constructor(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    call(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    }
}
class ThrottleSubscriber extends (/* unused pure expression or super */ null && (SimpleOuterSubscriber)) {
    constructor(destination, durationSelector, _leading, _trailing) {
        super(destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasValue = false;
    }
    _next(value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    }
    send() {
        const { _hasValue, _sendValue } = this;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    }
    throttle(value) {
        const duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
    }
    tryDurationSelector(value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    }
    throttlingDone() {
        const { _throttled, _trailing } = this;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    }
    notifyNext() {
        this.throttlingDone();
    }
    notifyComplete() {
        this.throttlingDone();
    }
}
//# sourceMappingURL=throttle.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js



function throttleTime(duration, scheduler = scheduler_async/* async */.P, config = defaultThrottleConfig) {
    return (source) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
}
class ThrottleTimeOperator {
    constructor(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    call(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    }
}
class ThrottleTimeSubscriber extends Subscriber/* Subscriber */.L {
    constructor(destination, duration, scheduler, leading, trailing) {
        super(destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    _next(value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    }
    _complete() {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    }
    clearThrottle() {
        const throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    }
}
function dispatchNext(arg) {
    const { subscriber } = arg;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map
;// CONCATENATED MODULE: ./node_modules/ngx-infinite-scroll/__ivy_ngcc__/modules/ngx-infinite-scroll.js




/**
 * @fileoverview added by tsickle
 * Generated from: src/services/ngx-ins-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} selector
 * @param {?} scrollWindow
 * @param {?} defaultElement
 * @param {?} fromRoot
 * @return {?}
 */

function resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {
    /** @type {?} */
    const hasWindow = window && !!window.document && window.document.documentElement;
    /** @type {?} */
    let container = hasWindow && scrollWindow ? window : defaultElement;
    if (selector) {
        /** @type {?} */
        const containerIsString = selector && hasWindow && typeof selector === 'string';
        container = containerIsString
            ? findElement(selector, defaultElement.nativeElement, fromRoot)
            : selector;
        if (!container) {
            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');
        }
    }
    return container;
}
/**
 * @param {?} selector
 * @param {?} customRoot
 * @param {?} fromRoot
 * @return {?}
 */
function findElement(selector, customRoot, fromRoot) {
    /** @type {?} */
    const rootEl = fromRoot ? window.document : customRoot;
    return rootEl.querySelector(selector);
}
/**
 * @param {?} prop
 * @return {?}
 */
function inputPropChanged(prop) {
    return prop && !prop.firstChange;
}
/**
 * @return {?}
 */
function hasWindowDefined() {
    return typeof window !== 'undefined';
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/axis-resolver.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VerticalProps = {
    clientHeight: "clientHeight",
    offsetHeight: "offsetHeight",
    scrollHeight: "scrollHeight",
    pageYOffset: "pageYOffset",
    offsetTop: "offsetTop",
    scrollTop: "scrollTop",
    top: "top"
};
/** @type {?} */
const HorizontalProps = {
    clientHeight: "clientWidth",
    offsetHeight: "offsetWidth",
    scrollHeight: "scrollWidth",
    pageYOffset: "pageXOffset",
    offsetTop: "offsetLeft",
    scrollTop: "scrollLeft",
    top: "left"
};
class AxisResolver {
    /**
     * @param {?=} vertical
     */
    constructor(vertical = true) {
        this.vertical = vertical;
        this.propsMap = vertical ? VerticalProps : HorizontalProps;
    }
    /**
     * @return {?}
     */
    clientHeightKey() {
        return this.propsMap.clientHeight;
    }
    /**
     * @return {?}
     */
    offsetHeightKey() {
        return this.propsMap.offsetHeight;
    }
    /**
     * @return {?}
     */
    scrollHeightKey() {
        return this.propsMap.scrollHeight;
    }
    /**
     * @return {?}
     */
    pageYOffsetKey() {
        return this.propsMap.pageYOffset;
    }
    /**
     * @return {?}
     */
    offsetTopKey() {
        return this.propsMap.offsetTop;
    }
    /**
     * @return {?}
     */
    scrollTopKey() {
        return this.propsMap.scrollTop;
    }
    /**
     * @return {?}
     */
    topKey() {
        return this.propsMap.top;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/event-trigger.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @param {?} alwaysCallback
 * @param {?} shouldFireScrollEvent
 * @param {?} isTriggeredCurrentTotal
 * @return {?}
 */
function shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {
    if (alwaysCallback && shouldFireScrollEvent) {
        return true;
    }
    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {
        return true;
    }
    return false;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/position-resolver.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} __0
 * @return {?}
 */
function createResolver({ windowElement, axis }) {
    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);
}
/**
 * @param {?} resolver
 * @param {?} windowElement
 * @return {?}
 */
function createResolverWithContainer(resolver, windowElement) {
    /** @type {?} */
    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)
        ? windowElement
        : windowElement.nativeElement;
    return Object.assign(Object.assign({}, resolver), { container });
}
/**
 * @param {?} windowElement
 * @return {?}
 */
function isElementWindow(windowElement) {
    /** @type {?} */
    const isWindow = ['Window', 'global'].some((/**
     * @param {?} obj
     * @return {?}
     */
    (obj) => Object.prototype.toString.call(windowElement).includes(obj)));
    return isWindow;
}
/**
 * @param {?} isContainerWindow
 * @param {?} windowElement
 * @return {?}
 */
function getDocumentElement(isContainerWindow, windowElement) {
    return isContainerWindow ? windowElement.document.documentElement : null;
}
/**
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePoints(element, resolver) {
    /** @type {?} */
    const height = extractHeightForElement(resolver);
    return resolver.isWindow
        ? calculatePointsForWindow(height, element, resolver)
        : calculatePointsForElement(height, element, resolver);
}
/**
 * @param {?} height
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePointsForWindow(height, element, resolver) {
    const { axis, container, isWindow } = resolver;
    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);
    // scrolled until now / current y point
    /** @type {?} */
    const scrolled = height +
        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);
    // total height / most bottom y point
    /** @type {?} */
    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);
    /** @type {?} */
    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +
        nativeElementHeight;
    return { height, scrolled, totalToScroll, isWindow };
}
/**
 * @param {?} height
 * @param {?} element
 * @param {?} resolver
 * @return {?}
 */
function calculatePointsForElement(height, element, resolver) {
    const { axis, container } = resolver;
    // perhaps use container.offsetTop instead of 'scrollTop'
    /** @type {?} */
    const scrolled = container[axis.scrollTopKey()];
    /** @type {?} */
    const totalToScroll = container[axis.scrollHeightKey()];
    return { height, scrolled, totalToScroll, isWindow: false };
}
/**
 * @param {?} axis
 * @return {?}
 */
function extractHeightPropKeys(axis) {
    return {
        offsetHeightKey: axis.offsetHeightKey(),
        clientHeightKey: axis.clientHeightKey()
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function extractHeightForElement({ container, isWindow, axis }) {
    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);
    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);
}
/**
 * @param {?} elem
 * @param {?} isWindow
 * @param {?} offsetHeightKey
 * @param {?} clientHeightKey
 * @return {?}
 */
function getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {
    if (isNaN(elem[offsetHeightKey])) {
        /** @type {?} */
        const docElem = getDocumentElement(isWindow, elem);
        return docElem ? docElem[clientHeightKey] : 0;
    }
    else {
        return elem[offsetHeightKey];
    }
}
/**
 * @param {?} elem
 * @param {?} axis
 * @param {?} isWindow
 * @return {?}
 */
function getElementOffsetTop(elem, axis, isWindow) {
    /** @type {?} */
    const topKey = axis.topKey();
    // elem = elem.nativeElement;
    if (!elem.getBoundingClientRect) {
        // || elem.css('none')) {
        return;
    }
    return (elem.getBoundingClientRect()[topKey] +
        getElementPageYOffset(elem, axis, isWindow));
}
/**
 * @param {?} elem
 * @param {?} axis
 * @param {?} isWindow
 * @return {?}
 */
function getElementPageYOffset(elem, axis, isWindow) {
    /** @type {?} */
    const pageYOffset = axis.pageYOffsetKey();
    /** @type {?} */
    const scrollTop = axis.scrollTopKey();
    /** @type {?} */
    const offsetTop = axis.offsetTopKey();
    if (isNaN(window.pageYOffset)) {
        return getDocumentElement(isWindow, elem)[scrollTop];
    }
    else if (elem.ownerDocument) {
        return elem.ownerDocument.defaultView[pageYOffset];
    }
    else {
        return elem[offsetTop];
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/scroll-resolver.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} container
 * @param {?} distance
 * @param {?} scrollingDown
 * @return {?}
 */
function shouldFireScrollEvent(container, distance, scrollingDown) {
    /** @type {?} */
    let remaining;
    /** @type {?} */
    let containerBreakpoint;
    if (container.totalToScroll <= 0) {
        return false;
    }
    /** @type {?} */
    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;
    if (scrollingDown) {
        remaining =
            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;
        containerBreakpoint = distance.down / 10;
    }
    else {
        /** @type {?} */
        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);
        remaining = container.scrolled / totalHiddenContentHeight;
        containerBreakpoint = distance.up / 10;
    }
    /** @type {?} */
    const shouldFireEvent = remaining <= containerBreakpoint;
    return shouldFireEvent;
}
/**
 * @param {?} lastScrollPosition
 * @param {?} container
 * @return {?}
 */
function isScrollingDownwards(lastScrollPosition, container) {
    return lastScrollPosition < container.scrolled;
}
/**
 * @param {?} lastScrollPosition
 * @param {?} container
 * @param {?} distance
 * @return {?}
 */
function getScrollStats(lastScrollPosition, container, distance) {
    /** @type {?} */
    const scrollDown = isScrollingDownwards(lastScrollPosition, container);
    return {
        fire: shouldFireScrollEvent(container, distance, scrollDown),
        scrollDown
    };
}
/**
 * @param {?} position
 * @param {?} scrollState
 * @return {?}
 */

/**
 * @param {?} totalToScroll
 * @param {?} scrollState
 * @return {?}
 */

/**
 * @param {?} scrollState
 * @return {?}
 */

/**
 * @param {?} scroll
 * @param {?} scrollState
 * @param {?} triggered
 * @param {?} isScrollingDown
 * @return {?}
 */

/**
 * @param {?} totalToScroll
 * @param {?} scrollState
 * @param {?} isScrollingDown
 * @return {?}
 */

/**
 * @param {?} scrollState
 * @param {?} scrolledUntilNow
 * @param {?} totalToScroll
 * @return {?}
 */

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/scroll-state.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollState {
    /**
     * @param {?} __0
     */
    constructor({ totalToScroll }) {
        this.lastScrollPosition = 0;
        this.lastTotalToScroll = 0;
        this.totalToScroll = 0;
        this.triggered = {
            down: 0,
            up: 0
        };
        this.totalToScroll = totalToScroll;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    updateScrollPosition(position) {
        return (this.lastScrollPosition = position);
    }
    /**
     * @param {?} totalToScroll
     * @return {?}
     */
    updateTotalToScroll(totalToScroll) {
        if (this.lastTotalToScroll !== totalToScroll) {
            this.lastTotalToScroll = this.totalToScroll;
            this.totalToScroll = totalToScroll;
        }
    }
    /**
     * @param {?} scrolledUntilNow
     * @param {?} totalToScroll
     * @return {?}
     */
    updateScroll(scrolledUntilNow, totalToScroll) {
        this.updateScrollPosition(scrolledUntilNow);
        this.updateTotalToScroll(totalToScroll);
    }
    /**
     * @param {?} scroll
     * @param {?} isScrollingDown
     * @return {?}
     */
    updateTriggeredFlag(scroll, isScrollingDown) {
        if (isScrollingDown) {
            this.triggered.down = scroll;
        }
        else {
            this.triggered.up = scroll;
        }
    }
    /**
     * @param {?} totalToScroll
     * @param {?} isScrollingDown
     * @return {?}
     */
    isTriggeredScroll(totalToScroll, isScrollingDown) {
        return isScrollingDown
            ? this.triggered.down === totalToScroll
            : this.triggered.up === totalToScroll;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/services/scroll-register.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function createScroller(config) {
    const { scrollContainer, scrollWindow, element, fromRoot } = config;
    /** @type {?} */
    const resolver = createResolver({
        axis: new AxisResolver(!config.horizontal),
        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)
    });
    /** @type {?} */
    const scrollState = new ScrollState({
        totalToScroll: calculatePoints(element, resolver)
    });
    /** @type {?} */
    const options = {
        container: resolver.container,
        throttle: config.throttle
    };
    /** @type {?} */
    const distance = {
        up: config.upDistance,
        down: config.downDistance
    };
    return attachScrollEvent(options).pipe((0,mergeMap/* mergeMap */.zg)((/**
     * @return {?}
     */
    () => (0,of.of)(calculatePoints(element, resolver)))), (0,operators_map/* map */.U)((/**
     * @param {?} positionStats
     * @return {?}
     */
    (positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance))), (0,tap/* tap */.b)((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll))), (0,filter/* filter */.h)((/**
     * @param {?} __0
     * @return {?}
     */
    ({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown)))), (0,tap/* tap */.b)((/**
     * @param {?} __0
     * @return {?}
     */
    ({ scrollDown, stats: { totalToScroll } }) => {
        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);
    })), (0,operators_map/* map */.U)(toInfiniteScrollAction));
}
/**
 * @param {?} options
 * @return {?}
 */
function attachScrollEvent(options) {
    /** @type {?} */
    let obs = (0,fromEvent/* fromEvent */.R)(options.container, 'scroll');
    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.
    // Let's avoid calling the function unless needed.
    // Replacing with throttleTime seems to solve the problem
    // See https://github.com/orizens/ngx-infinite-scroll/issues/198
    if (options.throttle) {
        obs = obs.pipe(throttleTime(options.throttle));
    }
    return obs;
}
/**
 * @param {?} lastScrollPosition
 * @param {?} stats
 * @param {?} distance
 * @return {?}
 */
function toInfiniteScrollParams(lastScrollPosition, stats, distance) {
    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);
    return {
        scrollDown,
        fire,
        stats
    };
}
/** @type {?} */
const InfiniteScrollActions = {
    DOWN: '[NGX_ISE] DOWN',
    UP: '[NGX_ISE] UP'
};
/**
 * @param {?} response
 * @return {?}
 */
function toInfiniteScrollAction(response) {
    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;
    return {
        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,
        payload: {
            currentScrollPosition
        }
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/modules/infinite-scroll.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InfiniteScrollDirective {
    /**
     * @param {?} element
     * @param {?} zone
     */
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        this.scrolled = new core/* EventEmitter */.vpe();
        this.scrolledUp = new core/* EventEmitter */.vpe();
        this.infiniteScrollDistance = 2;
        this.infiniteScrollUpDistance = 1.5;
        this.infiniteScrollThrottle = 150;
        this.infiniteScrollDisabled = false;
        this.infiniteScrollContainer = null;
        this.scrollWindow = true;
        this.immediateCheck = false;
        this.horizontal = false;
        this.alwaysCallback = false;
        this.fromRoot = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.infiniteScrollDisabled) {
            this.setup();
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {
        /** @type {?} */
        const containerChanged = inputPropChanged(infiniteScrollContainer);
        /** @type {?} */
        const disabledChanged = inputPropChanged(infiniteScrollDisabled);
        /** @type {?} */
        const distanceChanged = inputPropChanged(infiniteScrollDistance);
        /** @type {?} */
        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||
            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;
        if (containerChanged || disabledChanged || distanceChanged) {
            this.destroyScroller();
            if (shouldSetup) {
                this.setup();
            }
        }
    }
    /**
     * @return {?}
     */
    setup() {
        if (hasWindowDefined()) {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.disposeScroller = createScroller({
                    fromRoot: this.fromRoot,
                    alwaysCallback: this.alwaysCallback,
                    disable: this.infiniteScrollDisabled,
                    downDistance: this.infiniteScrollDistance,
                    element: this.element,
                    horizontal: this.horizontal,
                    scrollContainer: this.infiniteScrollContainer,
                    scrollWindow: this.scrollWindow,
                    throttle: this.infiniteScrollThrottle,
                    upDistance: this.infiniteScrollUpDistance
                }).subscribe((/**
                 * @param {?} payload
                 * @return {?}
                 */
                (payload) => this.zone.run((/**
                 * @return {?}
                 */
                () => this.handleOnScroll(payload)))));
            }));
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleOnScroll({ type, payload }) {
        switch (type) {
            case InfiniteScrollActions.DOWN:
                return this.scrolled.emit(payload);
            case InfiniteScrollActions.UP:
                return this.scrolledUp.emit(payload);
            default:
                return;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyScroller();
    }
    /**
     * @return {?}
     */
    destroyScroller() {
        if (this.disposeScroller) {
            this.disposeScroller.unsubscribe();
        }
    }
}
InfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) { return new (t || InfiniteScrollDirective)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b)); };
InfiniteScrollDirective.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: InfiniteScrollDirective, selectors: [["", "infiniteScroll", ""], ["", "infinite-scroll", ""], ["", "data-infinite-scroll", ""]], inputs: { infiniteScrollDistance: "infiniteScrollDistance", infiniteScrollUpDistance: "infiniteScrollUpDistance", infiniteScrollThrottle: "infiniteScrollThrottle", infiniteScrollDisabled: "infiniteScrollDisabled", infiniteScrollContainer: "infiniteScrollContainer", scrollWindow: "scrollWindow", immediateCheck: "immediateCheck", horizontal: "horizontal", alwaysCallback: "alwaysCallback", fromRoot: "fromRoot" }, outputs: { scrolled: "scrolled", scrolledUp: "scrolledUp" }, features: [core/* ɵɵNgOnChangesFeature */.TTD] });
/** @nocollapse */
InfiniteScrollDirective.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: core/* NgZone */.R0b }
];
InfiniteScrollDirective.propDecorators = {
    scrolled: [{ type: core/* Output */.r_U }],
    scrolledUp: [{ type: core/* Output */.r_U }],
    infiniteScrollDistance: [{ type: core/* Input */.IIB }],
    infiniteScrollUpDistance: [{ type: core/* Input */.IIB }],
    infiniteScrollThrottle: [{ type: core/* Input */.IIB }],
    infiniteScrollDisabled: [{ type: core/* Input */.IIB }],
    infiniteScrollContainer: [{ type: core/* Input */.IIB }],
    scrollWindow: [{ type: core/* Input */.IIB }],
    immediateCheck: [{ type: core/* Input */.IIB }],
    horizontal: [{ type: core/* Input */.IIB }],
    alwaysCallback: [{ type: core/* Input */.IIB }],
    fromRoot: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(InfiniteScrollDirective, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: core/* NgZone */.R0b }]; }, { scrolled: [{
            type: core/* Output */.r_U
        }], scrolledUp: [{
            type: core/* Output */.r_U
        }], infiniteScrollDistance: [{
            type: core/* Input */.IIB
        }], infiniteScrollUpDistance: [{
            type: core/* Input */.IIB
        }], infiniteScrollThrottle: [{
            type: core/* Input */.IIB
        }], infiniteScrollDisabled: [{
            type: core/* Input */.IIB
        }], infiniteScrollContainer: [{
            type: core/* Input */.IIB
        }], scrollWindow: [{
            type: core/* Input */.IIB
        }], immediateCheck: [{
            type: core/* Input */.IIB
        }], horizontal: [{
            type: core/* Input */.IIB
        }], alwaysCallback: [{
            type: core/* Input */.IIB
        }], fromRoot: [{
            type: core/* Input */.IIB
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: src/modules/ngx-infinite-scroll.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InfiniteScrollModule {
}
InfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) { return new (t || InfiniteScrollModule)(); };
InfiniteScrollModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: InfiniteScrollModule });
InfiniteScrollModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [], imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(InfiniteScrollModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                declarations: [InfiniteScrollDirective],
                exports: [InfiniteScrollDirective],
                imports: [],
                providers: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(InfiniteScrollModule, { declarations: [InfiniteScrollDirective], exports: [InfiniteScrollDirective] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: src/ngx-infinite-scroll.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-library-starter
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-infinite-scroll.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=ngx-infinite-scroll.js.map
;// CONCATENATED MODULE: ./src/app/pages/instagram-feed/image-feed.component.ts




















function ImageFeedComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 14);
    core/* ɵɵelementStart */.TgZ(2, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 16);
    core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 17);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 24);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 32);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 33);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 34);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 33);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "a", 35);
    core/* ɵɵelement */._UZ(10, "img", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 37);
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r18 = ctx.$implicit;
    const ctx_r15 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r18.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r18.likes, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r18.location, "\u200B ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r15.getInstagramUrl(post_r18.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r15.getInstagramImageUrl(post_r18.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r18.caption, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 32);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 33);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 34);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 33);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "a", 35);
    core/* ɵɵelement */._UZ(10, "img", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 37);
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r19 = ctx.$implicit;
    const ctx_r16 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r19.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r19.likes, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r19.location, "\u200B ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r16.getInstagramUrl(post_r19.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r16.getInstagramImageUrl(post_r19.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r19.caption, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 32);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 33);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 34);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 33);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "a", 35);
    core/* ɵɵelement */._UZ(10, "img", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 37);
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r20 = ctx.$implicit;
    const ctx_r17 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r20.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r20.likes, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r20.location, "\u200B ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r17.getInstagramUrl(post_r20.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r17.getInstagramImageUrl(post_r20.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r20.caption, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 4);
    core/* ɵɵelementStart */.TgZ(1, "div", 27);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_2_Template, 13, 6, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 29);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_4_Template, 13, 6, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 30);
    core/* ɵɵtemplate */.YNc(6, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_div_6_Template, 13, 6, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.instaPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.instaPosts.second);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r13.instaPosts.third);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 32);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 33);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 34);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 33);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "a", 35);
    core/* ɵɵelement */._UZ(10, "img", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 37);
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r23 = ctx.$implicit;
    const ctx_r21 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r23.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r23.likes, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r23.location, "\u200B ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r21.getInstagramUrl(post_r23.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r21.getInstagramImageUrl(post_r23.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r23.caption, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 32);
    core/* ɵɵelementStart */.TgZ(2, "div", 4);
    core/* ɵɵelementStart */.TgZ(3, "div", 33);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 34);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 33);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "a", 35);
    core/* ɵɵelement */._UZ(10, "img", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 37);
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r24 = ctx.$implicit;
    const ctx_r22 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r24.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r24.likes, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r24.location, "\u200B ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r22.getInstagramUrl(post_r24.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r22.getInstagramImageUrl(post_r24.code), core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r24.caption, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 38);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_div_2_Template, 13, 6, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 39);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_div_4_Template, 13, 6, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r14 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r14.instaPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r14.instaPosts.second);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_0_Template, 7, 3, "div", 25);
    core/* ɵɵtemplate */.YNc(1, ImageFeedComponent_mat_tab_group_20_ng_template_3_div_1_Template, 5, 2, "div", 26);
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.feedColumnPreference == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.feedColumnPreference == 2);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 40);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelement */._UZ(1, "div", 41);
    core/* ɵɵelementStart */.TgZ(2, "div", 42);
    core/* ɵɵelementStart */.TgZ(3, "a", 35);
    core/* ɵɵelement */._UZ(4, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r30 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", post_r30.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r30.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r30.title, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelement */._UZ(1, "div", 41);
    core/* ɵɵelementStart */.TgZ(2, "div", 42);
    core/* ɵɵelementStart */.TgZ(3, "a", 35);
    core/* ɵɵelement */._UZ(4, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r31 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", post_r31.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r31.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r31.title, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelement */._UZ(1, "div", 41);
    core/* ɵɵelementStart */.TgZ(2, "div", 42);
    core/* ɵɵelementStart */.TgZ(3, "a", 35);
    core/* ɵɵelement */._UZ(4, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r32 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", post_r32.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r32.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r32.title, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 4);
    core/* ɵɵelementStart */.TgZ(1, "div", 27);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_2_Template, 7, 3, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 29);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_4_Template, 7, 3, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 30);
    core/* ɵɵtemplate */.YNc(6, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_div_6_Template, 7, 3, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r25 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r25.redditPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r25.redditPosts.second);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r25.redditPosts.third);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelement */._UZ(1, "div", 41);
    core/* ɵɵelementStart */.TgZ(2, "div", 42);
    core/* ɵɵelementStart */.TgZ(3, "a", 35);
    core/* ɵɵelement */._UZ(4, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r35 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", post_r35.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r35.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r35.title, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelement */._UZ(1, "div", 41);
    core/* ɵɵelementStart */.TgZ(2, "div", 42);
    core/* ɵɵelementStart */.TgZ(3, "a", 35);
    core/* ɵɵelement */._UZ(4, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r36 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", post_r36.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r36.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r36.title, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 38);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_div_2_Template, 7, 3, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 39);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_div_4_Template, 7, 3, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r26 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r26.redditPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r26.redditPosts.second);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_0_Template, 7, 3, "div", 25);
    core/* ɵɵtemplate */.YNc(1, ImageFeedComponent_mat_tab_group_20_ng_template_6_div_1_Template, 5, 2, "div", 26);
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.feedColumnPreference == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.feedColumnPreference == 2);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 45);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 42);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelement */._UZ(2, "img", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 37);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r42 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r42.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r42.mediaUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r42.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵelement */._UZ(3, "img", 53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 54);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r42 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r42.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", post_r42.userPicture, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r42.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 41);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 47);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 48);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_div_7_Template, 5, 3, "div", 49);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_div_8_Template, 6, 3, "div", 50);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r42 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r42.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r42.favoriteCount, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \u21D5", post_r42.retweetCount, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r42.mediaUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r42.mediaUrl == null);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_7_a_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 35);
    core/* ɵɵelement */._UZ(1, "img", 51);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r47 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵproperty */.Q6J("href", post_r47.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r47.mediaUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 42);
    core/* ɵɵtemplate */.YNc(1, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_7_a_1_Template, 2, 2, "a", 55);
    core/* ɵɵelementStart */.TgZ(2, "div", 37);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r47 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r47.mediaUrl != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r47.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelementStart */.TgZ(2, "div", 56);
    core/* ɵɵelement */._UZ(3, "img", 53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 54);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r47 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r47.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", post_r47.userPicture, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r47.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 41);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 47);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 48);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_7_Template, 4, 2, "div", 49);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_div_8_Template, 6, 3, "div", 50);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r47 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r47.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r47.favoriteCount, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \u21D5", post_r47.retweetCount, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r47.mediaUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r47.mediaUrl == null);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_7_a_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 35);
    core/* ɵɵelement */._UZ(1, "img", 51);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r54 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵproperty */.Q6J("href", post_r54.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r54.mediaUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 42);
    core/* ɵɵtemplate */.YNc(1, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_7_a_1_Template, 2, 2, "a", 55);
    core/* ɵɵelementStart */.TgZ(2, "div", 37);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r54 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r54.mediaUrl != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r54.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelementStart */.TgZ(2, "div", 56);
    core/* ɵɵelement */._UZ(3, "img", 53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 54);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r54 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r54.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", post_r54.userPicture, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r54.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 41);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 47);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 48);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_7_Template, 4, 2, "div", 49);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_div_8_Template, 6, 3, "div", 50);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r54 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r54.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r54.favoriteCount, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \u21D5", post_r54.retweetCount, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r54.mediaUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r54.mediaUrl == null);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 4);
    core/* ɵɵelementStart */.TgZ(1, "div", 27);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_2_Template, 9, 5, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 29);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_4_Template, 9, 5, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 30);
    core/* ɵɵtemplate */.YNc(6, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_div_6_Template, 9, 5, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r37 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r37.twitterPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r37.twitterPosts.second);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r37.twitterPosts.third);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 42);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelement */._UZ(2, "img", 51);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 37);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r63 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r63.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r63.mediaUrl, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r63.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵelement */._UZ(3, "img", 53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 54);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r63 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r63.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", post_r63.userPicture, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r63.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 41);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 47);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 48);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_div_7_Template, 5, 3, "div", 49);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_div_8_Template, 6, 3, "div", 50);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r63 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r63.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r63.favoriteCount, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \u21D5", post_r63.retweetCount, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r63.mediaUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r63.mediaUrl == null);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_7_a_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 35);
    core/* ɵɵelement */._UZ(1, "img", 51);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r68 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵproperty */.Q6J("href", post_r68.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", post_r68.mediaUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 42);
    core/* ɵɵtemplate */.YNc(1, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_7_a_1_Template, 2, 2, "a", 55);
    core/* ɵɵelementStart */.TgZ(2, "div", 37);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r68 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r68.mediaUrl != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r68.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵelementStart */.TgZ(1, "a", 35);
    core/* ɵɵelementStart */.TgZ(2, "div", 56);
    core/* ɵɵelement */._UZ(3, "img", 53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 54);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r68 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", post_r68.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("src", post_r68.userPicture, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r68.text, " ");
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵelementStart */.TgZ(1, "div", 41);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 47);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 48);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_7_Template, 4, 2, "div", 49);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_div_8_Template, 6, 3, "div", 50);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r68 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r68.username, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \uD83E\uDDE1", post_r68.favoriteCount, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" \u21D5", post_r68.retweetCount, " ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r68.mediaUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r68.mediaUrl == null);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 38);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_2_Template, 9, 5, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 39);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_div_4_Template, 9, 5, "div", 28);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r38 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r38.twitterPosts.first);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r38.twitterPosts.second);
} }
function ImageFeedComponent_mat_tab_group_20_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 46);
    core/* ɵɵelementStart */.TgZ(1, "span");
    core/* ɵɵtext */._uU(2, "Earlier this year Twitter announced that access to their API will stop being free. This change finally caught up with this website. The feed is no longer being updated (unless I start paying subscription, which I won't). I will either find a way around or remove the twitter feed");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(3, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_3_Template, 7, 3, "div", 25);
    core/* ɵɵtemplate */.YNc(4, ImageFeedComponent_mat_tab_group_20_ng_template_9_div_4_Template, 5, 2, "div", 26);
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r12.feedColumnPreference == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r12.feedColumnPreference == 2);
} }
function ImageFeedComponent_mat_tab_group_20_Template(rf, ctx) { if (rf & 1) {
    const _r76 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "mat-tab-group", 18);
    core/* ɵɵlistener */.NdJ("selectedIndexChange", function ImageFeedComponent_mat_tab_group_20_Template_mat_tab_group_selectedIndexChange_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r76); const ctx_r75 = core/* ɵɵnextContext */.oxw(); return ctx_r75.selectedTab = $event; })("selectedTabChange", function ImageFeedComponent_mat_tab_group_20_Template_mat_tab_group_selectedTabChange_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r76); const ctx_r77 = core/* ɵɵnextContext */.oxw(); return ctx_r77.tabChanged($event); });
    core/* ɵɵelementStart */.TgZ(1, "mat-tab", 19);
    core/* ɵɵtemplate */.YNc(2, ImageFeedComponent_mat_tab_group_20_ng_template_2_Template, 1, 0, "ng-template", 20);
    core/* ɵɵtemplate */.YNc(3, ImageFeedComponent_mat_tab_group_20_ng_template_3_Template, 2, 2, "ng-template", 21);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab", 22);
    core/* ɵɵtemplate */.YNc(5, ImageFeedComponent_mat_tab_group_20_ng_template_5_Template, 1, 0, "ng-template", 20);
    core/* ɵɵtemplate */.YNc(6, ImageFeedComponent_mat_tab_group_20_ng_template_6_Template, 2, 2, "ng-template", 21);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-tab", 23);
    core/* ɵɵtemplate */.YNc(8, ImageFeedComponent_mat_tab_group_20_ng_template_8_Template, 1, 0, "ng-template", 20);
    core/* ɵɵtemplate */.YNc(9, ImageFeedComponent_mat_tab_group_20_ng_template_9_Template, 5, 2, "ng-template", 21);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r2.selectedTab);
} }
class ImageFeedComponent {
    constructor(restService, utilityService, sanitizer, router, route, meta) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.sanitizer = sanitizer;
        this.router = router;
        this.route = route;
        this.meta = meta;
        this.instaPosts = new TrippleInstagramFeed();
        this.twitterPosts = new TrippleTwitterFeed();
        this.redditPosts = new TrippleRedditFeed();
        this.instaPageNum = 0;
        this.twitterpageNum = 0;
        this.redditpageNum = 0;
        this.selectedTab = 0;
        this.instaInitialized = false;
        this.twitterInitialized = false;
        this.redditInitialized = false;
        this.isMobile = false;
        this.feedColumnPreference = 3;
        this.utilityService.setTitle(3, 'Image feed');
        this.selectedTab = this.getSelectedTab();
        this.feedColumnPreference = this.getFeedColumnPreference();
        this.getFeed();
        if (window.innerWidth < 1000) {
            this.isMobile = true;
        }
        this.utilityService.restoreReferrer();
    }
    safe(post) {
        const url = 'https://www.instagram.com/p/' + post.code + '/embed';
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    onScrollDown() {
        if (this.selectedTab === 0) {
            this.onInstagramScrollDown();
        }
        if (this.selectedTab === 2) {
            this.onTwitterScrollDown();
        }
        if (this.selectedTab === 1) {
            this.onRedditScrollDown();
        }
    }
    onInstagramScrollDown() {
        if (this.instaInitialized) {
            this.instaPageNum++;
            this.updateInstagramFeed();
        }
    }
    onTwitterScrollDown() {
        if (this.twitterInitialized) {
            this.twitterpageNum++;
            this.updateTwitterFeed();
        }
    }
    onRedditScrollDown() {
        if (this.redditInitialized) {
            this.redditpageNum++;
            this.updateRedditFeed();
        }
    }
    getFeed() {
        this.restService.getInstagramPostsPaged(this.feedColumnPreference, this.instaPageNum).subscribe({
            next: data => {
                console.log("instagram: " + data.fetchOk);
                this.initialInstagramLoad(data);
                return data;
            }
        });
        this.restService.getTwitterPostsPaged(this.feedColumnPreference, this.twitterpageNum).subscribe({
            next: data => {
                this.initialTwitterLoad(data);
                return data;
            }
        });
        this.restService.getRedditPostsPaged(this.feedColumnPreference, this.redditpageNum).subscribe({
            next: data => {
                this.initialRedditLoad(data);
                return data;
            }
        });
    }
    updateInstagramFeed() {
        this.restService.getInstagramPostsPaged(this.feedColumnPreference, this.instaPageNum).subscribe({
            next: data => {
                this.slowlyAddInstaPosts(data);
                return data;
            }
        });
    }
    updateTwitterFeed() {
        this.restService.getTwitterPostsPaged(this.feedColumnPreference, this.twitterpageNum).subscribe({
            next: data => {
                this.slowlyAddTwitterPosts(data);
                return data;
            }
        });
    }
    updateRedditFeed() {
        this.restService.getRedditPostsPaged(this.feedColumnPreference, this.redditpageNum).subscribe({
            next: data => {
                this.slowlyAddRedditPosts(data);
                return data;
            }
        });
    }
    getInstagramImageUrl(code) {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/INSTA_' + code;
    }
    getInstagramUrl(code) {
        return 'https://www.instagram.com/p/' + code;
    }
    safeStreamableSource(url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    tabChanged(tabChangeEvent) {
        this.updateUrl();
        this.initialInstagramLoad(this.instaPostsInitial);
        this.initialTwitterLoad(this.twitterPostsInitial);
        this.initialRedditLoad(this.redditPostsInitial);
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    getSelectedTab() {
        const tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == null) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    initialInstagramLoad(newPosts) {
        if (this.instaPosts.first.length === 0 && this.selectedTab === 0) {
            this.slowlyAddInstaPosts(newPosts);
        }
        else {
            this.instaPostsInitial = newPosts;
        }
    }
    slowlyAddInstaPosts(newPosts) {
        this.instaPosts.first.push(newPosts.first[0]);
        if (this.isMobile) {
            this.instaPosts.first.push(newPosts.second[0]);
            this.instaPosts.first.push(newPosts.third[0]);
        }
        else {
            this.instaPosts.second.push(newPosts.second[0]);
            this.instaPosts.third.push(newPosts.third[0]);
        }
        for (let i = 1; i < newPosts.first.length; i++) {
            setTimeout(() => {
                this.instaPosts.first.push(newPosts.first[i]);
                if (this.isMobile) {
                    this.instaPosts.first.push(newPosts.second[i]);
                    this.instaPosts.first.push(newPosts.third[i]);
                }
                else {
                    this.instaPosts.second.push(newPosts.second[i]);
                    this.instaPosts.third.push(newPosts.third[i]);
                }
                if (i === newPosts.first.length - 1) {
                    this.instaInitialized = true;
                }
            }, i * 200);
        }
    }
    initialTwitterLoad(newPosts) {
        if (this.twitterPosts.first.length === 0 && this.selectedTab === 2) {
            this.slowlyAddTwitterPosts(newPosts);
        }
        else {
            this.twitterPostsInitial = newPosts;
        }
    }
    slowlyAddTwitterPosts(newPosts) {
        this.twitterPosts.first.push(newPosts.first[0]);
        if (this.isMobile) {
            this.twitterPosts.first.push(newPosts.second[0]);
        }
        else {
            this.twitterPosts.second.push(newPosts.second[0]);
        }
        if (this.feedColumnPreference == 3) {
            if (this.isMobile) {
                this.twitterPosts.first.push(newPosts.third[0]);
            }
            else {
                this.twitterPosts.third.push(newPosts.third[0]);
            }
        }
        for (let i = 1; i < newPosts.first.length; i++) {
            setTimeout(() => {
                this.twitterPosts.first.push(newPosts.first[i]);
                if (this.isMobile) {
                    this.twitterPosts.first.push(newPosts.second[i]);
                }
                else {
                    this.twitterPosts.second.push(newPosts.second[i]);
                }
                if (this.feedColumnPreference == 3) {
                    if (this.isMobile) {
                        this.twitterPosts.first.push(newPosts.third[i]);
                    }
                    else {
                        this.twitterPosts.third.push(newPosts.third[i]);
                    }
                }
                if (i === newPosts.first.length - 1) {
                    this.twitterInitialized = true;
                }
            }, i * 500);
        }
    }
    initialRedditLoad(newPosts) {
        if (this.redditPosts.first.length === 0 && this.selectedTab === 1) {
            this.slowlyAddRedditPosts(newPosts);
        }
        else {
            this.redditPostsInitial = newPosts;
        }
    }
    slowlyAddRedditPosts(newPosts) {
        this.redditPosts.first.push(newPosts.first[0]);
        if (this.isMobile) {
            this.redditPosts.first.push(newPosts.second[0]);
        }
        else {
            this.redditPosts.second.push(newPosts.second[0]);
        }
        if (this.feedColumnPreference == 3) {
            if (this.isMobile) {
                this.redditPosts.first.push(newPosts.third[0]);
            }
            else {
                this.redditPosts.third.push(newPosts.third[0]);
            }
        }
        for (let i = 1; i < newPosts.first.length; i++) {
            setTimeout(() => {
                this.redditPosts.first.push(newPosts.first[i]);
                if (this.isMobile) {
                    this.redditPosts.first.push(newPosts.second[i]);
                }
                else {
                    this.redditPosts.second.push(newPosts.second[i]);
                }
                if (this.feedColumnPreference == 3) {
                    if (this.isMobile) {
                        this.redditPosts.first.push(newPosts.third[i]);
                    }
                    else {
                        this.redditPosts.third.push(newPosts.third[i]);
                    }
                }
                if (i === newPosts.first.length - 1) {
                    this.redditInitialized = true;
                }
            }, i * 500);
        }
    }
    getFeedColumnPreference() {
        const feedPreferenceValue = localStorage.getItem('f1-feed-preference');
        if (feedPreferenceValue != null) {
            return Number(feedPreferenceValue);
        }
        else {
            return 3;
        }
    }
}
ImageFeedComponent.ɵfac = function ImageFeedComponent_Factory(t) { return new (t || ImageFeedComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(platform_browser/* Meta */.h_)); };
ImageFeedComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ImageFeedComponent, selectors: [["app-instagram-feed-cmp"]], decls: 21, vars: 5, consts: [["infinite-scroll", "", 3, "infiniteScrollDistance", "scrolled"], ["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [3, "selectedIndex", "selectedIndexChange", "selectedTabChange", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [3, "selectedIndex", "selectedIndexChange", "selectedTabChange"], ["label", "Instagram"], ["mat-tab-label", ""], ["matTabContent", ""], ["label", "Reddit"], ["label", "Twitter"], ["src", "assets/img/instagram-icon.ico"], ["class", "row", 4, "ngIf"], ["class", "row container-fluid no-padding-no-margin", 4, "ngIf"], [1, "col-lg-4", "col-12", "no-right-padding"], ["class", "instagram-post-margin", 4, "ngFor", "ngForOf"], [1, "col-lg-4", "col-12", "no-padding"], [1, "col-lg-4", "col-12", "no-left-padding"], [1, "instagram-post-margin"], [1, "container-fluid"], [1, "col-lg-4", "col-4", "instagram-post-info", "single-line"], [1, "col-lg-4", "col-4", "instagram-post-info"], ["target", "_blank", 3, "href"], ["onerror", "this.src='assets/img/instagram-icon.png';", 1, "w-100", 3, "src"], [1, "instagram-post-info"], [1, "row", "container-fluid", "no-padding-no-margin"], [1, "col-lg-6", "col-12", "no-padding-always"], ["src", "assets/img/reddit-icon.png"], [1, "div-half", "twitter-post-info"], [1, "text-center"], ["onerror", "this.src='assets/img/reddit-icon.png';", 3, "src"], [1, "reddit-post-info"], ["src", "assets/img/twitter-icon.png"], [1, "p-3", "m-2", "card", "card-stats", "bg-danger", "border-solid"], [1, "div-quarter", "twitter-post-info"], [1, "div-quarter", "twitter-post-info", "single-line"], ["class", "text-center", 4, "ngIf"], ["class", "div-left-header bg-dark-blue", 4, "ngIf"], ["onerror", "this.src='assets/img/twitter-icon.png';", 3, "src"], [1, "div-left-header", "bg-dark-blue"], [3, "src"], [1, "bg-dark-blue", "tweet-without-image"], ["target", "_blank", 3, "href", 4, "ngIf"], [1, "aaa"]], template: function ImageFeedComponent_Template(rf, ctx) { if (rf & 1) {
        const _r78 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵlistener */.NdJ("scrolled", function ImageFeedComponent_Template_div_scrolled_0_listener() { return ctx.onScrollDown(); });
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 1);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 2, 3);
        core/* ɵɵlistener */.NdJ("openedChange", function ImageFeedComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 4);
        core/* ɵɵelementStart */.TgZ(5, "div", 5);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 6);
        core/* ɵɵlistener */.NdJ("ngModelChange", function ImageFeedComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 7);
        core/* ɵɵelementStart */.TgZ(9, "button", 8);
        core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(7); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 8);
        core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(7); });
        core/* ɵɵtext */._uU(12, " Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, ImageFeedComponent_div_13_Template, 8, 3, "div", 9);
        core/* ɵɵelementStart */.TgZ(14, "div", 10);
        core/* ɵɵelementStart */.TgZ(15, "button", 11);
        core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r78); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 10);
        core/* ɵɵelementStart */.TgZ(18, "button", 11);
        core/* ɵɵlistener */.NdJ("click", function ImageFeedComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r78); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, ImageFeedComponent_mat_tab_group_20_Template, 10, 1, "mat-tab-group", 13);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵproperty */.Q6J("infiniteScrollDistance", 3);
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.instaPosts != null);
    } }, directives: [InfiniteScrollDirective, sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabLabel */.uD, tabs/* MatTabContent */.Vc], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/config/carousel-config.ts




function NgbdCarouselConfig_ngb_carousel_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 2);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "h3");
    core/* ɵɵtext */._uU(3, "10 seconds between slides...");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "p");
    core/* ɵɵtext */._uU(5, "This carousel uses customized default values.");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r1.images[0], core/* ɵɵsanitizeUrl */.LSH);
} }
function NgbdCarouselConfig_ngb_carousel_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 4);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "h3");
    core/* ɵɵtext */._uU(3, "No mouse events...");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "p");
    core/* ɵɵtext */._uU(5, "This carousel doesn't pause or resume on mouse events");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r2.images[1], core/* ɵɵsanitizeUrl */.LSH);
} }
function NgbdCarouselConfig_ngb_carousel_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 5);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "h3");
    core/* ɵɵtext */._uU(3, "No keyboard...");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "p");
    core/* ɵɵtext */._uU(5, "This carousel uses customized default values.");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r3.images[2], core/* ɵɵsanitizeUrl */.LSH);
} }
function NgbdCarouselConfig_ngb_carousel_0_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 6);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "h3");
    core/* ɵɵtext */._uU(3, "And no wrap after last slide.");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "p");
    core/* ɵɵtext */._uU(5, "This carousel uses customized default values.");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r4.images[3], core/* ɵɵsanitizeUrl */.LSH);
} }
function NgbdCarouselConfig_ngb_carousel_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "ngb-carousel");
    core/* ɵɵtemplate */.YNc(1, NgbdCarouselConfig_ngb_carousel_0_ng_template_1_Template, 6, 1, "ng-template", 1);
    core/* ɵɵtemplate */.YNc(2, NgbdCarouselConfig_ngb_carousel_0_ng_template_2_Template, 6, 1, "ng-template", 1);
    core/* ɵɵtemplate */.YNc(3, NgbdCarouselConfig_ngb_carousel_0_ng_template_3_Template, 6, 1, "ng-template", 1);
    core/* ɵɵtemplate */.YNc(4, NgbdCarouselConfig_ngb_carousel_0_ng_template_4_Template, 6, 1, "ng-template", 1);
    core/* ɵɵelementEnd */.qZA();
} }
class NgbdCarouselConfig {
    constructor(config) {
        this.images = [1, 2, 3, 4].map(() => `https://picsum.photos/900/500?random&t=${Math.random()}`);
        // customize default values of carousels used by this component tree
        config.interval = 3000;
        config.wrap = true;
        config.keyboard = false;
        config.pauseOnHover = false;
    }
}
NgbdCarouselConfig.ɵfac = function NgbdCarouselConfig_Factory(t) { return new (t || NgbdCarouselConfig)(core/* ɵɵdirectiveInject */.Y36(ng_bootstrap/* NgbCarouselConfig */.Lu)); };
NgbdCarouselConfig.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: NgbdCarouselConfig, selectors: [["ngbd-carousel-config"]], features: [core/* ɵɵProvidersFeature */._Bn([ng_bootstrap/* NgbCarouselConfig */.Lu] // add NgbCarouselConfig to the component providers
        )], decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngbSlide", ""], ["alt", "Random first slide", 1, "img-fluid", 3, "src"], [1, "carousel-caption"], ["alt", "Random second slide", 1, "img-fluid", 3, "src"], ["alt", "Random third slide", 1, "img-fluid", 3, "src"], ["alt", "Random fourth slide", 1, "img-fluid", 3, "src"]], template: function NgbdCarouselConfig_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵtemplate */.YNc(0, NgbdCarouselConfig_ngb_carousel_0_Template, 5, 0, "ngb-carousel", 0);
    } if (rf & 2) {
        core/* ɵɵproperty */.Q6J("ngIf", ctx.images);
    } }, directives: [common/* NgIf */.O5, ng_bootstrap/* NgbCarousel */.uo, ng_bootstrap/* NgbSlide */.xl], styles: [".img-fluid[_ngcontent-%COMP%]{min-width:100%}"] });

;// CONCATENATED MODULE: ./src/app/model/NewsContent.ts
class NewsContent {
}
class NewsComment {
}
class NewsCommentSection {
}

;// CONCATENATED MODULE: ./src/app/shared/dialog/submit-content-dialog.component.ts













class SubmitContentDialog {
    constructor(restService, utilityService, router, dialogRef) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.dialogRef = dialogRef;
        this.newContent = new NewsContent();
        this.status = "1";
    }
    sendMessage() {
        this.newContent.username = localStorage.getItem('f1-chosen-nickname');
        this.newContent.status = +this.status;
        let observableStandings = this.restService.postContent(this.newContent);
        observableStandings.subscribe({
            next: data => {
                this.newContent = new NewsContent();
                this.utilityService.pushToastrMessage("Posted.");
                this.dialogRef.close();
                this.router.navigate(['news/post'], { queryParams: { code: data } });
                return data;
            },
            error: error => {
                this.utilityService.pushToastrMessage("Error occured.");
                console.error('There was an error!', error);
            }
        });
    }
}
SubmitContentDialog.ɵfac = function SubmitContentDialog_Factory(t) { return new (t || SubmitContentDialog)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
SubmitContentDialog.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SubmitContentDialog, selectors: [["submit-content-dialog"]], decls: 20, vars: 3, consts: [["mat-dialog-content", "", 1, "min-dialog-size", "overflow-hidden"], [1, "row"], [1, "col-lg-12", "col-md-12", "col-sm-12"], [1, "col-12"], ["placeholder", "title", "type", "text", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "w-100"], ["placeholder", "url", "type", "text", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "form-group"], ["matInput", "", 1, "form-control", "message-text-area-50vh", 3, "ngModel", "ngModelChange"], [1, "row", "align-bottom"], ["mat-raised-button", "", 1, "active-color-button", "bg-success", "text-white", "w-100", "px-6", 3, "click"]], template: function SubmitContentDialog_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1);
        core/* ɵɵelementStart */.TgZ(2, "div", 2);
        core/* ɵɵelementStart */.TgZ(3, "div", 1);
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "label");
        core/* ɵɵtext */._uU(6, "Title");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "input", 4);
        core/* ɵɵlistener */.NdJ("ngModelChange", function SubmitContentDialog_Template_input_ngModelChange_7_listener($event) { return ctx.newContent.title = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 5);
        core/* ɵɵelementStart */.TgZ(9, "label");
        core/* ɵɵtext */._uU(10, "URL (not required)");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "input", 6);
        core/* ɵɵlistener */.NdJ("ngModelChange", function SubmitContentDialog_Template_input_ngModelChange_11_listener($event) { return ctx.newContent.url = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(12, "div", 3);
        core/* ɵɵelementStart */.TgZ(13, "div", 7);
        core/* ɵɵelementStart */.TgZ(14, "label");
        core/* ɵɵtext */._uU(15, "Text");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(16, "textarea", 8);
        core/* ɵɵlistener */.NdJ("ngModelChange", function SubmitContentDialog_Template_textarea_ngModelChange_16_listener($event) { return ctx.newContent.textContent = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function SubmitContentDialog_Template_button_click_18_listener() { return ctx.sendMessage(); });
        core/* ɵɵtext */._uU(19, " POST ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.newContent.title);
        core/* ɵɵadvance */.xp6(4);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.newContent.url);
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.newContent.textContent);
    } }, directives: [MatDialogContent, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, MatInput, fesm2015_button/* MatButton */.lW], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/poweredByAws/news-section.component.ts


















function NewsSectionComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 14);
    core/* ɵɵelementStart */.TgZ(2, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.utilityService.replyingTo(comment_r4.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 16);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.utilityService.replyingTo(comment_r4.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 17);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r4 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.comment);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_3_img_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 44);
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵproperty */.Q6J("src", post_r11.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 42);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtemplate */.YNc(2, NewsSectionComponent_div_20_div_7_tr_3_a_3_img_2_Template, 1, 1, "img", 43);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("href", post_r11.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.iconUrl != null);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_4_img_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 44);
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵproperty */.Q6J("src", post_r11.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_4_img_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 47);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 45);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtemplate */.YNc(2, NewsSectionComponent_div_20_div_7_tr_3_a_4_img_2_Template, 1, 1, "img", 43);
    core/* ɵɵtemplate */.YNc(3, NewsSectionComponent_div_20_div_7_tr_3_a_4_img_3_Template, 1, 0, "img", 46);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("href", "#/news/post?code=" + post_r11.code, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.iconUrl == null);
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 48);
    core/* ɵɵelementStart */.TgZ(1, "div", 39);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("href", post_r11.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r11.title, " ");
} }
function NewsSectionComponent_div_20_div_7_tr_3_a_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 49);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r11 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("href", "#/news/post?code=" + post_r11.code, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r11.title, " ");
} }
function NewsSectionComponent_div_20_div_7_tr_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr", 29);
    core/* ɵɵelement */._UZ(1, "td", 30);
    core/* ɵɵelementStart */.TgZ(2, "td", 31);
    core/* ɵɵtemplate */.YNc(3, NewsSectionComponent_div_20_div_7_tr_3_a_3_Template, 3, 2, "a", 32);
    core/* ɵɵtemplate */.YNc(4, NewsSectionComponent_div_20_div_7_tr_3_a_4_Template, 4, 3, "a", 33);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td", 34);
    core/* ɵɵtemplate */.YNc(6, NewsSectionComponent_div_20_div_7_tr_3_a_6_Template, 3, 2, "a", 35);
    core/* ɵɵtemplate */.YNc(7, NewsSectionComponent_div_20_div_7_tr_3_a_7_Template, 2, 2, "a", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "td", 37);
    core/* ɵɵelementStart */.TgZ(9, "a", 38);
    core/* ɵɵelementStart */.TgZ(10, "div", 39);
    core/* ɵɵtext */._uU(11);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "td", 40);
    core/* ɵɵelementStart */.TgZ(13, "a", 38);
    core/* ɵɵelementStart */.TgZ(14, "div", 39);
    core/* ɵɵelementStart */.TgZ(15, "button", 41);
    core/* ɵɵtext */._uU(16);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(17, "td", 30);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const post_r11 = ctx.$implicit;
    const ctx_r10 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.url != null && post_r11.status != 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.url == null || post_r11.status == 5);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.url != null && post_r11.status != 4 && post_r11.status != 5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", post_r11.url == null || post_r11.status == 4 || post_r11.status == 5);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("href", "#/news/post?code=" + post_r11.code, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r10.getDate(post_r11.timestampCreated), " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("href", "#/news/post?code=" + post_r11.code, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngClass", post_r11.status == 4 || post_r11.status == 5 ? "btn-outline-danger" : "btn-outline-info");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", post_r11.commentCount, " ");
} }
function NewsSectionComponent_div_20_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r27 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 24);
    core/* ɵɵelementStart */.TgZ(2, "tbody");
    core/* ɵɵtemplate */.YNc(3, NewsSectionComponent_div_20_div_7_tr_3_Template, 18, 9, "tr", 25);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div");
    core/* ɵɵelementStart */.TgZ(5, "div", 26);
    core/* ɵɵelementStart */.TgZ(6, "button", 27);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_7_Template_button_click_6_listener() { core/* ɵɵrestoreView */.CHM(_r27); const ctx_r26 = core/* ɵɵnextContext */.oxw(2); return ctx_r26.updatePosts(-1); });
    core/* ɵɵelementStart */.TgZ(7, "mat-icon");
    core/* ɵɵtext */._uU(8, "keyboard_arrow_left");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "div", 28);
    core/* ɵɵelementStart */.TgZ(10, "button", 27);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_7_Template_button_click_10_listener() { core/* ɵɵrestoreView */.CHM(_r27); const ctx_r28 = core/* ɵɵnextContext */.oxw(2); return ctx_r28.updatePosts(1); });
    core/* ɵɵelementStart */.TgZ(11, "mat-icon");
    core/* ɵɵtext */._uU(12, "keyboard_arrow_right");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r8.posts);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r8.disabledPaging(1));
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r8.disabledPaging(2));
} }
function NewsSectionComponent_div_20_div_8_div_1_div_2_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 66);
} if (rf & 2) {
    const news_r33 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r33.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_2_img_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 67);
} if (rf & 2) {
    const news_r33 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r33.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
const news_section_component_c0 = function (a0) { return { "h5": a0 }; };
function NewsSectionComponent_div_20_div_8_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r39 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 58);
    core/* ɵɵelementStart */.TgZ(2, "div", 59);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_2_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r39); const news_r33 = restoredCtx.$implicit; const ctx_r38 = core/* ɵɵnextContext */.oxw(4); return ctx_r38.redirectToNews(news_r33); });
    core/* ɵɵelementStart */.TgZ(3, "div", 60);
    core/* ɵɵelementStart */.TgZ(4, "div", 61);
    core/* ɵɵelementStart */.TgZ(5, "p", 62);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵtemplate */.YNc(8, NewsSectionComponent_div_20_div_8_div_1_div_2_img_8_Template, 1, 1, "img", 63);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(9, NewsSectionComponent_div_20_div_8_div_1_div_2_img_9_Template, 1, 1, "img", 64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 65);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_2_Template_div_click_10_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r39); const news_r33 = restoredCtx.$implicit; const ctx_r40 = core/* ɵɵnextContext */.oxw(4); return ctx_r40.redirectToNewsComments(news_r33.code); });
    core/* ɵɵelementStart */.TgZ(11, "span");
    core/* ɵɵtext */._uU(12, "Comments");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const news_r33 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("ngClass", news_r33.imageUrl != null ? "bg-light" : "bg-black text-white-hover-reverse");
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngClass", core/* ɵɵpureFunction1 */.VKq(5, news_section_component_c0, news_r33.imageUrl == null));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(news_r33.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", news_r33.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", news_r33.imageUrl != null);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_4_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 66);
} if (rf & 2) {
    const news_r41 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r41.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_4_img_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 67);
} if (rf & 2) {
    const news_r41 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r41.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r47 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 58);
    core/* ɵɵelementStart */.TgZ(2, "div", 59);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_4_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r47); const news_r41 = restoredCtx.$implicit; const ctx_r46 = core/* ɵɵnextContext */.oxw(4); return ctx_r46.redirectToNews(news_r41); });
    core/* ɵɵelementStart */.TgZ(3, "div", 60);
    core/* ɵɵelementStart */.TgZ(4, "div", 61);
    core/* ɵɵelementStart */.TgZ(5, "span", 62);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵtemplate */.YNc(8, NewsSectionComponent_div_20_div_8_div_1_div_4_img_8_Template, 1, 1, "img", 63);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(9, NewsSectionComponent_div_20_div_8_div_1_div_4_img_9_Template, 1, 1, "img", 64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 65);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_4_Template_div_click_10_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r47); const news_r41 = restoredCtx.$implicit; const ctx_r48 = core/* ɵɵnextContext */.oxw(4); return ctx_r48.redirectToNewsComments(news_r41.code); });
    core/* ɵɵelementStart */.TgZ(11, "span");
    core/* ɵɵtext */._uU(12, "Comments");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const news_r41 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("ngClass", news_r41.imageUrl != null ? "bg-light" : "bg-black text-white-hover-reverse");
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngClass", core/* ɵɵpureFunction1 */.VKq(5, news_section_component_c0, news_r41.imageUrl == null));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(news_r41.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", news_r41.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", news_r41.imageUrl != null);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_6_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 66);
} if (rf & 2) {
    const news_r49 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r49.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_6_img_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 67);
} if (rf & 2) {
    const news_r49 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r49.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsSectionComponent_div_20_div_8_div_1_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r55 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 58);
    core/* ɵɵelementStart */.TgZ(2, "div", 59);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_6_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r55); const news_r49 = restoredCtx.$implicit; const ctx_r54 = core/* ɵɵnextContext */.oxw(4); return ctx_r54.redirectToNews(news_r49); });
    core/* ɵɵelementStart */.TgZ(3, "div", 60);
    core/* ɵɵelementStart */.TgZ(4, "div", 61);
    core/* ɵɵelementStart */.TgZ(5, "span", 62);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵtemplate */.YNc(8, NewsSectionComponent_div_20_div_8_div_1_div_6_img_8_Template, 1, 1, "img", 63);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(9, NewsSectionComponent_div_20_div_8_div_1_div_6_img_9_Template, 1, 1, "img", 64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 65);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_div_1_div_6_Template_div_click_10_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r55); const news_r49 = restoredCtx.$implicit; const ctx_r56 = core/* ɵɵnextContext */.oxw(4); return ctx_r56.redirectToNewsComments(news_r49.code); });
    core/* ɵɵelementStart */.TgZ(11, "span");
    core/* ɵɵtext */._uU(12, "Comments");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const news_r49 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("ngClass", news_r49.imageUrl != null ? "bg-light" : "bg-black text-white-hover-reverse");
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngClass", core/* ɵɵpureFunction1 */.VKq(5, news_section_component_c0, news_r49.imageUrl == null));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(news_r49.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", news_r49.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", news_r49.imageUrl != null);
} }
function NewsSectionComponent_div_20_div_8_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r58 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 52);
    core/* ɵɵlistener */.NdJ("scrolled", function NewsSectionComponent_div_20_div_8_div_1_Template_div_scrolled_0_listener() { core/* ɵɵrestoreView */.CHM(_r58); const ctx_r57 = core/* ɵɵnextContext */.oxw(3); return ctx_r57.updatePosts(1); });
    core/* ɵɵelementStart */.TgZ(1, "div", 53);
    core/* ɵɵtemplate */.YNc(2, NewsSectionComponent_div_20_div_8_div_1_div_2_Template, 13, 7, "div", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 55);
    core/* ɵɵtemplate */.YNc(4, NewsSectionComponent_div_20_div_8_div_1_div_4_Template, 13, 7, "div", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 56);
    core/* ɵɵtemplate */.YNc(6, NewsSectionComponent_div_20_div_8_div_1_div_6_Template, 13, 7, "div", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r29 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("infiniteScrollDistance", 2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r29.postsSorted[0]);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r29.postsSorted[1]);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r29.postsSorted[2]);
} }
function NewsSectionComponent_div_20_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r60 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, NewsSectionComponent_div_20_div_8_div_1_Template, 7, 4, "div", 50);
    core/* ɵɵelementStart */.TgZ(2, "div", 51);
    core/* ɵɵelementStart */.TgZ(3, "button", 27);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_div_8_Template_button_click_3_listener() { core/* ɵɵrestoreView */.CHM(_r60); const ctx_r59 = core/* ɵɵnextContext */.oxw(2); return ctx_r59.updatePosts(1); });
    core/* ɵɵelementStart */.TgZ(4, "span");
    core/* ɵɵtext */._uU(5, "Older news");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.postsSorted != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r9.disabledPaging(1));
} }
function NewsSectionComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r62 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 18);
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "div", 19);
    core/* ɵɵelementStart */.TgZ(3, "div", 20);
    core/* ɵɵelementStart */.TgZ(4, "div", 21);
    core/* ɵɵelementStart */.TgZ(5, "button", 22);
    core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_div_20_Template_button_click_5_listener() { core/* ɵɵrestoreView */.CHM(_r62); const ctx_r61 = core/* ɵɵnextContext */.oxw(); return ctx_r61.submit(); });
    core/* ɵɵtext */._uU(6, "New thread");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(7, NewsSectionComponent_div_20_div_7_Template, 13, 3, "div", 23);
    core/* ɵɵtemplate */.YNc(8, NewsSectionComponent_div_20_div_8_Template, 6, 2, "div", 23);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.feedPreference == 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.feedPreference == 1);
} }
function NewsSectionComponent_img_21_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 68);
} }
class NewsSectionComponent {
    constructor(restService, utilityService, router, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.dialog = dialog;
        this.postsSorted = [];
        this.overlays = [];
        this.datePipe = new common/* DatePipe */.uU('en-US');
        this.utilityService.setTitle(2, 'News');
        this.feedPreference = this.getFeedPreference();
        this.getOverlays();
        this.page = 0;
        this.postsSorted[0] = [];
        this.postsSorted[1] = [];
        this.postsSorted[2] = [];
        this.getPosts(true);
    }
    submit() {
        this.dialog.open(SubmitContentDialog);
    }
    openPost(code) {
        this.router.navigate(['news/post'], { queryParams: { code: code } });
    }
    getDate(date) {
        const date1 = new Date(date);
        const isToday = (new Date().toDateString() === date1.toDateString());
        if (isToday) {
            return 'today';
        }
        const isYesterday = (new Date(Date.now() - 86400000).toDateString() === date1.toDateString());
        if (isYesterday) {
            return 'yesterday';
        }
        return this.datePipe.transform(date, 'MMM d, y');
    }
    updatePosts(number) {
        this.page = this.page + number;
        this.getPosts(true);
    }
    getPosts(iterate) {
        this.restService.getNews(this.page).subscribe({
            next: data => {
                this.posts = data;
                if (this.feedPreference == 1) {
                    this.sortPostsInThreeColumns();
                    if (iterate) {
                        this.page = this.page + 1;
                        this.getPosts(false);
                    }
                }
                return data;
            }
        });
    }
    sortPostsInThreeColumns() {
        let index = 0;
        this.posts.forEach(entry => {
            this.postsSorted[index].push(entry);
            index++;
            if (index == 3) {
                index = 0;
            }
        });
    }
    disabledPaging(mode) {
        if (mode === 1) {
            return this.page === 0;
        }
        if (mode === 2) {
            return this.posts.length < 15;
        }
    }
    getOverlays() {
        if (this.utilityService.getContext() != null) {
            this.overlays = this.utilityService.getContext().overlays;
        }
    }
    getFeedPreference() {
        const feedPreferenceValue = localStorage.getItem('f1-news-feed-preference');
        if (feedPreferenceValue != null) {
            return Number(feedPreferenceValue);
        }
        else {
            return 0;
        }
    }
    redirectToNews(newsContent) {
        let url = newsContent.url;
        if (newsContent.url == null || newsContent.status == 4 || newsContent.status == 5) {
            this.redirectToNewsComments(newsContent.code);
        }
        else {
            window.open(url, '_blank').focus();
        }
    }
    redirectToNewsComments(code) {
        const queryParams = { code: code };
        this.router.navigate(['news/post'], {
            queryParams: queryParams
        });
    }
}
NewsSectionComponent.ɵfac = function NewsSectionComponent_Factory(t) { return new (t || NewsSectionComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
NewsSectionComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: NewsSectionComponent, selectors: [["app-news-section-cmp"]], decls: 22, vars: 5, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "focus", "focusout", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "height-fill-screen", 4, "ngIf"], ["alt", "bottom-right-image", "class", "bottom-right-image2 display-on-desktop-only", "src", "assets/img/apu_reporter.png", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "height-fill-screen"], [1, "col-lg-12", "col-md-6", "col-sm-6"], [1, "card", "card-stats"], [1, "post-comment", "align-middle"], ["mat-flat-button", "", 1, "bg-danger", "text-white", 3, "click"], [4, "ngIf"], [1, "table", "table-striped"], ["class", "hover-effects-bold-row", 4, "ngFor", "ngForOf"], [1, "basic-left", "icon-big", "text-center"], ["color", "primary", "mat-flat-button", "", 1, "width-100", "z-index-2", 3, "disabled", "click"], [1, "basic-right", "icon-big", "text-center"], [1, "hover-effects-bold-row"], [1, "width-10"], [1, "p-0", "d-sm-none", "d-none", "d-lg-table-cell"], ["target", "_blank", 3, "href", 4, "ngIf"], [3, "href", 4, "ngIf"], [1, "p-0"], ["class", "newsPostLinks postLinks", "target", "_blank", 3, "href", 4, "ngIf"], ["class", "newsPostLinks postLinks", 3, "href", 4, "ngIf"], [1, "p-0", "max-width-10rem", "d-sm-none", "d-none", "d-lg-table-cell"], [1, "newsPostLinks", "simpleLink", 3, "href"], [1, "link-container"], [1, "p-0", "width-10"], [1, "btn", "btn-sm", "btn-round", "btn-icon", 3, "ngClass"], ["target", "_blank", 3, "href"], ["class", "w-42px", "onerror", "this.src='assets/img/favicon2.png'", 3, "src", 4, "ngIf"], ["onerror", "this.src='assets/img/favicon2.png'", 1, "w-42px", 3, "src"], [3, "href"], ["class", "w-42px", "src", "assets/img/favicon2.png", 4, "ngIf"], ["src", "assets/img/favicon2.png", 1, "w-42px"], ["target", "_blank", 1, "newsPostLinks", "postLinks", 3, "href"], [1, "newsPostLinks", "postLinks", 3, "href"], ["class", "row px-2", "infinite-scroll", "", 3, "infiniteScrollDistance", "scrolled", 4, "ngIf"], [1, "text-center"], ["infinite-scroll", "", 1, "row", "px-2", 3, "infiniteScrollDistance", "scrolled"], [1, "col-12", "col-lg-4", "pl-lg-3"], ["class", "card card-stats border border-dark cursor-pointer", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "col-12", "col-lg-4", "px-lg-2"], [1, "col-12", "col-lg-4", "pr-lg-3"], [1, "card", "card-stats", "border", "border-dark", "cursor-pointer", 3, "ngClass"], [1, "card-body", "mx-2"], [3, "click"], [1, "row", "mb-1"], [1, "col-11"], [3, "ngClass"], ["alt", "no icon", "style", "max-width: 15px;", 3, "src", 4, "ngIf"], ["alt", "no image", 3, "src", 4, "ngIf"], [1, "text-center", "p-2", "bg-dark-blue", "text-white", 3, "click"], ["alt", "no icon", 2, "max-width", "15px", 3, "src"], ["alt", "no image", 3, "src"], ["alt", "bottom-right-image", "src", "assets/img/apu_reporter.png", 1, "bottom-right-image2", "display-on-desktop-only"]], template: function NewsSectionComponent_Template(rf, ctx) { if (rf & 1) {
        const _r63 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function NewsSectionComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("focus", function NewsSectionComponent_Template_textarea_focus_7_listener() { return ctx.utilityService.focusFunction(); })("focusout", function NewsSectionComponent_Template_textarea_focusout_7_listener() { return ctx.utilityService.focusOutFunction(); })("ngModelChange", function NewsSectionComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(9); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(9); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, NewsSectionComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r63); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function NewsSectionComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r63); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, NewsSectionComponent_div_20_Template, 9, 2, "div", 12);
        core/* ɵɵtemplate */.YNc(21, NewsSectionComponent_img_21_Template, 1, 0, "img", 13);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.posts != null);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.overlays.includes("apustaja"));
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, icon/* MatIcon */.Hw, common/* NgClass */.mk, InfiniteScrollDirective], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/poweredByAws/news.component.ts



















function NewsComponent_div_1_div_3_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 22);
    core/* ɵɵelementStart */.TgZ(1, "div", 23);
    core/* ɵɵelement */._UZ(2, "i", 24);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function NewsComponent_div_1_div_3_div_9_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 23);
    core/* ɵɵelement */._UZ(1, "img", 29);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r11.post.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_3_div_9_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 23);
    core/* ɵɵelement */._UZ(1, "i", 30);
    core/* ɵɵelementEnd */.qZA();
} }
function NewsComponent_div_1_div_3_div_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 22);
    core/* ɵɵelementStart */.TgZ(1, "a", 25);
    core/* ɵɵelementStart */.TgZ(2, "div", 26);
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_3_div_9_div_3_Template, 2, 1, "div", 27);
    core/* ɵɵtemplate */.YNc(4, NewsComponent_div_1_div_3_div_9_div_4_Template, 2, 0, "div", 27);
    core/* ɵɵelementStart */.TgZ(5, "span", 28);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r7.post.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r7.post.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r7.post.iconUrl == null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r7.getDomain());
} }
function NewsComponent_div_1_div_3_div_10_a_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "a", 25);
    core/* ɵɵelement */._UZ(1, "img", 34);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("href", ctx_r13.post.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r13.post.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_3_div_10_img_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 34);
} if (rf & 2) {
    const ctx_r14 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("src", ctx_r14.post.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_3_div_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_3_div_10_a_1_Template, 2, 2, "a", 32);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_3_div_10_img_2_Template, 1, 1, "img", 33);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.post.url != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.post.url == null);
} }
function NewsComponent_div_1_div_3_div_11_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 35);
    core/* ɵɵelementStart */.TgZ(1, "div", 36);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 37);
    core/* ɵɵelement */._UZ(4, "br");
    core/* ɵɵelementStart */.TgZ(5, "span", 28);
    core/* ɵɵtext */._uU(6, "By");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(7, "br");
    core/* ɵɵelementStart */.TgZ(8, "span", 28);
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r9.post.textContent, " ");
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r9.post.username, ".");
} }
function NewsComponent_div_1_div_3_div_12_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "blockquote", 38);
    core/* ɵɵelement */._UZ(2, "p", 39);
    core/* ɵɵelementStart */.TgZ(3, "a", 40);
    core/* ɵɵelement */._UZ(4, "img", 41);
    core/* ɵɵelementStart */.TgZ(5, "p");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r15 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("href", ctx_r15.post.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r15.post.title);
} }
function NewsComponent_div_1_div_3_div_12_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelement */._UZ(1, "img", 42);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r16 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r16.post.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_3_div_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 31);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_3_div_12_div_1_Template, 7, 2, "div", 4);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_3_div_12_div_2_Template, 2, 1, "div", 4);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.isTweet);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.isImage);
} }
function NewsComponent_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 15);
    core/* ɵɵelementStart */.TgZ(1, "div", 16);
    core/* ɵɵelementStart */.TgZ(2, "div", 17);
    core/* ɵɵelementStart */.TgZ(3, "div", 5);
    core/* ɵɵelementStart */.TgZ(4, "div", 18);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵpipe */.ALo(6, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 5);
    core/* ɵɵtemplate */.YNc(8, NewsComponent_div_1_div_3_div_8_Template, 3, 0, "div", 19);
    core/* ɵɵtemplate */.YNc(9, NewsComponent_div_1_div_3_div_9_Template, 7, 4, "div", 19);
    core/* ɵɵtemplate */.YNc(10, NewsComponent_div_1_div_3_div_10_Template, 3, 2, "div", 20);
    core/* ɵɵtemplate */.YNc(11, NewsComponent_div_1_div_3_div_11_Template, 10, 2, "div", 21);
    core/* ɵɵtemplate */.YNc(12, NewsComponent_div_1_div_3_div_12_Template, 3, 2, "div", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate1 */.hij("", core/* ɵɵpipeBind2 */.xi3(6, 6, ctx_r1.post.timestampCreated, "MMM d, y"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.post.url == null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.post.url != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.post.imageUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.post.textContent != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.post.imageUrl == null && ctx_r1.post.textContent == null);
} }
function NewsComponent_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 5);
    core/* ɵɵelementStart */.TgZ(2, "div", 43);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵpipe */.ALo(4, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 44);
    core/* ɵɵelement */._UZ(6, "div", 45);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", core/* ɵɵpipeBind2 */.xi3(4, 2, ctx_r2.post.timestampCreated, "MMM d, y, HH:mm"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("innerHTML", ctx_r2.sanitizedHtml(), core/* ɵɵsanitizeHtml */.oJD);
} }
function NewsComponent_div_1_div_5_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 48);
    core/* ɵɵelement */._UZ(1, "iframe", 49);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r17 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r17.sanitizeUrl(ctx_r17.post.url), core/* ɵɵsanitizeResourceUrl */.uOi);
} }
function NewsComponent_div_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 16);
    core/* ɵɵelementStart */.TgZ(2, "div", 17);
    core/* ɵɵelementStart */.TgZ(3, "div", 5);
    core/* ɵɵelementStart */.TgZ(4, "div", 43);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵpipe */.ALo(6, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 46);
    core/* ɵɵtemplate */.YNc(8, NewsComponent_div_1_div_5_div_8_Template, 2, 1, "div", 47);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate1 */.hij("", core/* ɵɵpipeBind2 */.xi3(6, 2, ctx_r3.post.timestampCreated, "MMM d, y, HH:mm"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.post.status == 5);
} }
function NewsComponent_div_1_div_16_div_8_div_1_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(comment_r18.textContent);
} }
function NewsComponent_div_1_div_16_div_8_div_1_div_2_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 26);
    core/* ɵɵelement */._UZ(1, "iframe", 59);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const section_r26 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", section_r26.youtubeLink, core/* ɵɵsanitizeResourceUrl */.uOi);
} }
function NewsComponent_div_1_div_16_div_8_div_1_div_2_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_16_div_8_div_1_div_2_div_1_div_3_Template, 2, 1, "div", 58);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const section_r26 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(section_r26.textContent);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", section_r26.youtubeLink != null);
} }
function NewsComponent_div_1_div_16_div_8_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_8_div_1_div_2_div_1_Template, 4, 2, "div", 12);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", comment_r18.sections);
} }
function NewsComponent_div_1_div_16_div_8_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_8_div_1_div_1_Template, 2, 1, "div", 4);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_16_div_8_div_1_div_2_Template, 2, 1, "div", 4);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections.length == 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections.length > 0);
} }
function NewsComponent_div_1_div_16_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 55);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_8_div_1_Template, 3, 2, "div", 56);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections != null);
} }
function NewsComponent_div_1_div_16_div_9_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 62);
    core/* ɵɵelement */._UZ(1, "img", 63);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(2).$implicit;
    const ctx_r32 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r32.getCommentImageUrl(comment_r18.id), core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_16_div_9_div_2_source_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "source", 67);
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    const ctx_r36 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r36.getCommentImageUrl(comment_r18.id), core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_16_div_9_div_2_source_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "source", 68);
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    const ctx_r37 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r37.getCommentImageUrl(comment_r18.id), core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_16_div_9_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 62);
    core/* ɵɵelementStart */.TgZ(1, "video", 64);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_16_div_9_div_2_source_2_Template, 1, 1, "source", 65);
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_16_div_9_div_2_source_3_Template, 1, 1, "source", 66);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status == 3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status == 4);
} }
function NewsComponent_div_1_div_16_div_9_div_3_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate */.Oqu(comment_r18.textContent);
} }
function NewsComponent_div_1_div_16_div_9_div_3_div_2_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 26);
    core/* ɵɵelement */._UZ(1, "iframe", 59);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const section_r45 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", section_r45.youtubeLink, core/* ɵɵsanitizeResourceUrl */.uOi);
} }
function NewsComponent_div_1_div_16_div_9_div_3_div_2_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_16_div_9_div_3_div_2_div_1_div_3_Template, 2, 1, "div", 58);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const section_r45 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(section_r45.textContent);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", section_r45.youtubeLink != null);
} }
function NewsComponent_div_1_div_16_div_9_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_9_div_3_div_2_div_1_Template, 4, 2, "div", 12);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(3).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", comment_r18.sections);
} }
function NewsComponent_div_1_div_16_div_9_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_9_div_3_div_1_Template, 2, 1, "div", 4);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_16_div_9_div_3_div_2_Template, 2, 1, "div", 4);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw(2).$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections.length == 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections.length > 0);
} }
function NewsComponent_div_1_div_16_div_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 60);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_16_div_9_div_1_Template, 2, 1, "div", 61);
    core/* ɵɵtemplate */.YNc(2, NewsComponent_div_1_div_16_div_9_div_2_Template, 4, 2, "div", 61);
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_16_div_9_div_3_Template, 3, 2, "div", 56);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status == 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status > 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.sections != null);
} }
function NewsComponent_div_1_div_16_Template(rf, ctx) { if (rf & 1) {
    const _r52 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 50);
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵelementStart */.TgZ(3, "div", 51);
    core/* ɵɵlistener */.NdJ("click", function NewsComponent_div_1_div_16_Template_div_click_3_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r52); const comment_r18 = restoredCtx.$implicit; const ctx_r51 = core/* ɵɵnextContext */.oxw(2); return ctx_r51.addressUser(comment_r18.username); });
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 52);
    core/* ɵɵlistener */.NdJ("click", function NewsComponent_div_1_div_16_Template_div_click_5_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r52); const comment_r18 = restoredCtx.$implicit; const ctx_r53 = core/* ɵɵnextContext */.oxw(2); return ctx_r53.addressUser("" + comment_r18.id); });
    core/* ɵɵtext */._uU(6);
    core/* ɵɵpipe */.ALo(7, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(8, NewsComponent_div_1_div_16_div_8_Template, 2, 1, "div", 53);
    core/* ɵɵtemplate */.YNc(9, NewsComponent_div_1_div_16_div_9_Template, 4, 3, "div", 54);
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r18 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate */.Oqu(comment_r18.username);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate2 */.AsE("", core/* ɵɵpipeBind2 */.xi3(7, 5, comment_r18.timestampCreated, "MMM d, y, HH:mm"), " - No.", comment_r18.id, "");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status == 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", comment_r18.status > 1);
} }
function NewsComponent_div_1_div_20_div_1_img_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 79);
} if (rf & 2) {
    const news_r55 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r55.iconUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_20_div_1_img_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 80);
} if (rf & 2) {
    const news_r55 = core/* ɵɵnextContext */.oxw().$implicit;
    core/* ɵɵproperty */.Q6J("src", news_r55.imageUrl, core/* ɵɵsanitizeUrl */.LSH);
} }
function NewsComponent_div_1_div_20_div_1_img_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 81);
} }
function NewsComponent_div_1_div_20_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r62 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 71);
    core/* ɵɵelementStart */.TgZ(1, "div", 72);
    core/* ɵɵlistener */.NdJ("click", function NewsComponent_div_1_div_20_div_1_Template_div_click_1_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r62); const news_r55 = restoredCtx.$implicit; const ctx_r61 = core/* ɵɵnextContext */.oxw(3); return ctx_r61.redirectToNews(news_r55.code); });
    core/* ɵɵelementStart */.TgZ(2, "div", 73);
    core/* ɵɵelementStart */.TgZ(3, "div", 74);
    core/* ɵɵelementStart */.TgZ(4, "div", 75);
    core/* ɵɵelementStart */.TgZ(5, "span");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵtemplate */.YNc(8, NewsComponent_div_1_div_20_div_1_img_8_Template, 1, 1, "img", 76);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(9, NewsComponent_div_1_div_20_div_1_img_9_Template, 1, 1, "img", 77);
    core/* ɵɵtemplate */.YNc(10, NewsComponent_div_1_div_20_div_1_img_10_Template, 1, 0, "img", 78);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const news_r55 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵtextInterpolate */.Oqu(news_r55.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", news_r55.iconUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", news_r55.imageUrl != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", news_r55.imageUrl == null);
} }
function NewsComponent_div_1_div_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 69);
    core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_div_20_div_1_Template, 11, 4, "div", 70);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r5.nextNews);
} }
const news_component_c0 = function () { return [1, 3, 4]; };
const news_component_c1 = function () { return [5, 6]; };
function NewsComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r64 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "div", 2);
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵtemplate */.YNc(3, NewsComponent_div_1_div_3_Template, 13, 9, "div", 3);
    core/* ɵɵtemplate */.YNc(4, NewsComponent_div_1_div_4_Template, 7, 5, "div", 4);
    core/* ɵɵtemplate */.YNc(5, NewsComponent_div_1_div_5_Template, 9, 5, "div", 4);
    core/* ɵɵelementStart */.TgZ(6, "div", 5);
    core/* ɵɵelementStart */.TgZ(7, "div", 6);
    core/* ɵɵelementStart */.TgZ(8, "div");
    core/* ɵɵelementStart */.TgZ(9, "textarea", 7);
    core/* ɵɵlistener */.NdJ("ngModelChange", function NewsComponent_div_1_Template_textarea_ngModelChange_9_listener($event) { core/* ɵɵrestoreView */.CHM(_r64); const ctx_r63 = core/* ɵɵnextContext */.oxw(); return ctx_r63.commentText = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div", 8);
    core/* ɵɵelementStart */.TgZ(11, "button", 9);
    core/* ɵɵlistener */.NdJ("click", function NewsComponent_div_1_Template_button_click_11_listener() { core/* ɵɵrestoreView */.CHM(_r64); const ctx_r65 = core/* ɵɵnextContext */.oxw(); return ctx_r65.postNewsComment(); });
    core/* ɵɵtext */._uU(12, "Leave comment");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "input", 10);
    core/* ɵɵlistener */.NdJ("change", function NewsComponent_div_1_Template_input_change_13_listener($event) { core/* ɵɵrestoreView */.CHM(_r64); const ctx_r66 = core/* ɵɵnextContext */.oxw(); return ctx_r66.addFileToComment($event); });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "label", 11);
    core/* ɵɵtext */._uU(15);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(16, NewsComponent_div_1_div_16_Template, 11, 8, "div", 12);
    core/* ɵɵelementStart */.TgZ(17, "div", 13);
    core/* ɵɵelementStart */.TgZ(18, "span");
    core/* ɵɵtext */._uU(19, "Other news");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(20, NewsComponent_div_1_div_20_Template, 2, 1, "div", 14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", core/* ɵɵpureFunction0 */.DdM(7, news_component_c0).includes(ctx_r0.post.status));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.post.status == 2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", core/* ɵɵpureFunction0 */.DdM(8, news_component_c1).includes(ctx_r0.post.status));
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.commentText);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.fileUploadLabel);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.post.comments);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.nextNews != null);
} }
class NewsComponent {
    constructor(restService, utilityService, route, router, dialog, sanitizer) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.route = route;
        this.router = router;
        this.dialog = dialog;
        this.sanitizer = sanitizer;
        this.commentText = '';
        this.currentReloadCounter = 1;
        this.minimumReloadCounterValue = 0;
        this.isTweet = false;
        this.isImage = false;
        this.imageExtensions = ['.jpg', '.png', '.webp'];
        this.fileUploadLabel = 'Add image';
    }
    ngOnInit() {
        this.utilityService.disablePeriodicFetchOfComments();
        this.route.queryParams.subscribe(params => {
            let selectedCode = params['code'];
            this.getNewsByCode(selectedCode);
            let bump = params['bump'];
            if (bump != null) {
                this.restService.bumpNewsPost(selectedCode).subscribe({
                    next: data => {
                        console.log('bump result: ' + data);
                    },
                    error: error => {
                        console.error('There was a bumpNewsPost error!', error);
                    }
                });
            }
        });
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
    }
    getNewsByCode(selectedCode) {
        this.restService.getNewsPost(selectedCode).subscribe({
            next: data => {
                this.post = data;
                if (this.post == null) {
                    this.goToAwsList();
                }
                else {
                    this.restService.getNextThreeNews(this.post.timestampActivity).subscribe({
                        next: data2 => {
                            this.nextNews = data2;
                        }
                    });
                    this.utilityService.setTitle(2, this.post.title);
                }
                this.checkIfTweet();
                this.checkIfImage();
                this.checkIfYoutube();
            }
        });
    }
    ngOnDestroy() {
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
        clearInterval(this.commentsReloader);
    }
    submit() {
        this.dialog.open(SubmitContentDialog);
    }
    goToAwsList() {
        this.router.navigate(['posts']);
    }
    addFileToComment(event) {
        const element = event.currentTarget;
        let fileList = element.files;
        if (fileList.length > 0 && fileList.item(0).size < 5000000 && this.setAwsCommentStatus(fileList.item(0)) > 1) {
            this.uploadFile = fileList.item(0);
            let label = this.uploadFile.name;
            if (label.length > 15) {
                label = label.substring(0, 11) + '...';
            }
            this.fileUploadLabel = label;
        }
        else {
            this.uploadFile = null;
            this.fileUploadLabel = 'Add image';
        }
    }
    postNewsComment() {
        let awsComment = new NewsComment();
        let validCauseImage = this.checkImageUpload();
        let validCauseText = this.commentText.trim() != '';
        if (validCauseText || validCauseImage) {
            if (validCauseImage) {
                awsComment.status = this.setAwsCommentStatus(this.uploadFile);
            }
            awsComment.contentCode = this.post.code;
            awsComment.textContent = this.commentText;
            awsComment.username = localStorage.getItem('f1-chosen-nickname');
            this.restService.postNewsComment(awsComment).subscribe({
                next: data => {
                    let comment = data;
                    if (validCauseImage) {
                        this.uploadImage(comment.id);
                    }
                    else {
                        this.reloadAwsComments();
                    }
                    this.commentText = '';
                    this.uploadFile = null;
                },
                error: error => {
                    console.error('There was an error!', error);
                    this.utilityService.pushToastrErrorMessage('Refused. Comment not posted.');
                }
            });
            this.minimumReloadCounterValue = 0;
            this.currentReloadCounter = 1;
        }
    }
    reloadAwsComments() {
        this.getNewsComments();
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
    }
    getNewsCommentsPeriodically() {
        if (this.currentReloadCounter > this.minimumReloadCounterValue) {
            this.getNewsComments();
            this.minimumReloadCounterValue++;
            this.currentReloadCounter = 0;
        }
        else {
            this.currentReloadCounter++;
        }
    }
    getNewsComments() {
        this.restService.getNewsComments(this.post.code).subscribe({
            next: data => {
                this.post.comments = data;
                this.checkIfYoutube();
            },
            error: error => {
                console.error('There was an error!', error);
            }
        });
    }
    addressUser(text) {
        this.commentText = this.commentText + '@' + text + ' - ';
    }
    getDomain() {
        let url = this.post.url;
        let start = 0;
        if (this.post.url.indexOf('//') > 0) {
            start = this.post.url.indexOf('//') + 2;
        }
        url = this.post.url.substring(start);
        if (url.indexOf('/') > 0) {
            url = url.substring(0, url.indexOf('/'));
        }
        return url;
    }
    sanitizedHtml() {
        return this.sanitizer.bypassSecurityTrustHtml(this.post.textContent);
    }
    checkIfImage() {
        for (const extension of this.imageExtensions) {
            if (this.post.url != null && this.post.url.endsWith(extension)) {
                this.isImage = true;
            }
        }
    }
    checkIfTweet() {
        if (this.post.url != null && this.post.url.includes('twitter.com')) {
            this.isTweet = true;
            window.twttr.widgets.load();
            setTimeout(() => {
                window.twttr.widgets.load();
            }, 3000);
        }
    }
    getCommentImageUrl(commentId) {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/comment_' + commentId;
    }
    sanitizeUrl(url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    redirectToNews(code) {
        window.scroll({
            top: 0,
            left: 0,
            behavior: 'smooth'
        });
        const queryParams = { code: code };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    checkImageUpload() {
        return this.uploadFile != null;
    }
    setAwsCommentStatus(file) {
        if (file.type.startsWith('image/')) {
            return 2;
        }
        else if (file.type.startsWith('video/webm')) {
            return 3;
        }
        else if (file.type.startsWith('video/')) {
            return 4;
        }
        else {
            return 1;
        }
    }
    uploadImage(id) {
        const formData = new FormData();
        formData.append('image', this.uploadFile);
        this.restService.saveCommentImage(id, formData).subscribe({
            next: data => {
                this.reloadAwsComments();
                setTimeout(() => this.reloadAwsComments(), 2000);
            },
            error: error => {
                console.error('There was an error!', error);
                this.utilityService.pushToastrErrorMessage('ERROR OCCURED. Comment not posted.');
            }
        });
    }
    sectionComment(comment, startingPoint) {
        let response = -1;
        let subcomment = comment.textContent.substring(startingPoint).replace('\n', ' ');
        let index1 = subcomment.indexOf('https://youtu.be/');
        let index2 = subcomment.indexOf('https://www.youtube.com/watch?v=');
        let index = null;
        let baseLength = null;
        if (index1 >= 0 && (index2 == -1 || index1 < index2)) {
            index = index1;
            baseLength = 17;
        }
        else if (index2 >= 0 && (index1 == -1 || index2 < index1)) {
            index = index2;
            baseLength = 32;
        }
        if (index != null) {
            let remainder = subcomment.substring(index).replace('\n', ' ');
            let spaceIndex = remainder.indexOf(' ');
            if (spaceIndex < 0) {
                spaceIndex = remainder.length;
            }
            let text = subcomment.substring(0, Number(index + spaceIndex));
            let code = subcomment.substring(Number(index + baseLength), Number(index + spaceIndex));
            let url = 'https://www.youtube.com/embed/' + code.replace('?t=', '?start=');
            let safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(url);
            response = startingPoint + index + spaceIndex;
            let entry = {};
            entry.textContent = text;
            entry.youtubeLink = safeUrl;
            comment.sections.push(entry);
        }
        else {
            if (comment.sections.length > 0) {
                let entry = {};
                entry.textContent = subcomment;
                comment.sections.push(entry);
            }
        }
        return response;
    }
    checkIfYoutube() {
        if (this.post.comments != null && this.post.comments.length > 0) {
            this.post.comments.forEach(comment => {
                comment.sections = [];
                let startingPoint = 0;
                let counter = 0;
                while (startingPoint >= 0) {
                    startingPoint = this.sectionComment(comment, startingPoint);
                    counter++;
                    if (counter > 10) {
                        startingPoint = -1;
                    }
                }
            });
        }
    }
}
NewsComponent.ɵfac = function NewsComponent_Factory(t) { return new (t || NewsComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(MatDialog), core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7)); };
NewsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: NewsComponent, selectors: [["app-aws-cmp"]], decls: 2, vars: 1, consts: [["class", "height-fill-screen bg-grey", 4, "ngIf"], [1, "height-fill-screen", "bg-grey"], [1, "px-sm-0", "pt-sm-0", "px-lg-2", "pt-lg-3"], ["class", "div-padded-left-right-0-5", 4, "ngIf"], [4, "ngIf"], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area-100", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "black-button", 3, "click"], ["id", "file-upload", "type", "file", 2, "display", "none", 3, "change"], ["for", "file-upload", 1, "mat-focus-indicator", "black-button", "mat-flat-button", "mat-button-base"], [4, "ngFor", "ngForOf"], [1, "mt-1", "basic-news-comment", "border", "border-dark", "text-center", "p-1"], ["class", "row px-2", 4, "ngIf"], [1, "div-padded-left-right-0-5"], [1, "card", "card-stats"], [1, "card-body"], [1, "col-12", "col-lg-12", "div-padded-always-left-right-1-2", "text-right"], ["class", "col-12 col-lg-2 no-right-padding", 4, "ngIf"], ["class", "pre-line col-12 col-lg-10 div-padded-always-left-right-1-2", 4, "ngIf"], ["class", "pre-line col-12", 4, "ngIf"], [1, "col-12", "col-lg-2", "no-right-padding"], [1, "icon-big", "text-center", "icon-warning"], [1, "nc-icon", "nc-align-left-2", "text-success"], ["target", "_blank", 3, "href"], [1, "text-center"], ["class", "icon-big text-center icon-warning", 4, "ngIf"], [1, "teko-text-small"], ["alt", "iconUrl", "onerror", "this.src='assets/img/favicon2.png'", 1, "w-42px", 3, "src"], [1, "nc-icon", "nc-globe", "text-success"], [1, "pre-line", "col-12", "col-lg-10", "div-padded-always-left-right-1-2"], ["target", "_blank", 3, "href", 4, "ngIf"], ["alt", "NO IMAGE", 3, "src", 4, "ngIf"], ["alt", "NO IMAGE", 3, "src"], [1, "pre-line", "col-12"], [1, "px-4", "pt-2"], [1, "px-4"], [1, "twitter-tweet"], ["dir", "ltr", "lang", "en"], [1, "postLinks", 3, "href"], ["alt", "loading", "src", "assets/img/loading.gif", 2, "max-width", "35px"], ["alt", "imageUrl", 3, "src"], [1, "col-12", "col-lg-12", "div-padded-always-top-right-2rem", "text-right"], [1, "div-padded-left-right-0-5", "pb-3"], [3, "innerHTML"], [1, "div-padded-left-right-0-5", "w-100", "pb-3"], ["style", "width:100%;position:relative;", 4, "ngIf"], [2, "width", "100%", "position", "relative"], ["allowfullscreen", "", "frameborder", "0", 2, "width", "calc(50vh*1.78)", "height", "50vh", "display", "block", "margin", "0 auto", 3, "src"], [1, "basic-news-comment"], [1, "one-aws", "hover-pointer", 3, "click"], [1, "two-aws", "hover-pointer", 3, "click"], ["class", "basic-comment-body", 4, "ngIf"], ["class", "basic-comment-body-no-padding d-flex", 4, "ngIf"], [1, "basic-comment-body"], ["class", "pl-3 pr-5", 4, "ngIf"], [1, "pl-3", "pr-5"], ["class", "text-center", 4, "ngIf"], ["allow", "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", "allowfullscreen", "", "height", "315", "title", "YouTube video player", "width", "560", 3, "src"], [1, "basic-comment-body-no-padding", "d-flex"], ["class", "max-width-30-pc px-3", 4, "ngIf"], [1, "max-width-30-pc", "px-3"], ["alt", "commentImage", "onerror", "this.src='assets/img/drivers/default.png'", 3, "src"], ["controls", "", "preload", "metadata", "width", "100%"], ["type", "video/webm", 3, "src", 4, "ngIf"], ["type", "video/mp4", 3, "src", 4, "ngIf"], ["type", "video/webm", 3, "src"], ["type", "video/mp4", 3, "src"], [1, "row", "px-2"], ["class", "col-12 col-lg-3 pt-1 px-lg-2", 4, "ngFor", "ngForOf"], [1, "col-12", "col-lg-3", "pt-1", "px-lg-2"], [1, "card", "card-stats", "bg-light", "border", "border-dark", "cursor-pointer", 3, "click"], [1, "card-body", "mx-2"], [1, "row", "mb-1"], [1, "col-11"], ["alt", "n", "style", "max-width: 15px;", 3, "src", 4, "ngIf"], ["alt", "n", 3, "src", 4, "ngIf"], ["alt", "no image", "src", "https://i.imgur.com/t4bVLeg.jpg", 4, "ngIf"], ["alt", "n", 2, "max-width", "15px", 3, "src"], ["alt", "n", 3, "src"], ["alt", "no image", "src", "https://i.imgur.com/t4bVLeg.jpg"]], template: function NewsComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵtemplate */.YNc(1, NewsComponent_div_1_Template, 21, 9, "div", 0);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.post != null);
    } }, directives: [common/* NgIf */.O5, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, bidi/* Dir */.Lv], pipes: [common/* DatePipe */.uU], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/model/commentModeration.ts
class CommentModeration {
}

;// CONCATENATED MODULE: ./src/app/pages/moderator/moderator.component.ts
















function ModeratorComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 11);
    core/* ɵɵelementStart */.TgZ(1, "p");
    core/* ɵɵtext */._uU(2, "Are you a moderator");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "mat-form-field");
    core/* ɵɵelementStart */.TgZ(4, "mat-select", 12);
    core/* ɵɵlistener */.NdJ("valueChange", function ModeratorComponent_div_13_Template_mat_select_valueChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r6); const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.answer1 = $event; });
    core/* ɵɵelementStart */.TgZ(5, "mat-option", 13);
    core/* ɵɵtext */._uU(6, "No");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-option", 14);
    core/* ɵɵtext */._uU(8, "Yes");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("value", ctx_r0.answer1);
} }
function ModeratorComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 11);
    core/* ɵɵelementStart */.TgZ(1, "p");
    core/* ɵɵtext */._uU(2, "What is your wage?");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "mat-form-field");
    core/* ɵɵelementStart */.TgZ(4, "mat-select", 15);
    core/* ɵɵlistener */.NdJ("selectionChange", function ModeratorComponent_div_14_Template_mat_select_selectionChange_4_listener() { core/* ɵɵrestoreView */.CHM(_r8); const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.verification(); })("ngModelChange", function ModeratorComponent_div_14_Template_mat_select_ngModelChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r8); const ctx_r9 = core/* ɵɵnextContext */.oxw(); return ctx_r9.answer2 = $event; })("valueChange", function ModeratorComponent_div_14_Template_mat_select_valueChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r8); const ctx_r10 = core/* ɵɵnextContext */.oxw(); return ctx_r10.answer2 = $event; });
    core/* ɵɵelementStart */.TgZ(5, "mat-option", 16);
    core/* ɵɵtext */._uU(6, "1\u20AC per action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-option", 14);
    core/* ɵɵtext */._uU(8, "1000 \u20AC");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "mat-option", 17);
    core/* ɵɵtext */._uU(10, "1 Pepe");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "mat-option", 18);
    core/* ɵɵtext */._uU(12, "1 BTC");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "mat-option", 19);
    core/* ɵɵtext */._uU(14, "I do it for free!");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r1.answer2)("value", ctx_r1.answer2);
} }
function ModeratorComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 11);
    core/* ɵɵelementStart */.TgZ(1, "p");
    core/* ɵɵtext */._uU(2, "Verification");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "p", 20);
    core/* ɵɵtext */._uU(4, "FAILED");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function ModeratorComponent_div_16_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 11);
    core/* ɵɵelementStart */.TgZ(1, "p");
    core/* ɵɵtext */._uU(2, "Verification");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "p", 21);
    core/* ɵɵtext */._uU(4, "SUCCESS");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function ModeratorComponent_div_17_mat_option_38_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 35);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const option_r12 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", option_r12);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", option_r12, " ");
} }
function ModeratorComponent_div_17_Template(rf, ctx) { if (rf & 1) {
    const _r14 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "div", 2);
    core/* ɵɵelementStart */.TgZ(2, "div", 3);
    core/* ɵɵelementStart */.TgZ(3, "span");
    core/* ɵɵtext */._uU(4, "MODERATION HUB ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(5, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 4);
    core/* ɵɵelementStart */.TgZ(7, "div", 22);
    core/* ɵɵelementStart */.TgZ(8, "div", 23);
    core/* ɵɵelementStart */.TgZ(9, "div", 24);
    core/* ɵɵtext */._uU(10, "Select panel");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "mat-radio-group", 25);
    core/* ɵɵlistener */.NdJ("ngModelChange", function ModeratorComponent_div_17_Template_mat_radio_group_ngModelChange_11_listener($event) { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r13 = core/* ɵɵnextContext */.oxw(); return ctx_r13.moderation.panel = $event; });
    core/* ɵɵelementStart */.TgZ(12, "div");
    core/* ɵɵelementStart */.TgZ(13, "mat-radio-button", 26);
    core/* ɵɵtext */._uU(14, "Sidebar");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "div");
    core/* ɵɵelementStart */.TgZ(16, "mat-radio-button", 27);
    core/* ɵɵtext */._uU(17, "AWS");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "div", 23);
    core/* ɵɵelementStart */.TgZ(19, "div", 24);
    core/* ɵɵtext */._uU(20, "Select action");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(21, "mat-radio-group", 28);
    core/* ɵɵlistener */.NdJ("change", function ModeratorComponent_div_17_Template_mat_radio_group_change_21_listener($event) { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r15 = core/* ɵɵnextContext */.oxw(); return ctx_r15.actionChoice($event); })("ngModelChange", function ModeratorComponent_div_17_Template_mat_radio_group_ngModelChange_21_listener($event) { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r16 = core/* ɵɵnextContext */.oxw(); return ctx_r16.moderation.action = $event; });
    core/* ɵɵelementStart */.TgZ(22, "div");
    core/* ɵɵelementStart */.TgZ(23, "mat-radio-button", 27);
    core/* ɵɵtext */._uU(24, "Delete comment");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(25, "div");
    core/* ɵɵelementStart */.TgZ(26, "mat-radio-button", 26);
    core/* ɵɵtext */._uU(27, "Restore comment");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(28, "div", 23);
    core/* ɵɵelementStart */.TgZ(29, "div", 29);
    core/* ɵɵtext */._uU(30, "Comment ID:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(31, "mat-form-field", 30);
    core/* ɵɵelementStart */.TgZ(32, "input", 31);
    core/* ɵɵlistener */.NdJ("ngModelChange", function ModeratorComponent_div_17_Template_input_ngModelChange_32_listener($event) { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r17 = core/* ɵɵnextContext */.oxw(); return ctx_r17.moderation.commentId = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(33, "div", 23);
    core/* ɵɵelementStart */.TgZ(34, "div", 29);
    core/* ɵɵtext */._uU(35, "Reason");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(36, "mat-form-field");
    core/* ɵɵelementStart */.TgZ(37, "mat-select", 32);
    core/* ɵɵlistener */.NdJ("ngModelChange", function ModeratorComponent_div_17_Template_mat_select_ngModelChange_37_listener($event) { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r18 = core/* ɵɵnextContext */.oxw(); return ctx_r18.moderation.reason = $event; });
    core/* ɵɵtemplate */.YNc(38, ModeratorComponent_div_17_mat_option_38_Template, 2, 2, "mat-option", 33);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(39, "button", 34);
    core/* ɵɵlistener */.NdJ("click", function ModeratorComponent_div_17_Template_button_click_39_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r19 = core/* ɵɵnextContext */.oxw(); return ctx_r19.executeModeratorAction(); });
    core/* ɵɵtext */._uU(40, "Execute");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r4.moderation.panel);
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r4.moderation.action);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r4.moderation.commentId);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r4.moderation.reason);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r4.reasons);
} }
class ModeratorComponent {
    constructor(restService, utilityService, toastr) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.toastr = toastr;
        this.reasonsToDelete = ['Unspecified', 'Spam', 'Hate speech', 'I don\'t like them', 'Suspected Australian'];
        this.reasonsToRestore = ['Unspecified', 'Mistake', 'They\'re sorry', 'I\'m sorry'];
        this.moderation = new CommentModeration();
        this.utilityService.setTitle(101, 'Restricted moderation area');
        this.answer1 = 0;
        this.answer2 = 0;
        this.verified = 0;
    }
    verification() {
        this.answer1 = 3;
        if (this.answer2 == 5 && this.verified == 0) {
            this.verified = 1;
        }
        else {
            this.verified = 2;
        }
    }
    executeModeratorAction() {
        if (isNaN(this.moderation.commentId)) {
            this.moderation.commentId = null;
        }
        if (this.moderation.panel == null || this.moderation.action == null || this.moderation.reason == null || this.moderation.commentId == null) {
            this.toastr.error('Panel, action, reason and commentId are mandatory', '', {
                timeOut: 4000,
                closeButton: false,
                enableHtml: false,
                toastClass: 'alert alert-danger',
                positionClass: 'toast-top-center'
            });
        }
        else {
            this.restService.moderateComment(this.moderation).subscribe({
                next: data => {
                    this.response = data;
                    if (this.response.state > 0) {
                        this.moderation = new CommentModeration();
                        this.toastr.success(this.response.message, '', {
                            timeOut: 4000,
                            closeButton: false,
                            enableHtml: false,
                            toastClass: 'alert alert-info',
                            positionClass: 'toast-top-center'
                        });
                    }
                    if (this.response.state <= 0) {
                        this.toastr.error('Unable to find comment no.' + this.moderation.commentId, '', {
                            timeOut: 4000,
                            closeButton: false,
                            enableHtml: false,
                            toastClass: 'alert alert-danger',
                            positionClass: 'toast-top-center'
                        });
                    }
                    return data;
                }
            });
        }
    }
    actionChoice(event) {
        this.moderation.reason = null;
        if (this.moderation.action == 2) {
            this.reasons = this.reasonsToDelete;
        }
        if (this.moderation.action == 1) {
            this.reasons = this.reasonsToRestore;
        }
    }
}
ModeratorComponent.ɵfac = function ModeratorComponent_Factory(t) { return new (t || ModeratorComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(ngx_toastr/* ToastrService */._W)); };
ModeratorComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ModeratorComponent, selectors: [["app-moderator-cmp"]], decls: 18, vars: 5, consts: [[1, "height-fill-screen"], [1, "div-padded-left-2", "div-padded-top-1", "col-lg-12", "col-md-12", "col-sm-12"], [1, "card", "card-stats"], [1, "card-header"], [1, "card-body"], [1, "row"], [1, "col-lg-2", "col-2", "no-right-padding"], [1, "icon-big", "text-center", "icon-warning"], [1, "nc-icon", "nc-circle-10", "text-warning"], ["class", "col-lg-4 col-8", 4, "ngIf"], ["class", "div-padded-left-2 div-padded-top-1 col-lg-12 col-md-12 col-sm-12", 4, "ngIf"], [1, "col-lg-4", "col-8"], [3, "value", "valueChange"], ["default", "", "value", "1"], ["value", "2"], [3, "ngModel", "value", "selectionChange", "ngModelChange", "valueChange"], ["value", "1"], ["value", "3"], ["value", "4"], ["value", "5"], [1, "text-danger"], [1, "text-success"], [1, "div-padded-2rem", "row"], [1, "col-12", "col-lg-3"], [1, "div-padded-bottom", "div-padded-right-2"], ["aria-label", "Select panel", 3, "ngModel", "ngModelChange"], ["value", "1", 1, "div-padded-right-2"], ["value", "2", 1, "div-padded-right-2"], ["aria-label", "Select action", 3, "ngModel", "change", "ngModelChange"], [1, "div-padded-right-2"], ["appearance", "fill", 1, "example-full-width"], ["matInput", "", "placeholder", "Enter comment ID...", "numbersOnly", "", 3, "ngModel", "ngModelChange"], [3, "ngModel", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], ["mat-raised-button", "", 1, "bg-info", "text-white", "width-100", 3, "click"], [3, "value"]], template: function ModeratorComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "div", 0);
        core/* ɵɵelementStart */.TgZ(2, "div", 1);
        core/* ɵɵelementStart */.TgZ(3, "div", 2);
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "span");
        core/* ɵɵtext */._uU(6, "MODERATOR VERIFICATION ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(7, "hr");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 4);
        core/* ɵɵelementStart */.TgZ(9, "div", 5);
        core/* ɵɵelementStart */.TgZ(10, "div", 6);
        core/* ɵɵelementStart */.TgZ(11, "div", 7);
        core/* ɵɵelement */._UZ(12, "i", 8);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, ModeratorComponent_div_13_Template, 9, 1, "div", 9);
        core/* ɵɵtemplate */.YNc(14, ModeratorComponent_div_14_Template, 15, 2, "div", 9);
        core/* ɵɵtemplate */.YNc(15, ModeratorComponent_div_15_Template, 5, 0, "div", 9);
        core/* ɵɵtemplate */.YNc(16, ModeratorComponent_div_16_Template, 5, 0, "div", 9);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(17, ModeratorComponent_div_17_Template, 41, 5, "div", 10);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(13);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.answer1 < 2);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.answer1 == 2);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.verified == 2);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.verified == 1);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.verified == 1);
    } }, directives: [common/* NgIf */.O5, MatFormField, MatSelect, fesm2015_core/* MatOption */.ey, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_radio/* MatRadioGroup */.VQ, fesm2015_radio/* MatRadioButton */.U0, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, common/* NgForOf */.sg, fesm2015_button/* MatButton */.lW], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/poweredByAws/aws-demo.component.ts

















function AwsDemoComponent_div_2_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 15);
    core/* ɵɵelementStart */.TgZ(1, "div", 16);
    core/* ɵɵelement */._UZ(2, "i", 17);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function AwsDemoComponent_div_2_div_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 15);
    core/* ɵɵelementStart */.TgZ(1, "a", 18);
    core/* ɵɵelementStart */.TgZ(2, "div", 19);
    core/* ɵɵelementStart */.TgZ(3, "div", 16);
    core/* ɵɵelement */._UZ(4, "i", 20);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "span", 21);
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("href", ctx_r4.post.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r4.getDomain());
} }
function AwsDemoComponent_div_2_div_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 22);
    core/* ɵɵelementStart */.TgZ(1, "div");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div");
    core/* ɵɵelement */._UZ(4, "br");
    core/* ɵɵelementStart */.TgZ(5, "span", 21);
    core/* ɵɵtext */._uU(6, "By");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(7, "br");
    core/* ɵɵelementStart */.TgZ(8, "span", 21);
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r5.post.textContent, " ");
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r5.post.username, ".");
} }
function AwsDemoComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 9);
    core/* ɵɵelementStart */.TgZ(1, "div", 10);
    core/* ɵɵelementStart */.TgZ(2, "div", 11);
    core/* ɵɵelementStart */.TgZ(3, "div", 3);
    core/* ɵɵelementStart */.TgZ(4, "div", 12);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵpipe */.ALo(6, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div", 3);
    core/* ɵɵtemplate */.YNc(8, AwsDemoComponent_div_2_div_8_Template, 3, 0, "div", 13);
    core/* ɵɵtemplate */.YNc(9, AwsDemoComponent_div_2_div_9_Template, 7, 2, "div", 13);
    core/* ɵɵtemplate */.YNc(10, AwsDemoComponent_div_2_div_10_Template, 10, 2, "div", 14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate1 */.hij("", core/* ɵɵpipeBind2 */.xi3(6, 4, ctx_r0.post.timestampCreated, "medium"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.post.url == null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.post.url != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.post.status == 1);
} }
function AwsDemoComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "div", 23);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵpipe */.ALo(4, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 24);
    core/* ɵɵelement */._UZ(6, "div", 25);
    core/* ɵɵelementStart */.TgZ(7, "div", 26);
    core/* ɵɵelementStart */.TgZ(8, "i");
    core/* ɵɵtext */._uU(9, " Thank you for reading, and feel free to give your own opinion below.");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", core/* ɵɵpipeBind2 */.xi3(4, 2, ctx_r1.post.timestampCreated, "medium"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("innerHTML", ctx_r1.sanitizedHtml(), core/* ɵɵsanitizeHtml */.oJD);
} }
function AwsDemoComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 27);
    core/* ɵɵelementStart */.TgZ(2, "div");
    core/* ɵɵelementStart */.TgZ(3, "div", 28);
    core/* ɵɵlistener */.NdJ("click", function AwsDemoComponent_div_13_Template_div_click_3_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.addressUser(comment_r6.username); });
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div", 29);
    core/* ɵɵlistener */.NdJ("click", function AwsDemoComponent_div_13_Template_div_click_5_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r8); const comment_r6 = restoredCtx.$implicit; const ctx_r9 = core/* ɵɵnextContext */.oxw(); return ctx_r9.addressUser("" + comment_r6.id); });
    core/* ɵɵtext */._uU(6);
    core/* ɵɵpipe */.ALo(7, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "div", 30);
    core/* ɵɵtext */._uU(9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r6 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.username);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate2 */.AsE("", core/* ɵɵpipeBind2 */.xi3(7, 4, comment_r6.timestampCreated, "medium"), " - No.", comment_r6.id, "");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r6.textContent);
} }
class AwsDemoComponent {
    constructor(restService, utilityService, route, router, dialog, sanitizer) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.route = route;
        this.router = router;
        this.dialog = dialog;
        this.sanitizer = sanitizer;
        this.commentText = '';
        this.currentReloadCounter = 1;
        this.minimumReloadCounterValue = 0;
    }
    ngOnInit() {
        this.utilityService.disablePeriodicFetchOfComments();
        this.route.queryParams.subscribe(params => {
            let selectedCode = params['code'];
            this.getNewsByCode(selectedCode);
        });
        // this.commentsReloader = setInterval(() => {
        //   this.getNewsCommentsPeriodically()
        // }, 20000);
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
    }
    getNewsByCode(selectedCode) {
        this.restService.getNewsPost(selectedCode).subscribe({
            next: data => {
                this.post = data;
                if (this.post == null) {
                    this.goToAwsList();
                }
                else {
                    this.utilityService.setTitle(2, this.post.title);
                }
            },
            error: error => {
                console.error('There was an error!', error);
            }
        });
    }
    ngOnDestroy() {
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
        clearInterval(this.commentsReloader);
    }
    submit() {
        this.dialog.open(SubmitContentDialog);
    }
    goToAwsList() {
        this.router.navigate(['posts']);
    }
    postNewsComment() {
        let newsComment = new NewsComment();
        if (this.commentText.trim() != '') {
            newsComment.contentCode = this.post.code;
            newsComment.textContent = this.commentText;
            newsComment.username = localStorage.getItem('f1-chosen-nickname');
            this.restService.postNewsComment(newsComment).subscribe({
                next: data => {
                    this.commentText = '';
                },
                error: error => {
                    console.error('There was an error!', error);
                    this.utilityService.pushToastrErrorMessage('ERROR OCCURED. Comment not posted.');
                }
            });
            this.minimumReloadCounterValue = 0;
            this.currentReloadCounter = 1;
        }
    }
    reloadAwsComments() {
        this.getNewsComments();
        this.minimumReloadCounterValue = 0;
        this.currentReloadCounter = 1;
    }
    getNewsCommentsPeriodically() {
        if (this.currentReloadCounter > this.minimumReloadCounterValue) {
            this.getNewsComments();
            this.minimumReloadCounterValue++;
            this.currentReloadCounter = 0;
        }
        else {
            this.currentReloadCounter++;
        }
    }
    getNewsComments() {
        this.restService.getNewsComments(this.post.code).subscribe({
            next: data => {
                this.post.comments = data;
            },
            error: error => {
                console.error('There was an error!', error);
            }
        });
    }
    addressUser(text) {
        this.commentText = this.commentText + '@' + text + ' - ';
    }
    getDomain() {
        let url = this.post.url;
        let start = 0;
        if (this.post.url.indexOf('//') > 0) {
            start = this.post.url.indexOf('//') + 2;
        }
        url = this.post.url.substring(start);
        if (url.indexOf('/') > 0) {
            url = url.substring(0, url.indexOf('/'));
        }
        return url;
    }
    sanitizedHtml() {
        return this.sanitizer.bypassSecurityTrustHtml(this.postText);
    }
}
AwsDemoComponent.ɵfac = function AwsDemoComponent_Factory(t) { return new (t || AwsDemoComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(MatDialog), core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7)); };
AwsDemoComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: AwsDemoComponent, selectors: [["app-aws-demo-cmp"]], decls: 14, vars: 4, consts: [[1, "height-fill-screen"], ["class", "div-padded-left-right-0-5", 4, "ngIf"], [4, "ngIf"], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area-100", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "bg-success", "text-white", 3, "click"], [4, "ngFor", "ngForOf"], [1, "div-padded-left-right-0-5"], [1, "card", "card-stats"], [1, "card-body"], [1, "col-12", "col-lg-12", "div-padded-always-left-right-1-2", "text-right"], ["class", "col-12 col-lg-2 no-right-padding", 4, "ngIf"], ["class", "pre-line col-12 col-lg-10 div-padded-always-left-right-1-2", 4, "ngIf"], [1, "col-12", "col-lg-2", "no-right-padding"], [1, "icon-big", "text-center", "icon-warning"], [1, "nc-icon", "nc-align-left-2", "text-success"], ["target", "_blank", 3, "href"], [1, "text-center"], [1, "nc-icon", "nc-globe", "text-success"], [1, "teko-text-small"], [1, "pre-line", "col-12", "col-lg-10", "div-padded-always-left-right-1-2"], [1, "col-12", "col-lg-12", "div-padded-always-top-right-2rem", "text-right"], [1, "div-padded-left-right-0-5", "pb-3"], [3, "innerHTML"], [1, "pt-5", "pb-3"], [1, "basic-comment"], [1, "one-aws", 3, "click"], [1, "two-aws", 3, "click"], [1, "basic-comment-body"]], template: function AwsDemoComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "div", 0);
        core/* ɵɵtemplate */.YNc(2, AwsDemoComponent_div_2_Template, 11, 7, "div", 1);
        core/* ɵɵtemplate */.YNc(3, AwsDemoComponent_div_3_Template, 10, 5, "div", 2);
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function AwsDemoComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.commentText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function AwsDemoComponent_Template_button_click_9_listener() { return ctx.postNewsComment(); });
        core/* ɵɵtext */._uU(10, "Comment");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function AwsDemoComponent_Template_button_click_11_listener() { return ctx.reloadAwsComments(); });
        core/* ɵɵtext */._uU(12, "Reload");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, AwsDemoComponent_div_13_Template, 11, 7, "div", 8);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.post.status == 1);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.post.status == 2);
        core/* ɵɵadvance */.xp6(4);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.commentText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.post.comments);
    } }, directives: [common/* NgIf */.O5, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg], pipes: [common/* DatePipe */.uU], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(6215);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(5319);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/zip.js
var zip = __webpack_require__(1571);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules
var delay = __webpack_require__(1289);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js
var debounceTime = __webpack_require__(4395);
;// CONCATENATED MODULE: ./node_modules/ng-gallery/fesm2020/ng-gallery.mjs









function GalleryImageComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 4);
  }

  if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("background-image", ctx_r0.imageUrl);
    core/* ɵɵproperty */.Q6J("@fadeIn", undefined);
  }
}

function GalleryImageComponent_div_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 8);
  }

  if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("innerHTML", ctx_r3.errorTemplate, core/* ɵɵsanitizeHtml */.oJD);
  }
}

function GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "h4");
    core/* ɵɵtext */._uU(2, "\u26A0");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
  }
}

function GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "h2");
    core/* ɵɵtext */._uU(1, "\u26A0");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(2, "p");
    core/* ɵɵtext */._uU(3, "Unable to load the image!");
    core/* ɵɵelementEnd */.qZA();
  }
}

function GalleryImageComponent_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, GalleryImageComponent_div_3_ng_template_2_ng_container_0_Template, 3, 0, "ng-container", 9);
    core/* ɵɵtemplate */.YNc(1, GalleryImageComponent_div_3_ng_template_2_ng_template_1_Template, 4, 0, "ng-template", null, 10, core/* ɵɵtemplateRefExtractor */.W1O);
  }

  if (rf & 2) {
    const _r7 = core/* ɵɵreference */.MAs(2);

    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r5.isThumbnail)("ngIfElse", _r7);
  }
}

function GalleryImageComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 5);
    core/* ɵɵtemplate */.YNc(1, GalleryImageComponent_div_3_div_1_Template, 1, 1, "div", 6);
    core/* ɵɵtemplate */.YNc(2, GalleryImageComponent_div_3_ng_template_2_Template, 3, 2, "ng-template", null, 7, core/* ɵɵtemplateRefExtractor */.W1O);
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const _r4 = core/* ɵɵreference */.MAs(3);

    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r1.errorTemplate)("ngIfElse", _r4);
  }
}

function GalleryImageComponent_ng_container_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 13);
  }

  if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("innerHTML", ctx_r9.loaderTemplate, core/* ɵɵsanitizeHtml */.oJD);
  }
}

function GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 15);
  }
}

function GalleryImageComponent_ng_container_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, GalleryImageComponent_ng_container_4_ng_template_2_div_0_Template, 1, 0, "div", 14);
  }

  if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r11.isThumbnail);
  }
}

function GalleryImageComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵtemplate */.YNc(1, GalleryImageComponent_ng_container_4_div_1_Template, 1, 1, "div", 11);
    core/* ɵɵtemplate */.YNc(2, GalleryImageComponent_ng_container_4_ng_template_2_Template, 1, 1, "ng-template", null, 12, core/* ɵɵtemplateRefExtractor */.W1O);
    core/* ɵɵelementContainerEnd */.BQk();
  }

  if (rf & 2) {
    const _r10 = core/* ɵɵreference */.MAs(3);

    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.loaderTemplate)("ngIfElse", _r10);
  }
}

function GalleryThumbComponent_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainer */.GkF(0);
  }
}

const ng_gallery_c0 = function (a0, a1, a2) {
  return {
    index: a0,
    type: a1,
    data: a2
  };
};

function GalleryThumbComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 2);
    core/* ɵɵtemplate */.YNc(1, GalleryThumbComponent_div_1_ng_container_1_Template, 1, 0, "ng-container", 3);
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngTemplateOutlet", ctx_r0.config.thumbTemplate)("ngTemplateOutletContext", core/* ɵɵpureFunction3 */.kEZ(2, ng_gallery_c0, ctx_r0.index, ctx_r0.type, ctx_r0.data));
  }
}

function GalleryThumbsComponent_div_0_gallery_thumb_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-thumb", 4);
    core/* ɵɵlistener */.NdJ("tapClick", function GalleryThumbsComponent_div_0_gallery_thumb_2_Template_gallery_thumb_tapClick_0_listener() {
      const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6);
      const i_r4 = restoredCtx.index;
      const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r5.thumbClick.emit(i_r4);
    })("error", function GalleryThumbsComponent_div_0_gallery_thumb_2_Template_gallery_thumb_error_0_listener($event) {
      const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6);
      const i_r4 = restoredCtx.index;
      const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r7.error.emit({
        itemIndex: i_r4,
        error: $event
      });
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("type", item_r3.type)("config", ctx_r2.config)("data", item_r3.data)("currIndex", ctx_r2.state.currIndex)("index", i_r4)("tapClickDisabled", ctx_r2.config.disableThumb);
  }
}

function GalleryThumbsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "div", 2);
    core/* ɵɵtemplate */.YNc(2, GalleryThumbsComponent_div_0_gallery_thumb_2_Template, 1, 6, "gallery-thumb", 3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const sliderState_r1 = ctx.$implicit;
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵclassProp */.ekj("g-contain", ctx_r0.config.thumbView === ctx_r0.thumbnailsView.Contain)("g-contain-small-content", ctx_r0.thumbnailsLessThanSlider)("g-no-transition", sliderState_r1.active);
    core/* ɵɵproperty */.Q6J("ngStyle", sliderState_r1.style);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.state.items);
  }
}

const ng_gallery_c1 = ["video"];

function GalleryVideoComponent_source_2_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "source", 3);
  }

  if (rf & 2) {
    const src_r2 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("src", src_r2 == null ? null : src_r2.url, core/* ɵɵsanitizeUrl */.LSH)("type", src_r2 == null ? null : src_r2.type);
  }
}

const ng_gallery_c2 = ["iframe"];

function GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainer */.GkF(0);
  }
}

const ng_gallery_c3 = function (a0, a1, a2, a3) {
  return {
    index: a0,
    currIndex: a1,
    type: a2,
    data: a3
  };
};

function GalleryItemComponent_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "gallery-image", 7);
    core/* ɵɵlistener */.NdJ("error", function GalleryItemComponent_ng_container_0_ng_container_1_Template_gallery_image_error_1_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r8);
      const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r7.error.emit($event);
    });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(2, "div", 8);
    core/* ɵɵtemplate */.YNc(3, GalleryItemComponent_ng_container_0_ng_container_1_ng_container_3_Template, 1, 0, "ng-container", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
  }

  if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("src", ctx_r1.data.src)("loadingIcon", ctx_r1.config.loadingIcon)("loadingError", ctx_r1.config.loadingError);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngTemplateOutlet", ctx_r1.config.itemTemplate)("ngTemplateOutletContext", core/* ɵɵpureFunction4 */.l5B(5, ng_gallery_c3, ctx_r1.index, ctx_r1.currIndex, ctx_r1.type, ctx_r1.data));
  }
}

function GalleryItemComponent_ng_container_0_gallery_video_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-video", 10);
    core/* ɵɵlistener */.NdJ("error", function GalleryItemComponent_ng_container_0_gallery_video_2_Template_gallery_video_error_0_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r10);
      const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r9.error.emit($event);
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r2.data.src)("poster", ctx_r2.data.poster)("controls", ctx_r2.data.controls)("play", ctx_r2.isAutoPlay)("pause", ctx_r2.currIndex !== ctx_r2.index);
  }
}

function GalleryItemComponent_ng_container_0_gallery_iframe_3_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "gallery-iframe", 11);
  }

  if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r3.youtubeSrc)("autoplay", ctx_r3.isAutoPlay)("pause", ctx_r3.currIndex !== ctx_r3.index);
  }
}

function GalleryItemComponent_ng_container_0_gallery_iframe_4_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "gallery-iframe", 12);
  }

  if (rf & 2) {
    const ctx_r4 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r4.data.src);
  }
}

function GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainer */.GkF(0);
  }
}

function GalleryItemComponent_ng_container_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0);
    core/* ɵɵelementStart */.TgZ(1, "div", 8);
    core/* ɵɵtemplate */.YNc(2, GalleryItemComponent_ng_container_0_ng_container_5_ng_container_2_Template, 1, 0, "ng-container", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementContainerEnd */.BQk();
  }

  if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngTemplateOutlet", ctx_r5.config.itemTemplate)("ngTemplateOutletContext", core/* ɵɵpureFunction4 */.l5B(2, ng_gallery_c3, ctx_r5.index, ctx_r5.currIndex, ctx_r5.type, ctx_r5.data));
  }
}

function GalleryItemComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementContainerStart */.ynx(0, 1);
    core/* ɵɵtemplate */.YNc(1, GalleryItemComponent_ng_container_0_ng_container_1_Template, 4, 10, "ng-container", 2);
    core/* ɵɵtemplate */.YNc(2, GalleryItemComponent_ng_container_0_gallery_video_2_Template, 1, 5, "gallery-video", 3);
    core/* ɵɵtemplate */.YNc(3, GalleryItemComponent_ng_container_0_gallery_iframe_3_Template, 1, 3, "gallery-iframe", 4);
    core/* ɵɵtemplate */.YNc(4, GalleryItemComponent_ng_container_0_gallery_iframe_4_Template, 1, 1, "gallery-iframe", 5);
    core/* ɵɵtemplate */.YNc(5, GalleryItemComponent_ng_container_0_ng_container_5_Template, 3, 7, "ng-container", 6);
    core/* ɵɵelementContainerEnd */.BQk();
  }

  if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngSwitch", ctx_r0.type);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", ctx_r0.Types.Image);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", ctx_r0.Types.Video);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", ctx_r0.Types.Youtube);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngSwitchCase", ctx_r0.Types.Iframe);
  }
}

function GallerySliderComponent_div_0_gallery_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-item", 4);
    core/* ɵɵlistener */.NdJ("tapClick", function GallerySliderComponent_div_0_gallery_item_2_Template_gallery_item_tapClick_0_listener() {
      const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6);
      const i_r4 = restoredCtx.index;
      const ctx_r5 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r5.itemClick.emit(i_r4);
    })("error", function GallerySliderComponent_div_0_gallery_item_2_Template_gallery_item_error_0_listener($event) {
      const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6);
      const i_r4 = restoredCtx.index;
      const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
      return ctx_r7.error.emit({
        itemIndex: i_r4,
        error: $event
      });
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("type", item_r3.type)("config", ctx_r2.config)("data", item_r3.data)("currIndex", ctx_r2.state.currIndex)("index", i_r4);
  }
}

function GallerySliderComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "div", 2);
    core/* ɵɵtemplate */.YNc(2, GallerySliderComponent_div_0_gallery_item_2_Template, 1, 5, "gallery-item", 3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const sliderState_r1 = ctx.$implicit;
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngStyle", ctx_r0.zoom);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵclassProp */.ekj("g-no-transition", sliderState_r1.active);
    core/* ɵɵproperty */.Q6J("ngStyle", sliderState_r1.style);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.state.items);
  }
}

const ng_gallery_c4 = ["*"];

function GalleryNavComponent_i_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "i", 2);
    core/* ɵɵlistener */.NdJ("tapClick", function GalleryNavComponent_i_0_Template_i_tapClick_0_listener() {
      core/* ɵɵrestoreView */.CHM(_r3);
      const ctx_r2 = core/* ɵɵnextContext */.oxw();
      return ctx_r2.action.emit("prev");
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("innerHtml", ctx_r0.navIcon, core/* ɵɵsanitizeHtml */.oJD);
  }
}

function GalleryNavComponent_i_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "i", 3);
    core/* ɵɵlistener */.NdJ("tapClick", function GalleryNavComponent_i_1_Template_i_tapClick_0_listener() {
      core/* ɵɵrestoreView */.CHM(_r5);
      const ctx_r4 = core/* ɵɵnextContext */.oxw();
      return ctx_r4.action.emit("next");
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("innerHtml", ctx_r1.navIcon, core/* ɵɵsanitizeHtml */.oJD);
  }
}

function GalleryDotsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵlistener */.NdJ("tapClick", function GalleryDotsComponent_div_0_Template_div_tapClick_0_listener() {
      const restoredCtx = core/* ɵɵrestoreView */.CHM(_r4);
      const i_r2 = restoredCtx.index;
      const ctx_r3 = core/* ɵɵnextContext */.oxw();
      return ctx_r3.action.emit(i_r2);
    });
    core/* ɵɵelement */._UZ(1, "div", 2);
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const i_r2 = ctx.index;
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("width", ctx_r0.config == null ? null : ctx_r0.config.dotsSize, "px")("height", ctx_r0.config == null ? null : ctx_r0.config.dotsSize, "px");
    core/* ɵɵclassProp */.ekj("g-dot-active", i_r2 === ctx_r0.state.currIndex);
  }
}

function GalleryCoreComponent_gallery_thumbs_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-thumbs", 5);
    core/* ɵɵlistener */.NdJ("action", function GalleryCoreComponent_gallery_thumbs_0_Template_gallery_thumbs_action_0_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r5);
      const ctx_r4 = core/* ɵɵnextContext */.oxw();
      return ctx_r4.action.emit($event);
    })("thumbClick", function GalleryCoreComponent_gallery_thumbs_0_Template_gallery_thumbs_thumbClick_0_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r5);
      const ctx_r6 = core/* ɵɵnextContext */.oxw();
      return ctx_r6.thumbClick.emit($event);
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("state", ctx_r0.state)("config", ctx_r0.config);
  }
}

function GalleryCoreComponent_gallery_nav_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-nav", 6);
    core/* ɵɵlistener */.NdJ("action", function GalleryCoreComponent_gallery_nav_3_Template_gallery_nav_action_0_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r8);
      const ctx_r7 = core/* ɵɵnextContext */.oxw();
      return ctx_r7.action.emit($event);
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("state", ctx_r1.state)("config", ctx_r1.config);
  }
}

function GalleryCoreComponent_gallery_dots_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = core/* ɵɵgetCurrentView */.EpF();

    core/* ɵɵelementStart */.TgZ(0, "gallery-dots", 6);
    core/* ɵɵlistener */.NdJ("action", function GalleryCoreComponent_gallery_dots_4_Template_gallery_dots_action_0_listener($event) {
      core/* ɵɵrestoreView */.CHM(_r10);
      const ctx_r9 = core/* ɵɵnextContext */.oxw();
      return ctx_r9.action.emit($event);
    });
    core/* ɵɵelementEnd */.qZA();
  }

  if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("state", ctx_r2.state)("config", ctx_r2.config);
  }
}

function GalleryCoreComponent_gallery_counter_5_Template(rf, ctx) {
  if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "gallery-counter", 7);
  }

  if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("state", ctx_r3.state);
  }
}

var GalleryAction;

(function (GalleryAction) {
  GalleryAction["INITIALIZED"] = "initialized";
  GalleryAction["ITEMS_CHANGED"] = "itemsChanged";
  GalleryAction["INDEX_CHANGED"] = "indexChanged";
  GalleryAction["PLAY"] = "play";
  GalleryAction["STOP"] = "stop";
})(GalleryAction || (GalleryAction = {}));

var ImageSize;

(function (ImageSize) {
  ImageSize["Cover"] = "cover";
  ImageSize["Contain"] = "contain";
})(ImageSize || (ImageSize = {}));

var LoadingStrategy;

(function (LoadingStrategy) {
  LoadingStrategy["Preload"] = "preload";
  LoadingStrategy["Lazy"] = "lazy";
  LoadingStrategy["Default"] = "default";
})(LoadingStrategy || (LoadingStrategy = {}));

var ThumbnailsPosition;

(function (ThumbnailsPosition) {
  ThumbnailsPosition["Top"] = "top";
  ThumbnailsPosition["Left"] = "left";
  ThumbnailsPosition["Right"] = "right";
  ThumbnailsPosition["Bottom"] = "bottom";
})(ThumbnailsPosition || (ThumbnailsPosition = {}));

var ImageLoaderMode;

(function (ImageLoaderMode) {
  ImageLoaderMode["Determinate"] = "determinate";
  ImageLoaderMode["Indeterminate"] = "indeterminate";
})(ImageLoaderMode || (ImageLoaderMode = {}));

var DotsPosition;

(function (DotsPosition) {
  DotsPosition["Top"] = "top";
  DotsPosition["Bottom"] = "bottom";
})(DotsPosition || (DotsPosition = {}));

var CounterPosition;

(function (CounterPosition) {
  CounterPosition["Top"] = "top";
  CounterPosition["Bottom"] = "bottom";
})(CounterPosition || (CounterPosition = {}));

var ThumbnailsMode;

(function (ThumbnailsMode) {
  ThumbnailsMode["Free"] = "free";
  ThumbnailsMode["Strict"] = "strict";
})(ThumbnailsMode || (ThumbnailsMode = {}));

var SlidingDirection;

(function (SlidingDirection) {
  SlidingDirection["Horizontal"] = "horizontal";
  SlidingDirection["Vertical"] = "vertical";
})(SlidingDirection || (SlidingDirection = {}));

var GalleryItemType;

(function (GalleryItemType) {
  GalleryItemType["Image"] = "image";
  GalleryItemType["Video"] = "video";
  GalleryItemType["Youtube"] = "youtube";
  GalleryItemType["Iframe"] = "iframe";
})(GalleryItemType || (GalleryItemType = {}));

var ThumbnailsView;

(function (ThumbnailsView) {
  ThumbnailsView["Default"] = "default";
  ThumbnailsView["Contain"] = "contain";
})(ThumbnailsView || (ThumbnailsView = {}));
/** Initial state */


const defaultState = {
  action: GalleryAction.INITIALIZED,
  isPlaying: false,
  hasNext: false,
  hasPrev: false,
  currIndex: 0,
  items: []
};
const defaultConfig = {
  nav: true,
  loop: true,
  zoomOut: 0,
  dots: false,
  thumb: true,
  dotsSize: 30,
  counter: true,
  gestures: true,
  autoPlay: false,
  thumbWidth: 120,
  thumbHeight: 90,
  panSensitivity: 25,
  disableThumb: false,
  playerInterval: 3000,
  imageSize: ImageSize.Contain,
  thumbMode: ThumbnailsMode.Strict,
  dotsPosition: DotsPosition.Bottom,
  counterPosition: CounterPosition.Top,
  thumbPosition: ThumbnailsPosition.Bottom,
  loadingStrategy: LoadingStrategy.Default,
  slidingDirection: SlidingDirection.Horizontal,
  navIcon: `<?xml version="1.0" encoding="UTF-8"?><svg width="512px" height="512px" enable-background="new 0 0 240.823 240.823" version="1.1" viewBox="0 0 240.823 240.823" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"><path d="m183.19 111.82l-108.3-108.26c-4.752-4.74-12.451-4.74-17.215 0-4.752 4.74-4.752 12.439 0 17.179l99.707 99.671-99.695 99.671c-4.752 4.74-4.752 12.439 0 17.191 4.752 4.74 12.463 4.74 17.215 0l108.3-108.26c4.68-4.691 4.68-12.511-0.012-17.19z" fill="#fff"/></svg>`,
  loadingIcon: `<?xml version="1.0" encoding="UTF-8"?><svg stroke="#fff" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd" stroke-width="2"><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="0s" calcMode="spline" dur="1.8s" keySplines="0.165, 0.84, 0.44, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 20"/><animate attributeName="stroke-opacity" begin="0s" calcMode="spline" dur="1.8s" keySplines="0.3, 0.61, 0.355, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 0"/></circle><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="-0.9s" calcMode="spline" dur="1.8s" keySplines="0.165, 0.84, 0.44, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 20"/><animate attributeName="stroke-opacity" begin="-0.9s" calcMode="spline" dur="1.8s" keySplines="0.3, 0.61, 0.355, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 0"/></circle></g></svg>`
};

class ImageItem {
  constructor(data) {
    this.data = data;
    this.type = GalleryItemType.Image;
  }

}

class VideoItem {
  constructor(data) {
    this.data = data;
    this.type = GalleryItemType.Video;
  }

}

class IframeItem {
  constructor(data) {
    this.data = data;
    this.type = GalleryItemType.Iframe;
  }

}

class YoutubeItem {
  constructor(data) {
    this.data = { ...data,
      ...{
        src: `https://youtube.com/embed/${data.src}`,
        thumb: data.thumb ? data.thumb : `//img.youtube.com/vi/${data.src}/default.jpg`
      }
    };
    this.type = GalleryItemType.Youtube;
  }

}

const filterActions = actions => {
  return (0,filter/* filter */.h)(state => actions.indexOf(state.action) > -1);
};

class GalleryRef {
  constructor(config, deleteInstance) {
    this.deleteInstance = deleteInstance;
    /** Stream that emits on item click */

    this.itemClick = new Subject/* Subject */.xQ();
    /** Stream that emits on thumbnail click */

    this.thumbClick = new Subject/* Subject */.xQ();
    /** Stream that emits on an error occurs */

    this.error = new Subject/* Subject */.xQ();
    this._state = new BehaviorSubject/* BehaviorSubject */.X(defaultState);
    this._config = new BehaviorSubject/* BehaviorSubject */.X(config);
    this.state = this._state.asObservable();
    this.config = this._config.asObservable();
  }

  get stateSnapshot() {
    return this._state.value;
  }
  /** Stream that emits when gallery is initialized/reset */


  get initialized() {
    return this.state.pipe(filterActions([GalleryAction.INITIALIZED]));
  }
  /** Stream that emits when items is changed (items loaded, item added, item removed) */


  get itemsChanged() {
    return this.state.pipe(filterActions([GalleryAction.ITEMS_CHANGED]));
  }
  /** Stream that emits when current item is changed */


  get indexChanged() {
    return this.state.pipe(filterActions([GalleryAction.INDEX_CHANGED]));
  }
  /** Stream that emits when the player should start or stop */


  get playingChanged() {
    return this.state.pipe(filterActions([GalleryAction.PLAY, GalleryAction.STOP]));
  }
  /** Stream that emits when the player should start or stop */


  get playerActions() {
    return this.state.pipe(filterActions([GalleryAction.PLAY, GalleryAction.STOP, GalleryAction.INDEX_CHANGED]));
  }
  /**
   * Activate player actions listener
   */


  activatePlayer() {
    return this.playerActions.pipe((0,switchMap/* switchMap */.w)(e => e.isPlaying ? (0,of.of)({}).pipe((0,delay/* delay */.g)(this._config.value.playerInterval), (0,tap/* tap */.b)(() => this.next())) : empty/* EMPTY */.E));
  }
  /**
   * Set gallery state
   */


  setState(state) {
    this._state.next({ ...this.stateSnapshot,
      ...state
    });
  }
  /**
   * Set gallery config
   */


  setConfig(config) {
    this._config.next({ ...this._config.value,
      ...config
    });
  }
  /**
   * Add gallery item
   */


  add(item, active) {
    const items = [...this.stateSnapshot.items, item];
    this.setState({
      action: GalleryAction.ITEMS_CHANGED,
      items,
      hasNext: items.length > 1,
      currIndex: active ? items.length - 1 : this.stateSnapshot.currIndex
    });
  }
  /**
   * Add image item
   */


  addImage(data, active) {
    this.add(new ImageItem(data), active);
  }
  /**
   * Add video item
   */


  addVideo(data, active) {
    this.add(new VideoItem(data), active);
  }
  /**
   * Add iframe item
   */


  addIframe(data, active) {
    this.add(new IframeItem(data), active);
  }
  /**
   * Add youtube item
   */


  addYoutube(data, active) {
    this.add(new YoutubeItem(data), active);
  }
  /**
   * Remove gallery item
   */


  remove(i) {
    const state = this.stateSnapshot;
    const items = [...state.items.slice(0, i), ...state.items.slice(i + 1, state.items.length)];
    this.setState({
      action: GalleryAction.ITEMS_CHANGED,
      currIndex: i < 1 ? state.currIndex : i - 1,
      items,
      hasNext: items.length > 1,
      hasPrev: i > 0
    });
  }
  /**
   * Load items and reset the state
   */


  load(items) {
    if (items) {
      this.setState({
        action: GalleryAction.ITEMS_CHANGED,
        items,
        hasNext: items.length > 1,
        hasPrev: false
      });
    }
  }
  /**
   * Set active item
   */


  set(i) {
    if (i !== this.stateSnapshot.currIndex) {
      this.setState({
        action: GalleryAction.INDEX_CHANGED,
        currIndex: i,
        hasNext: i < this.stateSnapshot.items.length - 1,
        hasPrev: i > 0
      });
    }
  }
  /**
   * Next item
   */


  next() {
    if (this.stateSnapshot.hasNext) {
      this.set(this.stateSnapshot.currIndex + 1);
    } else if (this._config.value.loop) {
      this.set(0);
    }
  }
  /**
   * Prev item
   */


  prev() {
    if (this.stateSnapshot.hasPrev) {
      this.set(this.stateSnapshot.currIndex - 1);
    } else if (this._config.value.loop) {
      this.set(this.stateSnapshot.items.length - 1);
    }
  }
  /**
   * Start gallery player
   */


  play(interval) {
    if (interval) {
      this.setConfig({
        playerInterval: interval
      });
    }

    this.setState({
      action: GalleryAction.PLAY,
      isPlaying: true
    });
  }
  /**
   * Stop gallery player
   */


  stop() {
    this.setState({
      action: GalleryAction.STOP,
      isPlaying: false
    });
  }
  /**
   * Reset gallery to initial state
   */


  reset() {
    this.setState(defaultState);
  }
  /**
   * Destroy gallery
   */


  destroy() {
    this._state.complete();

    this._config.complete();

    this.itemClick.complete();
    this.thumbClick.complete();
    this.deleteInstance();
  }

}

const GALLERY_CONFIG = new core/* InjectionToken */.OlP('GALLERY_CONFIG');

class Gallery {
  constructor(config) {
    /** Store gallery instances */
    this._instances = new Map();
    this.config = config ? { ...defaultConfig,
      ...config
    } : defaultConfig;
  }
  /**
   * Get or create gallery by ID
   * @param id
   * @param config
   */


  ref(id = 'root', config) {
    if (this._instances.has(id)) {
      const galleryRef = this._instances.get(id);

      if (config) {
        galleryRef.setConfig({ ...this.config,
          ...config
        });
      }

      return galleryRef;
    } else {
      return this._instances.set(id, new GalleryRef({ ...this.config,
        ...config
      }, this.deleteInstance(id))).get(id);
    }
  }
  /**
   * Destroy all gallery instances
   */


  destroyAll() {
    this._instances.forEach(ref => ref.destroy());
  }
  /**
   * Reset all gallery instances
   */


  resetAll() {
    this._instances.forEach(ref => ref.reset());
  }
  /**
   * A destroyer function for each gallery instance
   */


  deleteInstance(id) {
    return () => {
      if (this._instances.has(id)) {
        this._instances.delete(id);
      }
    };
  }

}

Gallery.ɵfac = function Gallery_Factory(t) {
  return new (t || Gallery)(core/* ɵɵinject */.LFG(GALLERY_CONFIG, 8));
};

Gallery.ɵprov = /* @__PURE__ */core/* ɵɵdefineInjectable */.Yz7({
  token: Gallery,
  factory: Gallery.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(Gallery, [{
    type: core/* Injectable */.GSi,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: core/* Optional */.FiY
      }, {
        type: core/* Inject */.tBr,
        args: [GALLERY_CONFIG]
      }]
    }];
  }, null);
})();

class LazyImage {
  constructor(document) {
    this.document = document;
    this._imageLoader$ = new Subject/* Subject */.xQ();
    this._loaderSub$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this.loaded = new core/* EventEmitter */.vpe();
    this.error = new core/* EventEmitter */.vpe();
    this._loaderSub$ = this._imageLoader$.pipe((0,switchMap/* switchMap */.w)(imageSrc => this.nativeLoader(imageSrc))).subscribe();
  }

  ngOnChanges(changes) {
    if (changes['src'] && changes['src'].previousValue !== changes['src'].currentValue) {
      this.loadImage(this.src);
    }
  }

  ngOnDestroy() {
    this._loaderSub$.unsubscribe();

    this._imageLoader$.complete();
  }

  loadImage(imagePath) {
    this._imageLoader$.next(imagePath);
  }
  /**
   * Native image loader, does not emit progress
   * @param url
   */


  nativeLoader(url) {
    const img = this.document.createElement('img'); // Stop previously loading

    img.src = url; // Image load success

    const loadSuccess = (0,fromEvent/* fromEvent */.R)(img, 'load').pipe((0,tap/* tap */.b)(() => this.loaded.emit(url))); // Image load failed

    const loadError = (0,fromEvent/* fromEvent */.R)(img, 'error').pipe((0,tap/* tap */.b)(() => this.error.emit(new Error(`[lazyImage]: The image ${url} did not load`))));
    return (0,zip/* zip */.$R)(loadSuccess, loadError);
  }

}

LazyImage.ɵfac = function LazyImage_Factory(t) {
  return new (t || LazyImage)(core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0));
};

LazyImage.ɵdir = /* @__PURE__ */core/* ɵɵdefineDirective */.lG2({
  type: LazyImage,
  selectors: [["", "lazyImage", ""]],
  inputs: {
    src: ["lazyImage", "src"]
  },
  outputs: {
    loaded: "loaded",
    error: "error"
  },
  features: [core/* ɵɵNgOnChangesFeature */.TTD]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(LazyImage, [{
    type: core/* Directive */.Xek,
    args: [{
      selector: '[lazyImage]'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: core/* Inject */.tBr,
        args: [common/* DOCUMENT */.K0]
      }]
    }];
  }, {
    src: [{
      type: core/* Input */.IIB,
      args: ['lazyImage']
    }],
    loaded: [{
      type: core/* Output */.r_U
    }],
    error: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryImageComponent {
  constructor(_sanitizer) {
    this._sanitizer = _sanitizer;
    /** Stream that emits the state */

    this._state = new BehaviorSubject/* BehaviorSubject */.X('loading');
    this.state = this._state.asObservable();
    /** Progress value */

    this.progress = 0;
    /** Stream that emits when an error occurs */

    this.error = new core/* EventEmitter */.vpe();
  }

  get imageLoadSuccess() {
    return !!this.imageUrl;
  }

  get imageLoadFailed() {
    return !!this.loadError;
  }

  ngOnInit() {
    if (this.loadingIcon) {
      this.loaderTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingIcon);
    }

    if (this.loadingError) {
      this.errorTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingError);
    }
  }

  ngOnDestroy() {
    this._state.complete();
  }

  onProgress({
    loaded,
    total
  }) {
    this.progress = loaded * 100 / total;
  }

  onLoaded(blobUrl) {
    this.imageUrl = this._sanitizer.bypassSecurityTrustStyle(`url("${blobUrl}")`);

    this._state.next('success');
  }

  onError(err) {
    this.loadError = err;

    this._state.next('failed');

    this.error.emit(err);
  }

}

GalleryImageComponent.ɵfac = function GalleryImageComponent_Factory(t) {
  return new (t || GalleryImageComponent)(core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7));
};

GalleryImageComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryImageComponent,
  selectors: [["gallery-image"]],
  hostVars: 4,
  hostBindings: function GalleryImageComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core/* ɵɵclassProp */.ekj("g-image-loaded", ctx.imageLoadSuccess)("g-image-error", ctx.imageLoadFailed);
    }
  },
  inputs: {
    isThumbnail: "isThumbnail",
    src: "src",
    loadingIcon: "loadingIcon",
    loadingError: "loadingError"
  },
  outputs: {
    error: "error"
  },
  decls: 5,
  vars: 7,
  consts: [[3, "lazyImage", "ngSwitch", "progress", "loaded", "error"], ["class", "g-image-item", 3, "backgroundImage", 4, "ngSwitchCase"], ["class", "g-image-error-message", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [1, "g-image-item"], [1, "g-image-error-message"], [3, "innerHTML", 4, "ngIf", "ngIfElse"], ["defaultError", ""], [3, "innerHTML"], [4, "ngIf", "ngIfElse"], ["isLarge", ""], ["class", "g-loading", 3, "innerHTML", 4, "ngIf", "ngIfElse"], ["defaultLoader", ""], [1, "g-loading", 3, "innerHTML"], ["class", "g-thumb-loading", 4, "ngIf"], [1, "g-thumb-loading"]],
  template: function GalleryImageComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵelementContainerStart */.ynx(0, 0);
      core/* ɵɵlistener */.NdJ("progress", function GalleryImageComponent_Template_ng_container_progress_0_listener($event) {
        return ctx.onProgress($event);
      })("loaded", function GalleryImageComponent_Template_ng_container_loaded_0_listener($event) {
        return ctx.onLoaded($event);
      })("error", function GalleryImageComponent_Template_ng_container_error_0_listener($event) {
        return ctx.onError($event);
      });
      core/* ɵɵpipe */.ALo(1, "async");
      core/* ɵɵtemplate */.YNc(2, GalleryImageComponent_div_2_Template, 1, 3, "div", 1);
      core/* ɵɵtemplate */.YNc(3, GalleryImageComponent_div_3_Template, 4, 2, "div", 2);
      core/* ɵɵtemplate */.YNc(4, GalleryImageComponent_ng_container_4_Template, 4, 2, "ng-container", 3);
      core/* ɵɵelementContainerEnd */.BQk();
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("lazyImage", ctx.src)("ngSwitch", core/* ɵɵpipeBind1 */.lcZ(1, 5, ctx.state));
      core/* ɵɵadvance */.xp6(2);
      core/* ɵɵproperty */.Q6J("ngSwitchCase", "success");
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngSwitchCase", "failed");
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngSwitchCase", "loading");
    }
  },
  directives: [LazyImage, common/* NgSwitch */.RF, common/* NgSwitchCase */.n9, common/* NgIf */.O5],
  pipes: [common/* AsyncPipe */.Ov],
  encapsulation: 2,
  data: {
    animation: [(0,animations/* trigger */.X$)('fadeIn', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
      opacity: 0
    }), (0,animations/* animate */.jt)('300ms ease-in', (0,animations/* style */.oB)({
      opacity: 1
    }))])])]
  },
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryImageComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-image',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      animations: [(0,animations/* trigger */.X$)('fadeIn', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
        opacity: 0
      }), (0,animations/* animate */.jt)('300ms ease-in', (0,animations/* style */.oB)({
        opacity: 1
      }))])])],
      template: `
    <ng-container [lazyImage]="src"
                  (progress)="onProgress($event)"
                  (loaded)="onLoaded($event)"
                  (error)="onError($event)"
                  [ngSwitch]="state | async">

      <div *ngSwitchCase="'success'"
           @fadeIn
           class="g-image-item"
           [style.backgroundImage]="imageUrl">
      </div>

      <div *ngSwitchCase="'failed'"
           class="g-image-error-message">
        <div *ngIf="errorTemplate; else defaultError"
             [innerHTML]="errorTemplate"></div>
        <ng-template #defaultError>
          <ng-container *ngIf="isThumbnail; else isLarge">
            <h4>⚠</h4>
          </ng-container>
          <ng-template #isLarge>
            <h2>⚠</h2>
            <p>Unable to load the image!</p>
          </ng-template>
        </ng-template>
      </div>

      <ng-container *ngSwitchCase="'loading'">
        <div *ngIf="loaderTemplate; else defaultLoader"
             class="g-loading"
             [innerHTML]="loaderTemplate">
        </div>
        <ng-template #defaultLoader>
          <div *ngIf="isThumbnail" class="g-thumb-loading"></div>
        </ng-template>
      </ng-container>
    </ng-container>
  `
    }]
  }], function () {
    return [{
      type: platform_browser/* DomSanitizer */.H7
    }];
  }, {
    isThumbnail: [{
      type: core/* Input */.IIB
    }],
    src: [{
      type: core/* Input */.IIB
    }],
    loadingIcon: [{
      type: core/* Input */.IIB
    }],
    loadingError: [{
      type: core/* Input */.IIB
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    imageLoadSuccess: [{
      type: core/* HostBinding */.pfw,
      args: ['class.g-image-loaded']
    }],
    imageLoadFailed: [{
      type: core/* HostBinding */.pfw,
      args: ['class.g-image-error']
    }]
  });
})();

class GalleryThumbComponent {
  constructor() {
    this.error = new core/* EventEmitter */.vpe();
  }

  get isActive() {
    return this.index === this.currIndex;
  }

}

GalleryThumbComponent.ɵfac = function GalleryThumbComponent_Factory(t) {
  return new (t || GalleryThumbComponent)();
};

GalleryThumbComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryThumbComponent,
  selectors: [["gallery-thumb"]],
  hostVars: 2,
  hostBindings: function GalleryThumbComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core/* ɵɵclassProp */.ekj("g-active-thumb", ctx.isActive);
    }
  },
  inputs: {
    config: "config",
    index: "index",
    currIndex: "currIndex",
    type: "type",
    data: "data"
  },
  outputs: {
    error: "error"
  },
  decls: 2,
  vars: 5,
  consts: [["mode", "indeterminate", 3, "src", "isThumbnail", "loadingIcon", "loadingError", "error"], ["class", "g-template g-thumb-template", 4, "ngIf"], [1, "g-template", "g-thumb-template"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function GalleryThumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵelementStart */.TgZ(0, "gallery-image", 0);
      core/* ɵɵlistener */.NdJ("error", function GalleryThumbComponent_Template_gallery_image_error_0_listener($event) {
        return ctx.error.emit($event);
      });
      core/* ɵɵelementEnd */.qZA();
      core/* ɵɵtemplate */.YNc(1, GalleryThumbComponent_div_1_Template, 2, 6, "div", 1);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("src", ctx.data.thumb)("isThumbnail", true)("loadingIcon", ctx.config.thumbLoadingIcon)("loadingError", ctx.config.thumbLoadingError);
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.thumbTemplate);
    }
  },
  directives: [GalleryImageComponent, common/* NgIf */.O5, common/* NgTemplateOutlet */.tP],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryThumbComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-thumb',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <gallery-image [src]="data.thumb" 
                   mode="indeterminate"
                   [isThumbnail]="true" 
                   [loadingIcon]="config.thumbLoadingIcon"
                   [loadingError]="config.thumbLoadingError "
                   (error)="error.emit($event)"></gallery-image>

    <div *ngIf="config.thumbTemplate" class="g-template g-thumb-template">
      <ng-container
        *ngTemplateOutlet="config.thumbTemplate; context: { index: this.index, type: this.type, data: this.data }">
      </ng-container>
    </div>
  `
    }]
  }], null, {
    config: [{
      type: core/* Input */.IIB
    }],
    index: [{
      type: core/* Input */.IIB
    }],
    currIndex: [{
      type: core/* Input */.IIB
    }],
    type: [{
      type: core/* Input */.IIB
    }],
    data: [{
      type: core/* Input */.IIB
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    isActive: [{
      type: core/* HostBinding */.pfw,
      args: ['class.g-active-thumb']
    }]
  });
})();
/**
 * This directive uses tap event if HammerJS is loaded, otherwise it falls back to normal click event
 */


class TapClick {
  constructor(_el) {
    this._el = _el;
    this.clickListener = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this.tapClick = new core/* EventEmitter */.vpe();
  }

  ngOnInit() {
    this.activateClickEvent();
  }

  activateClickEvent() {
    if (typeof Hammer !== 'undefined') {
      // Use Hammer.js tap event
      this._hammer = new Hammer(this._el.nativeElement);

      this._hammer.on('tap', () => {
        if (!this.tapClickDisabled) {
          this.tapClick.emit(null);
        }
      });
    } else {
      // Use normal click event
      this.clickListener = (0,fromEvent/* fromEvent */.R)(this._el.nativeElement, 'click').pipe((0,filter/* filter */.h)(() => !this.tapClickDisabled), (0,tap/* tap */.b)(() => this.tapClick.emit(null))).subscribe();
    }
  }

  ngOnDestroy() {
    if (this._hammer) {
      this._hammer.destroy();
    }

    this.clickListener.unsubscribe();
  }

}

TapClick.ɵfac = function TapClick_Factory(t) {
  return new (t || TapClick)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq));
};

TapClick.ɵdir = /* @__PURE__ */core/* ɵɵdefineDirective */.lG2({
  type: TapClick,
  selectors: [["", "tapClick", ""]],
  inputs: {
    tapClickDisabled: "tapClickDisabled"
  },
  outputs: {
    tapClick: "tapClick"
  }
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(TapClick, [{
    type: core/* Directive */.Xek,
    args: [{
      selector: '[tapClick]'
    }]
  }], function () {
    return [{
      type: core/* ElementRef */.SBq
    }];
  }, {
    tapClickDisabled: [{
      type: core/* Input */.IIB
    }],
    tapClick: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryThumbsComponent {
  constructor(_el, _zone) {
    this._el = _el;
    this._zone = _zone;
    /** Sliding worker */

    this._slidingWorker$ = new BehaviorSubject/* BehaviorSubject */.X({
      value: 0,
      active: false
    });
    /** Current slider position in free sliding mode */

    this._freeModeCurrentOffset = 0;
    /** Thumbnails view enum */

    this.thumbnailsView = ThumbnailsView;
    /** Stream that emits when the active item should change */

    this.action = new core/* EventEmitter */.vpe();
    /** Stream that emits when thumb is clicked */

    this.thumbClick = new core/* EventEmitter */.vpe();
    /** Stream that emits when an error occurs */

    this.error = new core/* EventEmitter */.vpe(); // Activate sliding worker

    this.sliderState$ = this._slidingWorker$.pipe((0,operators_map/* map */.U)(state => ({
      style: this.getSliderStyles(state),
      active: state.active
    })));
  }

  ngOnChanges() {
    // Refresh the slider
    this.updateSlider({
      value: 0,
      active: false
    });
    this._freeModeCurrentOffset = 0;
  }

  ngOnInit() {
    if (this.config.gestures && !this.config.disableThumb && typeof Hammer !== 'undefined') {
      let direction;

      switch (this.config.thumbPosition) {
        case ThumbnailsPosition.Right:
        case ThumbnailsPosition.Left:
          direction = Hammer.DIRECTION_VERTICAL;
          break;

        case ThumbnailsPosition.Top:
        case ThumbnailsPosition.Bottom:
          direction = Hammer.DIRECTION_HORIZONTAL;
          break;
      } // Activate gestures


      this._hammer = new Hammer(this._el.nativeElement);

      this._hammer.get('pan').set({
        direction
      });

      this._zone.runOutsideAngular(() => {
        // Move the slider
        switch (this.config.thumbMode) {
          case ThumbnailsMode.Strict:
            this._hammer.on('pan', e => this.strictMode(e));

            break;

          case ThumbnailsMode.Free:
            this._hammer.on('pan', e => this.freeMode(e));

        }
      });
    }
  }

  ngOnDestroy() {
    if (this._hammer) {
      this._hammer.destroy();
    }
  }
  /**
   * Sliding strict mode
   */


  strictMode(e) {
    switch (this.config.thumbPosition) {
      case ThumbnailsPosition.Right:
      case ThumbnailsPosition.Left:
        this.updateSlider({
          value: e.deltaY,
          active: true
        });

        if (e.isFinal) {
          this.updateSlider({
            value: 0,
            active: false
          });
          this.verticalPan(e);
        }

        break;

      case ThumbnailsPosition.Top:
      case ThumbnailsPosition.Bottom:
        this.updateSlider({
          value: e.deltaX,
          active: true
        });

        if (e.isFinal) {
          this.updateSlider({
            value: 0,
            active: false
          });
          this.horizontalPan(e);
        }

    }
  }
  /**
   * Sliding free mode
   */


  freeMode(e) {
    switch (this.config.thumbPosition) {
      case ThumbnailsPosition.Right:
      case ThumbnailsPosition.Left:
        this.updateSlider({
          value: this._freeModeCurrentOffset + e.deltaY,
          active: true
        });

        if (e.isFinal) {
          if (this.minFreeScrollExceeded(e.deltaY, this.config.thumbWidth, this.config.thumbHeight)) {
            this._freeModeCurrentOffset = -(this.state.items.length - 1 - this.state.currIndex) * this.config.thumbHeight;
          } else if (this.maxFreeScrollExceeded(e.deltaY, this.config.thumbHeight, this.config.thumbWidth)) {
            this._freeModeCurrentOffset = this.state.currIndex * this.config.thumbHeight;
          } else {
            this._freeModeCurrentOffset += e.deltaY;
          }

          this.updateSlider({
            value: this._freeModeCurrentOffset,
            active: false
          });
        }

        break;

      case ThumbnailsPosition.Top:
      case ThumbnailsPosition.Bottom:
        this.updateSlider({
          value: this._freeModeCurrentOffset + e.deltaX,
          active: true
        });

        if (e.isFinal) {
          if (this.minFreeScrollExceeded(e.deltaX, this.config.thumbHeight, this.config.thumbWidth)) {
            this._freeModeCurrentOffset = -(this.state.items.length - 1 - this.state.currIndex) * this.config.thumbWidth;
          } else if (this.maxFreeScrollExceeded(e.deltaX, this.config.thumbWidth, this.config.thumbHeight)) {
            this._freeModeCurrentOffset = this.state.currIndex * this.config.thumbWidth;
          } else {
            this._freeModeCurrentOffset += e.deltaX;
          }

          this.updateSlider({
            value: this._freeModeCurrentOffset,
            active: false
          });
        }

    }
  }
  /**
   * Check if the minimum free scroll is exceeded (used in Bottom, Left directions)
   */


  minFreeScrollExceeded(delta, width, height) {
    return -(this._freeModeCurrentOffset + delta - width / 2) > (this.state.items.length - this.state.currIndex) * height;
  }
  /**
   * Check if the maximum free scroll is exceeded (used in Top, Right directions)
   */


  maxFreeScrollExceeded(delta, width, height) {
    return this._freeModeCurrentOffset + delta > this.state.currIndex * width + height / 2;
  }
  /**
   * Convert sliding state to styles
   */


  getSliderStyles(state) {
    const currIndex = this.state.currIndex;
    const itemsLength = this.state.items.length;
    const {
      thumbWidth,
      thumbHeight
    } = this.config;
    let value;

    switch (this.config.thumbPosition) {
      case ThumbnailsPosition.Top:
      case ThumbnailsPosition.Bottom:
        this.width = '100%';
        this.height = this.config.thumbHeight + 'px';

        switch (this.config.thumbView) {
          case 'contain':
            const containerWidth = this._el.nativeElement.clientWidth;
            const minHorizontalShift = itemsLength * thumbWidth - containerWidth; // If slider size is larger than thumbnails size

            if (containerWidth > itemsLength * thumbWidth) {
              this.thumbnailsLessThanSlider = true;
            } else {
              // If slider size is smaller than thumbnails size
              this.thumbnailsLessThanSlider = false;

              if (currIndex * thumbWidth + thumbWidth / 2 > containerWidth / 2) {
                value = -Math.min(currIndex * thumbWidth + thumbWidth / 2 - containerWidth / 2, minHorizontalShift);
              } else {
                value = 0;
              }
            }

            break;

          default:
            value = -(currIndex * thumbWidth) - (thumbWidth / 2 - state.value);
        }

        return {
          transform: `translate3d(${value}px, 0, 0)`,
          width: itemsLength * thumbWidth + 'px',
          height: '100%'
        };

      case ThumbnailsPosition.Left:
      case ThumbnailsPosition.Right:
        this.width = this.config.thumbWidth + 'px';
        this.height = '100%';

        switch (this.config.thumbView) {
          case 'contain':
            const containerHeight = this._el.nativeElement.clientHeight;
            const minVerticalShift = itemsLength * thumbHeight - containerHeight; // If slider size is larger than thumbnails size

            if (containerHeight > itemsLength * thumbHeight) {
              this.thumbnailsLessThanSlider = true;
            } else {
              // If slider size is smaller than thumbnails size
              this.thumbnailsLessThanSlider = false;

              if (currIndex * thumbHeight + thumbHeight / 2 > containerHeight / 2) {
                value = -Math.min(currIndex * thumbHeight + thumbHeight / 2 - containerHeight / 2, minVerticalShift);
              } else {
                value = 0;
              }
            }

            break;

          default:
            value = -(currIndex * thumbHeight) - (thumbHeight / 2 - state.value);
        }

        return {
          transform: `translate3d(0, ${value}px, 0)`,
          width: '100%',
          height: itemsLength * thumbHeight + 'px'
        };
    }
  }

  verticalPan(e) {
    if (!(e.direction & Hammer.DIRECTION_UP && e.offsetDirection & Hammer.DIRECTION_VERTICAL)) {
      return;
    }

    if (e.velocityY > 0.3) {
      this.prev();
    } else if (e.velocityY < -0.3) {
      this.next();
    } else {
      if (e.deltaY / 2 <= -this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {
        this.next();
      } else if (e.deltaY / 2 >= this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {
        this.prev();
      } else {
        this.action.emit(this.state.currIndex);
      }
    }
  }

  horizontalPan(e) {
    if (!(e.direction & Hammer.DIRECTION_HORIZONTAL && e.offsetDirection & Hammer.DIRECTION_HORIZONTAL)) {
      return;
    }

    if (e.velocityX > 0.3) {
      this.prev();
    } else if (e.velocityX < -0.3) {
      this.next();
    } else {
      if (e.deltaX / 2 <= -this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {
        this.next();
      } else if (e.deltaX / 2 >= this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {
        this.prev();
      } else {
        this.action.emit(this.state.currIndex);
      }
    }
  }

  next() {
    this.action.emit('next');
  }

  prev() {
    this.action.emit('prev');
  }

  updateSlider(state) {
    const newState = { ...this._slidingWorker$.value,
      ...state
    };

    this._slidingWorker$.next(newState);
  }

}

GalleryThumbsComponent.ɵfac = function GalleryThumbsComponent_Factory(t) {
  return new (t || GalleryThumbsComponent)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b));
};

GalleryThumbsComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryThumbsComponent,
  selectors: [["gallery-thumbs"]],
  hostVars: 4,
  hostBindings: function GalleryThumbsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core/* ɵɵstyleProp */.Udp("height", ctx.height)("width", ctx.width);
    }
  },
  inputs: {
    state: "state",
    config: "config"
  },
  outputs: {
    action: "action",
    thumbClick: "thumbClick",
    error: "error"
  },
  features: [core/* ɵɵNgOnChangesFeature */.TTD],
  decls: 2,
  vars: 3,
  consts: [["class", "g-thumbs-container", 4, "ngIf"], [1, "g-thumbs-container"], [1, "g-slider", 3, "ngStyle"], [3, "type", "config", "data", "currIndex", "index", "tapClickDisabled", "tapClick", "error", 4, "ngFor", "ngForOf"], [3, "type", "config", "data", "currIndex", "index", "tapClickDisabled", "tapClick", "error"]],
  template: function GalleryThumbsComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵtemplate */.YNc(0, GalleryThumbsComponent_div_0_Template, 3, 8, "div", 0);
      core/* ɵɵpipe */.ALo(1, "async");
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngIf", core/* ɵɵpipeBind1 */.lcZ(1, 1, ctx.sliderState$));
    }
  },
  directives: [common/* NgIf */.O5, common/* NgStyle */.PC, common/* NgForOf */.sg, GalleryThumbComponent, TapClick],
  pipes: [common/* AsyncPipe */.Ov],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryThumbsComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-thumbs',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <div *ngIf="sliderState$ | async; let sliderState"
         class="g-thumbs-container">
      <div class="g-slider"
           [class.g-contain]="config.thumbView === thumbnailsView.Contain"
           [class.g-contain-small-content]="thumbnailsLessThanSlider"
           [class.g-no-transition]="sliderState.active"
           [ngStyle]="sliderState.style">

        <gallery-thumb *ngFor="let item of state.items;let i = index"
                       [type]="item.type"
                       [config]="config"
                       [data]="item.data"
                       [currIndex]="state.currIndex"
                       [index]="i"
                       [tapClickDisabled]="config.disableThumb"
                       (tapClick)="thumbClick.emit(i)"
                       (error)="error.emit({itemIndex: i, error: $event})"></gallery-thumb>
      </div>
    </div>
  `
    }]
  }], function () {
    return [{
      type: core/* ElementRef */.SBq
    }, {
      type: core/* NgZone */.R0b
    }];
  }, {
    state: [{
      type: core/* Input */.IIB
    }],
    config: [{
      type: core/* Input */.IIB
    }],
    action: [{
      type: core/* Output */.r_U
    }],
    thumbClick: [{
      type: core/* Output */.r_U
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    height: [{
      type: core/* HostBinding */.pfw,
      args: ['style.height']
    }],
    width: [{
      type: core/* HostBinding */.pfw,
      args: ['style.width']
    }]
  });
})();

class GalleryVideoComponent {
  constructor() {
    /** Stream that emits when an error occurs */
    this.error = new core/* EventEmitter */.vpe();
  }

  set pauseVideo(shouldPause) {
    if (this.video.nativeElement) {
      const video = this.video.nativeElement;

      if (shouldPause && !video.paused) {
        video.pause();
      }
    }
  }

  set playVideo(shouldPlay) {
    if (this.video.nativeElement) {
      const video = this.video.nativeElement;

      if (shouldPlay) {
        video.play();
      }
    }
  }

  ngOnInit() {
    if (this.src instanceof Array) {
      // If video has multiple sources
      this.videoSources = [...this.src];
    } else {
      this.videoSources = [{
        url: this.src
      }];
    }

    this.controls = typeof this.controlsEnabled === 'boolean' ? this.controlsEnabled : true;
  }

}

GalleryVideoComponent.ɵfac = function GalleryVideoComponent_Factory(t) {
  return new (t || GalleryVideoComponent)();
};

GalleryVideoComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryVideoComponent,
  selectors: [["gallery-video"]],
  viewQuery: function GalleryVideoComponent_Query(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵviewQuery */.Gf(ng_gallery_c1, 7);
    }

    if (rf & 2) {
      let _t;

      core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.video = _t.first);
    }
  },
  inputs: {
    src: "src",
    poster: "poster",
    controlsEnabled: ["controls", "controlsEnabled"],
    pauseVideo: ["pause", "pauseVideo"],
    playVideo: ["play", "playVideo"]
  },
  outputs: {
    error: "error"
  },
  decls: 3,
  vars: 3,
  consts: [[3, "controls", "poster", "error"], ["video", ""], [3, "src", "type", 4, "ngFor", "ngForOf"], [3, "src", "type"]],
  template: function GalleryVideoComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵelementStart */.TgZ(0, "video", 0, 1);
      core/* ɵɵlistener */.NdJ("error", function GalleryVideoComponent_Template_video_error_0_listener($event) {
        return ctx.error.emit($event);
      });
      core/* ɵɵtemplate */.YNc(2, GalleryVideoComponent_source_2_Template, 1, 2, "source", 2);
      core/* ɵɵelementEnd */.qZA();
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("controls", ctx.controls)("poster", ctx.poster, core/* ɵɵsanitizeUrl */.LSH);
      core/* ɵɵadvance */.xp6(2);
      core/* ɵɵproperty */.Q6J("ngForOf", ctx.videoSources);
    }
  },
  directives: [common/* NgForOf */.sg],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryVideoComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-video',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <video #video [controls]="controls" [poster]="poster" (error)="error.emit($event)">
      <source *ngFor="let src of videoSources" [src]="src?.url" [type]="src?.type"/>
    </video>
  `
    }]
  }], null, {
    src: [{
      type: core/* Input */.IIB
    }],
    poster: [{
      type: core/* Input */.IIB
    }],
    controlsEnabled: [{
      type: core/* Input */.IIB,
      args: ['controls']
    }],
    pauseVideo: [{
      type: core/* Input */.IIB,
      args: ['pause']
    }],
    playVideo: [{
      type: core/* Input */.IIB,
      args: ['play']
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    video: [{
      type: core/* ViewChild */.i9L,
      args: ['video', {
        static: true
      }]
    }]
  });
})();

class GalleryIframeComponent {
  constructor(_sanitizer) {
    this._sanitizer = _sanitizer;
  }

  set src(src) {
    this.videoSrc = src;
    this.iframeSrc = this._sanitizer.bypassSecurityTrustResourceUrl(src);
  }

  set pauseVideo(shouldPause) {
    if (this.iframe.nativeElement) {
      if (shouldPause) {
        const iframe = this.iframe.nativeElement;
        iframe.src = null;

        if (!this.autoplay && this.videoSrc) {
          this.iframeSrc = this._sanitizer.bypassSecurityTrustResourceUrl(this.videoSrc);
        }
      }
    }
  }

}

GalleryIframeComponent.ɵfac = function GalleryIframeComponent_Factory(t) {
  return new (t || GalleryIframeComponent)(core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7));
};

GalleryIframeComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryIframeComponent,
  selectors: [["gallery-iframe"]],
  viewQuery: function GalleryIframeComponent_Query(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵviewQuery */.Gf(ng_gallery_c2, 7);
    }

    if (rf & 2) {
      let _t;

      core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.iframe = _t.first);
    }
  },
  inputs: {
    src: "src",
    pauseVideo: ["pause", "pauseVideo"],
    autoplay: "autoplay"
  },
  decls: 2,
  vars: 2,
  consts: [["frameborder", "0", "allowfullscreen", "", 3, "src"], ["iframe", ""]],
  template: function GalleryIframeComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵelement */._UZ(0, "iframe", 0, 1);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("src", ctx.iframeSrc, core/* ɵɵsanitizeResourceUrl */.uOi);
      core/* ɵɵattribute */.uIk("allow", ctx.autoplay ? "autoplay" : "");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryIframeComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-iframe',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <iframe #iframe
            frameborder="0"
            allowfullscreen
            [attr.allow]="autoplay ? 'autoplay' : ''"
            [src]="iframeSrc">
    </iframe>
  `
    }]
  }], function () {
    return [{
      type: platform_browser/* DomSanitizer */.H7
    }];
  }, {
    src: [{
      type: core/* Input */.IIB,
      args: ['src']
    }],
    pauseVideo: [{
      type: core/* Input */.IIB,
      args: ['pause']
    }],
    autoplay: [{
      type: core/* Input */.IIB
    }],
    iframe: [{
      type: core/* ViewChild */.i9L,
      args: ['iframe', {
        static: true
      }]
    }]
  });
})();

class GalleryItemComponent {
  constructor() {
    this.Types = GalleryItemType;
    /** Stream that emits when an error occurs */

    this.error = new core/* EventEmitter */.vpe();
  }

  get isActive() {
    return this.index === this.currIndex;
  }

  get isAutoPlay() {
    if (this.isActive) {
      if (this.type === GalleryItemType.Video || this.type === GalleryItemType.Youtube) {
        return this.data.autoplay;
      }
    }
  }

  get youtubeSrc() {
    let autoplay = 0;

    if (this.isActive && this.type === GalleryItemType.Youtube && this.data.autoplay) {
      autoplay = 1;
    }

    const url = new URL(this.data.src);
    url.search = new URLSearchParams({
      wmode: 'transparent',
      ...this.data.params,
      autoplay
    }).toString();
    return url.href;
  }

  get load() {
    switch (this.config.loadingStrategy) {
      case LoadingStrategy.Preload:
        return true;

      case LoadingStrategy.Lazy:
        return this.currIndex === this.index;

      default:
        return this.currIndex === this.index || this.currIndex === this.index - 1 || this.currIndex === this.index + 1;
    }
  }

}

GalleryItemComponent.ɵfac = function GalleryItemComponent_Factory(t) {
  return new (t || GalleryItemComponent)();
};

GalleryItemComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryItemComponent,
  selectors: [["gallery-item"]],
  hostVars: 2,
  hostBindings: function GalleryItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core/* ɵɵclassProp */.ekj("g-active-item", ctx.isActive);
    }
  },
  inputs: {
    config: "config",
    index: "index",
    currIndex: "currIndex",
    type: "type",
    data: "data"
  },
  outputs: {
    error: "error"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "ngSwitch", 4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "src", "poster", "controls", "play", "pause", "error", 4, "ngSwitchCase"], [3, "src", "autoplay", "pause", 4, "ngSwitchCase"], [3, "src", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "src", "loadingIcon", "loadingError", "error"], [1, "g-template", "g-item-template"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "src", "poster", "controls", "play", "pause", "error"], [3, "src", "autoplay", "pause"], [3, "src"]],
  template: function GalleryItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵtemplate */.YNc(0, GalleryItemComponent_ng_container_0_Template, 6, 5, "ng-container", 0);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngIf", ctx.load);
    }
  },
  directives: [common/* NgIf */.O5, common/* NgSwitch */.RF, common/* NgSwitchCase */.n9, common/* NgSwitchDefault */.ED, GalleryImageComponent, common/* NgTemplateOutlet */.tP, GalleryVideoComponent, GalleryIframeComponent],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryItemComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-item',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <ng-container *ngIf="load" [ngSwitch]="type">

      <ng-container *ngSwitchCase="Types.Image">

        <gallery-image [src]="data.src"
                       [loadingIcon]="config.loadingIcon"
                       [loadingError]="config.loadingError"
                       (error)="error.emit($event)"></gallery-image>

        <div class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.itemTemplate;
          context: { index: this.index, currIndex: this.currIndex, type: this.type, data: this.data }">
          </ng-container>
        </div>

      </ng-container>

      <gallery-video *ngSwitchCase="Types.Video"
                     [src]="data.src"
                     [poster]="data.poster"
                     [controls]="data.controls"
                     [play]="isAutoPlay"
                     [pause]="currIndex !== index"
                     (error)="error.emit($event)"></gallery-video>

      <gallery-iframe *ngSwitchCase="Types.Youtube"
                      [src]="youtubeSrc"
                      [autoplay]="isAutoPlay"
                      [pause]="currIndex !== index"></gallery-iframe>

      <gallery-iframe *ngSwitchCase="Types.Iframe"
                      [src]="data.src"></gallery-iframe>

      <ng-container *ngSwitchDefault>

        <div class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.itemTemplate;
          context: { index: this.index, currIndex: this.currIndex, type: this.type, data: this.data }">
          </ng-container>
        </div>

      </ng-container>

    </ng-container>
  `
    }]
  }], null, {
    config: [{
      type: core/* Input */.IIB
    }],
    index: [{
      type: core/* Input */.IIB
    }],
    currIndex: [{
      type: core/* Input */.IIB
    }],
    type: [{
      type: core/* Input */.IIB
    }],
    data: [{
      type: core/* Input */.IIB
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    isActive: [{
      type: core/* HostBinding */.pfw,
      args: ['class.g-active-item']
    }]
  });
})();

class GallerySliderComponent {
  constructor(_el, _zone, platform) {
    this._el = _el;
    this._zone = _zone;
    this.platform = platform;
    /** Sliding worker */

    this._slidingWorker$ = new BehaviorSubject/* BehaviorSubject */.X({
      value: 0,
      active: false
    });
    /** Stream that emits when the active item should change */

    this.action = new core/* EventEmitter */.vpe();
    /** Stream that emits when item is clicked */

    this.itemClick = new core/* EventEmitter */.vpe();
    /** Stream that emits when an error occurs */

    this.error = new core/* EventEmitter */.vpe(); // Activate sliding worker

    this.sliderState$ = this._slidingWorker$.pipe((0,operators_map/* map */.U)(state => ({
      style: this.getSliderStyles(state),
      active: state.active
    })));
  }
  /** Item zoom */


  get zoom() {
    return {
      transform: `perspective(50px) translate3d(0, 0, ${-this.config.zoomOut}px)`
    };
  }

  ngOnChanges() {
    // Refresh the slider
    this.updateSlider({
      value: 0,
      active: false
    });
  }

  ngOnInit() {
    if (this.config.gestures && typeof Hammer !== 'undefined') {
      const direction = this.config.slidingDirection === SlidingDirection.Horizontal ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL; // Activate gestures

      this._hammer = new Hammer(this._el.nativeElement);

      this._hammer.get('pan').set({
        direction
      });

      this._zone.runOutsideAngular(() => {
        // Move the slider
        this._hammer.on('pan', e => {
          switch (this.config.slidingDirection) {
            case SlidingDirection.Horizontal:
              this.updateSlider({
                value: e.deltaX,
                active: true
              });

              if (e.isFinal) {
                this.updateSlider({
                  value: 0,
                  active: false
                });
                this.horizontalPan(e);
              }

              break;

            case SlidingDirection.Vertical:
              this.updateSlider({
                value: e.deltaY,
                active: true
              });

              if (e.isFinal) {
                this.updateSlider({
                  value: 0,
                  active: false
                });
                this.verticalPan(e);
              }

          }
        });
      });
    } // Rearrange slider on window resize


    if ((0,common/* isPlatformBrowser */.NF)(this.platform)) {
      this._resizeSub$ = (0,fromEvent/* fromEvent */.R)(window, 'resize').pipe((0,debounceTime/* debounceTime */.b)(200), (0,tap/* tap */.b)(() => this.updateSlider(this._slidingWorker$.value))).subscribe();
    }

    setTimeout(() => this.updateSlider({
      value: 0,
      active: false
    }));
  }

  ngOnDestroy() {
    if (this._hammer) {
      this._hammer.destroy();
    }

    if (this._resizeSub$) {
      this._resizeSub$.unsubscribe();
    }

    this._slidingWorker$.complete();
  }
  /**
   * Convert sliding state to styles
   */


  getSliderStyles(state) {
    switch (this.config.slidingDirection) {
      case SlidingDirection.Horizontal:
        return {
          transform: `translate3d(${-(this.state.currIndex * this._el.nativeElement.offsetWidth) + state.value}px, 0, 0)`,
          width: `calc(100% * ${this.state.items.length})`,
          height: '100%'
        };

      case SlidingDirection.Vertical:
        return {
          transform: `translate3d(0, ${-(this.state.currIndex * this._el.nativeElement.offsetHeight) + state.value}px, 0)`,
          width: '100%',
          height: `calc(100% * ${this.state.items.length})`
        };
    }
  }

  verticalPan(e) {
    if (!(e.direction & Hammer.DIRECTION_UP && e.offsetDirection & Hammer.DIRECTION_VERTICAL)) {
      return;
    }

    if (e.velocityY > 0.3) {
      this.prev();
    } else if (e.velocityY < -0.3) {
      this.next();
    } else {
      if (e.deltaY / 2 <= -this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {
        this.next();
      } else if (e.deltaY / 2 >= this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {
        this.prev();
      } else {
        this.action.emit(this.state.currIndex);
      }
    }
  }

  horizontalPan(e) {
    if (!(e.direction & Hammer.DIRECTION_HORIZONTAL && e.offsetDirection & Hammer.DIRECTION_HORIZONTAL)) {
      return;
    }

    if (e.velocityX > 0.3) {
      this.prev();
    } else if (e.velocityX < -0.3) {
      this.next();
    } else {
      if (e.deltaX / 2 <= -this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {
        this.next();
      } else if (e.deltaX / 2 >= this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {
        this.prev();
      } else {
        this.action.emit(this.state.currIndex);
      }
    }
  }

  next() {
    this.action.emit('next');
  }

  prev() {
    this.action.emit('prev');
  }

  updateSlider(state) {
    const newState = { ...this._slidingWorker$.value,
      ...state
    };

    this._slidingWorker$.next(newState);
  }

}

GallerySliderComponent.ɵfac = function GallerySliderComponent_Factory(t) {
  return new (t || GallerySliderComponent)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(core/* PLATFORM_ID */.Lbi));
};

GallerySliderComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GallerySliderComponent,
  selectors: [["gallery-slider"]],
  inputs: {
    state: "state",
    config: "config"
  },
  outputs: {
    action: "action",
    itemClick: "itemClick",
    error: "error"
  },
  features: [core/* ɵɵNgOnChangesFeature */.TTD],
  ngContentSelectors: ng_gallery_c4,
  decls: 3,
  vars: 3,
  consts: [["class", "g-items-container", 3, "ngStyle", 4, "ngIf"], [1, "g-items-container", 3, "ngStyle"], [1, "g-slider", 3, "ngStyle"], [3, "type", "config", "data", "currIndex", "index", "tapClick", "error", 4, "ngFor", "ngForOf"], [3, "type", "config", "data", "currIndex", "index", "tapClick", "error"]],
  template: function GallerySliderComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵprojectionDef */.F$t();
      core/* ɵɵtemplate */.YNc(0, GallerySliderComponent_div_0_Template, 3, 5, "div", 0);
      core/* ɵɵpipe */.ALo(1, "async");
      core/* ɵɵprojection */.Hsn(2);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngIf", core/* ɵɵpipeBind1 */.lcZ(1, 1, ctx.sliderState$));
    }
  },
  directives: [common/* NgIf */.O5, common/* NgStyle */.PC, common/* NgForOf */.sg, GalleryItemComponent, TapClick],
  pipes: [common/* AsyncPipe */.Ov],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GallerySliderComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-slider',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <div *ngIf="sliderState$ | async; let sliderState"
         class="g-items-container"
         [ngStyle]="zoom">

      <div class="g-slider"
           [class.g-no-transition]="sliderState.active"
           [ngStyle]="sliderState.style">

        <gallery-item *ngFor="let item of state.items; let i = index"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      (tapClick)="itemClick.emit(i)"
                      (error)="error.emit({itemIndex: i, error: $event})">
        </gallery-item>

      </div>
    </div>
    <ng-content></ng-content>
  `
    }]
  }], function () {
    return [{
      type: core/* ElementRef */.SBq
    }, {
      type: core/* NgZone */.R0b
    }, {
      type: Object,
      decorators: [{
        type: core/* Inject */.tBr,
        args: [core/* PLATFORM_ID */.Lbi]
      }]
    }];
  }, {
    state: [{
      type: core/* Input */.IIB
    }],
    config: [{
      type: core/* Input */.IIB
    }],
    action: [{
      type: core/* Output */.r_U
    }],
    itemClick: [{
      type: core/* Output */.r_U
    }],
    error: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryNavComponent {
  constructor(_sanitizer) {
    this._sanitizer = _sanitizer;
    this.action = new core/* EventEmitter */.vpe();
  }

  ngOnInit() {
    this.navIcon = this._sanitizer.bypassSecurityTrustHtml(this.config.navIcon);
  }

}

GalleryNavComponent.ɵfac = function GalleryNavComponent_Factory(t) {
  return new (t || GalleryNavComponent)(core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7));
};

GalleryNavComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryNavComponent,
  selectors: [["gallery-nav"]],
  inputs: {
    state: "state",
    config: "config"
  },
  outputs: {
    action: "action"
  },
  decls: 2,
  vars: 2,
  consts: [["class", "g-nav-prev", "aria-label", "Previous", 3, "innerHtml", "tapClick", 4, "ngIf"], ["class", "g-nav-next", "aria-label", "Next", 3, "innerHtml", "tapClick", 4, "ngIf"], ["aria-label", "Previous", 1, "g-nav-prev", 3, "innerHtml", "tapClick"], ["aria-label", "Next", 1, "g-nav-next", 3, "innerHtml", "tapClick"]],
  template: function GalleryNavComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵtemplate */.YNc(0, GalleryNavComponent_i_0_Template, 1, 1, "i", 0);
      core/* ɵɵtemplate */.YNc(1, GalleryNavComponent_i_1_Template, 1, 1, "i", 1);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.loop || ctx.state.hasPrev);
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.loop || ctx.state.hasNext);
    }
  },
  directives: [common/* NgIf */.O5, TapClick],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryNavComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-nav',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <i *ngIf="config.loop || state.hasPrev"
       class="g-nav-prev"
       aria-label="Previous"
       (tapClick)="action.emit('prev')"
       [innerHtml]="navIcon"></i>

    <i *ngIf="config.loop || state.hasNext"
       class="g-nav-next"
       aria-label="Next"
       (tapClick)="action.emit('next')"
       [innerHtml]="navIcon"></i>
  `
    }]
  }], function () {
    return [{
      type: platform_browser/* DomSanitizer */.H7
    }];
  }, {
    state: [{
      type: core/* Input */.IIB
    }],
    config: [{
      type: core/* Input */.IIB
    }],
    action: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryDotsComponent {
  constructor() {
    this.action = new core/* EventEmitter */.vpe();
  }

}

GalleryDotsComponent.ɵfac = function GalleryDotsComponent_Factory(t) {
  return new (t || GalleryDotsComponent)();
};

GalleryDotsComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryDotsComponent,
  selectors: [["gallery-dots"]],
  inputs: {
    state: "state",
    config: "config"
  },
  outputs: {
    action: "action"
  },
  decls: 1,
  vars: 1,
  consts: [["class", "g-dot", 3, "g-dot-active", "width", "height", "tapClick", 4, "ngFor", "ngForOf"], [1, "g-dot", 3, "tapClick"], [1, "g-dot-inner"]],
  template: function GalleryDotsComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵtemplate */.YNc(0, GalleryDotsComponent_div_0_Template, 2, 6, "div", 0);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngForOf", ctx.state.items);
    }
  },
  directives: [common/* NgForOf */.sg, TapClick],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryDotsComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-dots',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <div class="g-dot"
         *ngFor="let item of state.items; let i = index"
         [class.g-dot-active]="i === state.currIndex"
         [style.width.px]="config?.dotsSize"
         [style.height.px]="config?.dotsSize"
         (tapClick)="action.emit(i)">
      <div class="g-dot-inner"></div>
    </div>
  `
    }]
  }], null, {
    state: [{
      type: core/* Input */.IIB
    }],
    config: [{
      type: core/* Input */.IIB
    }],
    action: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryCounterComponent {}

GalleryCounterComponent.ɵfac = function GalleryCounterComponent_Factory(t) {
  return new (t || GalleryCounterComponent)();
};

GalleryCounterComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryCounterComponent,
  selectors: [["gallery-counter"]],
  inputs: {
    state: "state"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "g-counter"]],
  template: function GalleryCounterComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵelementStart */.TgZ(0, "div", 0);
      core/* ɵɵtext */._uU(1);
      core/* ɵɵelementEnd */.qZA();
    }

    if (rf & 2) {
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵtextInterpolate */.Oqu(ctx.state.currIndex + 1 + "/" + ctx.state.items.length);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryCounterComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-counter',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <div class="g-counter">{{(state.currIndex + 1) + '/' + state.items.length}}</div>
  `
    }]
  }], null, {
    state: [{
      type: core/* Input */.IIB
    }]
  });
})();

class GalleryCoreComponent {
  constructor() {
    this.action = new core/* EventEmitter */.vpe();
    this.itemClick = new core/* EventEmitter */.vpe();
    this.thumbClick = new core/* EventEmitter */.vpe();
    this.error = new core/* EventEmitter */.vpe();
  }
  /** Set thumbnails position */


  get thumbPosition() {
    return this.config.thumbPosition;
  }
  /** Set sliding direction */


  get slidingDirection() {
    return this.config.slidingDirection;
  }
  /** Disable thumbnails clicks */


  get disableThumb() {
    return this.config.disableThumb;
  }
  /** Set gallery image size */


  get imageSize() {
    return this.config.imageSize;
  }
  /** Set gallery dots position */


  get dotsPosition() {
    return this.config.dotsPosition;
  }
  /** Set gallery counter position */


  get counterPosition() {
    return this.config.counterPosition;
  }

}

GalleryCoreComponent.ɵfac = function GalleryCoreComponent_Factory(t) {
  return new (t || GalleryCoreComponent)();
};

GalleryCoreComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryCoreComponent,
  selectors: [["gallery-core"]],
  hostVars: 6,
  hostBindings: function GalleryCoreComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core/* ɵɵattribute */.uIk("thumbPosition", ctx.thumbPosition)("slidingDirection", ctx.slidingDirection)("disableThumb", ctx.disableThumb)("imageSize", ctx.imageSize)("dotsPosition", ctx.dotsPosition)("counterPosition", ctx.counterPosition);
    }
  },
  inputs: {
    state: "state",
    config: "config"
  },
  outputs: {
    action: "action",
    itemClick: "itemClick",
    thumbClick: "thumbClick",
    error: "error"
  },
  decls: 6,
  vars: 6,
  consts: [[3, "state", "config", "action", "thumbClick", 4, "ngIf"], [1, "g-box"], [3, "state", "config", "action", "itemClick", "error"], [3, "state", "config", "action", 4, "ngIf"], [3, "state", 4, "ngIf"], [3, "state", "config", "action", "thumbClick"], [3, "state", "config", "action"], [3, "state"]],
  template: function GalleryCoreComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵtemplate */.YNc(0, GalleryCoreComponent_gallery_thumbs_0_Template, 1, 2, "gallery-thumbs", 0);
      core/* ɵɵelementStart */.TgZ(1, "div", 1);
      core/* ɵɵelementStart */.TgZ(2, "gallery-slider", 2);
      core/* ɵɵlistener */.NdJ("action", function GalleryCoreComponent_Template_gallery_slider_action_2_listener($event) {
        return ctx.action.emit($event);
      })("itemClick", function GalleryCoreComponent_Template_gallery_slider_itemClick_2_listener($event) {
        return ctx.itemClick.emit($event);
      })("error", function GalleryCoreComponent_Template_gallery_slider_error_2_listener($event) {
        return ctx.error.emit($event);
      });
      core/* ɵɵtemplate */.YNc(3, GalleryCoreComponent_gallery_nav_3_Template, 1, 2, "gallery-nav", 3);
      core/* ɵɵelementEnd */.qZA();
      core/* ɵɵtemplate */.YNc(4, GalleryCoreComponent_gallery_dots_4_Template, 1, 2, "gallery-dots", 3);
      core/* ɵɵtemplate */.YNc(5, GalleryCoreComponent_gallery_counter_5_Template, 1, 1, "gallery-counter", 4);
      core/* ɵɵelementEnd */.qZA();
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.thumb);
      core/* ɵɵadvance */.xp6(2);
      core/* ɵɵproperty */.Q6J("state", ctx.state)("config", ctx.config);
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.nav && ctx.state.items.length > 1);
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.dots);
      core/* ɵɵadvance */.xp6(1);
      core/* ɵɵproperty */.Q6J("ngIf", ctx.config.counter);
    }
  },
  directives: [common/* NgIf */.O5, GallerySliderComponent, GalleryThumbsComponent, GalleryNavComponent, GalleryDotsComponent, GalleryCounterComponent],
  encapsulation: 2,
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryCoreComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery-core',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <gallery-thumbs *ngIf="config.thumb"
                    [state]="state"
                    [config]="config"
                    (action)="action.emit($event)"
                    (thumbClick)="thumbClick.emit($event)">
    </gallery-thumbs>
    <div class="g-box">
      <gallery-slider [state]="state"
                      [config]="config"
                      (action)="action.emit($event)"
                      (itemClick)="itemClick.emit($event)"
                      (error)="error.emit($event)">

        <gallery-nav *ngIf="config.nav && state.items.length > 1"
                     [state]="state"
                     [config]="config"
                     (action)="action.emit($event)">
        </gallery-nav>

      </gallery-slider>

      <gallery-dots *ngIf="config.dots"
                    [state]="state"
                    [config]="config"
                    (action)="action.emit($event)">
      </gallery-dots>

      <gallery-counter *ngIf="config.counter"
                       [state]="state">
      </gallery-counter>
    </div>
  `
    }]
  }], null, {
    state: [{
      type: core/* Input */.IIB
    }],
    config: [{
      type: core/* Input */.IIB
    }],
    action: [{
      type: core/* Output */.r_U
    }],
    itemClick: [{
      type: core/* Output */.r_U
    }],
    thumbClick: [{
      type: core/* Output */.r_U
    }],
    error: [{
      type: core/* Output */.r_U
    }],
    thumbPosition: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.thumbPosition']
    }],
    slidingDirection: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.slidingDirection']
    }],
    disableThumb: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.disableThumb']
    }],
    imageSize: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.imageSize']
    }],
    dotsPosition: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.dotsPosition']
    }],
    counterPosition: [{
      type: core/* HostBinding */.pfw,
      args: ['attr.counterPosition']
    }]
  });
})();

class GalleryComponent {
  constructor(_gallery) {
    this._gallery = _gallery;
    this.nav = this._gallery.config.nav;
    this.dots = this._gallery.config.dots;
    this.loop = this._gallery.config.loop;
    this.thumb = this._gallery.config.thumb;
    this.zoomOut = this._gallery.config.zoomOut;
    this.counter = this._gallery.config.counter;
    this.dotsSize = this._gallery.config.dotsSize;
    this.autoPlay = this._gallery.config.autoPlay;
    this.gestures = this._gallery.config.gestures;
    this.thumbWidth = this._gallery.config.thumbWidth;
    this.thumbHeight = this._gallery.config.thumbHeight;
    this.disableThumb = this._gallery.config.disableThumb;
    this.panSensitivity = this._gallery.config.panSensitivity;
    this.playerInterval = this._gallery.config.playerInterval;
    this.itemTemplate = this._gallery.config.itemTemplate;
    this.thumbTemplate = this._gallery.config.thumbTemplate;
    this.thumbMode = this._gallery.config.thumbMode;
    this.imageSize = this._gallery.config.imageSize;
    this.dotsPosition = this._gallery.config.dotsPosition;
    this.counterPosition = this._gallery.config.counterPosition;
    this.slidingDirection = this._gallery.config.slidingDirection;
    this.loadingStrategy = this._gallery.config.loadingStrategy;
    this.thumbPosition = this._gallery.config.thumbPosition;
    this.thumbView = this._gallery.config.thumbView; // Inputs used by the lightbox

    /** Destroy gallery ref on component destroy event */

    this.destroyRef = true;
    /** Skip initializing the config with components inputs (Lightbox mode) */

    this.skipInitConfig = false;
    this.itemClick = new core/* EventEmitter */.vpe();
    this.thumbClick = new core/* EventEmitter */.vpe();
    this.playingChange = new core/* EventEmitter */.vpe();
    this.indexChange = new core/* EventEmitter */.vpe();
    this.itemsChange = new core/* EventEmitter */.vpe();
    this.error = new core/* EventEmitter */.vpe();
    this._itemClick$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this._thumbClick$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this._itemChange$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this._indexChange$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this._playingChange$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
    this._playerListener$ = Subscription/* Subscription.EMPTY */.w.EMPTY;
  }

  getConfig() {
    return {
      nav: this.nav,
      dots: this.dots,
      loop: this.loop,
      thumb: this.thumb,
      zoomOut: this.zoomOut,
      counter: this.counter,
      autoPlay: this.autoPlay,
      gestures: this.gestures,
      dotsSize: this.dotsSize,
      imageSize: this.imageSize,
      thumbMode: this.thumbMode,
      thumbView: this.thumbView,
      thumbWidth: this.thumbWidth,
      thumbHeight: this.thumbHeight,
      disableThumb: this.disableThumb,
      dotsPosition: this.dotsPosition,
      itemTemplate: this.itemTemplate,
      thumbTemplate: this.thumbTemplate,
      thumbPosition: this.thumbPosition,
      panSensitivity: this.panSensitivity,
      playerInterval: this.playerInterval,
      counterPosition: this.counterPosition,
      loadingStrategy: this.loadingStrategy,
      slidingDirection: this.slidingDirection
    };
  }

  onAction(i) {
    switch (i) {
      case 'next':
        this.galleryRef.next();
        break;

      case 'prev':
        this.galleryRef.prev();
        break;

      default:
        this.galleryRef.set(i);
    }
  }

  ngOnChanges(changes) {
    if (this.galleryRef) {
      this.galleryRef.setConfig(this.getConfig());

      if (changes.items && changes.items.currentValue !== changes.items.previousValue) {
        this.load(this.items);
      }
    }
  }

  ngOnInit() {
    // Get gallery instance by id
    if (this.skipInitConfig) {
      this.galleryRef = this._gallery.ref(this.id);
    } else {
      this.galleryRef = this._gallery.ref(this.id, this.getConfig());
    } // Load gallery items


    this.load(this.items); // Activate player listener

    this._playerListener$ = this.galleryRef.activatePlayer().subscribe(); // Subscribes to events on demand

    if (this.indexChange.observers.length) {
      this._indexChange$ = this.galleryRef.indexChanged.subscribe(state => this.indexChange.emit(state));
    }

    if (this.itemsChange.observers.length) {
      this._itemChange$ = this.galleryRef.itemsChanged.subscribe(state => this.itemsChange.emit(state));
    }

    if (this.playingChange.observers.length) {
      this._playingChange$ = this.galleryRef.playingChanged.subscribe(state => this.playingChange.emit(state));
    } // Start playing if auto-play is set to true


    if (this.autoPlay) {
      this.play();
    }
  }

  ngOnDestroy() {
    this._itemClick$.unsubscribe();

    this._thumbClick$.unsubscribe();

    this._itemChange$.unsubscribe();

    this._indexChange$.unsubscribe();

    this._playingChange$.unsubscribe();

    this._playerListener$.unsubscribe();

    if (this.destroyRef) {
      this.galleryRef.destroy();
    }
  }

  onItemClick(i) {
    this.itemClick.emit(i);
    this.galleryRef.itemClick.next(i);
  }

  onThumbClick(i) {
    this.galleryRef.set(i);
    this.thumbClick.emit(i);
    this.galleryRef.thumbClick.next(i);
  }

  onError(err) {
    this.error.emit(err);
    this.galleryRef.error.next(err);
  }

  load(items) {
    this.galleryRef.load(items);
  }

  add(item, active) {
    this.galleryRef.add(item, active);
  }

  addImage(data, active) {
    this.add(new ImageItem(data), active);
  }

  addVideo(data, active) {
    this.add(new VideoItem(data), active);
  }

  addIframe(data, active) {
    this.add(new IframeItem(data), active);
  }

  addYoutube(data, active) {
    this.add(new YoutubeItem(data), active);
  }

  remove(i) {
    this.galleryRef.remove(i);
  }

  next() {
    this.galleryRef.next();
  }

  prev() {
    this.galleryRef.prev();
  }

  set(i) {
    this.galleryRef.set(i);
  }

  reset() {
    this.galleryRef.reset();
  }

  play(interval) {
    this.galleryRef.play(interval);
  }

  stop() {
    this.galleryRef.stop();
  }

}

GalleryComponent.ɵfac = function GalleryComponent_Factory(t) {
  return new (t || GalleryComponent)(core/* ɵɵdirectiveInject */.Y36(Gallery));
};

GalleryComponent.ɵcmp = /* @__PURE__ */core/* ɵɵdefineComponent */.Xpm({
  type: GalleryComponent,
  selectors: [["gallery"]],
  inputs: {
    id: "id",
    items: "items",
    nav: "nav",
    dots: "dots",
    loop: "loop",
    thumb: "thumb",
    zoomOut: "zoomOut",
    counter: "counter",
    dotsSize: "dotsSize",
    autoPlay: "autoPlay",
    gestures: "gestures",
    thumbWidth: "thumbWidth",
    thumbHeight: "thumbHeight",
    disableThumb: "disableThumb",
    panSensitivity: "panSensitivity",
    playerInterval: "playerInterval",
    itemTemplate: "itemTemplate",
    thumbTemplate: "thumbTemplate",
    thumbMode: "thumbMode",
    imageSize: "imageSize",
    dotsPosition: "dotsPosition",
    counterPosition: "counterPosition",
    slidingDirection: "slidingDirection",
    loadingStrategy: "loadingStrategy",
    thumbPosition: "thumbPosition",
    thumbView: "thumbView",
    destroyRef: "destroyRef",
    skipInitConfig: "skipInitConfig"
  },
  outputs: {
    itemClick: "itemClick",
    thumbClick: "thumbClick",
    playingChange: "playingChange",
    indexChange: "indexChange",
    itemsChange: "itemsChange",
    error: "error"
  },
  features: [core/* ɵɵNgOnChangesFeature */.TTD],
  ngContentSelectors: ng_gallery_c4,
  decls: 4,
  vars: 6,
  consts: [[3, "state", "config", "action", "itemClick", "thumbClick", "error"]],
  template: function GalleryComponent_Template(rf, ctx) {
    if (rf & 1) {
      core/* ɵɵprojectionDef */.F$t();
      core/* ɵɵelementStart */.TgZ(0, "gallery-core", 0);
      core/* ɵɵlistener */.NdJ("action", function GalleryComponent_Template_gallery_core_action_0_listener($event) {
        return ctx.onAction($event);
      })("itemClick", function GalleryComponent_Template_gallery_core_itemClick_0_listener($event) {
        return ctx.onItemClick($event);
      })("thumbClick", function GalleryComponent_Template_gallery_core_thumbClick_0_listener($event) {
        return ctx.onThumbClick($event);
      })("error", function GalleryComponent_Template_gallery_core_error_0_listener($event) {
        return ctx.onError($event);
      });
      core/* ɵɵpipe */.ALo(1, "async");
      core/* ɵɵpipe */.ALo(2, "async");
      core/* ɵɵelementEnd */.qZA();
      core/* ɵɵprojection */.Hsn(3);
    }

    if (rf & 2) {
      core/* ɵɵproperty */.Q6J("state", core/* ɵɵpipeBind1 */.lcZ(1, 2, ctx.galleryRef.state))("config", core/* ɵɵpipeBind1 */.lcZ(2, 4, ctx.galleryRef.config));
    }
  },
  directives: [GalleryCoreComponent],
  pipes: [common/* AsyncPipe */.Ov],
  styles: ["gallery-core[dotsPosition=top] gallery-dots{top:0}  gallery-core[dotsPosition=bottom] gallery-dots{bottom:0}  gallery-dots{margin:7px;position:absolute;left:50%;transform:translate(-50%)}  .g-dot{cursor:pointer;z-index:20}  .g-dot:hover .g-dot-inner{opacity:1}  .g-dot-active .g-dot-inner{opacity:1;transform:scale(1.5)!important}  .g-dot-inner{background-color:#fff;opacity:.6;width:30%;height:30%;border-radius:50%;box-shadow:0 0 1px #000;transition:all ease .2s}  gallery-dots,   .g-dot,   .g-dot-inner{display:flex;justify-content:center;align-items:center}  .g-nav-next,   .g-nav-prev{position:absolute;top:50%;width:30px;height:40px;cursor:pointer;z-index:999}  .g-nav-next{right:.5em;transform:translateY(-50%) perspective(1px)}  .g-nav-prev{left:.5em;transform:translateY(-50%) perspective(1px) scale(-1)}@media only screen and (max-width: 480px){  .g-nav-next{right:.2em}  .g-nav-prev{left:.2em}}  .g-items-container{height:100%}  .g-slider{position:absolute;transition:transform .4s cubic-bezier(.5,0,.5,1)}  gallery-core[slidingDirection=horizontal] .g-slider{flex-direction:row}  gallery-core[slidingDirection=vertical] .g-slider{flex-direction:column}  gallery-thumbs{display:block;z-index:1;overflow:unset}  .g-thumbs-container{position:relative;z-index:206;width:100%;height:100%;left:0;top:0;display:flex;overflow:unset}  gallery-core[disableThumb=true] gallery-thumb{cursor:default}  gallery-core[thumbPosition=top] gallery-thumbs .g-slider,   gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider{flex-direction:row;top:0;left:50%}  gallery-core[thumbPosition=top] gallery-thumbs .g-slider.g-contain,   gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider.g-contain{left:0}  gallery-core[thumbPosition=top] gallery-thumbs .g-slider.g-contain.g-contain-small-content,   gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider.g-contain.g-contain-small-content{left:50%;transform:translate(-50%)!important}  gallery-core[thumbPosition=top] gallery-thumb,   gallery-core[thumbPosition=bottom] gallery-thumb{padding:1px 0 1px 1px}  gallery-core[thumbPosition=left] gallery-thumbs .g-slider,   gallery-core[thumbPosition=right] gallery-thumbs .g-slider{flex-direction:column;top:50%;left:0}  gallery-core[thumbPosition=left] gallery-thumbs .g-slider.g-contain,   gallery-core[thumbPosition=right] gallery-thumbs .g-slider.g-contain{top:0}  gallery-core[thumbPosition=left] gallery-thumbs .g-slider.g-contain.g-contain-small-content,   gallery-core[thumbPosition=right] gallery-thumbs .g-slider.g-contain.g-contain-small-content{top:50%;transform:translateY(-50%)!important}  gallery-core[thumbPosition=left] gallery-thumb,   gallery-core[thumbPosition=right] gallery-thumb{padding:0 1px 1px}  gallery-core[thumbPosition=top]{flex-direction:column}  gallery-core[thumbPosition=left]{flex-direction:row}  gallery-core[thumbPosition=right]{flex-direction:row-reverse}  gallery-core[thumbPosition=bottom]{flex-direction:column-reverse}  gallery-thumb.g-active-thumb .g-thumb-loading{background-color:#464646}  .g-thumb-loading{position:relative;overflow:hidden;height:100%;background-color:#262626}  .g-thumb-loading:before{content:\"\";position:absolute;top:0;right:0;bottom:0;left:50%;z-index:1;width:500%;margin-left:-250%;-webkit-animation:phAnimation .8s linear infinite;animation:phAnimation .8s linear infinite;background:linear-gradient(to right,rgba(255,255,255,0) 46%,rgba(255,255,255,.35) 50%,rgba(255,255,255,0) 54%) 50% 50%}@-webkit-keyframes phAnimation{0%{transform:translate(-30%)}to{transform:translate(30%)}}@keyframes phAnimation{0%{transform:translate(-30%)}to{transform:translate(30%)}}  gallery-core[counterPosition=top] .g-counter{top:0;border-bottom-left-radius:4px;border-bottom-right-radius:4px}  gallery-core[counterPosition=bottom] .g-counter{bottom:0;border-top-left-radius:4px;border-top-right-radius:4px}  .g-counter{z-index:50;position:absolute;left:50%;transform:translate(-50%) perspective(1px);font-size:12px;padding:4px 10px;color:#fff;background-color:#00000080}  gallery[gallerize] gallery-item{cursor:pointer}  gallery-item,   gallery-thumb{position:relative;height:100%;width:100%;display:block;overflow:hidden}  gallery-item h2,   gallery-item h4,   gallery-thumb h2,   gallery-thumb h4{color:coral;margin:0}  gallery-item h2,   gallery-thumb h2{font-size:3.5em;margin-bottom:.3em}  gallery-item h4,   gallery-thumb h4{font-size:1.6em}  gallery-item{z-index:10}  gallery-item video,   gallery-item iframe{position:absolute;width:100%;height:100%}  gallery-thumb{opacity:.5;cursor:pointer;transition:opacity .3s cubic-bezier(.5,0,.5,1)}  gallery-thumb.g-active-thumb{opacity:1}  .g-image-item{background-position:center center;background-repeat:no-repeat;background-size:cover;width:100%;height:100%}  .g-template,   .g-image-error-message{position:absolute;z-index:10;left:0;top:0;right:0;bottom:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}  .g-loading{position:absolute;transform:translate(-50%,-50%);left:50%;top:50%;width:80px;height:80px}  gallery-core[imageSize=contain] gallery-slider .g-image-item{background-size:contain}  gallery-image{display:flex;justify-content:center;align-items:center;height:100%}  gallery{position:relative;z-index:1;overflow:hidden;display:block;height:500px;background-color:#000}  gallery *{box-sizing:border-box}  gallery,   gallery-core{position:relative;overflow:hidden}  gallery-core,   .g-box,   .g-slider{display:flex;height:100%;width:100%}  gallery[fluid]{transform:translate(-50vw);width:100vw;left:50%}  gallery[fluid][fluid=false]{transform:none;width:auto;width:initial;left:auto;left:initial}  .g-no-transition{transition:unset!important}  .g-box,   gallery-slider{overflow:hidden;position:relative;display:flex;flex-direction:column;flex:1;order:1;height:100%}  gallery-nav svg,   .g-btn-close svg{width:100%;height:100%;filter:drop-shadow(0px 0px 1px black);transition:opacity linear .2s;opacity:.6}  gallery-nav svg:hover,   .g-btn-close svg:hover{opacity:1}"],
  changeDetection: 0
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryComponent, [{
    type: core/* Component */.wA2,
    args: [{
      selector: 'gallery',
      changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
      template: `
    <gallery-core [state]="galleryRef.state | async"
                  [config]="galleryRef.config | async"
                  (action)="onAction($event)"
                  (itemClick)="onItemClick($event)"
                  (thumbClick)="onThumbClick($event)"
                  (error)="onError($event)"></gallery-core>
    <ng-content></ng-content>
  `,
      styles: ["::ng-deep gallery-core[dotsPosition=top] gallery-dots{top:0}::ng-deep gallery-core[dotsPosition=bottom] gallery-dots{bottom:0}::ng-deep gallery-dots{margin:7px;position:absolute;left:50%;transform:translate(-50%)}::ng-deep .g-dot{cursor:pointer;z-index:20}::ng-deep .g-dot:hover .g-dot-inner{opacity:1}::ng-deep .g-dot-active .g-dot-inner{opacity:1;transform:scale(1.5)!important}::ng-deep .g-dot-inner{background-color:#fff;opacity:.6;width:30%;height:30%;border-radius:50%;box-shadow:0 0 1px #000;transition:all ease .2s}::ng-deep gallery-dots,::ng-deep .g-dot,::ng-deep .g-dot-inner{display:flex;justify-content:center;align-items:center}::ng-deep .g-nav-next,::ng-deep .g-nav-prev{position:absolute;top:50%;width:30px;height:40px;cursor:pointer;z-index:999}::ng-deep .g-nav-next{right:.5em;transform:translateY(-50%) perspective(1px)}::ng-deep .g-nav-prev{left:.5em;transform:translateY(-50%) perspective(1px) scale(-1)}@media only screen and (max-width: 480px){::ng-deep .g-nav-next{right:.2em}::ng-deep .g-nav-prev{left:.2em}}::ng-deep .g-items-container{height:100%}::ng-deep .g-slider{position:absolute;transition:transform .4s cubic-bezier(.5,0,.5,1)}::ng-deep gallery-core[slidingDirection=horizontal] .g-slider{flex-direction:row}::ng-deep gallery-core[slidingDirection=vertical] .g-slider{flex-direction:column}::ng-deep gallery-thumbs{display:block;z-index:1;overflow:unset}::ng-deep .g-thumbs-container{position:relative;z-index:206;width:100%;height:100%;left:0;top:0;display:flex;overflow:unset}::ng-deep gallery-core[disableThumb=true] gallery-thumb{cursor:default}::ng-deep gallery-core[thumbPosition=top] gallery-thumbs .g-slider,::ng-deep gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider{flex-direction:row;top:0;left:50%}::ng-deep gallery-core[thumbPosition=top] gallery-thumbs .g-slider.g-contain,::ng-deep gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider.g-contain{left:0}::ng-deep gallery-core[thumbPosition=top] gallery-thumbs .g-slider.g-contain.g-contain-small-content,::ng-deep gallery-core[thumbPosition=bottom] gallery-thumbs .g-slider.g-contain.g-contain-small-content{left:50%;transform:translate(-50%)!important}::ng-deep gallery-core[thumbPosition=top] gallery-thumb,::ng-deep gallery-core[thumbPosition=bottom] gallery-thumb{padding:1px 0 1px 1px}::ng-deep gallery-core[thumbPosition=left] gallery-thumbs .g-slider,::ng-deep gallery-core[thumbPosition=right] gallery-thumbs .g-slider{flex-direction:column;top:50%;left:0}::ng-deep gallery-core[thumbPosition=left] gallery-thumbs .g-slider.g-contain,::ng-deep gallery-core[thumbPosition=right] gallery-thumbs .g-slider.g-contain{top:0}::ng-deep gallery-core[thumbPosition=left] gallery-thumbs .g-slider.g-contain.g-contain-small-content,::ng-deep gallery-core[thumbPosition=right] gallery-thumbs .g-slider.g-contain.g-contain-small-content{top:50%;transform:translateY(-50%)!important}::ng-deep gallery-core[thumbPosition=left] gallery-thumb,::ng-deep gallery-core[thumbPosition=right] gallery-thumb{padding:0 1px 1px}::ng-deep gallery-core[thumbPosition=top]{flex-direction:column}::ng-deep gallery-core[thumbPosition=left]{flex-direction:row}::ng-deep gallery-core[thumbPosition=right]{flex-direction:row-reverse}::ng-deep gallery-core[thumbPosition=bottom]{flex-direction:column-reverse}::ng-deep gallery-thumb.g-active-thumb .g-thumb-loading{background-color:#464646}::ng-deep .g-thumb-loading{position:relative;overflow:hidden;height:100%;background-color:#262626}::ng-deep .g-thumb-loading:before{content:\"\";position:absolute;top:0;right:0;bottom:0;left:50%;z-index:1;width:500%;margin-left:-250%;-webkit-animation:phAnimation .8s linear infinite;animation:phAnimation .8s linear infinite;background:linear-gradient(to right,rgba(255,255,255,0) 46%,rgba(255,255,255,.35) 50%,rgba(255,255,255,0) 54%) 50% 50%}@-webkit-keyframes phAnimation{0%{transform:translate(-30%)}to{transform:translate(30%)}}@keyframes phAnimation{0%{transform:translate(-30%)}to{transform:translate(30%)}}::ng-deep gallery-core[counterPosition=top] .g-counter{top:0;border-bottom-left-radius:4px;border-bottom-right-radius:4px}::ng-deep gallery-core[counterPosition=bottom] .g-counter{bottom:0;border-top-left-radius:4px;border-top-right-radius:4px}::ng-deep .g-counter{z-index:50;position:absolute;left:50%;transform:translate(-50%) perspective(1px);font-size:12px;padding:4px 10px;color:#fff;background-color:#00000080}::ng-deep gallery[gallerize] gallery-item{cursor:pointer}::ng-deep gallery-item,::ng-deep gallery-thumb{position:relative;height:100%;width:100%;display:block;overflow:hidden}::ng-deep gallery-item h2,::ng-deep gallery-item h4,::ng-deep gallery-thumb h2,::ng-deep gallery-thumb h4{color:coral;margin:0}::ng-deep gallery-item h2,::ng-deep gallery-thumb h2{font-size:3.5em;margin-bottom:.3em}::ng-deep gallery-item h4,::ng-deep gallery-thumb h4{font-size:1.6em}::ng-deep gallery-item{z-index:10}::ng-deep gallery-item video,::ng-deep gallery-item iframe{position:absolute;width:100%;height:100%}::ng-deep gallery-thumb{opacity:.5;cursor:pointer;transition:opacity .3s cubic-bezier(.5,0,.5,1)}::ng-deep gallery-thumb.g-active-thumb{opacity:1}::ng-deep .g-image-item{background-position:center center;background-repeat:no-repeat;background-size:cover;width:100%;height:100%}::ng-deep .g-template,::ng-deep .g-image-error-message{position:absolute;z-index:10;left:0;top:0;right:0;bottom:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}::ng-deep .g-loading{position:absolute;transform:translate(-50%,-50%);left:50%;top:50%;width:80px;height:80px}::ng-deep gallery-core[imageSize=contain] gallery-slider .g-image-item{background-size:contain}::ng-deep gallery-image{display:flex;justify-content:center;align-items:center;height:100%}::ng-deep gallery{position:relative;z-index:1;overflow:hidden;display:block;height:500px;background-color:#000}::ng-deep gallery *{box-sizing:border-box}::ng-deep gallery,::ng-deep gallery-core{position:relative;overflow:hidden}::ng-deep gallery-core,::ng-deep .g-box,::ng-deep .g-slider{display:flex;height:100%;width:100%}::ng-deep gallery[fluid]{transform:translate(-50vw);width:100vw;left:50%}::ng-deep gallery[fluid][fluid=false]{transform:none;width:auto;width:initial;left:auto;left:initial}::ng-deep .g-no-transition{transition:unset!important}::ng-deep .g-box,::ng-deep gallery-slider{overflow:hidden;position:relative;display:flex;flex-direction:column;flex:1;order:1;height:100%}::ng-deep gallery-nav svg,::ng-deep .g-btn-close svg{width:100%;height:100%;filter:drop-shadow(0px 0px 1px black);transition:opacity linear .2s;opacity:.6}::ng-deep gallery-nav svg:hover,::ng-deep .g-btn-close svg:hover{opacity:1}\n"]
    }]
  }], function () {
    return [{
      type: Gallery
    }];
  }, {
    id: [{
      type: core/* Input */.IIB
    }],
    items: [{
      type: core/* Input */.IIB
    }],
    nav: [{
      type: core/* Input */.IIB
    }],
    dots: [{
      type: core/* Input */.IIB
    }],
    loop: [{
      type: core/* Input */.IIB
    }],
    thumb: [{
      type: core/* Input */.IIB
    }],
    zoomOut: [{
      type: core/* Input */.IIB
    }],
    counter: [{
      type: core/* Input */.IIB
    }],
    dotsSize: [{
      type: core/* Input */.IIB
    }],
    autoPlay: [{
      type: core/* Input */.IIB
    }],
    gestures: [{
      type: core/* Input */.IIB
    }],
    thumbWidth: [{
      type: core/* Input */.IIB
    }],
    thumbHeight: [{
      type: core/* Input */.IIB
    }],
    disableThumb: [{
      type: core/* Input */.IIB
    }],
    panSensitivity: [{
      type: core/* Input */.IIB
    }],
    playerInterval: [{
      type: core/* Input */.IIB
    }],
    itemTemplate: [{
      type: core/* Input */.IIB
    }],
    thumbTemplate: [{
      type: core/* Input */.IIB
    }],
    thumbMode: [{
      type: core/* Input */.IIB
    }],
    imageSize: [{
      type: core/* Input */.IIB
    }],
    dotsPosition: [{
      type: core/* Input */.IIB
    }],
    counterPosition: [{
      type: core/* Input */.IIB
    }],
    slidingDirection: [{
      type: core/* Input */.IIB
    }],
    loadingStrategy: [{
      type: core/* Input */.IIB
    }],
    thumbPosition: [{
      type: core/* Input */.IIB
    }],
    thumbView: [{
      type: core/* Input */.IIB
    }],
    destroyRef: [{
      type: core/* Input */.IIB
    }],
    skipInitConfig: [{
      type: core/* Input */.IIB
    }],
    itemClick: [{
      type: core/* Output */.r_U
    }],
    thumbClick: [{
      type: core/* Output */.r_U
    }],
    playingChange: [{
      type: core/* Output */.r_U
    }],
    indexChange: [{
      type: core/* Output */.r_U
    }],
    itemsChange: [{
      type: core/* Output */.r_U
    }],
    error: [{
      type: core/* Output */.r_U
    }]
  });
})();

class GalleryModule {
  static withConfig(config) {
    return {
      ngModule: GalleryModule,
      providers: [{
        provide: GALLERY_CONFIG,
        useValue: config
      }]
    };
  }

}

GalleryModule.ɵfac = function GalleryModule_Factory(t) {
  return new (t || GalleryModule)();
};

GalleryModule.ɵmod = /* @__PURE__ */core/* ɵɵdefineNgModule */.oAB({
  type: GalleryModule
});
GalleryModule.ɵinj = /* @__PURE__ */core/* ɵɵdefineInjector */.cJS({
  imports: [[common/* CommonModule */.ez]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(GalleryModule, [{
    type: core/* NgModule */.LVF,
    args: [{
      imports: [common/* CommonModule */.ez],
      declarations: [GalleryComponent, GalleryNavComponent, GalleryDotsComponent, GalleryCoreComponent, GallerySliderComponent, GalleryCounterComponent, GalleryThumbsComponent, GalleryThumbComponent, GalleryItemComponent, GalleryImageComponent, GalleryVideoComponent, GalleryIframeComponent, LazyImage, TapClick],
      exports: [GalleryComponent, LazyImage, TapClick]
    }]
  }], null, null);
})();
/**
 * Generated bundle index. Do not edit.
 */


 //# sourceMappingURL=ng-gallery.mjs.map
;// CONCATENATED MODULE: ./src/app/pages/art-carousel/art-carousel.ts
















function ArtCarousel_mat_select_2_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 6);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const option_r2 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", option_r2.key);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", option_r2.value, " ");
} }
function ArtCarousel_mat_select_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "mat-select", 4);
    core/* ɵɵlistener */.NdJ("selectionChange", function ArtCarousel_mat_select_2_Template_mat_select_selectionChange_0_listener() { core/* ɵɵrestoreView */.CHM(_r4); const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3.getDropdownData(); })("ngModelChange", function ArtCarousel_mat_select_2_Template_mat_select_ngModelChange_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r4); const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.dropdownKey = $event; });
    core/* ɵɵtemplate */.YNc(1, ArtCarousel_mat_select_2_mat_option_1_Template, 2, 2, "mat-option", 5);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.dropdownKey);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.dropdown);
} }
class ArtCarousel {
    constructor(restService, utilityService, config, dialog, gallery) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.dialog = dialog;
        this.gallery = gallery;
        config.interval = 0;
        config.wrap = false;
        config.keyboard = true;
        config.showNavigationIndicators = false;
        this.currentImage = 0;
        this.restService.getJsonTwo('ART_DROPDOWN').subscribe({
            next: data => {
                this.dropdown = data;
                this.dropdownKey = this.dropdown[0].key;
                this.getDropdownData();
            }
        });
    }
    getImage(code) {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'getArt/f1exposure.com_' + code + '.png';
    }
    getDropdownData() {
        this.restService.getJsonTwo(this.dropdownKey).subscribe({
            next: data => {
                this.gallery.ref('ai-gallery').reset();
                this.imageLinks = data;
                this.galleryImages = [];
                data.forEach(input => {
                    let entry = new ImageItem({ src: input, thumb: input });
                    this.galleryImages.push(entry);
                });
            }
        });
    }
    imageClick(event) {
        if (event >= 0) {
            window.open(this.imageLinks[event], "_blank");
        }
    }
}
ArtCarousel.ɵfac = function ArtCarousel_Factory(t) { return new (t || ArtCarousel)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(ng_bootstrap/* NgbCarouselConfig */.Lu), core/* ɵɵdirectiveInject */.Y36(MatDialog), core/* ɵɵdirectiveInject */.Y36(Gallery)); };
ArtCarousel.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ArtCarousel, selectors: [["app-art-carousel"]], viewQuery: function ArtCarousel_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(GalleryComponent, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.ngxGalleryComponent = _t.first);
    } }, features: [core/* ɵɵProvidersFeature */._Bn([
            {
                provide: GALLERY_CONFIG,
                useValue: {
                    dots: true,
                    imageSize: 'cover'
                }
            }
        ])], decls: 5, vars: 2, consts: [[1, "bg-grey", "text-center"], [1, "bg-grey", "border-info", "text-center", "py-3"], ["panelClass", "mt-4 ml-minus-2", 3, "ngModel", "selectionChange", "ngModelChange", 4, "ngIf"], ["id", "ai-gallery", "thumbView", "contain", "counterPosition", "bottom", "thumbPosition", "right", 1, "img-90vh", 3, "items", "itemClick"], ["panelClass", "mt-4 ml-minus-2", 3, "ngModel", "selectionChange", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function ArtCarousel_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1);
        core/* ɵɵtemplate */.YNc(2, ArtCarousel_mat_select_2_Template, 2, 2, "mat-select", 2);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(3, "div");
        core/* ɵɵelementStart */.TgZ(4, "gallery", 3);
        core/* ɵɵlistener */.NdJ("itemClick", function ArtCarousel_Template_gallery_itemClick_4_listener($event) { return ctx.imageClick($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.dropdown);
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("items", ctx.galleryImages);
    } }, directives: [common/* NgIf */.O5, GalleryComponent, MatSelect, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, common/* NgForOf */.sg, fesm2015_core/* MatOption */.ey], encapsulation: 2 });

;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/slider.js












/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */





const slider_c0 = ["sliderWrapper"];
const activeEventOptions = (0,platform/* normalizePassiveListenerOptions */.i$)({ passive: false });
/**
 * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
 * the default separation we chose.
 */
const MIN_AUTO_TICK_SEPARATION = 30;
/** The thumb gap size for a disabled slider. */
const DISABLED_THUMB_GAP = 7;
/** The thumb gap size for a non-active slider at its minimum value. */
const MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
/** The thumb gap size for an active slider at its minimum value. */
const MIN_VALUE_ACTIVE_THUMB_GAP = 10;
/**
 * Provider Expression that allows mat-slider to register as a ControlValueAccessor.
 * This allows it to support [(ngModel)] and [formControl].
 * @docs-private
 */
const MAT_SLIDER_VALUE_ACCESSOR = {
    provide: fesm2015_forms/* NG_VALUE_ACCESSOR */.JU,
    useExisting: (0,core/* forwardRef */.Gpc)(() => MatSlider),
    multi: true
};
/** A simple change event emitted by the MatSlider component. */
class MatSliderChange {
}
// Boilerplate for applying mixins to MatSlider.
/** @docs-private */
const _MatSliderBase = (0,fesm2015_core/* mixinTabIndex */.sb)((0,fesm2015_core/* mixinColor */.pj)((0,fesm2015_core/* mixinDisabled */.Id)(class {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}), 'accent'));
/**
 * Allows users to select from a range of values by moving the slider thumb. It is similar in
 * behavior to the native `<input type="range">` element.
 */
class MatSlider extends _MatSliderBase {
    constructor(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _ngZone, _document, _animationMode) {
        super(elementRef);
        this._focusMonitor = _focusMonitor;
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._ngZone = _ngZone;
        this._animationMode = _animationMode;
        this._invert = false;
        this._max = 100;
        this._min = 0;
        this._step = 1;
        this._thumbLabel = false;
        this._tickInterval = 0;
        this._value = null;
        this._vertical = false;
        /** Event emitted when the slider value has changed. */
        this.change = new core/* EventEmitter */.vpe();
        /** Event emitted when the slider thumb moves. */
        this.input = new core/* EventEmitter */.vpe();
        /**
         * Emits when the raw value of the slider changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * @docs-private
         */
        this.valueChange = new core/* EventEmitter */.vpe();
        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
        this.onTouched = () => { };
        this._percent = 0;
        /**
         * Whether or not the thumb is sliding and what the user is using to slide it with.
         * Used to determine if there should be a transition for the thumb and fill track.
         */
        this._isSliding = null;
        /**
         * Whether or not the slider is active (clicked or sliding).
         * Used to shrink and grow the thumb as according to the Material Design spec.
         */
        this._isActive = false;
        /** The size of a tick interval as a percentage of the size of the track. */
        this._tickIntervalPercent = 0;
        /** The dimensions of the slider. */
        this._sliderDimensions = null;
        this._controlValueAccessorChangeFn = () => { };
        /** Subscription to the Directionality change EventEmitter. */
        this._dirChangeSubscription = Subscription/* Subscription.EMPTY */.w.EMPTY;
        /** Called when the user has put their pointer down on the slider. */
        this._pointerDown = (event) => {
            // Don't do anything if the slider is disabled or the
            // user is using anything other than the main mouse button.
            if (this.disabled || this._isSliding || (!slider_isTouchEvent(event) && event.button !== 0)) {
                return;
            }
            this._ngZone.run(() => {
                this._touchId = slider_isTouchEvent(event) ?
                    getTouchIdForSlider(event, this._elementRef.nativeElement) : undefined;
                const pointerPosition = getPointerPositionOnPage(event, this._touchId);
                if (pointerPosition) {
                    const oldValue = this.value;
                    this._isSliding = 'pointer';
                    this._lastPointerEvent = event;
                    event.preventDefault();
                    this._focusHostElement();
                    this._onMouseenter(); // Simulate mouseenter in case this is a mobile device.
                    this._bindGlobalEvents(event);
                    this._focusHostElement();
                    this._updateValueFromPosition(pointerPosition);
                    this._valueOnSlideStart = oldValue;
                    // Emit a change and input event if the value changed.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                    }
                }
            });
        };
        /**
         * Called when the user has moved their pointer after
         * starting to drag. Bound on the document level.
         */
        this._pointerMove = (event) => {
            if (this._isSliding === 'pointer') {
                const pointerPosition = getPointerPositionOnPage(event, this._touchId);
                if (pointerPosition) {
                    // Prevent the slide from selecting anything else.
                    event.preventDefault();
                    const oldValue = this.value;
                    this._lastPointerEvent = event;
                    this._updateValueFromPosition(pointerPosition);
                    // Native range elements always emit `input` events when the value changed while sliding.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                    }
                }
            }
        };
        /** Called when the user has lifted their pointer. Bound on the document level. */
        this._pointerUp = (event) => {
            if (this._isSliding === 'pointer') {
                if (!slider_isTouchEvent(event) || typeof this._touchId !== 'number' ||
                    // Note that we use `changedTouches`, rather than `touches` because it
                    // seems like in most cases `touches` is empty for `touchend` events.
                    findMatchingTouch(event.changedTouches, this._touchId)) {
                    event.preventDefault();
                    this._removeGlobalEvents();
                    this._isSliding = null;
                    this._touchId = undefined;
                    if (this._valueOnSlideStart != this.value && !this.disabled) {
                        this._emitChangeEvent();
                    }
                    this._valueOnSlideStart = this._lastPointerEvent = null;
                }
            }
        };
        /** Called when the window has lost focus. */
        this._windowBlur = () => {
            // If the window is blurred while dragging we need to stop dragging because the
            // browser won't dispatch the `mouseup` and `touchend` events anymore.
            if (this._lastPointerEvent) {
                this._pointerUp(this._lastPointerEvent);
            }
        };
        this._document = _document;
        this.tabIndex = parseInt(tabIndex) || 0;
        _ngZone.runOutsideAngular(() => {
            const element = elementRef.nativeElement;
            element.addEventListener('mousedown', this._pointerDown, activeEventOptions);
            element.addEventListener('touchstart', this._pointerDown, activeEventOptions);
        });
    }
    /** Whether the slider is inverted. */
    get invert() { return this._invert; }
    set invert(value) {
        this._invert = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /** The maximum value that the slider can have. */
    get max() { return this._max; }
    set max(v) {
        this._max = (0,coercion/* coerceNumberProperty */.su)(v, this._max);
        this._percent = this._calculatePercentage(this._value);
        // Since this also modifies the percentage, we need to let the change detection know.
        this._changeDetectorRef.markForCheck();
    }
    /** The minimum value that the slider can have. */
    get min() { return this._min; }
    set min(v) {
        this._min = (0,coercion/* coerceNumberProperty */.su)(v, this._min);
        this._percent = this._calculatePercentage(this._value);
        // Since this also modifies the percentage, we need to let the change detection know.
        this._changeDetectorRef.markForCheck();
    }
    /** The values at which the thumb will snap. */
    get step() { return this._step; }
    set step(v) {
        this._step = (0,coercion/* coerceNumberProperty */.su)(v, this._step);
        if (this._step % 1 !== 0) {
            this._roundToDecimal = this._step.toString().split('.').pop().length;
        }
        // Since this could modify the label, we need to notify the change detection.
        this._changeDetectorRef.markForCheck();
    }
    /** Whether or not to show the thumb label. */
    get thumbLabel() { return this._thumbLabel; }
    set thumbLabel(value) { this._thumbLabel = (0,coercion/* coerceBooleanProperty */.Ig)(value); }
    /**
     * How often to show ticks. Relative to the step so that a tick always appears on a step.
     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
     */
    get tickInterval() { return this._tickInterval; }
    set tickInterval(value) {
        if (value === 'auto') {
            this._tickInterval = 'auto';
        }
        else if (typeof value === 'number' || typeof value === 'string') {
            this._tickInterval = (0,coercion/* coerceNumberProperty */.su)(value, this._tickInterval);
        }
        else {
            this._tickInterval = 0;
        }
    }
    /** Value of the slider. */
    get value() {
        // If the value needs to be read and it is still uninitialized, initialize it to the min.
        if (this._value === null) {
            this.value = this._min;
        }
        return this._value;
    }
    set value(v) {
        if (v !== this._value) {
            let value = (0,coercion/* coerceNumberProperty */.su)(v, 0);
            // While incrementing by a decimal we can end up with values like 33.300000000000004.
            // Truncate it to ensure that it matches the label and to make it easier to work with.
            if (this._roundToDecimal && value !== this.min && value !== this.max) {
                value = parseFloat(value.toFixed(this._roundToDecimal));
            }
            this._value = value;
            this._percent = this._calculatePercentage(this._value);
            // Since this also modifies the percentage, we need to let the change detection know.
            this._changeDetectorRef.markForCheck();
        }
    }
    /** Whether the slider is vertical. */
    get vertical() { return this._vertical; }
    set vertical(value) {
        this._vertical = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /** The value to be used for display purposes. */
    get displayValue() {
        if (this.displayWith) {
            // Value is never null but since setters and getters cannot have
            // different types, the value getter is also typed to return null.
            return this.displayWith(this.value);
        }
        // Note that this could be improved further by rounding something like 0.999 to 1 or
        // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
        // every change detection cycle.
        if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
            return this.value.toFixed(this._roundToDecimal);
        }
        return this.value || 0;
    }
    /** set focus to the host element */
    focus(options) {
        this._focusHostElement(options);
    }
    /** blur the host element */
    blur() {
        this._blurHostElement();
    }
    /** The percentage of the slider that coincides with the value. */
    get percent() { return this._clamp(this._percent); }
    /**
     * Whether the axis of the slider is inverted.
     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
     */
    _shouldInvertAxis() {
        // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
        // top. However from a y-axis standpoint this is inverted.
        return this.vertical ? !this.invert : this.invert;
    }
    /** Whether the slider is at its minimum value. */
    _isMinValue() {
        return this.percent === 0;
    }
    /**
     * The amount of space to leave between the slider thumb and the track fill & track background
     * elements.
     */
    _getThumbGap() {
        if (this.disabled) {
            return DISABLED_THUMB_GAP;
        }
        if (this._isMinValue() && !this.thumbLabel) {
            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
        }
        return 0;
    }
    /** CSS styles for the track background element. */
    _getTrackBackgroundStyles() {
        const axis = this.vertical ? 'Y' : 'X';
        const scale = this.vertical ? `1, ${1 - this.percent}, 1` : `${1 - this.percent}, 1, 1`;
        const sign = this._shouldInvertMouseCoords() ? '-' : '';
        return {
            // scale3d avoids some rendering issues in Chrome. See #12071.
            transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`
        };
    }
    /** CSS styles for the track fill element. */
    _getTrackFillStyles() {
        const percent = this.percent;
        const axis = this.vertical ? 'Y' : 'X';
        const scale = this.vertical ? `1, ${percent}, 1` : `${percent}, 1, 1`;
        const sign = this._shouldInvertMouseCoords() ? '' : '-';
        return {
            // scale3d avoids some rendering issues in Chrome. See #12071.
            transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`,
            // iOS Safari has a bug where it won't re-render elements which start of as `scale(0)` until
            // something forces a style recalculation on it. Since we'll end up with `scale(0)` when
            // the value of the slider is 0, we can easily get into this situation. We force a
            // recalculation by changing the element's `display` when it goes from 0 to any other value.
            display: percent === 0 ? 'none' : ''
        };
    }
    /** CSS styles for the ticks container element. */
    _getTicksContainerStyles() {
        let axis = this.vertical ? 'Y' : 'X';
        // For a horizontal slider in RTL languages we push the ticks container off the left edge
        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
        let sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';
        let offset = this._tickIntervalPercent / 2 * 100;
        return {
            'transform': `translate${axis}(${sign}${offset}%)`
        };
    }
    /** CSS styles for the ticks element. */
    _getTicksStyles() {
        let tickSize = this._tickIntervalPercent * 100;
        let backgroundSize = this.vertical ? `2px ${tickSize}%` : `${tickSize}% 2px`;
        let axis = this.vertical ? 'Y' : 'X';
        // Depending on the direction we pushed the ticks container, push the ticks the opposite
        // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
        // ticks 180 degrees so we're really cutting off the end edge abd not the start.
        let sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';
        let rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';
        let styles = {
            'backgroundSize': backgroundSize,
            // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
            'transform': `translateZ(0) translate${axis}(${sign}${tickSize / 2}%)${rotate}`
        };
        if (this._isMinValue() && this._getThumbGap()) {
            const shouldInvertAxis = this._shouldInvertAxis();
            let side;
            if (this.vertical) {
                side = shouldInvertAxis ? 'Bottom' : 'Top';
            }
            else {
                side = shouldInvertAxis ? 'Right' : 'Left';
            }
            styles[`padding${side}`] = `${this._getThumbGap()}px`;
        }
        return styles;
    }
    _getThumbContainerStyles() {
        const shouldInvertAxis = this._shouldInvertAxis();
        let axis = this.vertical ? 'Y' : 'X';
        // For a horizontal slider in RTL languages we push the thumb container off the left edge
        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
        let invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !shouldInvertAxis : shouldInvertAxis;
        let offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
        return {
            'transform': `translate${axis}(-${offset}%)`
        };
    }
    /**
     * Whether mouse events should be converted to a slider position by calculating their distance
     * from the right or bottom edge of the slider as opposed to the top or left.
     */
    _shouldInvertMouseCoords() {
        const shouldInvertAxis = this._shouldInvertAxis();
        return (this._getDirection() == 'rtl' && !this.vertical) ? !shouldInvertAxis : shouldInvertAxis;
    }
    /** The language direction for this slider element. */
    _getDirection() {
        return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
    }
    ngAfterViewInit() {
        this._focusMonitor
            .monitor(this._elementRef, true)
            .subscribe((origin) => {
            this._isActive = !!origin && origin !== 'keyboard';
            this._changeDetectorRef.detectChanges();
        });
        if (this._dir) {
            this._dirChangeSubscription = this._dir.change.subscribe(() => {
                this._changeDetectorRef.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        const element = this._elementRef.nativeElement;
        element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);
        element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);
        this._lastPointerEvent = null;
        this._removeGlobalEvents();
        this._focusMonitor.stopMonitoring(this._elementRef);
        this._dirChangeSubscription.unsubscribe();
    }
    _onMouseenter() {
        if (this.disabled) {
            return;
        }
        // We save the dimensions of the slider here so we can use them to update the spacing of the
        // ticks and determine where on the slider click and slide events happen.
        this._sliderDimensions = this._getSliderDimensions();
        this._updateTickIntervalPercent();
    }
    _onFocus() {
        // We save the dimensions of the slider here so we can use them to update the spacing of the
        // ticks and determine where on the slider click and slide events happen.
        this._sliderDimensions = this._getSliderDimensions();
        this._updateTickIntervalPercent();
    }
    _onBlur() {
        this.onTouched();
    }
    _onKeydown(event) {
        if (this.disabled || (0,keycodes/* hasModifierKey */.Vb)(event) ||
            (this._isSliding && this._isSliding !== 'keyboard')) {
            return;
        }
        const oldValue = this.value;
        switch (event.keyCode) {
            case keycodes/* PAGE_UP */.Ku:
                this._increment(10);
                break;
            case keycodes/* PAGE_DOWN */.VM:
                this._increment(-10);
                break;
            case keycodes/* END */.uR:
                this.value = this.max;
                break;
            case keycodes/* HOME */.Sd:
                this.value = this.min;
                break;
            case keycodes/* LEFT_ARROW */.oh:
                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
                // inverted slider the thumb moves in that direction. However for a blind user, nothing
                // about the slider indicates that it is inverted. They will expect left to be decrement,
                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
                // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
                // sighted users, therefore we do not swap the meaning.
                this._increment(this._getDirection() == 'rtl' ? 1 : -1);
                break;
            case keycodes/* UP_ARROW */.LH:
                this._increment(1);
                break;
            case keycodes/* RIGHT_ARROW */.SV:
                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
                this._increment(this._getDirection() == 'rtl' ? -1 : 1);
                break;
            case keycodes/* DOWN_ARROW */.JH:
                this._increment(-1);
                break;
            default:
                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
                // it.
                return;
        }
        if (oldValue != this.value) {
            this._emitInputEvent();
            this._emitChangeEvent();
        }
        this._isSliding = 'keyboard';
        event.preventDefault();
    }
    _onKeyup() {
        if (this._isSliding === 'keyboard') {
            this._isSliding = null;
        }
    }
    /** Use defaultView of injected document if available or fallback to global window reference */
    _getWindow() {
        return this._document.defaultView || window;
    }
    /**
     * Binds our global move and end events. They're bound at the document level and only while
     * dragging so that the user doesn't have to keep their pointer exactly over the slider
     * as they're swiping across the screen.
     */
    _bindGlobalEvents(triggerEvent) {
        // Note that we bind the events to the `document`, because it allows us to capture
        // drag cancel events where the user's pointer is outside the browser window.
        const document = this._document;
        const isTouch = slider_isTouchEvent(triggerEvent);
        const moveEventName = isTouch ? 'touchmove' : 'mousemove';
        const endEventName = isTouch ? 'touchend' : 'mouseup';
        document.addEventListener(moveEventName, this._pointerMove, activeEventOptions);
        document.addEventListener(endEventName, this._pointerUp, activeEventOptions);
        if (isTouch) {
            document.addEventListener('touchcancel', this._pointerUp, activeEventOptions);
        }
        const window = this._getWindow();
        if (typeof window !== 'undefined' && window) {
            window.addEventListener('blur', this._windowBlur);
        }
    }
    /** Removes any global event listeners that we may have added. */
    _removeGlobalEvents() {
        const document = this._document;
        document.removeEventListener('mousemove', this._pointerMove, activeEventOptions);
        document.removeEventListener('mouseup', this._pointerUp, activeEventOptions);
        document.removeEventListener('touchmove', this._pointerMove, activeEventOptions);
        document.removeEventListener('touchend', this._pointerUp, activeEventOptions);
        document.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);
        const window = this._getWindow();
        if (typeof window !== 'undefined' && window) {
            window.removeEventListener('blur', this._windowBlur);
        }
    }
    /** Increments the slider by the given number of steps (negative number decrements). */
    _increment(numSteps) {
        this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);
    }
    /** Calculate the new value from the new physical location. The value will always be snapped. */
    _updateValueFromPosition(pos) {
        if (!this._sliderDimensions) {
            return;
        }
        let offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
        let size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
        let posComponent = this.vertical ? pos.y : pos.x;
        // The exact value is calculated from the event and used to find the closest snap value.
        let percent = this._clamp((posComponent - offset) / size);
        if (this._shouldInvertMouseCoords()) {
            percent = 1 - percent;
        }
        // Since the steps may not divide cleanly into the max value, if the user
        // slid to 0 or 100 percent, we jump to the min/max value. This approach
        // is slightly more intuitive than using `Math.ceil` below, because it
        // follows the user's pointer closer.
        if (percent === 0) {
            this.value = this.min;
        }
        else if (percent === 1) {
            this.value = this.max;
        }
        else {
            const exactValue = this._calculateValue(percent);
            // This calculation finds the closest step by finding the closest
            // whole number divisible by the step relative to the min.
            const closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
            // The value needs to snap to the min and max.
            this.value = this._clamp(closestValue, this.min, this.max);
        }
    }
    /** Emits a change event if the current value is different from the last emitted value. */
    _emitChangeEvent() {
        this._controlValueAccessorChangeFn(this.value);
        this.valueChange.emit(this.value);
        this.change.emit(this._createChangeEvent());
    }
    /** Emits an input event when the current value is different from the last emitted value. */
    _emitInputEvent() {
        this.input.emit(this._createChangeEvent());
    }
    /** Updates the amount of space between ticks as a percentage of the width of the slider. */
    _updateTickIntervalPercent() {
        if (!this.tickInterval || !this._sliderDimensions) {
            return;
        }
        if (this.tickInterval == 'auto') {
            let trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
            let pixelsPerStep = trackSize * this.step / (this.max - this.min);
            let stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
            let pixelsPerTick = stepsPerTick * this.step;
            this._tickIntervalPercent = pixelsPerTick / trackSize;
        }
        else {
            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
        }
    }
    /** Creates a slider change object from the specified value. */
    _createChangeEvent(value = this.value) {
        let event = new MatSliderChange();
        event.source = this;
        event.value = value;
        return event;
    }
    /** Calculates the percentage of the slider that a value is. */
    _calculatePercentage(value) {
        return ((value || 0) - this.min) / (this.max - this.min);
    }
    /** Calculates the value a percentage of the slider corresponds to. */
    _calculateValue(percentage) {
        return this.min + percentage * (this.max - this.min);
    }
    /** Return a number between two numbers. */
    _clamp(value, min = 0, max = 1) {
        return Math.max(min, Math.min(value, max));
    }
    /**
     * Get the bounding client rect of the slider track element.
     * The track is used rather than the native element to ignore the extra space that the thumb can
     * take up.
     */
    _getSliderDimensions() {
        return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
    }
    /**
     * Focuses the native element.
     * Currently only used to allow a blur event to fire but will be used with keyboard input later.
     */
    _focusHostElement(options) {
        this._elementRef.nativeElement.focus(options);
    }
    /** Blurs the native element. */
    _blurHostElement() {
        this._elementRef.nativeElement.blur();
    }
    /**
     * Sets the model value. Implemented as part of ControlValueAccessor.
     * @param value
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Registers a callback to be triggered when the value has changed.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     */
    registerOnChange(fn) {
        this._controlValueAccessorChangeFn = fn;
    }
    /**
     * Registers a callback to be triggered when the component is touched.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Sets whether the component should be disabled.
     * Implemented as part of ControlValueAccessor.
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
MatSlider.ɵfac = function MatSlider_Factory(t) { return new (t || MatSlider)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(a11y/* FocusMonitor */.tE), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8), core/* ɵɵinjectAttribute */.$8M('tabindex'), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0), core/* ɵɵdirectiveInject */.Y36(fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb, 8)); };
MatSlider.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatSlider, selectors: [["mat-slider"]], viewQuery: function MatSlider_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(slider_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._sliderWrapper = _t.first);
    } }, hostAttrs: ["role", "slider", 1, "mat-slider", "mat-focus-indicator"], hostVars: 29, hostBindings: function MatSlider_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("focus", function MatSlider_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MatSlider_blur_HostBindingHandler() { return ctx._onBlur(); })("keydown", function MatSlider_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("keyup", function MatSlider_keyup_HostBindingHandler() { return ctx._onKeyup(); })("mouseenter", function MatSlider_mouseenter_HostBindingHandler() { return ctx._onMouseenter(); })("selectstart", function MatSlider_selectstart_HostBindingHandler($event) { return $event.preventDefault(); });
    } if (rf & 2) {
        core/* ɵɵhostProperty */.Ikx("tabIndex", ctx.tabIndex);
        core/* ɵɵattribute */.uIk("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-valuetext", ctx.valueText == null ? ctx.displayValue : ctx.valueText)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        core/* ɵɵclassProp */.ekj("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._shouldInvertAxis())("mat-slider-invert-mouse-coords", ctx._shouldInvertMouseCoords())("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue())("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue() && ctx._getThumbGap() && ctx._shouldInvertAxis())("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
    } }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", invert: "invert", max: "max", min: "min", step: "step", thumbLabel: "thumbLabel", tickInterval: "tickInterval", value: "value", vertical: "vertical", displayWith: "displayWith", valueText: "valueText" }, outputs: { change: "change", input: "input", valueChange: "valueChange" }, exportAs: ["matSlider"], features: [core/* ɵɵProvidersFeature */._Bn([MAT_SLIDER_VALUE_ACCESSOR]), core/* ɵɵInheritDefinitionFeature */.qOj], decls: 13, vars: 6, consts: [[1, "mat-slider-wrapper"], ["sliderWrapper", ""], [1, "mat-slider-track-wrapper"], [1, "mat-slider-track-background", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]], template: function MatSlider_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0, 1);
        core/* ɵɵelementStart */.TgZ(2, "div", 2);
        core/* ɵɵelement */._UZ(3, "div", 3);
        core/* ɵɵelement */._UZ(4, "div", 4);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(5, "div", 5);
        core/* ɵɵelement */._UZ(6, "div", 6);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "div", 7);
        core/* ɵɵelement */._UZ(8, "div", 8);
        core/* ɵɵelement */._UZ(9, "div", 9);
        core/* ɵɵelementStart */.TgZ(10, "div", 10);
        core/* ɵɵelementStart */.TgZ(11, "span", 11);
        core/* ɵɵtext */._uU(12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(3);
        core/* ɵɵproperty */.Q6J("ngStyle", ctx._getTrackBackgroundStyles());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngStyle", ctx._getTrackFillStyles());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngStyle", ctx._getTicksContainerStyles());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngStyle", ctx._getTicksStyles());
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngStyle", ctx._getThumbContainerStyles());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵtextInterpolate */.Oqu(ctx.displayValue);
    } }, directives: [common/* NgStyle */.PC], styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\"\";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\n"], encapsulation: 2, changeDetection: 0 });
MatSlider.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: a11y/* FocusMonitor */.tE },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] },
    { type: String, decorators: [{ type: core/* Attribute */.ahi, args: ['tabindex',] }] },
    { type: core/* NgZone */.R0b },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] },
    { type: String, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb,] }] }
];
MatSlider.propDecorators = {
    invert: [{ type: core/* Input */.IIB }],
    max: [{ type: core/* Input */.IIB }],
    min: [{ type: core/* Input */.IIB }],
    step: [{ type: core/* Input */.IIB }],
    thumbLabel: [{ type: core/* Input */.IIB }],
    tickInterval: [{ type: core/* Input */.IIB }],
    value: [{ type: core/* Input */.IIB }],
    displayWith: [{ type: core/* Input */.IIB }],
    valueText: [{ type: core/* Input */.IIB }],
    vertical: [{ type: core/* Input */.IIB }],
    change: [{ type: core/* Output */.r_U }],
    input: [{ type: core/* Output */.r_U }],
    valueChange: [{ type: core/* Output */.r_U }],
    _sliderWrapper: [{ type: core/* ViewChild */.i9L, args: ['sliderWrapper',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSlider, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-slider',
                exportAs: 'matSlider',
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(keydown)': '_onKeydown($event)',
                    '(keyup)': '_onKeyup()',
                    '(mouseenter)': '_onMouseenter()',
                    // On Safari starting to slide temporarily triggers text selection mode which
                    // show the wrong cursor. We prevent it by stopping the `selectstart` event.
                    '(selectstart)': '$event.preventDefault()',
                    'class': 'mat-slider mat-focus-indicator',
                    'role': 'slider',
                    '[tabIndex]': 'tabIndex',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-valuemax]': 'max',
                    '[attr.aria-valuemin]': 'min',
                    '[attr.aria-valuenow]': 'value',
                    // NVDA and Jaws appear to announce the `aria-valuenow` by calculating its percentage based
                    // on its value between `aria-valuemin` and `aria-valuemax`. Due to how decimals are handled,
                    // it can cause the slider to read out a very long value like 0.20000068 if the current value
                    // is 0.2 with a min of 0 and max of 1. We work around the issue by setting `aria-valuetext`
                    // to the same value that we set on the slider's thumb which will be truncated.
                    '[attr.aria-valuetext]': 'valueText == null ? displayValue : valueText',
                    '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                    '[class.mat-slider-disabled]': 'disabled',
                    '[class.mat-slider-has-ticks]': 'tickInterval',
                    '[class.mat-slider-horizontal]': '!vertical',
                    '[class.mat-slider-axis-inverted]': '_shouldInvertAxis()',
                    // Class binding which is only used by the test harness as there is no other
                    // way for the harness to detect if mouse coordinates need to be inverted.
                    '[class.mat-slider-invert-mouse-coords]': '_shouldInvertMouseCoords()',
                    '[class.mat-slider-sliding]': '_isSliding',
                    '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                    '[class.mat-slider-vertical]': 'vertical',
                    '[class.mat-slider-min-value]': '_isMinValue()',
                    '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue() && _getThumbGap() && _shouldInvertAxis()',
                    '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"'
                },
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\n  <div class=\"mat-slider-track-wrapper\">\n    <div class=\"mat-slider-track-background\" [ngStyle]=\"_getTrackBackgroundStyles()\"></div>\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_getTrackFillStyles()\"></div>\n  </div>\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_getTicksContainerStyles()\">\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_getTicksStyles()\"></div>\n  </div>\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_getThumbContainerStyles()\">\n    <div class=\"mat-slider-focus-ring\"></div>\n    <div class=\"mat-slider-thumb\"></div>\n    <div class=\"mat-slider-thumb-label\">\n      <span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span>\n    </div>\n  </div>\n</div>\n",
                inputs: ['disabled', 'color', 'tabIndex'],
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\"\";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: a11y/* FocusMonitor */.tE }, { type: core/* ChangeDetectorRef */.sBO }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: String, decorators: [{
                type: core/* Attribute */.ahi,
                args: ['tabindex']
            }] }, { type: core/* NgZone */.R0b }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }, { type: String, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [fesm2015_animations/* ANIMATION_MODULE_TYPE */.Qb]
            }] }]; }, { change: [{
            type: core/* Output */.r_U
        }], input: [{
            type: core/* Output */.r_U
        }], valueChange: [{
            type: core/* Output */.r_U
        }], invert: [{
            type: core/* Input */.IIB
        }], max: [{
            type: core/* Input */.IIB
        }], min: [{
            type: core/* Input */.IIB
        }], step: [{
            type: core/* Input */.IIB
        }], thumbLabel: [{
            type: core/* Input */.IIB
        }], tickInterval: [{
            type: core/* Input */.IIB
        }], value: [{
            type: core/* Input */.IIB
        }], vertical: [{
            type: core/* Input */.IIB
        }], displayWith: [{
            type: core/* Input */.IIB
        }], valueText: [{
            type: core/* Input */.IIB
        }], _sliderWrapper: [{
            type: core/* ViewChild */.i9L,
            args: ['sliderWrapper']
        }] }); })();
/** Returns whether an event is a touch event. */
function slider_isTouchEvent(event) {
    // This function is called for every pixel that the user has dragged so we need it to be
    // as fast as possible. Since we only bind mouse events and touch events, we can assume
    // that if the event's name starts with `t`, it's a touch event.
    return event.type[0] === 't';
}
/** Gets the coordinates of a touch or mouse event relative to the viewport. */
function getPointerPositionOnPage(event, id) {
    let point;
    if (slider_isTouchEvent(event)) {
        // The `identifier` could be undefined if the browser doesn't support `TouchEvent.identifier`.
        // If that's the case, attribute the first touch to all active sliders. This should still cover
        // the most common case while only breaking multi-touch.
        if (typeof id === 'number') {
            point = findMatchingTouch(event.touches, id) || findMatchingTouch(event.changedTouches, id);
        }
        else {
            // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
            point = event.touches[0] || event.changedTouches[0];
        }
    }
    else {
        point = event;
    }
    return point ? { x: point.clientX, y: point.clientY } : undefined;
}
/** Finds a `Touch` with a specific ID in a `TouchList`. */
function findMatchingTouch(touches, id) {
    for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === id) {
            return touches[i];
        }
    }
    return undefined;
}
/** Gets the unique ID of a touch that matches a specific slider. */
function getTouchIdForSlider(event, sliderHost) {
    for (let i = 0; i < event.touches.length; i++) {
        const target = event.touches[i].target;
        if (sliderHost === target || sliderHost.contains(target)) {
            return event.touches[i].identifier;
        }
    }
    return undefined;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatSliderModule {
}
MatSliderModule.ɵfac = function MatSliderModule_Factory(t) { return new (t || MatSliderModule)(); };
MatSliderModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatSliderModule });
MatSliderModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ], fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatSliderModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ],
                exports: [MatSlider, fesm2015_core/* MatCommonModule */.BQ],
                declarations: [MatSlider]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatSliderModule, { declarations: function () { return [MatSlider]; }, imports: function () { return [common/* CommonModule */.ez, fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatSlider, fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=slider.js.map
;// CONCATENATED MODULE: ./src/app/shared/barChartRace/am-chart.component.ts










function AmChartComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r2 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 4);
    core/* ɵɵelementStart */.TgZ(1, "mat-slider", 5);
    core/* ɵɵlistener */.NdJ("change", function AmChartComponent_div_2_Template_mat_slider_change_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r1 = core/* ɵɵnextContext */.oxw(); return ctx_r1.onStepDurationChange($event.value); })("ngModelChange", function AmChartComponent_div_2_Template_mat_slider_ngModelChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3.stepDurationSlider = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(2, "p");
    core/* ɵɵtext */._uU(3, "Speed");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.stepDurationSlider)("displayWith", ctx_r0.formatLabel);
} }
const am_chart_component_c0 = function (a0) { return { "height-10-px": a0 }; };
class AmChartComponent {
    constructor(platformId, zone) {
        this.platformId = platformId;
        this.zone = zone;
        this.onOff = true;
        this.chartDivId = 'div' + Math.floor(Math.random() * 100000);
        this.dataMap = new Map();
        this.stepDurationSlider = 2;
        //vece=sporije
        this.stepDuration = 600;
    }
    // Run the function only in the browser
    browserOnly(f) {
        if ((0,common/* isPlatformBrowser */.NF)(this.platformId)) {
            this.zone.runOutsideAngular(() => {
                f();
            });
        }
    }
    formatLabel(value) {
        return value;
    }
    ngAfterViewInit() {
        this.stepDuration = 1600 - (this.stepDurationSlider * 200);
        /* Chart code */
        // Data
        let dataMap = this.getDataFromSeries();
        // Create root element
        // https://www.amcharts.com/docs/v5/getting-started/#Root_element
        let root = Root.new(this.chartDivId);
        this.root = root;
        //vece=sporije
        let stepDuration = this.stepDuration;
        // Set themes
        // https://www.amcharts.com/docs/v5/concepts/themes/
        root.setThemes([Animated.new(root)]);
        // Create chart
        // https://www.amcharts.com/docs/v5/charts/xy-chart/
        let chart = root.container.children.push(XYChart.new(root, {
            panX: true,
            panY: true,
            wheelX: "none",
            wheelY: "none"
        }));
        // We don't want zoom-out button to appear while animating, so we hide it at all
        chart.zoomOutButton.set("forceHidden", true);
        // Create axes
        // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/
        let yRenderer = AxisRendererY.new(root, {
            minGridDistance: 20,
            inversed: true
        });
        // hide grid
        yRenderer.grid.template.set("visible", false);
        let yAxis = chart.yAxes.push(CategoryAxis.new(root, {
            maxDeviation: 0,
            categoryField: "network",
            renderer: yRenderer
        }));
        let xRenderer = AxisRendererX.new(root, {
            minGridDistance: 20
            // opacity: 0,
            // visible: false,
            // disabled: true
        });
        //  xRenderer.grid.template.set("visible", false);
        xRenderer.labels.template.set("visible", false);
        xRenderer.ticks.template.set("visible", false);
        let xAxis = chart.xAxes.push(ValueAxis.new(root, {
            maxDeviation: 0,
            min: 0,
            strictMinMax: true,
            extraMax: 0.1,
            renderer: xRenderer
        }));
        xAxis.set("interpolationDuration", stepDuration / 10);
        xAxis.set("interpolationEasing", linear);
        // Add series
        // https://www.amcharts.com/docs/v5/charts/xy-chart/series/
        let series = chart.series.push(ColumnSeries.new(root, {
            xAxis: xAxis,
            yAxis: yAxis,
            valueXField: "value",
            categoryYField: "network"
        }));
        // Rounded corners for columns
        series.columns.template.setAll({ cornerRadiusBR: 5, cornerRadiusTR: 5 });
        // Make each column to be of a different color
        series.columns.template.adapters.add("fill", function (fill, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        series.columns.template.adapters.add("stroke", function (stroke, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        // Add label bullet
        series.bullets.push(function () {
            return Bullet.new(root, {
                locationX: 1,
                sprite: Label.new(root, {
                    text: "{valueXWorking.formatNumber('#.')}",
                    fill: root.interfaceColors.get("alternativeText"),
                    centerX: p100,
                    centerY: p50,
                    populateText: true
                })
            });
        });
        let label = chart.plotContainer.children.push(Label.new(root, {
            text: "1",
            fontSize: "18em",
            opacity: 0.2,
            x: p100,
            y: p100,
            centerY: p100,
            centerX: p100
        }));
        // Get series item by category
        function getSeriesItem(category) {
            for (var i = 0; i < series.dataItems.length; i++) {
                let dataItem = series.dataItems[i];
                if (dataItem.get("categoryY") == category) {
                    return dataItem;
                }
            }
            return null;
        }
        // Axis sorting
        function sortCategoryAxis() {
            // sort by value
            series.dataItems.sort(function (x, y) {
                // @ts-ignore
                return y.get("valueX") - x.get("valueX"); // descending
                //return x.get("valueX") - y.get("valueX"); // ascending
            });
            // go through each axis item
            each(yAxis.dataItems, function (dataItem) {
                // get corresponding series item
                let seriesDataItem = getSeriesItem(dataItem.get("category"));
                if (seriesDataItem) {
                    // get index of series data item
                    let index = series.dataItems.indexOf(seriesDataItem);
                    // calculate delta position
                    let deltaPosition = (index - dataItem.get("index", 0)) / series.dataItems.length;
                    // set index to be the same as series data item index
                    if (dataItem.get("index") != index) {
                        dataItem.set("index", index);
                        // set deltaPosition instanlty
                        dataItem.set("deltaPosition", -deltaPosition);
                        // animate delta position to 0
                        dataItem.animate({
                            key: "deltaPosition",
                            to: 0,
                            duration: stepDuration / 2,
                            easing: out(cubic)
                        });
                    }
                }
            });
            // sort axis items by index.
            // This changes the order instantly, but as deltaPosition is set, they keep in the same places and then animate to true positions.
            yAxis.dataItems.sort(function (x, y) {
                // @ts-ignore
                return x.get("index") - y.get("index");
            });
        }
        let round = 0;
        // update data with values each 1.5 sec
        let interval = setInterval(function () {
            round++;
            if (round > dataMap.size) {
                clearInterval(interval);
                clearInterval(sortInterval);
            }
            updateData(dataMap);
        }, stepDuration);
        let sortInterval = setInterval(function () {
            sortCategoryAxis();
        }, 100);
        function setInitialData(dataMap) {
            let lapMap = dataMap.get(0);
            lapMap.forEach((value, key) => {
                series.data.push({ network: key, value: value });
                yAxis.data.push({ network: key });
            });
        }
        function updateData(dataMap) {
            let itemsWithNonZero = 0;
            if (dataMap.get(round)) {
                label.set("text", round.toString());
                each(series.dataItems, function (dataItem) {
                    let category = dataItem.get("categoryY");
                    let value = dataMap.get(round).get(category);
                    if (value > 0) {
                        itemsWithNonZero++;
                    }
                    dataItem.animate({
                        key: "valueX",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                    dataItem.animate({
                        key: "valueXWorking",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                });
                // console.log('zoom: ' + itemsWithNonZero + ' - ' + (itemsWithNonZero / yAxis.dataItems.length));
                yAxis.zoom(0, itemsWithNonZero / yAxis.dataItems.length);
            }
        }
        setInitialData(dataMap);
        setTimeout(function () {
            round++;
            updateData(dataMap);
        }, 50);
        // Make stuff animate on load
        // https://www.amcharts.com/docs/v5/concepts/animations/
        series.appear(1000);
        chart.appear(100, 100);
    }
    ngOnDestroy() {
        // Clean up chart when the component is removed
        this.browserOnly(() => {
            if (this.root) {
                this.root.dispose();
            }
            else {
                this.root.dispose();
            }
        });
    }
    getDataFromSeries() {
        let dataMap = new Map();
        for (let i = 0; i <= this.series[0].data.length; i++) {
            dataMap.set(i, new Map());
        }
        this.series.forEach(serie => {
            let name;
            if (this.codeMapping != null) {
                name = this.codeMapping.get(serie.name);
            }
            else {
                name = serie.name;
            }
            dataMap.get(0).set(name, 0);
            for (let i = 0; i < serie.data.length; i++) {
                if (!dataMap.has(serie.data[i][0])) {
                    dataMap.set(serie.data[i][0], new Map());
                }
                dataMap.get(serie.data[i][0]).set(name, serie.data[i][1]);
            }
        });
        this.dataMap = dataMap;
        return dataMap;
    }
    onStepDurationChange(value) {
    }
    onOffChart(event) {
        if (event.checked) {
            this.ngAfterViewInit();
        }
        else {
            this.ngOnDestroy();
        }
        this.onOff = event.checked;
    }
}
AmChartComponent.ɵfac = function AmChartComponent_Factory(t) { return new (t || AmChartComponent)(core/* ɵɵdirectiveInject */.Y36(core/* PLATFORM_ID */.Lbi), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b)); };
AmChartComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: AmChartComponent, selectors: [["app-amchart-cmp"]], inputs: { series: "series", onOff: "onOff", codeMapping: "codeMapping" }, decls: 4, vars: 6, consts: [[1, "text-center", "wide-slider-container-2"], [3, "ngModel", "change"], ["class", "text-center mt-1", 4, "ngIf"], [2, "width", "100%", "height", "500px", 3, "ngClass", "id"], [1, "text-center", "mt-1"], ["aria-label", "units", "max", "5", "min", "1", "thumbLabel", "", 3, "ngModel", "displayWith", "change", "ngModelChange"]], template: function AmChartComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "mat-slide-toggle", 1);
        core/* ɵɵlistener */.NdJ("change", function AmChartComponent_Template_mat_slide_toggle_change_1_listener($event) { return ctx.onOffChart($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(2, AmChartComponent_div_2_Template, 4, 2, "div", 2);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(3, "div", 3);
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.onOff);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.onOff);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngClass", core/* ɵɵpureFunction1 */.VKq(4, am_chart_component_c0, !ctx.onOff))("id", ctx.chartDivId);
    } }, directives: [slide_toggle/* MatSlideToggle */.Rr, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, common/* NgIf */.O5, common/* NgClass */.mk, MatSlider], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/database/seasons/seasons.component.ts
























function SeasonsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function SeasonsComponent_div_20_ng_template_6_tr_16_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 32);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 33);
    core/* ɵɵelementStart */.TgZ(4, "a", 34);
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td", 35);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td", 35);
    core/* ɵɵtext */._uU(10);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "td", 36);
    core/* ɵɵelementStart */.TgZ(12, "a", 34);
    core/* ɵɵelementStart */.TgZ(13, "div");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "td");
    core/* ɵɵtext */._uU(16);
    core/* ɵɵpipe */.ALo(17, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r14 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate1 */.MGl("href", "#/database/drivers?driver=", standing_r14.id, "", core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r14.name, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.code);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r14.nationality);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate1 */.MGl("href", "#/database/constructors?constructor=", standing_r14.ergastCode, "", core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r14.car, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(17, 8, standing_r14.points));
} }
function SeasonsComponent_div_20_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 28);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 29);
    core/* ɵɵelement */._UZ(4, "th", 30);
    core/* ɵɵelementStart */.TgZ(5, "th", 30);
    core/* ɵɵtext */._uU(6, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 31);
    core/* ɵɵtext */._uU(8, "Code");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "th", 31);
    core/* ɵɵtext */._uU(10, "Nationality");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th", 31);
    core/* ɵɵtext */._uU(12, "Car");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 30);
    core/* ɵɵtext */._uU(14, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "tbody");
    core/* ɵɵtemplate */.YNc(16, SeasonsComponent_div_20_ng_template_6_tr_16_Template, 18, 10, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(16);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r7.standings.driverStandings);
} }
function SeasonsComponent_div_20_ng_template_8_div_0_tr_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "th", 32);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 33);
    core/* ɵɵelementStart */.TgZ(4, "a", 38);
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "td");
    core/* ɵɵtext */._uU(8);
    core/* ɵɵpipe */.ALo(9, "number");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const standing_r18 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(standing_r18.position);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", standing_r18.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", standing_r18.name, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind1 */.lcZ(9, 4, standing_r18.points));
} }
function SeasonsComponent_div_20_ng_template_8_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 28);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 29);
    core/* ɵɵelement */._UZ(4, "th", 30);
    core/* ɵɵelementStart */.TgZ(5, "th", 30);
    core/* ɵɵtext */._uU(6, "Name");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "th", 30);
    core/* ɵɵtext */._uU(8, "Points");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "tbody");
    core/* ɵɵtemplate */.YNc(10, SeasonsComponent_div_20_ng_template_8_div_0_tr_10_Template, 10, 6, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r16 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(10);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r16.standings.constructorStandings);
} }
function SeasonsComponent_div_20_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SeasonsComponent_div_20_ng_template_8_div_0_Template, 11, 1, "div", 37);
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.standings !== undefined);
} }
function SeasonsComponent_div_20_ng_template_10_div_0_tr_17_Template(rf, ctx) { if (rf & 1) {
    const _r25 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 43);
    core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_div_20_ng_template_10_div_0_tr_17_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r25); const race_r22 = restoredCtx.$implicit; const ctx_r24 = core/* ɵɵnextContext */.oxw(4); return ctx_r24.openRace(ctx_r24.selectedSeason, race_r22.round); });
    core/* ɵɵelementStart */.TgZ(1, "th", 44);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵelementStart */.TgZ(4, "div");
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "td", 45);
    core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_div_20_ng_template_10_div_0_tr_17_Template_td_click_6_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r25); const race_r22 = restoredCtx.$implicit; const ctx_r26 = core/* ɵɵnextContext */.oxw(4); return ctx_r26.openRace(ctx_r26.selectedSeason, race_r22.round); });
    core/* ɵɵtext */._uU(7);
    core/* ɵɵpipe */.ALo(8, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "td", 33);
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵtext */._uU(11);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "td", 46);
    core/* ɵɵtext */._uU(13);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "td", 47);
    core/* ɵɵelementStart */.TgZ(15, "a", 48);
    core/* ɵɵelement */._UZ(16, "img", 49);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const race_r22 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r22.round);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", race_r22.raceName, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(8, 6, race_r22.date, "MMMM d yyyy"));
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵtextInterpolate1 */.hij(" ", race_r22.circuitName, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(race_r22.driver.givenName + " " + race_r22.driver.familyName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("href", race_r22.url, core/* ɵɵsanitizeUrl */.LSH);
} }
function SeasonsComponent_div_20_ng_template_10_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 28);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 29);
    core/* ɵɵelementStart */.TgZ(4, "th", 39);
    core/* ɵɵtext */._uU(5, "#");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "th", 30);
    core/* ɵɵtext */._uU(7, "Race");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "th", 40);
    core/* ɵɵtext */._uU(9, "Date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "th", 30);
    core/* ɵɵtext */._uU(11, "Circuit");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(12, "th", 30);
    core/* ɵɵtext */._uU(13, "Winner");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(14, "th", 41);
    core/* ɵɵtext */._uU(15, "Wiki");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "tbody");
    core/* ɵɵtemplate */.YNc(17, SeasonsComponent_div_20_ng_template_10_div_0_tr_17_Template, 17, 9, "tr", 42);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r20 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(17);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r20.standings.races);
} }
function SeasonsComponent_div_20_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SeasonsComponent_div_20_ng_template_10_div_0_Template, 18, 1, "div", 37);
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r9.standings !== undefined);
} }
function SeasonsComponent_div_20_ng_template_12_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r29 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 51);
    core/* ɵɵelement */._UZ(1, "apx-chart", 52);
    core/* ɵɵelementStart */.TgZ(2, "div", 53);
    core/* ɵɵelement */._UZ(3, "apx-chart", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 55);
    core/* ɵɵelementStart */.TgZ(5, "span");
    core/* ɵɵtext */._uU(6, "Exclude DNF results ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-slide-toggle", 56);
    core/* ɵɵlistener */.NdJ("change", function SeasonsComponent_div_20_ng_template_12_div_0_Template_mat_slide_toggle_change_7_listener($event) { core/* ɵɵrestoreView */.CHM(_r29); const ctx_r28 = core/* ɵɵnextContext */.oxw(3); return ctx_r28.includeDnf($event); })("ngModelChange", function SeasonsComponent_div_20_ng_template_12_div_0_Template_mat_slide_toggle_ngModelChange_7_listener($event) { core/* ɵɵrestoreView */.CHM(_r29); const ctx_r30 = core/* ɵɵnextContext */.oxw(3); return ctx_r30.showDnf = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "span");
    core/* ɵɵtext */._uU(9, " Include DNF results");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "apx-chart", 57);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r27 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("chart", ctx_r27.lineChart)("series", ctx_r27.driverPointsSeries)("stroke", ctx_r27.defStroke)("title", ctx_r27.titleStandings)("tooltip", ctx_r27.defTooltip)("yaxis", ctx_r27.defYaxis);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("chart", ctx_r27.driversHeatMapChartOptions.chart)("colors", ctx_r27.driversHeatMapChartOptions.colors)("dataLabels", ctx_r27.driversHeatMapChartOptions.dataLabels)("plotOptions", ctx_r27.driversHeatMapChartOptions.plotOptions)("series", ctx_r27.driversHeatMapChartOptions.series)("title", ctx_r27.titleByRound)("tooltip", ctx_r27.driversHeatMapChartOptions.tooltip);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r27.showDnf);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r27.scatterChart)("series", ctx_r27.gridToResultSeries)("stroke", ctx_r27.defStroke)("title", ctx_r27.titleResultToGrid)("tooltip", ctx_r27.resultToGridTooltip)("xaxis", ctx_r27.xaxis19)("yaxis", ctx_r27.yAxis19);
} }
function SeasonsComponent_div_20_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SeasonsComponent_div_20_ng_template_12_div_0_Template, 11, 21, "div", 50);
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r10.standings != undefined);
} }
function SeasonsComponent_div_20_ng_template_14_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 51);
    core/* ɵɵelement */._UZ(1, "apx-chart", 52);
    core/* ɵɵelementStart */.TgZ(2, "div", 53);
    core/* ɵɵelement */._UZ(3, "apx-chart", 54);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r31 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("chart", ctx_r31.lineChart)("series", ctx_r31.constructorPointsSeries)("stroke", ctx_r31.defStroke)("title", ctx_r31.titleStandings)("tooltip", ctx_r31.defTooltip)("yaxis", ctx_r31.defYaxis);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("chart", ctx_r31.constructorHeatMapChartOptions.chart)("colors", ctx_r31.constructorHeatMapChartOptions.colors)("dataLabels", ctx_r31.constructorHeatMapChartOptions.dataLabels)("plotOptions", ctx_r31.constructorHeatMapChartOptions.plotOptions)("series", ctx_r31.constructorHeatMapChartOptions.series)("title", ctx_r31.titleByRound)("tooltip", ctx_r31.constructorHeatMapChartOptions.tooltip);
} }
function SeasonsComponent_div_20_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SeasonsComponent_div_20_ng_template_14_div_0_Template, 4, 13, "div", 50);
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r11.standings.constructorStandingByRound != undefined);
} }
function SeasonsComponent_div_20_ng_template_16_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelement */._UZ(1, "app-amchart-cmp", 58);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r32 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("series", ctx_r32.driverPointsSeries)("codeMapping", ctx_r32.codeToNameMap);
} }
function SeasonsComponent_div_20_ng_template_16_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelement */._UZ(1, "app-amchart-cmp", 59);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r33 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("series", ctx_r33.constructorPointsSeries)("onOff", false);
} }
function SeasonsComponent_div_20_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, SeasonsComponent_div_20_ng_template_16_div_0_Template, 2, 2, "div", 37);
    core/* ɵɵelement */._UZ(1, "hr");
    core/* ɵɵtemplate */.YNc(2, SeasonsComponent_div_20_ng_template_16_div_2_Template, 2, 2, "div", 37);
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r12.standings != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r12.standings != null && ctx_r12.standings.constructorStandings.length > 0);
} }
function SeasonsComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r35 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 17);
    core/* ɵɵlistener */.NdJ("touchend", function SeasonsComponent_div_20_Template_div_touchend_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r34 = core/* ɵɵnextContext */.oxw(); return ctx_r34.touchend($event); })("touchstart", function SeasonsComponent_div_20_Template_div_touchstart_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r36 = core/* ɵɵnextContext */.oxw(); return ctx_r36.touchstart($event); });
    core/* ɵɵelementStart */.TgZ(1, "div", 18);
    core/* ɵɵelement */._UZ(2, "br");
    core/* ɵɵelementStart */.TgZ(3, "mat-slider", 19);
    core/* ɵɵlistener */.NdJ("change", function SeasonsComponent_div_20_Template_mat_slider_change_3_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r37 = core/* ɵɵnextContext */.oxw(); return ctx_r37.onSliderChange($event.value); })("ngModelChange", function SeasonsComponent_div_20_Template_mat_slider_ngModelChange_3_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r38 = core/* ɵɵnextContext */.oxw(); return ctx_r38.selectedSeason = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-tab-group", 20);
    core/* ɵɵlistener */.NdJ("selectedTabChange", function SeasonsComponent_div_20_Template_mat_tab_group_selectedTabChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r39 = core/* ɵɵnextContext */.oxw(); return ctx_r39.tabChanged($event); })("selectedIndexChange", function SeasonsComponent_div_20_Template_mat_tab_group_selectedIndexChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r35); const ctx_r40 = core/* ɵɵnextContext */.oxw(); return ctx_r40.selectedTab = $event; });
    core/* ɵɵelementStart */.TgZ(5, "mat-tab", 21);
    core/* ɵɵtemplate */.YNc(6, SeasonsComponent_div_20_ng_template_6_Template, 17, 1, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "mat-tab", 23);
    core/* ɵɵtemplate */.YNc(8, SeasonsComponent_div_20_ng_template_8_Template, 1, 1, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(9, "mat-tab", 24);
    core/* ɵɵtemplate */.YNc(10, SeasonsComponent_div_20_ng_template_10_Template, 1, 1, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "mat-tab", 25);
    core/* ɵɵtemplate */.YNc(12, SeasonsComponent_div_20_ng_template_12_Template, 1, 1, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "mat-tab", 26);
    core/* ɵɵtemplate */.YNc(14, SeasonsComponent_div_20_ng_template_14_Template, 1, 1, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "mat-tab", 27);
    core/* ɵɵtemplate */.YNc(16, SeasonsComponent_div_20_ng_template_16_Template, 3, 2, "ng-template", 22);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r2.selectedSeason)("displayWith", ctx_r2.formatLabel)("max", ctx_r2.maxSeason);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r2.selectedTab);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r2.standings.constructorStandings.length == 0);
    core/* ɵɵadvance */.xp6(6);
    core/* ɵɵproperty */.Q6J("disabled", ctx_r2.standings.constructorStandings.length == 0);
} }
class SeasonsComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.driverPointsSeries = [];
        this.gridToResultSeries = [];
        this.driverPointsByRoundSeries = [];
        this.constructorPointsSeries = [];
        this.constructorRoundsSeries = [];
        this.podiums = SeasonsComponent.initializeMultidimensionalArray();
        this.raceCount = 0;
        this.selectedTab = 0;
        this.selectedSeason = 2022;
        this.maxSeason = 2022;
        this.driversHeatMapStandingsSeries = [];
        this.constructorsHeatMapStandingsSeries = [];
        this.driverPositionMap = new Map();
        this.driverPositionByRaceMap = new Map();
        this.constructorPositionMap = new Map();
        this.chartSeriesList = [];
        this.chartWidth = '100%';
        this.codeToNameMap = new Map();
        this.lineChart = {
            animations: {
                enabled: true,
                speed: 1000,
                animateGradually: {
                    enabled: false
                },
            },
            height: 500,
            type: 'line',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.lineChartWithoutAnimation = {
            height: 500,
            type: 'line',
            zoom: {
                enabled: false
            },
            animations: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.scatterChart = {
            height: 500,
            type: 'scatter',
            zoom: {
                enabled: false
            },
            toolbar: ChartUtility.defaultToolbar
        };
        this.xaxis19 = {
            type: 'numeric',
            //tickAmount: 18,
            min: 1,
            // max:19,
            decimalsInFloat: 0,
            title: {
                text: 'Average grid position',
            }
        };
        this.defYaxis = {
            decimalsInFloat: 0
        };
        this.yAxis19 = {
            // tickAmount: 18,
            min: 1,
            // max:19,
            decimalsInFloat: 0,
            reversed: true,
            title: {
                text: 'Average result',
            }
        };
        this.titleStandings = {
            text: 'Points through season',
            align: 'center'
        };
        this.titleResultsHeatmap = {
            text: 'Results by race',
            align: 'center'
        };
        this.titleResultToGrid = {
            text: 'Average result and grid position',
            align: 'center'
        };
        this.titleByRound = {
            text: 'Points by race',
            align: 'center'
        };
        this.defStroke = {
            width: 3
        };
        this.defTooltip = {
            shared: false,
        };
        this.resultToGridTooltip = {
            // this.standings.races[opts.dataPointIndex].raceName;
            y: {
                formatter: (val, opts) => 'Average race result: ' + val,
                title: {
                    formatter: (seriesName) => seriesName,
                },
            },
            x: {
                formatter: (val, opts) => 'Average grid position: ' + val,
            }
        };
        this.showDnf = false;
        this.selectedTab = this.getSelectedTab();
        this.selectedSeason = this.getSelectedSeason();
        this.initializeChampionshipData(this.selectedSeason);
        this.utilityService.setTitle(71, 'Seasons');
        this.maxSeason = environment/* environment.currentSeason */.N.currentSeason - 1;
    }
    static initializeMultidimensionalArray() {
        let podiums = [];
        for (let i = 0; i < 30; i++) {
            podiums[i] = [];
        }
        return podiums;
    }
    setHeatMapAxis() {
        this.yAxis19 = {
            tickAmount: this.driverCount - 1,
            min: 1,
            max: this.driverCount,
            decimalsInFloat: 0,
            reversed: true,
            title: {
                text: 'Average result',
            }
        };
        this.xaxis19 = {
            type: 'numeric',
            tickAmount: this.driverCount - 1,
            min: 1,
            max: this.driverCount,
            decimalsInFloat: 0,
            title: {
                text: 'Average grid position',
            }
        };
    }
    formatLabel(value) {
        return value;
    }
    touchstart(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        this.swipeCoord = coord;
        this.swipeTime = time;
    }
    touchend(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
        const duration = time - this.swipeTime;
        // console.log('clientYb: ' + coord[1] + ' - ' + this.swipeCoord[1]);
        // if (duration < 1000
        //   && Math.abs(direction[0]) > 30 // Long enough
        //   && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
        //   const swipe = direction[0] < 0 ? 'next' : 'previous';
        //   if(swipe === 'next'){
        //     const isFirst = this.selectedTab === 0;
        //     if(this.selectedTab <= 3){
        //       this.selectedTab = isFirst ? 1 : this.selectedTab + 1;
        //     }
        //   } else if(swipe === 'previous'){
        //     const isLast = this.selectedTab === 4;
        //     if(this.selectedTab >= 1){
        //       this.selectedTab = this.selectedTab - 1;
        //     }
        //   }
        // }
    }
    includeDnf(event) {
        this.gridToResultSeries = [];
        if (event.checked) {
            this.standings.gridToResultChartWithDnf.forEach((standing) => {
                this.gridToResultSeries.push({
                    name: standing.name,
                    data: standing.series
                    //  color: standing.color
                });
            });
        }
        else {
            this.standings.gridToResultChartWithoutDnf.forEach((standing) => {
                this.gridToResultSeries.push({
                    name: standing.name,
                    data: standing.series
                    // color: standing.color
                });
            });
        }
    }
    tabChanged(tabChangeEvent) {
        this.updateUrl();
    }
    updateUrl() {
        const queryParams = { season: this.selectedSeason, tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive
    }
    onSliderChange(value) {
        this.initializeChampionshipData(value);
        this.updateUrl();
    }
    setPodiums(standing) {
        standing.series.forEach(item => {
            if (item[1] < 4) {
                let podium = new Podium();
                podium.name = standing.name;
                // podium.color = standing.color;
                podium.value = item[1];
                this.podiums[item[0]][item[1]] = podium;
                if (item[0] > this.raceCount) {
                    this.raceCount = item[0];
                }
            }
        });
        // this.reverseXaxis.tickAmount = this.raceCount;
    }
    setDriversHeatMapChart() {
        this.driversHeatMapChartOptions = {
            colors: ['#0000ff'],
            series: this.driversHeatMapStandingsSeries,
            chart: {
                height: 600,
                width: this.chartWidth,
                type: 'heatmap',
                animations: {
                    enabled: false
                },
                zoom: {
                    enabled: false,
                },
                toolbar: ChartUtility.defaultToolbar
            },
            title: ChartUtility.f1exposureTitle,
            dataLabels: {
                enabled: true,
                style: {
                    colors: ['#000000']
                },
                formatter: (val, opts) => {
                    if (val == null) {
                        return '';
                    }
                    return val;
                    // if(val==0){
                    //   return 'DNF';
                    // }
                    //return this.standings.driverResultByRound[opts.seriesIndex].name;
                }
            },
            plotOptions: {
                heatmap: {
                    radius: 2,
                    enableShades: true,
                    distributed: false,
                    useFillColorAsStroke: true,
                    reverseNegativeShade: true
                }
            },
            tooltip: {
                y: {
                    formatter: (val, opts) => {
                        return this.standings.races[opts.dataPointIndex].raceName;
                    }
                }
            }
        };
    }
    setConstructorHeatMapChart() {
        this.constructorHeatMapChartOptions = {
            colors: ['#0000ff'],
            series: this.constructorsHeatMapStandingsSeries,
            chart: {
                height: 600,
                width: this.chartWidth,
                type: 'heatmap',
                animations: {
                    enabled: false
                },
                zoom: {
                    enabled: false,
                },
                toolbar: ChartUtility.defaultToolbar
            },
            title: ChartUtility.f1exposureTitle,
            dataLabels: {
                enabled: true,
                style: {
                    colors: ['#000000']
                }
            },
            plotOptions: {
                heatmap: {
                    radius: 2,
                    enableShades: true,
                    distributed: false,
                    useFillColorAsStroke: true,
                    reverseNegativeShade: false
                }
            },
            tooltip: {
                y: {
                    formatter: (val, opts) => {
                        return this.standings.races[opts.dataPointIndex].raceName;
                    }
                }
            }
        };
    }
    mapPositionsAndCodes() {
        this.driverPositionMap = new Map();
        for (let standing of this.standings.driverStandings) {
            this.driverPositionMap.set(standing.code, standing.position);
            this.codeToNameMap.set(standing.code, standing.name);
        }
        this.constructorPositionMap = new Map();
        for (let standing of this.standings.constructorStandings) {
            this.constructorPositionMap.set(standing.name, standing.position);
        }
        this.driverCount = this.driverPositionMap.size;
        this.setHeatMapAxis();
        this.constructorCount = this.standings.constructorStandings.length;
    }
    getSelectedTab() {
        let tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == undefined) {
            return 0;
        }
        else {
            return Number(tab) - 1;
        }
    }
    getSelectedSeason() {
        let season = this.route.snapshot.queryParamMap.get('season');
        if (season == undefined) {
            return this.getRandomIntInclusive(1950, 2021);
        }
        else {
            return Number(season);
        }
    }
    initializeChampionshipData(season) {
        this.restService.getHistoricSeason(season).subscribe({
            next: data => {
                this.standings = data;
                this.mapPositionsAndCodes();
                this.driverPointsSeries = [];
                this.standings.driverStandingByRound.forEach((standing) => {
                    this.driverPointsSeries.push({
                        name: standing.name,
                        data: standing.series
                    });
                });
                this.podiums = SeasonsComponent.initializeMultidimensionalArray();
                this.driverPositionByRaceMap = new Map();
                this.driversHeatMapStandingsSeries = [];
                this.standings.driverPointsByRound.forEach((standing) => {
                    this.setPodiums(standing);
                    // let copy = JSON.parse(JSON.stringify(standing.series));
                    let copy = standing.series;
                    if (copy.length < this.raceCount) {
                        //popuni null utrke
                        let array = [];
                        copy.forEach((serie) => {
                            array.push(serie[0]);
                        });
                        for (let i = 1; i <= this.raceCount; i++) {
                            if (array.indexOf(i) < 0) {
                                copy.push([i, null]);
                            }
                        }
                        //sortiraj
                        copy.sort(function (a, b) {
                            if (a[0] < b[0]) {
                                return -1;
                            }
                            if (a[0] > b[0]) {
                                return 1;
                            }
                            return 0;
                        });
                    }
                    copy.forEach((serie) => {
                        if (serie[1] != null) {
                            this.driverPositionByRaceMap.set(standing.name + serie[0], serie[1]);
                        }
                    });
                    if (this.driverPositionMap.get(standing.name) == undefined) {
                    }
                    else {
                        let position = this.driverCount - this.driverPositionMap.get(standing.name);
                        this.driversHeatMapStandingsSeries[position] = {
                            name: standing.name,
                            data: copy
                        };
                    }
                });
                this.chartWidth = this.calculateChartWidthForMobileDevices(this.raceCount);
                this.gridToResultSeries = [];
                this.standings.gridToResultChartWithoutDnf.forEach((standing) => {
                    this.gridToResultSeries.push({
                        name: standing.name,
                        data: standing.series
                        // color: standing.color
                    });
                });
                this.constructorPointsSeries = [];
                this.constructorsHeatMapStandingsSeries = [];
                this.standings.constructorStandingByRound.forEach((standing) => {
                    this.constructorPointsSeries.push({
                        name: standing.name,
                        data: standing.series
                        //   color: standing.color
                    });
                });
                this.constructorRoundsSeries = [];
                this.standings.constructorPointsByRound.forEach((standing) => {
                    this.constructorRoundsSeries.push({
                        name: standing.name,
                        data: standing.series
                        // color: standing.color
                    });
                    this.constructorsHeatMapStandingsSeries[this.constructorCount - this.constructorPositionMap.get(standing.name)] = {
                        name: standing.name,
                        data: standing.series,
                    };
                });
                this.setDriversHeatMapChart();
                this.setConstructorHeatMapChart();
                this.utilityService.setTitle(71, season + ' Championship');
                return data;
            }
        });
    }
    openRace(season, round) {
        this.restService.getRace(season, round).subscribe({
            next: data => {
                const dialogRef = this.dialog.open(RacePopupComponent, {
                    maxWidth: '90vw'
                });
                dialogRef.componentInstance.race = data;
            }
        });
    }
    calculateChartWidthForMobileDevices(raceCount) {
        let width = window.screen.width;
        if (width > 1299 || raceCount < 15) {
            return '100%';
        }
        let newWidth = raceCount * 30 + 'px';
        // this.lineChartWithResponsiveWidth.width = newWidth;
        //  this.lineChartWithoutAnimation.width = newWidth;
        return newWidth;
    }
}
SeasonsComponent.ɵfac = function SeasonsComponent_Factory(t) { return new (t || SeasonsComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
SeasonsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SeasonsComponent, selectors: [["app-seasons-cmp"]], viewQuery: function SeasonsComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(table/* MatTable */.BZ, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.driverTable = _t.first);
    } }, decls: 21, vars: 4, consts: [["autosize", ""], ["autosize", "", "mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "\u201Dmat-content\u201D", 3, "touchend", "touchstart", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "\u201Dmat-content\u201D", 3, "touchend", "touchstart"], [1, "text-center", "wide-slider-container"], ["aria-label", "units", "min", "1950", "thumbLabel", "", 3, "ngModel", "displayWith", "max", "change", "ngModelChange"], [3, "selectedIndex", "selectedTabChange", "selectedIndexChange"], ["label", "Drivers"], ["matTabContent", ""], ["label", "Constructors", 3, "disabled"], ["label", "Races"], ["label", "Driver charts"], ["label", "Constructor charts", 3, "disabled"], ["label", "Timelapse"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["scope", "col"], ["scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["scope", "row"], [1, "hover-effects-row"], [2, "color", "black", 3, "href"], [1, "d-sm-none", "d-none", "d-lg-table-cell", "text-center"], [1, "d-sm-none", "d-none", "d-lg-table-cell", "hover-effects-row"], [4, "ngIf"], ["target", "_blank", 2, "color", "black", 3, "href"], ["scope", "col", 1, "width-10", "text-left"], ["scope", "col", 1, "text-center"], ["scope", "col", 1, "width-60", "d-lg-table-cell"], ["class", "hover-effects-row", 3, "click", 4, "ngFor", "ngForOf"], [1, "hover-effects-row", 3, "click"], ["scope", "width-10 row"], [1, "hover-effects-row", "text-right", 3, "click"], [1, "text-center"], [1, "d-lg-table-cell", "text-center"], ["target", "_blank", 1, "postLinks", 3, "href"], ["src", "../../../../assets/img/Wikipedia-icon.png"], ["class", "div-padded-2rem", 4, "ngIf"], [1, "div-padded-2rem"], [3, "chart", "series", "stroke", "title", "tooltip", "yaxis"], [1, "overflowX"], [3, "chart", "colors", "dataLabels", "plotOptions", "series", "title", "tooltip"], [1, "div-padded-always-top-right-2rem"], [3, "ngModel", "change", "ngModelChange"], [3, "chart", "series", "stroke", "title", "tooltip", "xaxis", "yaxis"], [3, "series", "codeMapping"], [3, "series", "onOff"]], template: function SeasonsComponent_Template(rf, ctx) { if (rf & 1) {
        const _r41 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function SeasonsComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function SeasonsComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(10); });
        core/* ɵɵtext */._uU(10, "Post");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(10); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, SeasonsComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r41); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function SeasonsComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r41); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, SeasonsComponent_div_20_Template, 17, 6, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.standings !== undefined);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, MatSlider, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, ng_apexcharts/* ChartComponent */.x, slide_toggle/* MatSlideToggle */.Rr, AmChartComponent], pipes: [common/* DecimalPipe */.JJ, common/* DatePipe */.uU], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/database/database.component.ts








function DatabaseComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r4 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 19);
    core/* ɵɵelementStart */.TgZ(2, "div", 20);
    core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r4); const comment_r2 = restoredCtx.$implicit; const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3.utilityService.replyingTo(comment_r2.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 21);
    core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r4); const comment_r2 = restoredCtx.$implicit; const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.utilityService.replyingTo(comment_r2.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 22);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r2.comment);
} }
class DatabaseComponent {
    constructor(utilityService) {
        this.utilityService = utilityService;
        this.utilityService.setTitleDefaultPage(7, 'F1Exposure');
    }
}
DatabaseComponent.ɵfac = function DatabaseComponent_Factory(t) { return new (t || DatabaseComponent)(core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t)); };
DatabaseComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: DatabaseComponent, selectors: [["app-database-cmp"]], decls: 39, vars: 7, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [1, "bg-white", "height-fill-screen"], [1, "event-result"], [1, "div-padded-always-0-5rem", "result-card", "position-left"], [3, "href"], ["mat-raised-button", "", 1, "countdown-desc-2", "height-fill-screen-50", "pink-color-button", "width-100"], [1, "div-padded-always-0-5rem", "result-card", "position-right"], ["mat-raised-button", "", 1, "countdown-desc-2", "height-fill-screen-50", "active-color-button", "width-100"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"]], template: function DatabaseComponent_Template(rf, ctx) { if (rf & 1) {
        const _r6 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function DatabaseComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function DatabaseComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(11); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(11); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, DatabaseComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r6); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function DatabaseComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r6); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(20, "div", 12);
        core/* ɵɵelementStart */.TgZ(21, "div", 13);
        core/* ɵɵelementStart */.TgZ(22, "div", 14);
        core/* ɵɵelementStart */.TgZ(23, "a", 15);
        core/* ɵɵelementStart */.TgZ(24, "button", 16);
        core/* ɵɵtext */._uU(25, "Seasons ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(26, "div", 17);
        core/* ɵɵelementStart */.TgZ(27, "a", 15);
        core/* ɵɵelementStart */.TgZ(28, "button", 18);
        core/* ɵɵtext */._uU(29, "Drivers");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(30, "div", 13);
        core/* ɵɵelementStart */.TgZ(31, "div", 14);
        core/* ɵɵelementStart */.TgZ(32, "a", 15);
        core/* ɵɵelementStart */.TgZ(33, "button", 18);
        core/* ɵɵtext */._uU(34, "Constructors ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(35, "div", 17);
        core/* ɵɵelementStart */.TgZ(36, "a", 15);
        core/* ɵɵelementStart */.TgZ(37, "button", 16);
        core/* ɵɵtext */._uU(38, "Circuits ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(10);
        core/* ɵɵproperty */.Q6J("href", "#/database/seasons", core/* ɵɵsanitizeUrl */.LSH);
        core/* ɵɵadvance */.xp6(4);
        core/* ɵɵproperty */.Q6J("href", "#/database/drivers", core/* ɵɵsanitizeUrl */.LSH);
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("href", "#/database/constructors", core/* ɵɵsanitizeUrl */.LSH);
        core/* ɵɵadvance */.xp6(4);
        core/* ɵɵproperty */.Q6J("href", "#/database/circuit", core/* ɵɵsanitizeUrl */.LSH);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/model/driverComparator.ts
class DriverCompared {
}
class DriverComparator {
    constructor() {
        this.driver1 = new DriverCompared();
        this.driver2 = new DriverCompared();
    }
}

;// CONCATENATED MODULE: ./src/app/pages/database/drivers/drivers-comparator.component.ts














const drivers_comparator_component_c0 = ["chart"];
function DriversComparatorComponent_div_2_mat_option_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 12);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const option_r4 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", option_r4.driverId);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", option_r4.driverName, " ");
} }
function DriversComparatorComponent_div_2_mat_option_15_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-option", 12);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const option_r5 = ctx.$implicit;
    core/* ɵɵproperty */.Q6J("value", option_r5.driverId);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", option_r5.driverName, " ");
} }
function DriversComparatorComponent_div_2_tr_17_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td", 13);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(3, "td");
    core/* ɵɵelementStart */.TgZ(4, "td", 13);
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r3.displayComparator.driver1.teamName);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r3.displayComparator.driver2.teamName);
} }
function DriversComparatorComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 1);
    core/* ɵɵelementStart */.TgZ(2, "input", 2);
    core/* ɵɵlistener */.NdJ("change", function DriversComparatorComponent_div_2_Template_input_change_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.onYearChangeText($event); })("ngModelChange", function DriversComparatorComponent_div_2_Template_input_ngModelChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r8 = core/* ɵɵnextContext */.oxw(); return ctx_r8.requestComparator.year = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "div", 3);
    core/* ɵɵelementStart */.TgZ(4, "mat-slider", 4);
    core/* ɵɵlistener */.NdJ("change", function DriversComparatorComponent_div_2_Template_mat_slider_change_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r9 = core/* ɵɵnextContext */.oxw(); return ctx_r9.onYearChange($event.value); })("ngModelChange", function DriversComparatorComponent_div_2_Template_mat_slider_ngModelChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r10 = core/* ɵɵnextContext */.oxw(); return ctx_r10.requestComparator.year = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "table", 5);
    core/* ɵɵelementStart */.TgZ(6, "thead");
    core/* ɵɵelementStart */.TgZ(7, "tr", 6);
    core/* ɵɵelementStart */.TgZ(8, "th", 7);
    core/* ɵɵelementStart */.TgZ(9, "mat-select", 8);
    core/* ɵɵlistener */.NdJ("selectionChange", function DriversComparatorComponent_div_2_Template_mat_select_selectionChange_9_listener() { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r11 = core/* ɵɵnextContext */.oxw(); return ctx_r11.getComparison(); })("ngModelChange", function DriversComparatorComponent_div_2_Template_mat_select_ngModelChange_9_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r12 = core/* ɵɵnextContext */.oxw(); return ctx_r12.requestComparator.driver1.driverId = $event; });
    core/* ɵɵtemplate */.YNc(10, DriversComparatorComponent_div_2_mat_option_10_Template, 2, 2, "mat-option", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "th");
    core/* ɵɵtext */._uU(12, "vs");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(13, "th", 7);
    core/* ɵɵelementStart */.TgZ(14, "mat-select", 8);
    core/* ɵɵlistener */.NdJ("selectionChange", function DriversComparatorComponent_div_2_Template_mat_select_selectionChange_14_listener() { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r13 = core/* ɵɵnextContext */.oxw(); return ctx_r13.getComparison(); })("ngModelChange", function DriversComparatorComponent_div_2_Template_mat_select_ngModelChange_14_listener($event) { core/* ɵɵrestoreView */.CHM(_r7); const ctx_r14 = core/* ɵɵnextContext */.oxw(); return ctx_r14.requestComparator.driver2.driverId = $event; });
    core/* ɵɵtemplate */.YNc(15, DriversComparatorComponent_div_2_mat_option_15_Template, 2, 2, "mat-option", 9);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(16, "tbody");
    core/* ɵɵtemplate */.YNc(17, DriversComparatorComponent_div_2_tr_17_Template, 6, 2, "tr", 0);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(18, "div", 10);
    core/* ɵɵelement */._UZ(19, "apx-chart", 11);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.requestComparator.year);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.requestComparator.year)("max", ctx_r0.displayComparator.maxYear);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.requestComparator.driver1.driverId);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.dropdownItems);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.requestComparator.driver2.driverId);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.dropdownItems);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r0.displayComparator.driver1 != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("series", ctx_r0.dynamicChartOptions.series)("chart", ctx_r0.staticChartOptions.chart)("dataLabels", ctx_r0.dynamicChartOptions.dataLabels)("plotOptions", ctx_r0.staticChartOptions.plotOptions)("responsive", ctx_r0.staticChartOptions.responsive)("xaxis", ctx_r0.staticChartOptions.xaxis)("yaxis", ctx_r0.staticChartOptions.yaxis)("legend", ctx_r0.staticChartOptions.legend)("fill", ctx_r0.staticChartOptions.fill)("tooltip", ctx_r0.staticChartOptions.tooltip);
} }
class DriversComparatorComponent {
    constructor(restService) {
        this.restService = restService;
        this.staticChartOptions = {
            series: [
                {
                    name: 'DRIVER 1',
                    data: [44, 5, 41, 67, 22, 43]
                },
                {
                    name: 'DRIVER 2',
                    data: [44, 2, 20, 8, 13, 27]
                }
            ],
            chart: {
                type: 'bar',
                height: 350,
                stacked: true,
                stackType: '100%',
                animations: {
                    enabled: false
                },
            },
            yaxis: {
                show: true
            },
            responsive: [
                {
                    breakpoint: 480,
                    options: {
                        legend: {
                            position: 'bottom',
                            offsetX: -10,
                            offsetY: 0
                        }
                    }
                }
            ],
            xaxis: {
                labels: {
                    show: false
                },
                categories: [
                    'Race',
                    'Qualifying',
                    'Points',
                    'Highest finish',
                    'Highest grid',
                    'DNF'
                ]
            },
            fill: {
                opacity: 1
            },
            legend: {
                show: false,
            },
            tooltip: {
                enabled: false
            },
            plotOptions: {
                bar: {
                    horizontal: true
                }
            },
        };
    }
    initComparison(season, driverId) {
        this.requestComparator = new DriverComparator();
        this.requestComparator.year = season;
        this.requestComparator.driver1.driverId = driverId;
        this.getCompareDriversDropdown();
    }
    callCompare() {
        this.restService.compareDrivers(this.requestComparator).subscribe({
            next: data => {
                this.displayComparator = data;
                this.updateChart();
            }
        });
    }
    getCompareDriversDropdown() {
        this.restService.compareDriversDropdown(this.requestComparator.year).subscribe({
            next: data => {
                this.dropdownItems = data;
                this.checkCurrentDriversExistInDropdown();
                this.callCompare();
            }
        });
    }
    checkRequestComparator() {
        if (this.requestComparator.maxYear == null) {
            this.requestComparator.maxYear = this.displayComparator.maxYear;
        }
        if (this.requestComparator.year == null) {
            this.requestComparator.year = this.displayComparator.maxYear;
        }
    }
    getComparison() {
        if (this.requestComparator.driver1 != null && this.requestComparator.driver2 != null) {
            this.callCompare();
        }
    }
    onYearChangeText(event) {
        const stringValue = event.target.value.trim().toLowerCase();
        this.onYearChange(Number(stringValue));
    }
    onYearChange(value) {
        this.getCompareDriversDropdown();
    }
    checkCurrentDriversExistInDropdown() {
        let positionCounter = 0;
        let found = this.dropdownItems.filter(item => item.driverId == this.requestComparator.driver1.driverId).length;
        if (found == 0) {
            this.requestComparator.driver1.driverId = this.dropdownItems[positionCounter].driverId;
            positionCounter++;
        }
        found = this.dropdownItems.filter(item => item.driverId == this.requestComparator.driver2.driverId).length;
        if (found == 0) {
            this.requestComparator.driver2.driverId = this.dropdownItems[positionCounter].driverId;
            positionCounter++;
        }
        if (this.requestComparator.driver1.driverId == this.requestComparator.driver2.driverId) {
            this.requestComparator.driver2.driverId = this.dropdownItems[positionCounter].driverId;
        }
    }
    updateChart() {
        let series = [];
        let dataList = [];
        let bestQualiSum = this.displayComparator.driver1.bestQualifying + this.displayComparator.driver2.bestQualifying;
        let bestRaceSum = this.displayComparator.driver1.bestRace + this.displayComparator.driver2.bestRace;
        let data1 = [this.displayComparator.driver1.race, this.displayComparator.driver1.qualifying, this.displayComparator.driver1.points,
            bestRaceSum - this.displayComparator.driver1.bestRace, bestQualiSum - this.displayComparator.driver1.bestQualifying, this.displayComparator.driver1.dnf];
        let data2 = [this.displayComparator.driver2.race, this.displayComparator.driver2.qualifying, this.displayComparator.driver2.points,
            bestRaceSum - this.displayComparator.driver2.bestRace, bestQualiSum - this.displayComparator.driver2.bestQualifying, this.displayComparator.driver2.dnf];
        dataList.push(data1);
        dataList.push(data2);
        series.push({
            name: this.displayComparator.driver1.driverName,
            data: dataList[0]
        });
        series.push({
            name: this.displayComparator.driver2.driverName,
            data: dataList[1]
        });
        this.dynamicChartOptions = {
            series: series,
            dataLabels: {
                enabled: true,
                textAnchor: 'start',
                style: {
                    colors: ['#fff']
                },
                formatter: function (val, opt) {
                    if (opt.dataPointIndex == 3) {
                        return bestRaceSum - dataList[opt.seriesIndex][opt.dataPointIndex] + '';
                    }
                    if (opt.dataPointIndex == 4) {
                        return bestQualiSum - dataList[opt.seriesIndex][opt.dataPointIndex] + '';
                    }
                    else {
                        return dataList[opt.seriesIndex][opt.dataPointIndex] + '';
                    }
                },
                offsetX: 0,
                dropShadow: {
                    enabled: true
                }
            }
        };
    }
}
DriversComparatorComponent.ɵfac = function DriversComparatorComponent_Factory(t) { return new (t || DriversComparatorComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v)); };
DriversComparatorComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: DriversComparatorComponent, selectors: [["app-drivers-comparator-cmp"]], viewQuery: function DriversComparatorComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(drivers_comparator_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 3, vars: 1, consts: [[4, "ngIf"], [1, "div-left-width-50-px"], ["matInput", "", "placeholder", "Year", 1, "width-50-px", 3, "ngModel", "change", "ngModelChange"], [1, "text-center", "wide-slider-container-2"], ["aria-label", "unit(s)", "min", "1950", 3, "ngModel", "max", "change", "ngModelChange"], ["matSort", "", 1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], [1, "min-width-20-vw"], [3, "ngModel", "selectionChange", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], ["id", "chart", 1, "padding-right-4-on-desktop"], [3, "series", "chart", "dataLabels", "plotOptions", "responsive", "xaxis", "yaxis", "legend", "fill", "tooltip"], [3, "value"], [1, "text-center"]], template: function DriversComparatorComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵelementStart */.TgZ(1, "div");
        core/* ɵɵtemplate */.YNc(2, DriversComparatorComponent_div_2_Template, 20, 18, "div", 0);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.displayComparator != null);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, MatSlider, MatSort, MatSelect, common/* NgForOf */.sg, ng_apexcharts/* ChartComponent */.x, fesm2015_core/* MatOption */.ey], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/shared/dialog/single-column-table-dialog.component.ts




function SingleColumnTableDialogComponent_div_1_tr_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const row_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(row_r2);
} }
function SingleColumnTableDialogComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 1);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 2);
    core/* ɵɵelementStart */.TgZ(4, "th");
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tbody");
    core/* ɵɵtemplate */.YNc(7, SingleColumnTableDialogComponent_div_1_tr_7_Template, 3, 1, "tr", 3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.title);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r0.rows);
} }
class SingleColumnTableDialogComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    init(title, rows) {
        this.title = title;
        this.rows = rows;
    }
}
SingleColumnTableDialogComponent.ɵfac = function SingleColumnTableDialogComponent_Factory(t) { return new (t || SingleColumnTableDialogComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
SingleColumnTableDialogComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: SingleColumnTableDialogComponent, selectors: [["app-single-column-table-dialog"]], decls: 2, vars: 1, consts: [[4, "ngIf"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], [4, "ngFor", "ngForOf"]], template: function SingleColumnTableDialogComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵtemplate */.YNc(1, SingleColumnTableDialogComponent_div_1_Template, 8, 2, "div", 0);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.rows !== undefined);
    } }, directives: [MatDialogContent, common/* NgIf */.O5, common/* NgForOf */.sg], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/database/drivers/drivers.component.ts
























const drivers_component_c0 = ["chart"];
function DriversComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function DriversComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function DriversComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function DriversComponent_div_20_img_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 47);
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r7.driver.wikiImage, core/* ɵɵsanitizeUrl */.LSH);
} }
function DriversComponent_div_20_h1_40_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "h1");
    core/* ɵɵelementStart */.TgZ(1, "span", 48);
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r8.driver.currentConstructor.name);
} }
function DriversComponent_div_20_h1_41_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "h1");
    core/* ɵɵelementStart */.TgZ(1, "span", 48);
    core/* ɵɵtext */._uU(2, "N/A");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function DriversComponent_div_20_div_42_tr_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "tr");
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const constructor_r12 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(constructor_r12[0]);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(constructor_r12[2]);
} }
function DriversComponent_div_20_div_42_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "table", 49);
    core/* ɵɵelementStart */.TgZ(2, "thead");
    core/* ɵɵelementStart */.TgZ(3, "tr", 50);
    core/* ɵɵelementStart */.TgZ(4, "th", 51);
    core/* ɵɵtext */._uU(5, "Team history");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "tbody");
    core/* ɵɵtemplate */.YNc(7, DriversComponent_div_20_div_42_tr_7_Template, 5, 2, "tr", 8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r10.driver.constructorHistory);
} }
function DriversComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r14 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "div", 17);
    core/* ɵɵelementStart */.TgZ(3, "div", 18);
    core/* ɵɵelementStart */.TgZ(4, "div", 19);
    core/* ɵɵelementStart */.TgZ(5, "button", 20);
    core/* ɵɵlistener */.NdJ("click", function DriversComponent_div_20_Template_button_click_5_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r13 = core/* ɵɵnextContext */.oxw(); return ctx_r13.openDriversPopup(); });
    core/* ɵɵelementStart */.TgZ(6, "mat-icon");
    core/* ɵɵtext */._uU(7, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementStart */.TgZ(9, "mat-icon");
    core/* ɵɵtext */._uU(10, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 21);
    core/* ɵɵtemplate */.YNc(12, DriversComponent_div_20_img_12_Template, 1, 1, "img", 22);
    core/* ɵɵelementStart */.TgZ(13, "p");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "p");
    core/* ɵɵelementStart */.TgZ(16, "a", 23);
    core/* ɵɵelementStart */.TgZ(17, "button", 24);
    core/* ɵɵtext */._uU(18, "Wikipedia");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "div", 25);
    core/* ɵɵelementStart */.TgZ(20, "button", 20);
    core/* ɵɵlistener */.NdJ("click", function DriversComponent_div_20_Template_button_click_20_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r15 = core/* ɵɵnextContext */.oxw(); return ctx_r15.openComparatorPopup(); });
    core/* ɵɵelementStart */.TgZ(21, "mat-icon");
    core/* ɵɵtext */._uU(22, "keyboard_arrow_down");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(23, " Compare with... ");
    core/* ɵɵelementStart */.TgZ(24, "mat-icon");
    core/* ɵɵtext */._uU(25, "keyboard_arrow_down");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(26, "div", 26);
    core/* ɵɵelementStart */.TgZ(27, "div", 3);
    core/* ɵɵelementStart */.TgZ(28, "div", 27);
    core/* ɵɵelementStart */.TgZ(29, "div", 28);
    core/* ɵɵelementStart */.TgZ(30, "div", 29);
    core/* ɵɵelementStart */.TgZ(31, "span");
    core/* ɵɵtext */._uU(32, "Current team:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(33, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(34, "div", 30);
    core/* ɵɵelementStart */.TgZ(35, "mat-accordion");
    core/* ɵɵelementStart */.TgZ(36, "mat-expansion-panel");
    core/* ɵɵelementStart */.TgZ(37, "mat-expansion-panel-header");
    core/* ɵɵelementStart */.TgZ(38, "mat-panel-title");
    core/* ɵɵelementStart */.TgZ(39, "div", 31);
    core/* ɵɵtemplate */.YNc(40, DriversComponent_div_20_h1_40_Template, 3, 1, "h1", 12);
    core/* ɵɵtemplate */.YNc(41, DriversComponent_div_20_h1_41_Template, 3, 0, "h1", 12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(42, DriversComponent_div_20_div_42_Template, 8, 1, "div", 12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(43, "div", 32);
    core/* ɵɵelementStart */.TgZ(44, "div", 28);
    core/* ɵɵelementStart */.TgZ(45, "div", 29);
    core/* ɵɵelementStart */.TgZ(46, "span");
    core/* ɵɵtext */._uU(47, "WDC:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(48, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(49, "div", 33);
    core/* ɵɵlistener */.NdJ("click", function DriversComponent_div_20_Template_div_click_49_listener() { core/* ɵɵrestoreView */.CHM(_r14); const ctx_r16 = core/* ɵɵnextContext */.oxw(); return ctx_r16.openWdcPopup(); });
    core/* ɵɵelementStart */.TgZ(50, "div", 31);
    core/* ɵɵelementStart */.TgZ(51, "h1");
    core/* ɵɵelementStart */.TgZ(52, "span", 34);
    core/* ɵɵtext */._uU(53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(54, "div", 32);
    core/* ɵɵelementStart */.TgZ(55, "div", 28);
    core/* ɵɵelementStart */.TgZ(56, "div", 29);
    core/* ɵɵelementStart */.TgZ(57, "span");
    core/* ɵɵtext */._uU(58, "Years in F1:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(59, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(60, "div", 35);
    core/* ɵɵelementStart */.TgZ(61, "div", 31);
    core/* ɵɵelementStart */.TgZ(62, "h1");
    core/* ɵɵelementStart */.TgZ(63, "span", 34);
    core/* ɵɵtext */._uU(64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(65, "div", 32);
    core/* ɵɵelementStart */.TgZ(66, "div", 28);
    core/* ɵɵelementStart */.TgZ(67, "div", 29);
    core/* ɵɵelementStart */.TgZ(68, "span");
    core/* ɵɵtext */._uU(69, "No of races:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(70, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(71, "div", 35);
    core/* ɵɵelementStart */.TgZ(72, "div", 31);
    core/* ɵɵelementStart */.TgZ(73, "h1");
    core/* ɵɵelementStart */.TgZ(74, "span", 34);
    core/* ɵɵtext */._uU(75);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(76, "div", 36);
    core/* ɵɵelementStart */.TgZ(77, "div", 28);
    core/* ɵɵelementStart */.TgZ(78, "div", 29);
    core/* ɵɵelementStart */.TgZ(79, "span");
    core/* ɵɵtext */._uU(80, "No of laps:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(81, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(82, "div", 37);
    core/* ɵɵelementStart */.TgZ(83, "div", 31);
    core/* ɵɵelementStart */.TgZ(84, "h1");
    core/* ɵɵelementStart */.TgZ(85, "span", 34);
    core/* ɵɵtext */._uU(86);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(87, "div", 3);
    core/* ɵɵelementStart */.TgZ(88, "div", 38);
    core/* ɵɵelementStart */.TgZ(89, "div", 18);
    core/* ɵɵelementStart */.TgZ(90, "div", 39);
    core/* ɵɵelement */._UZ(91, "apx-chart", 40);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(92, "div", 38);
    core/* ɵɵelementStart */.TgZ(93, "div", 18);
    core/* ɵɵelementStart */.TgZ(94, "div", 39);
    core/* ɵɵelement */._UZ(95, "apx-chart", 40);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(96, "div", 38);
    core/* ɵɵelementStart */.TgZ(97, "div", 18);
    core/* ɵɵelementStart */.TgZ(98, "div", 39);
    core/* ɵɵelement */._UZ(99, "apx-chart", 40);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(100, "div", 3);
    core/* ɵɵelementStart */.TgZ(101, "div", 41);
    core/* ɵɵelement */._UZ(102, "apx-chart", 42);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(103, "div", 43);
    core/* ɵɵelement */._UZ(104, "apx-chart", 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(105, "div", 45);
    core/* ɵɵelementStart */.TgZ(106, "div", 18);
    core/* ɵɵelementStart */.TgZ(107, "div", 39);
    core/* ɵɵelement */._UZ(108, "apx-chart", 46);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r2.driver.givenName + " " + ctx_r2.driver.familyName, " ");
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.driver.wikiImage != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r2.driver.wikiSummary, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("href", ctx_r2.driver.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(24);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.driver.currentConstructor != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.driver.currentConstructor == null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.driver.constructorHistory.length > 0);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.driver.wdcCount);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.driver.standingsBySeason.length);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.driver.raceCount);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.driver.lapCount);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.winsChartOptions.plotOptions)("series", ctx_r2.winsChartOptions.series)("title", ctx_r2.winsChartOptions.title);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.podiumsChartOptions.plotOptions)("series", ctx_r2.podiumsChartOptions.series)("title", ctx_r2.podiumsChartOptions.title);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.polesChartOptions.plotOptions)("series", ctx_r2.polesChartOptions.series)("title", ctx_r2.polesChartOptions.title);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.barChartOptions.chart)("dataLabels", ctx_r2.barChartOptions.dataLabels)("fill", ctx_r2.blueFill)("plotOptions", ctx_r2.barChartOptions.plotOptions)("series", ctx_r2.finalPointsChartOptions.axisSeries)("title", ctx_r2.finalPointsChartOptions.title)("xaxis", ctx_r2.finalPointsChartOptions.xaxis)("yaxis", ctx_r2.barChartOptions.yaxis);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.barChartOptions.chart)("dataLabels", ctx_r2.finalStandingChartOptions.dataLabels)("plotOptions", ctx_r2.barChartOptions.plotOptions)("series", ctx_r2.finalStandingChartOptions.axisSeries)("title", ctx_r2.finalStandingChartOptions.title)("xaxis", ctx_r2.finalStandingChartOptions.xaxis)("yaxis", ctx_r2.finalStandingChartOptions.yaxis);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.pointsThroughSeasonsChartOptions.chart)("series", ctx_r2.pointsThroughSeasonsChartOptions.axisSeries)("stroke", ctx_r2.pointsThroughSeasonsChartOptions.stroke)("title", ctx_r2.pointsThroughSeasonsChartOptions.title)("yaxis", ctx_r2.pointsThroughSeasonsChartOptions.yaxis);
} }
function DriversPopupComponent_tr_17_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 8);
    core/* ɵɵlistener */.NdJ("click", function DriversPopupComponent_tr_17_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const driver_r2 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.selectDriver(driver_r2.driverId); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td", 9);
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "td");
    core/* ɵɵtext */._uU(6);
    core/* ɵɵpipe */.ALo(7, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const driver_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(driver_r2.familyName + ", " + driver_r2.givenName);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(driver_r2.nationality);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(core/* ɵɵpipeBind2 */.xi3(7, 3, driver_r2.dateOfBirth, "y, MMMM d"));
} }
class DriversComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.radialBarChart = {
            type: 'radialBar',
            offsetY: -20
        };
        this.gradientFill = {
            type: 'gradient',
            gradient: {
                shade: 'light',
                shadeIntensity: 0.4,
                inverseColors: false,
                opacityFrom: 1,
                opacityTo: 1,
                stops: [0, 50, 53, 91]
            }
        };
        this.blueFill = {
            colors: ['#00ff95']
        };
        this.defLabels = ['Average Results'];
        this.barChartOptions = {
            chart: {
                height: 350,
                type: 'bar',
                toolbar: ChartUtility.defaultToolbar
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        position: 'top' // top, center, bottom
                    }
                }
            },
            dataLabels: {
                enabled: true,
                // formatter: function(val) {
                //   return val + "%MD";
                // },
                offsetY: -20,
                style: {
                    fontSize: '12px',
                    colors: ['#304758']
                }
            },
            yaxis: {
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                labels: {
                    show: false
                }
            }
        };
        this.getDriverDropdown();
        this.utilityService.setTitle(72, 'Drivers');
    }
    getDriverDropdown() {
        this.restService.getErgastDrivers().subscribe({
            next: data => {
                this.dropdownDrivers = data;
                this.driverId = this.getSelectedDriver();
                this.getDriver(this.driverId, true);
            }
        });
    }
    setCharts() {
        const winCount = this.driver.winCount;
        this.winsChartOptions = {
            series: [100 * this.driver.winCount / this.driver.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + winCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of wins',
                align: 'center',
                offsetY: 25
            }
        };
        const podiumCount = this.driver.podiumCount;
        this.podiumsChartOptions = {
            series: [100 * this.driver.podiumCount / this.driver.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + podiumCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of podiums',
                align: 'center',
                offsetY: 25
            }
        };
        const poleCount = this.driver.poleCount;
        this.polesChartOptions = {
            series: [100 * this.driver.poleCount / this.driver.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + poleCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of poles',
                align: 'center',
                offsetY: 25
            }
        };
        const finalStandingsSeries = [];
        const finalPointsSeries = [];
        const finalStandingsAxis = [];
        let maxStanding = 20;
        this.driver.standingsBySeason.forEach((standing) => {
            finalPointsSeries.push(standing.points);
            if (standing.position > 20) {
                maxStanding = standing.position;
            }
            finalStandingsSeries.push(20 - standing.position);
            finalStandingsAxis.push(standing.season);
        });
        if (maxStanding != 20) {
            for (let i = 0; i < finalStandingsSeries.length; i++) {
                finalStandingsSeries[i] = finalStandingsSeries[i] + maxStanding - 20;
            }
        }
        this.finalPointsChartOptions = {
            axisSeries: [
                {
                    name: 'Points',
                    data: finalPointsSeries
                }
            ],
            xaxis: {
                categories: finalStandingsAxis,
                position: 'bottom',
                labels: {
                    offsetY: 0
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                crosshairs: {
                    fill: {
                        type: 'gradient',
                        gradient: {
                            colorFrom: '#D8E3F0',
                            colorTo: '#BED1E6',
                            stops: [0, 100],
                            opacityFrom: 0.4,
                            opacityTo: 0.5
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    offsetY: -35
                }
            },
            title: {
                text: 'Final points by season',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            }
        };
        this.finalStandingChartOptions = {
            axisSeries: [
                {
                    name: 'Standing',
                    data: finalStandingsSeries
                }
            ],
            xaxis: {
                categories: finalStandingsAxis,
                position: 'bottom',
                labels: {
                    offsetY: 0
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                crosshairs: {
                    fill: {
                        type: 'gradient',
                        gradient: {
                            colorFrom: '#D8E3F0',
                            colorTo: '#BED1E6',
                            stops: [0, 100],
                            opacityFrom: 0.4,
                            opacityTo: 0.5
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    offsetY: -35
                }
            },
            yaxis: {
                min: 1,
                max: maxStanding - 1,
                reversed: false,
                axisBorder: {
                    show: true
                },
                axisTicks: {
                    show: false
                },
                labels: {
                    show: false,
                    formatter: (val, opts) => '' + (maxStanding - val)
                },
            },
            dataLabels: {
                enabled: true,
                formatter: function (val) {
                    return '' + (maxStanding - Number(val));
                },
                offsetY: -20,
                style: {
                    fontSize: '12px',
                    colors: ['#304758']
                }
            },
            title: {
                text: 'Final standing by season',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            }
        };
        this.setStandingsChart();
    }
    openDriversPopup() {
        const dialogRef = this.dialog.open(DriversPopupComponent);
        dialogRef.componentInstance.setDrivers(this.dropdownDrivers);
        dialogRef.afterClosed().subscribe(driverId => {
            if (driverId != null) {
                this.driverId = driverId;
                this.getDriver(this.driverId, true);
                this.updateUrl();
            }
        });
    }
    openWdcPopup() {
        const dialogRef = this.dialog.open(SingleColumnTableDialogComponent);
        dialogRef.componentInstance.init('Championships', this.driver.wdcList);
    }
    openComparatorPopup() {
        const dialogRef = this.dialog.open(DriversComparatorComponent);
        dialogRef.componentInstance.initComparison(this.driver.standingsBySeason[this.driver.standingsBySeason.length - 1].season, this.driverId);
    }
    getDriver(driverId, retry) {
        this.restService.getDriverStatistics(driverId).subscribe({
            next: data => {
                this.driver = data;
                this.utilityService.setTitle(72, this.driver.givenName + ' ' + this.driver.familyName);
                this.setCharts();
            },
            error: error => {
                this.utilityService.pushToastrMessage('Driver not found');
                this.driverId = 'max_verstappen';
                if (retry) {
                    this.getDriver(this.driverId, false);
                }
                console.error('There was an error!', error);
            }
        });
    }
    getSelectedDriver() {
        const driver = this.route.snapshot.queryParamMap.get('driver');
        if (driver == undefined) {
            return 'max_verstappen';
        }
        else {
            return driver;
        }
    }
    updateUrl() {
        const queryParams = { driver: this.driverId };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    setStandingsChart() {
        const driverStandingsSeries = [];
        this.driver.pointsThroughSeasons.forEach((standing) => {
            driverStandingsSeries.push({
                name: standing.name,
                data: standing.series,
            });
        });
        this.pointsThroughSeasonsChartOptions = {
            axisSeries: driverStandingsSeries,
            title: {
                text: 'Points through seasons',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            },
            chart: {
                height: 500,
                type: 'line',
                zoom: {
                    enabled: false
                },
                toolbar: ChartUtility.defaultToolbar
            },
            stroke: {
                width: 3
            },
            yaxis: {
                decimalsInFloat: 0
            }
        };
    }
}
DriversComponent.ɵfac = function DriversComponent_Factory(t) { return new (t || DriversComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
DriversComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: DriversComponent, selectors: [["app-drivers-cmp"]], viewQuery: function DriversComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(drivers_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 21, vars: 4, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "col-lg-4", "col-12"], [1, "card", "card-stats"], [1, "div-margin-always-1rem"], ["mat-flat-button", "", 1, "w-100", "active-color-button", 3, "click"], [1, "pt-1"], ["class", "float-right pl-2", "mat-card-image", "", 3, "src", 4, "ngIf"], ["target", "_blank", 3, "href"], ["mat-flat-button", "", 1, "active-color-button"], [1, "aaa"], [1, "col-lg-8", "col-12"], [1, "col-lg-3", "col-8", "div-padded-always-left-right-8px"], [1, "card"], [1, "card-header"], [1, "text-nowrap", "hide-mat-expansion-border"], [1, "text-center"], [1, "col-lg-2", "col-4", "div-padded-always-left-right-8px"], [1, "card-body", "hover-pointer", 3, "click"], [1, "teko-text-color", "text-size-40px"], [1, "card-body"], [1, "col-lg-3", "col-4", "div-padded-always-left-right-8px"], [1, "card-body", "text-nowrap"], [1, "col-lg-4", "col-6", "div-padded-always-left-right-8px"], [1, "card-body", "no-padding-bottom"], [3, "chart", "fill", "labels", "plotOptions", "series", "title"], [1, "card", "col-lg-6", "col-12", "div-padded-always-left-right-1-2"], [3, "chart", "dataLabels", "fill", "plotOptions", "series", "title", "xaxis", "yaxis"], [1, "card", "col-lg-6", "col-12", "div-padded-always-left-right-1"], [3, "chart", "dataLabels", "plotOptions", "series", "title", "xaxis", "yaxis"], [1, "col-lg-12", "col-12"], [3, "chart", "series", "stroke", "title", "yaxis"], ["mat-card-image", "", 1, "float-right", "pl-2", 3, "src"], [1, "teko-text-color", "text-size-30px"], [1, "table", "table-striped"], [1, "text-center", "bg-primary", "text-white"], ["colspan", "2"]], template: function DriversComponent_Template(rf, ctx) { if (rf & 1) {
        const _r17 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function DriversComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function DriversComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function DriversComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(11); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function DriversComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(11); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, DriversComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function DriversComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r17); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function DriversComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r17); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, DriversComponent_div_20_Template, 109, 49, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.driver != null);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, icon/* MatIcon */.Hw, expansion/* MatAccordion */.pp, expansion/* MatExpansionPanel */.ib, expansion/* MatExpansionPanelHeader */.yz, expansion/* MatExpansionPanelTitle */.yK, ng_apexcharts/* ChartComponent */.x, MatCardImage], encapsulation: 2 });
class DriversPopupComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    sortDrivers(sort) {
        if (sort.direction == 'asc') {
            switch (sort.active) {
                case 'name':
                    this.displayDrivers.sort((a, b) => (a.familyName.toUpperCase() > b.familyName.toUpperCase()) ? 1 : -1);
                    break;
                case 'nation':
                    this.displayDrivers.sort((a, b) => (a.nationality > b.nationality) ? 1 : -1);
                    break;
                case 'birth':
                    this.displayDrivers.sort((a, b) => (a.dateOfBirth > b.dateOfBirth) ? 1 : -1);
                    break;
            }
        }
        if (sort.direction == 'desc') {
            switch (sort.active) {
                case 'name':
                    this.displayDrivers.sort((a, b) => (a.familyName.toUpperCase() < b.familyName.toUpperCase()) ? 1 : -1);
                    break;
                case 'nation':
                    this.displayDrivers.sort((a, b) => (a.nationality < b.nationality) ? 1 : -1);
                    break;
                case 'birth':
                    this.displayDrivers.sort((a, b) => (a.dateOfBirth < b.dateOfBirth) ? 1 : -1);
                    break;
            }
        }
    }
    selectDriver(driverId) {
        this.dialogRef.close(driverId);
    }
    filterDrivers(event) {
        const filterValue = event.target.value.trim().toLowerCase();
        this.displayDrivers = this.drivers.filter(driver => (driver.familyName + driver.givenName).toLowerCase().indexOf(filterValue) > -1);
    }
    setDrivers(drivers) {
        this.drivers = drivers;
        this.displayDrivers = drivers;
    }
}
DriversPopupComponent.ɵfac = function DriversPopupComponent_Factory(t) { return new (t || DriversPopupComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
DriversPopupComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: DriversPopupComponent, selectors: [["app-drivers-popup-cmp"]], decls: 18, vars: 1, consts: [["matInput", "", 3, "keyup"], ["input", ""], ["matSort", "", 1, "table", "table-striped", 3, "matSortChange"], ["cdkFocusInitial", "", 1, "text-center", "bg-primary", "text-white"], ["mat-sort-header", "name", "scope", "col"], ["mat-sort-header", "nation", "scope", "col", 1, "d-sm-none", "d-none", "d-lg-table-cell"], ["mat-sort-header", "birth", "scope", "col"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"], [1, "d-sm-none", "d-none", "d-lg-table-cell"]], template: function DriversPopupComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵelementStart */.TgZ(1, "div");
        core/* ɵɵelementStart */.TgZ(2, "mat-form-field");
        core/* ɵɵelementStart */.TgZ(3, "mat-label");
        core/* ɵɵtext */._uU(4, "Filter");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(5, "input", 0, 1);
        core/* ɵɵlistener */.NdJ("keyup", function DriversPopupComponent_Template_input_keyup_5_listener($event) { return ctx.filterDrivers($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "table", 2);
        core/* ɵɵlistener */.NdJ("matSortChange", function DriversPopupComponent_Template_table_matSortChange_7_listener($event) { return ctx.sortDrivers($event); });
        core/* ɵɵelementStart */.TgZ(8, "thead");
        core/* ɵɵelementStart */.TgZ(9, "tr", 3);
        core/* ɵɵelementStart */.TgZ(10, "th", 4);
        core/* ɵɵtext */._uU(11, "Driver");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(12, "th", 5);
        core/* ɵɵtext */._uU(13, "Nation");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(14, "th", 6);
        core/* ɵɵtext */._uU(15, "Birth");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(16, "tbody");
        core/* ɵɵtemplate */.YNc(17, DriversPopupComponent_tr_17_Template, 8, 6, "tr", 7);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(17);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.displayDrivers);
    } }, directives: [MatDialogContent, MatFormField, MatLabel, MatInput, MatSort, MatSortHeader, common/* NgForOf */.sg], pipes: [common/* DatePipe */.uU], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/database/constructors/constructors.component.ts






















const constructors_component_c0 = ["chart"];
function ConstructorsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 13);
    core/* ɵɵelementStart */.TgZ(2, "div", 14);
    core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.utilityService.replyingTo(comment_r3.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const comment_r3 = restoredCtx.$implicit; const ctx_r6 = core/* ɵɵnextContext */.oxw(); return ctx_r6.utilityService.replyingTo(comment_r3.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 16);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r3 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r3.comment);
} }
function ConstructorsComponent_div_20_img_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 43);
} if (rf & 2) {
    const ctx_r7 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r7.constructorStatistics.wikiImage, core/* ɵɵsanitizeUrl */.LSH);
} }
function ConstructorsComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r9 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 3);
    core/* ɵɵelementStart */.TgZ(2, "div", 17);
    core/* ɵɵelementStart */.TgZ(3, "div", 18);
    core/* ɵɵelementStart */.TgZ(4, "div", 19);
    core/* ɵɵelementStart */.TgZ(5, "button", 20);
    core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_div_20_Template_button_click_5_listener() { core/* ɵɵrestoreView */.CHM(_r9); const ctx_r8 = core/* ɵɵnextContext */.oxw(); return ctx_r8.openDialog(); });
    core/* ɵɵelementStart */.TgZ(6, "mat-icon");
    core/* ɵɵtext */._uU(7, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementStart */.TgZ(9, "mat-icon");
    core/* ɵɵtext */._uU(10, "keyboard_arrow_up");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(11, "div", 21);
    core/* ɵɵtemplate */.YNc(12, ConstructorsComponent_div_20_img_12_Template, 1, 1, "img", 22);
    core/* ɵɵelementStart */.TgZ(13, "p");
    core/* ɵɵtext */._uU(14);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(15, "p");
    core/* ɵɵelementStart */.TgZ(16, "a", 23);
    core/* ɵɵelementStart */.TgZ(17, "button", 24);
    core/* ɵɵtext */._uU(18, "Wikipedia");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(19, "div", 25);
    core/* ɵɵelementStart */.TgZ(20, "div", 3);
    core/* ɵɵelementStart */.TgZ(21, "div", 26);
    core/* ɵɵelementStart */.TgZ(22, "div", 27);
    core/* ɵɵelementStart */.TgZ(23, "div", 28);
    core/* ɵɵelementStart */.TgZ(24, "span");
    core/* ɵɵtext */._uU(25, "WCC:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(26, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(27, "div", 29);
    core/* ɵɵelementStart */.TgZ(28, "div", 30);
    core/* ɵɵelementStart */.TgZ(29, "h1");
    core/* ɵɵelementStart */.TgZ(30, "span", 31);
    core/* ɵɵtext */._uU(31);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(32, "div", 26);
    core/* ɵɵelementStart */.TgZ(33, "div", 27);
    core/* ɵɵelementStart */.TgZ(34, "div", 28);
    core/* ɵɵelementStart */.TgZ(35, "span");
    core/* ɵɵtext */._uU(36, "WDC:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(37, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(38, "div", 32);
    core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_div_20_Template_div_click_38_listener() { core/* ɵɵrestoreView */.CHM(_r9); const ctx_r10 = core/* ɵɵnextContext */.oxw(); return ctx_r10.openWdcPopup(); });
    core/* ɵɵelementStart */.TgZ(39, "div", 30);
    core/* ɵɵelementStart */.TgZ(40, "h1");
    core/* ɵɵelementStart */.TgZ(41, "span", 31);
    core/* ɵɵtext */._uU(42);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(43, "div", 26);
    core/* ɵɵelementStart */.TgZ(44, "div", 27);
    core/* ɵɵelementStart */.TgZ(45, "div", 28);
    core/* ɵɵelementStart */.TgZ(46, "span");
    core/* ɵɵtext */._uU(47, "Years in F1:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(48, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(49, "div", 29);
    core/* ɵɵelementStart */.TgZ(50, "div", 30);
    core/* ɵɵelementStart */.TgZ(51, "h1");
    core/* ɵɵelementStart */.TgZ(52, "span", 31);
    core/* ɵɵtext */._uU(53);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(54, "div", 33);
    core/* ɵɵelementStart */.TgZ(55, "div", 27);
    core/* ɵɵelementStart */.TgZ(56, "div", 28);
    core/* ɵɵelementStart */.TgZ(57, "span");
    core/* ɵɵtext */._uU(58, "No of races:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(59, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(60, "div", 29);
    core/* ɵɵelementStart */.TgZ(61, "div", 30);
    core/* ɵɵelementStart */.TgZ(62, "h1");
    core/* ɵɵelementStart */.TgZ(63, "span", 31);
    core/* ɵɵtext */._uU(64);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(65, "div", 33);
    core/* ɵɵelementStart */.TgZ(66, "div", 27);
    core/* ɵɵelementStart */.TgZ(67, "div", 28);
    core/* ɵɵelementStart */.TgZ(68, "span");
    core/* ɵɵtext */._uU(69, "No of laps:");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(70, "hr");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(71, "div", 29);
    core/* ɵɵelementStart */.TgZ(72, "div", 30);
    core/* ɵɵelementStart */.TgZ(73, "h1");
    core/* ɵɵelementStart */.TgZ(74, "span", 31);
    core/* ɵɵtext */._uU(75);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(76, "div", 3);
    core/* ɵɵelementStart */.TgZ(77, "div", 34);
    core/* ɵɵelementStart */.TgZ(78, "div", 18);
    core/* ɵɵelementStart */.TgZ(79, "div", 35);
    core/* ɵɵelement */._UZ(80, "apx-chart", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(81, "div", 34);
    core/* ɵɵelementStart */.TgZ(82, "div", 18);
    core/* ɵɵelementStart */.TgZ(83, "div", 35);
    core/* ɵɵelement */._UZ(84, "apx-chart", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(85, "div", 34);
    core/* ɵɵelementStart */.TgZ(86, "div", 18);
    core/* ɵɵelementStart */.TgZ(87, "div", 35);
    core/* ɵɵelement */._UZ(88, "apx-chart", 36);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(89, "div", 3);
    core/* ɵɵelementStart */.TgZ(90, "div", 37);
    core/* ɵɵelement */._UZ(91, "apx-chart", 38);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(92, "div", 39);
    core/* ɵɵelement */._UZ(93, "apx-chart", 40);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(94, "div", 41);
    core/* ɵɵelementStart */.TgZ(95, "div", 18);
    core/* ɵɵelementStart */.TgZ(96, "div", 35);
    core/* ɵɵelement */._UZ(97, "apx-chart", 42);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r2.constructorStatistics.ergastConstructor.name, " ");
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.constructorStatistics.wikiImage != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r2.constructorStatistics.wikiSummary, " ");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("href", ctx_r2.constructorStatistics.ergastConstructor.url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(15);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.constructorStatistics.wccCount);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.constructorStatistics.wdcCount);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.constructorStatistics.standingsBySeason.length);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.constructorStatistics.raceCount);
    core/* ɵɵadvance */.xp6(11);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r2.constructorStatistics.lapCount);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.winsChartOptions.plotOptions)("series", ctx_r2.winsChartOptions.series)("title", ctx_r2.winsChartOptions.title);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.podiumsChartOptions.plotOptions)("series", ctx_r2.podiumsChartOptions.series)("title", ctx_r2.podiumsChartOptions.title);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.radialBarChart)("fill", ctx_r2.gradientFill)("labels", ctx_r2.defLabels)("plotOptions", ctx_r2.polesChartOptions.plotOptions)("series", ctx_r2.polesChartOptions.series)("title", ctx_r2.polesChartOptions.title);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.barChartOptions.chart)("dataLabels", ctx_r2.barChartOptions.dataLabels)("fill", ctx_r2.blueFill)("plotOptions", ctx_r2.barChartOptions.plotOptions)("series", ctx_r2.finalPointsChartOptions.axisSeries)("title", ctx_r2.finalPointsChartOptions.title)("xaxis", ctx_r2.finalPointsChartOptions.xaxis)("yaxis", ctx_r2.barChartOptions.yaxis);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.barChartOptions.chart)("dataLabels", ctx_r2.finalStandingChartOptions.dataLabels)("plotOptions", ctx_r2.barChartOptions.plotOptions)("series", ctx_r2.finalStandingChartOptions.axisSeries)("title", ctx_r2.finalStandingChartOptions.title)("xaxis", ctx_r2.finalStandingChartOptions.xaxis)("yaxis", ctx_r2.finalStandingChartOptions.yaxis);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("chart", ctx_r2.pointsThroughSeasonsChartOptions.chart)("series", ctx_r2.pointsThroughSeasonsChartOptions.axisSeries)("stroke", ctx_r2.pointsThroughSeasonsChartOptions.stroke)("title", ctx_r2.pointsThroughSeasonsChartOptions.title)("yaxis", ctx_r2.pointsThroughSeasonsChartOptions.yaxis);
} }
function ConstructorsPopupComponent_tr_15_Template(rf, ctx) { if (rf & 1) {
    const _r5 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "tr", 7);
    core/* ɵɵlistener */.NdJ("click", function ConstructorsPopupComponent_tr_15_Template_tr_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r5); const cs_r2 = restoredCtx.$implicit; const ctx_r4 = core/* ɵɵnextContext */.oxw(); return ctx_r4.selectConstructor(cs_r2.constructorId); });
    core/* ɵɵelementStart */.TgZ(1, "td");
    core/* ɵɵtext */._uU(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(3, "td");
    core/* ɵɵtext */._uU(4);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const cs_r2 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(cs_r2.name);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(cs_r2.nationality);
} }
class ConstructorsComponent {
    constructor(restService, utilityService, router, route, dialog) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.router = router;
        this.route = route;
        this.dialog = dialog;
        this.radialBarChart = {
            type: 'radialBar',
            offsetY: -20
        };
        this.gradientFill = {
            type: 'gradient',
            gradient: {
                shade: 'light',
                shadeIntensity: 0.4,
                inverseColors: false,
                opacityFrom: 1,
                opacityTo: 1,
                stops: [0, 50, 53, 91]
            }
        };
        this.blueFill = {
            colors: ['#00ff95']
        };
        this.defLabels = ['Average Results'];
        this.barChartOptions = {
            chart: {
                height: 350,
                type: 'bar',
                toolbar: ChartUtility.defaultToolbar
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        position: 'top' // top, center, bottom
                    }
                }
            },
            dataLabels: {
                enabled: true,
                // formatter: function(val) {
                //   return val + "%MD";
                // },
                offsetY: -20,
                style: {
                    fontSize: '12px',
                    colors: ['#304758']
                }
            },
            yaxis: {
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                labels: {
                    show: false
                }
            }
        };
        this.getConstructorDropdown();
        this.utilityService.setTitle(73, 'Constructors');
    }
    getConstructorDropdown() {
        this.restService.getErgastConstructors().subscribe({
            next: data => {
                this.dropdownConstructors = data;
                this.constructorId = this.getSelectedConstructor();
                this.getConstructor(this.constructorId);
            }
        });
    }
    setCharts() {
        const winCount = this.constructorStatistics.winCount;
        this.winsChartOptions = {
            series: [100 * this.constructorStatistics.winCount / this.constructorStatistics.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + winCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of wins',
                align: 'center',
                offsetY: 25
            }
        };
        const podiumCount = this.constructorStatistics.podiumCount;
        this.podiumsChartOptions = {
            series: [100 * this.constructorStatistics.podiumCount / this.constructorStatistics.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + podiumCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of podiums',
                align: 'center',
                offsetY: 25
            }
        };
        const poleCount = this.constructorStatistics.poleCount;
        this.polesChartOptions = {
            series: [100 * this.constructorStatistics.poleCount / this.constructorStatistics.raceCount],
            plotOptions: {
                radialBar: {
                    startAngle: -90,
                    endAngle: 90,
                    track: {
                        background: '#e7e7e7',
                        strokeWidth: '96%',
                        margin: 5,
                        dropShadow: {
                            enabled: true,
                            top: 2,
                            left: 0,
                            opacity: 0.31,
                            blur: 2
                        }
                    },
                    dataLabels: {
                        name: {
                            show: false
                        },
                        value: {
                            offsetY: -2,
                            fontSize: '22px',
                            formatter: function (val) {
                                return '' + poleCount;
                            }
                        }
                    }
                }
            },
            title: {
                text: 'Number of poles',
                align: 'center',
                offsetY: 25
            }
        };
        let finalStandingsSeries = [];
        let finalPointsSeries = [];
        let finalStandingsAxis = [];
        let maxStanding = 20;
        this.constructorStatistics.standingsBySeason.forEach((standing) => {
            finalPointsSeries.push(standing.points);
            if (standing.position > 20) {
                maxStanding = standing.position;
            }
            finalStandingsSeries.push(20 - standing.position);
            finalStandingsAxis.push(standing.season);
        });
        if (maxStanding != 20) {
            for (let i = 0; i < finalStandingsSeries.length; i++) {
                finalStandingsSeries[i] = finalStandingsSeries[i] + maxStanding - 20;
            }
        }
        let ticks = 10;
        if (finalStandingsAxis.length < ticks) {
            ticks = finalStandingsAxis.length;
        }
        this.finalPointsChartOptions = {
            axisSeries: [
                {
                    name: 'Points',
                    data: finalPointsSeries
                }
            ],
            xaxis: {
                categories: finalStandingsAxis,
                tickAmount: ticks,
                position: 'bottom',
                labels: {
                    offsetY: 0
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                crosshairs: {
                    fill: {
                        type: 'gradient',
                        gradient: {
                            colorFrom: '#D8E3F0',
                            colorTo: '#BED1E6',
                            stops: [0, 100],
                            opacityFrom: 0.4,
                            opacityTo: 0.5
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    offsetY: -35
                }
            },
            title: {
                text: 'Final points by season',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            }
        };
        this.finalStandingChartOptions = {
            axisSeries: [
                {
                    name: 'Standing',
                    data: finalStandingsSeries
                }
            ],
            xaxis: {
                categories: finalStandingsAxis,
                position: 'bottom',
                tickAmount: ticks,
                labels: {
                    offsetY: 0
                },
                axisBorder: {
                    show: false
                },
                axisTicks: {
                    show: false
                },
                crosshairs: {
                    fill: {
                        type: 'gradient',
                        gradient: {
                            colorFrom: '#D8E3F0',
                            colorTo: '#BED1E6',
                            stops: [0, 100],
                            opacityFrom: 0.4,
                            opacityTo: 0.5
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    offsetY: -35
                }
            },
            yaxis: {
                min: 1,
                max: maxStanding - 1,
                reversed: false,
                axisBorder: {
                    show: true
                },
                axisTicks: {
                    show: false
                },
                labels: {
                    show: false,
                    formatter: (val, opts) => '' + (maxStanding - val)
                },
            },
            dataLabels: {
                enabled: true,
                formatter: function (val) {
                    return '' + (maxStanding - Number(val));
                },
                offsetY: -20,
                style: {
                    fontSize: '12px',
                    colors: ['#304758']
                }
            },
            title: {
                text: 'Final standing by season',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            }
        };
        this.setStandingsChart();
    }
    openDialog() {
        const dialogRef = this.dialog.open(ConstructorsPopupComponent);
        dialogRef.componentInstance.setConstructors(this.dropdownConstructors);
        dialogRef.afterClosed().subscribe(constructorId => {
            if (constructorId != null) {
                this.constructorId = constructorId;
                this.getConstructor(this.constructorId);
                this.updateUrl();
            }
        });
    }
    getConstructor(id) {
        this.restService.getConstructorStatistics(id).subscribe({
            next: data => {
                this.constructorStatistics = data;
                this.utilityService.setTitle(73, this.constructorStatistics.ergastConstructor.name);
                this.setCharts();
            }
        });
    }
    getSelectedConstructor() {
        let constructor = this.route.snapshot.queryParamMap.get('constructor');
        if (constructor == undefined) {
            return 'red_bull';
        }
        else {
            return constructor;
        }
    }
    updateUrl() {
        const queryParams = { constructor: this.constructorId };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    setStandingsChart() {
        let constructorStandingsSeries = [];
        this.constructorStatistics.pointsThroughSeasons.forEach((standing) => {
            constructorStandingsSeries.push({
                name: standing.name,
                data: standing.series,
            });
        });
        this.pointsThroughSeasonsChartOptions = {
            axisSeries: constructorStandingsSeries,
            title: {
                text: 'Points through seasons',
                offsetY: 0,
                align: 'center',
                style: {
                    color: '#444'
                }
            },
            chart: {
                height: 500,
                type: 'line',
                zoom: {
                    enabled: false
                },
                toolbar: ChartUtility.defaultToolbar
            },
            stroke: {
                width: 3
            },
            yaxis: {
                decimalsInFloat: 0
            }
        };
    }
    openWdcPopup() {
        const dialogRef = this.dialog.open(SingleColumnTableDialogComponent);
        dialogRef.componentInstance.init('Championships', this.constructorStatistics.wdcList);
    }
}
ConstructorsComponent.ɵfac = function ConstructorsComponent_Factory(t) { return new (t || ConstructorsComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(MatDialog)); };
ConstructorsComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ConstructorsComponent, selectors: [["app-constructors-cmp"]], viewQuery: function ConstructorsComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(constructors_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.chart = _t.first);
    } }, decls: 21, vars: 4, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["mat-button", "", "type", "fixed-plugin", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "col-lg-4", "col-12"], [1, "card", "card-stats"], [1, "div-margin-always-1rem"], ["mat-flat-button", "", 1, "w-100", "active-color-button", 3, "click"], [1, "pt-1"], ["class", "float-right pl-2", "mat-card-image", "", "alt", "image", 3, "src", 4, "ngIf"], ["target", "_blank", 3, "href"], ["mat-flat-button", "", 1, "active-color-button"], [1, "col-lg-8", "col-12", "div-padded-always-left-right-8px"], [1, "col-lg-2", "col-4", "div-padded-always-left-right-8px"], [1, "card"], [1, "card-header"], [1, "card-body"], [1, "text-center"], [1, "teko-text-color", "text-size-40px"], [1, "card-body", "hover-pointer", 3, "click"], [1, "col-lg-3", "col-6", "div-padded-always-left-right-8px"], [1, "col-lg-4", "col-6", "div-padded-always-left-right-8px"], [1, "card-body", "no-padding-bottom"], [3, "chart", "fill", "labels", "plotOptions", "series", "title"], [1, "card", "col-lg-6", "col-12", "div-padded-always-left-right-1-2"], [3, "chart", "dataLabels", "fill", "plotOptions", "series", "title", "xaxis", "yaxis"], [1, "card", "col-lg-6", "col-12", "div-padded-always-left-right-1"], [3, "chart", "dataLabels", "plotOptions", "series", "title", "xaxis", "yaxis"], [1, "col-lg-12", "col-12"], [3, "chart", "series", "stroke", "title", "yaxis"], ["mat-card-image", "", "alt", "image", 1, "float-right", "pl-2", 3, "src"]], template: function ConstructorsComponent_Template(rf, ctx) { if (rf & 1) {
        const _r11 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function ConstructorsComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function ConstructorsComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(11); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(11); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, ConstructorsComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r11); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function ConstructorsComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r11); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, ConstructorsComponent_div_20_Template, 98, 47, "div", 12);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.constructorStatistics != null);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, icon/* MatIcon */.Hw, ng_apexcharts/* ChartComponent */.x, MatCardImage], encapsulation: 2 });
class ConstructorsPopupComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    selectConstructor(id) {
        this.dialogRef.close(id);
    }
    filterConstructors(event) {
        const filterValue = event.target.value.trim().toLowerCase();
        this.displayConstructors = this.constructors.filter(cons => (cons.name).toLowerCase().indexOf(filterValue) > -1);
    }
    sortConstructors(sort) {
        if (sort.direction == 'asc') {
            switch (sort.active) {
                case 'name':
                    this.displayConstructors.sort((a, b) => (a.name.toUpperCase() > b.name.toUpperCase()) ? 1 : -1);
                    break;
                case 'nation':
                    this.displayConstructors.sort((a, b) => (a.nationality > b.nationality) ? 1 : -1);
                    break;
            }
        }
        if (sort.direction == 'desc') {
            switch (sort.active) {
                case 'name':
                    this.displayConstructors.sort((a, b) => (a.name.toUpperCase() < b.name.toUpperCase()) ? 1 : -1);
                    break;
                case 'nation':
                    this.displayConstructors.sort((a, b) => (a.nationality < b.nationality) ? 1 : -1);
                    break;
            }
        }
    }
    setConstructors(constructors) {
        this.constructors = constructors;
        this.displayConstructors = constructors;
    }
}
ConstructorsPopupComponent.ɵfac = function ConstructorsPopupComponent_Factory(t) { return new (t || ConstructorsPopupComponent)(core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
ConstructorsPopupComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ConstructorsPopupComponent, selectors: [["app-constructors-popup-cmp"]], decls: 16, vars: 1, consts: [["matInput", "", 3, "keyup"], ["input", ""], ["matSort", "", 1, "table", "table-striped", 3, "matSortChange"], ["cdkFocusInitial", "", 1, "text-center", "bg-primary", "text-white"], ["mat-sort-header", "name", "scope", "col"], ["mat-sort-header", "nation", "scope", "col"], [3, "click", 4, "ngFor", "ngForOf"], [3, "click"]], template: function ConstructorsPopupComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "mat-dialog-content");
        core/* ɵɵelementStart */.TgZ(1, "div");
        core/* ɵɵelementStart */.TgZ(2, "mat-form-field");
        core/* ɵɵelementStart */.TgZ(3, "mat-label");
        core/* ɵɵtext */._uU(4, "Filter");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(5, "input", 0, 1);
        core/* ɵɵlistener */.NdJ("keyup", function ConstructorsPopupComponent_Template_input_keyup_5_listener($event) { return ctx.filterConstructors($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(7, "table", 2);
        core/* ɵɵlistener */.NdJ("matSortChange", function ConstructorsPopupComponent_Template_table_matSortChange_7_listener($event) { return ctx.sortConstructors($event); });
        core/* ɵɵelementStart */.TgZ(8, "thead");
        core/* ɵɵelementStart */.TgZ(9, "tr", 3);
        core/* ɵɵelementStart */.TgZ(10, "th", 4);
        core/* ɵɵtext */._uU(11, "Name");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(12, "th", 5);
        core/* ɵɵtext */._uU(13, "Country");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(14, "tbody");
        core/* ɵɵtemplate */.YNc(15, ConstructorsPopupComponent_tr_15_Template, 5, 2, "tr", 6);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(15);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.displayConstructors);
    } }, directives: [MatDialogContent, MatFormField, MatLabel, MatInput, MatSort, MatSortHeader, common/* NgForOf */.sg], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/pages/tifosi/tifosi.component.ts













function TifosiComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 21);
    core/* ɵɵelementStart */.TgZ(2, "div", 22);
    core/* ɵɵlistener */.NdJ("click", function TifosiComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.utilityService.replyingTo(comment_r4.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 23);
    core/* ɵɵlistener */.NdJ("click", function TifosiComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.utilityService.replyingTo(comment_r4.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 24);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r4 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.comment);
} }
function TifosiComponent_div_26_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 25);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r2.clock, " ");
} }
function TifosiComponent_div_27_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 26);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r3.difference, " ");
} }
class TifosiComponent {
    constructor(restService, utilityService, toastr) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.toastr = toastr;
        this.utilityService.setTitleDefaultPage(1, 'Suicide watch corner');
        this.calculateDays();
        this.getTimePeriodically();
        this.getTwitterFeed();
    }
    calculateDays() {
        let currentDate = new Date();
        let wcc = new Date(1225584000000);
        this.difference = Math.floor((Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate()) - Date.UTC(wcc.getFullYear(), wcc.getMonth(), wcc.getDate())) / (1000 * 60 * 60 * 24));
    }
    getTimePeriodically() {
        this.getTime();
        this.clockRefresher = setInterval(() => {
            this.getTime();
        }, 5000);
    }
    getTime() {
        let currentTime = new Date();
        this.clock = currentTime.getHours() + ":" + this.padValue(currentTime.getMinutes());
    }
    padValue(value) {
        return (value < 10) ? "0" + value : value;
    }
    ngOnDestroy() {
        clearInterval(this.clockRefresher);
    }
    getTwitterFeed() {
        this.restService.getTwitterFerrariPosts().subscribe({
            next: data => {
                this.tweets = data;
                return data;
            }
        });
    }
}
TifosiComponent.ɵfac = function TifosiComponent_Factory(t) { return new (t || TifosiComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(ngx_toastr/* ToastrService */._W)); };
TifosiComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: TifosiComponent, selectors: [["app-tifosi-cmp"]], decls: 32, vars: 5, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], [1, "height-fill-screen", "tifosi_container"], [1, "tifosi_left"], ["src", "assets/img/tifosi/leclerc1.jpg", "alt", "left1"], ["src", "assets/img/tifosi/clowns.jpg", "alt", "left2"], [1, "tifosi_middle"], [1, "tifoso-div"], ["class", "tifoso-clock-div", 4, "ngIf"], ["matTooltip", "World Constructor Championship 2008", "class", "tifoso-countdown-div", 4, "ngIf"], [1, "tifoso-1-div", "overlay-bottom-left-div-fixed-2", "display-on-desktop-only"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "tifoso-clock-div"], ["matTooltip", "World Constructor Championship 2008", 1, "tifoso-countdown-div"]], template: function TifosiComponent_Template(rf, ctx) { if (rf & 1) {
        const _r8 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function TifosiComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function TifosiComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function TifosiComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(1); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function TifosiComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(1); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, TifosiComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function TifosiComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r8); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function TifosiComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r8); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(20, "div", 12);
        core/* ɵɵelementStart */.TgZ(21, "div", 13);
        core/* ɵɵelement */._UZ(22, "img", 14);
        core/* ɵɵelement */._UZ(23, "img", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(24, "div", 16);
        core/* ɵɵelementStart */.TgZ(25, "div", 17);
        core/* ɵɵtemplate */.YNc(26, TifosiComponent_div_26_Template, 2, 1, "div", 18);
        core/* ɵɵtemplate */.YNc(27, TifosiComponent_div_27_Template, 2, 1, "div", 19);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(28, "div", 13);
        core/* ɵɵelement */._UZ(29, "img", 14);
        core/* ɵɵelement */._UZ(30, "img", 15);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(31, "div", 20);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(13);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.clock != null);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.difference != null);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, MatTooltip], styles: [".tifosi_container[_ngcontent-%COMP%]{margin-left:auto;margin-right:auto}.tifosi_left[_ngcontent-%COMP%]{width:calc((100% - 653px)/2);height:calc(100vh - 53px);overflow-y:hidden;float:left;text-align:center;display:block;min-height:680px;max-width:100%;max-height:100%}@media (max-width:1299px){.tifosi_left[_ngcontent-%COMP%]{height:calc(100vh - 73px)}}.tifosi_middle[_ngcontent-%COMP%]{position:relative;width:653px;float:left;max-width:100%;max-height:100%}.tifosi_right[_ngcontent-%COMP%]{width:calc((100% - 653px)/2);height:calc(100vh - 53px);overflow-y:scroll;float:left}@media (max-width:1299px){.tifosi_right[_ngcontent-%COMP%]{height:calc(100vh - 73px)}}"] });

;// CONCATENATED MODULE: ./src/app/model/calendar-data.ts
class CalendarData {
}
class F1Calendar {
}
class CountdownData {
}

;// CONCATENATED MODULE: ./src/app/pages/countdown/f1-countdown.component.ts






















const f1_countdown_component_c0 = ["countdown"];
function F1CountdownComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r6 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 14);
    core/* ɵɵelementStart */.TgZ(2, "div", 15);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_13_Template_div_click_2_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r5 = core/* ɵɵnextContext */.oxw(); return ctx_r5.utilityService.replyingTo(comment_r4.nickname); });
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "div", 16);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_13_Template_div_click_4_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r6); const comment_r4 = restoredCtx.$implicit; const ctx_r7 = core/* ɵɵnextContext */.oxw(); return ctx_r7.utilityService.replyingTo(comment_r4.id + ""); });
    core/* ɵɵtext */._uU(5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(6, "div", 17);
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const comment_r4 = ctx.$implicit;
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.nickname);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.id);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate */.Oqu(comment_r4.comment);
} }
function F1CountdownComponent_div_20_div_1_img_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 38);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r30 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r30.FP1Days, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
const f1_countdown_component_c1 = function (a0) { return { leftTime: a0 }; };
function F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r34 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r34); const ctx_r33 = core/* ɵɵnextContext */.oxw(4); return ctx_r33.countdownWasClicked(1); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
} if (rf & 2) {
    const ctx_r29 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r29.calendarData.f1Calendar.practice1Name, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r29.FP1Days > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r29.FP1Days == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r29.FP1Seconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_3_ng_template_1_Template, 15, 6, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r22 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r22.calendarData.f1Calendar.practice1Name);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r36 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r36.FP2Days, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r40 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r40); const ctx_r39 = core/* ɵɵnextContext */.oxw(4); return ctx_r39.countdownWasClicked(2); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
} if (rf & 2) {
    const ctx_r35 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r35.calendarData.f1Calendar.practice2Name, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r35.FP2Days > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r35.FP2Days == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r35.FP2Seconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_4_ng_template_1_Template, 15, 6, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r23 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r23.calendarData.f1Calendar.practice2Name);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r42 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r42.FP3Days, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r46 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r46); const ctx_r45 = core/* ɵɵnextContext */.oxw(4); return ctx_r45.countdownWasClicked(3); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
} if (rf & 2) {
    const ctx_r41 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r41.calendarData.f1Calendar.practice3Name, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r41.FP3Days > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r41.FP3Days == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r41.FP3Seconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_5_ng_template_1_Template, 15, 6, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r24 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r24.calendarData.f1Calendar.practice3Name);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r48 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r48.qualifyingDays, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r52 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r52); const ctx_r51 = core/* ɵɵnextContext */.oxw(4); return ctx_r51.countdownWasClicked(4); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
} if (rf & 2) {
    const ctx_r47 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r47.calendarData.f1Calendar.qualifyingName, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r47.qualifyingDays > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r47.qualifyingDays == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r47.qualifyingSeconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_6_ng_template_1_Template, 15, 6, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r25 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r25.calendarData.f1Calendar.qualifyingName);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r54 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r54.sprintDays, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r58 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r58); const ctx_r57 = core/* ɵɵnextContext */.oxw(4); return ctx_r57.countdownWasClicked(6); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(10, "br");
    core/* ɵɵelement */._UZ(11, "br");
    core/* ɵɵelement */._UZ(12, "br");
    core/* ɵɵelement */._UZ(13, "br");
    core/* ɵɵelement */._UZ(14, "br");
} if (rf & 2) {
    const ctx_r53 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r53.calendarData.f1Calendar.sprintName, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r53.sprintDays > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r53.sprintDays == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r53.sprintSeconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_7_ng_template_1_Template, 15, 6, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r26 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r26.calendarData.f1Calendar.sprintName);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_mat_slide_toggle_0_Template(rf, ctx) { if (rf & 1) {
    const _r63 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "mat-slide-toggle", 48);
    core/* ɵɵlistener */.NdJ("change", function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_mat_slide_toggle_0_Template_mat_slide_toggle_change_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r63); const ctx_r62 = core/* ɵɵnextContext */.oxw(5); return ctx_r62.toggleMusic($event); })("ngModelChange", function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_mat_slide_toggle_0_Template_mat_slide_toggle_ngModelChange_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r63); const ctx_r64 = core/* ɵɵnextContext */.oxw(5); return ctx_r64.isPlayingMusic = $event; });
    core/* ɵɵelement */._UZ(1, "i", 49);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r60 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r60.isPlayingMusic);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r65 = core/* ɵɵnextContext */.oxw(6);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r65.raceDays, " days");
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_div_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 45);
    core/* ɵɵtext */._uU(3, "1 day");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r69 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 40);
    core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_Template_div_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r69); const ctx_r68 = core/* ɵɵnextContext */.oxw(5); return ctx_r68.countdownWasClicked(5); });
    core/* ɵɵelementStart */.TgZ(1, "h1");
    core/* ɵɵelementStart */.TgZ(2, "span", 41);
    core/* ɵɵtext */._uU(3);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_div_4_Template, 4, 1, "div", 42);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_div_5_Template, 4, 0, "div", 42);
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span");
    core/* ɵɵelement */._UZ(8, "countdown", 43, 44);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r61 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r61.calendarData.f1Calendar.raceName, " in: ");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r61.raceDays > 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r61.raceDays == 1);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("config", core/* ɵɵpureFunction1 */.VKq(4, f1_countdown_component_c1, ctx_r61.raceSeconds));
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_mat_slide_toggle_0_Template, 2, 1, "mat-slide-toggle", 46);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_div_1_Template, 10, 6, "div", 47);
    core/* ɵɵelement */._UZ(2, "br");
    core/* ɵɵelement */._UZ(3, "br");
    core/* ɵɵelement */._UZ(4, "br");
    core/* ɵɵelement */._UZ(5, "br");
    core/* ɵɵelement */._UZ(6, "br");
} if (rf & 2) {
    const ctx_r59 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r59.itsTime);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r59.calendarData != null);
} }
function F1CountdownComponent_div_20_div_1_mat_tab_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-tab", 39);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_mat_tab_8_ng_template_1_Template, 7, 2, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r27 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵpropertyInterpolate */.s9C("label", ctx_r27.calendarData.f1Calendar.raceName);
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r71 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r71.calendarData.f1Calendar.practice1Name, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_14_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r72 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r72.calendarData.f1Calendar.practice2Name, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_15_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 53);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵpipe */.ALo(2, "date");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r73 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(2, 1, ctx_r73.checkTime(ctx_r73.calendarData.f1Calendar.practice2), "EEEE, MMMM d, HH:mm"), " ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_17_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r74 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r74.calendarData.f1Calendar.practice3Name, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_18_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 53);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵpipe */.ALo(2, "date");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r75 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(2, 1, ctx_r75.checkTime(ctx_r75.calendarData.f1Calendar.practice3), "EEEE, MMMM d, HH:mm"), " ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r76 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r76.calendarData.f1Calendar.qualifyingName, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_21_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 53);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵpipe */.ALo(2, "date");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r77 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(2, 1, ctx_r77.checkTime(ctx_r77.calendarData.f1Calendar.qualifying), "EEEE, MMMM d, HH:mm"), " ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_23_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r78 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r78.calendarData.f1Calendar.sprintName, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_24_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 53);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵpipe */.ALo(2, "date");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r79 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(2, 1, ctx_r79.checkTime(ctx_r79.calendarData.f1Calendar.sprint), "EEEE, MMMM d, HH:mm"), " ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_26_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 56);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r80 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", ctx_r80.calendarData.f1Calendar.raceName, " : ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_27_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 53);
    core/* ɵɵtext */._uU(1);
    core/* ɵɵpipe */.ALo(2, "date");
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r81 = core/* ɵɵnextContext */.oxw(5);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(2, 1, ctx_r81.checkTime(ctx_r81.calendarData.f1Calendar.race), "EEEE, MMMM d, HH:mm"), " ");
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r83 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div");
    core/* ɵɵelementStart */.TgZ(1, "div", 50);
    core/* ɵɵelementStart */.TgZ(2, "span");
    core/* ɵɵtext */._uU(3, "My time ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(4, "mat-slide-toggle", 51);
    core/* ɵɵlistener */.NdJ("ngModelChange", function F1CountdownComponent_div_20_div_1_ng_template_10_div_0_Template_mat_slide_toggle_ngModelChange_4_listener($event) { core/* ɵɵrestoreView */.CHM(_r83); const ctx_r82 = core/* ɵɵnextContext */.oxw(4); return ctx_r82.isUtc = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "span");
    core/* ɵɵtext */._uU(6, " UTC time");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(7, "div");
    core/* ɵɵelementStart */.TgZ(8, "div", 3);
    core/* ɵɵtemplate */.YNc(9, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_9_Template, 2, 1, "div", 52);
    core/* ɵɵelementStart */.TgZ(10, "div", 53);
    core/* ɵɵtext */._uU(11);
    core/* ɵɵpipe */.ALo(12, "date");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelement */._UZ(13, "div", 54);
    core/* ɵɵtemplate */.YNc(14, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_14_Template, 2, 1, "div", 52);
    core/* ɵɵtemplate */.YNc(15, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_15_Template, 3, 4, "div", 55);
    core/* ɵɵelement */._UZ(16, "div", 54);
    core/* ɵɵtemplate */.YNc(17, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_17_Template, 2, 1, "div", 52);
    core/* ɵɵtemplate */.YNc(18, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_18_Template, 3, 4, "div", 55);
    core/* ɵɵelement */._UZ(19, "div", 54);
    core/* ɵɵtemplate */.YNc(20, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_20_Template, 2, 1, "div", 52);
    core/* ɵɵtemplate */.YNc(21, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_21_Template, 3, 4, "div", 55);
    core/* ɵɵelement */._UZ(22, "div", 54);
    core/* ɵɵtemplate */.YNc(23, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_23_Template, 2, 1, "div", 52);
    core/* ɵɵtemplate */.YNc(24, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_24_Template, 3, 4, "div", 55);
    core/* ɵɵelement */._UZ(25, "div", 54);
    core/* ɵɵtemplate */.YNc(26, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_26_Template, 2, 1, "div", 52);
    core/* ɵɵtemplate */.YNc(27, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_div_27_Template, 3, 4, "div", 55);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r70 = core/* ɵɵnextContext */.oxw(4);
    core/* ɵɵadvance */.xp6(4);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r70.isUtc);
    core/* ɵɵadvance */.xp6(5);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.practice1Name != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵtextInterpolate1 */.hij(" ", core/* ɵɵpipeBind2 */.xi3(12, 13, ctx_r70.checkTime(ctx_r70.calendarData.f1Calendar.practice1), "EEEE, MMMM d, HH:mm"), " ");
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.practice2Name != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.practice2Name != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.practice3Name != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.practice3Name != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.qualifyingName != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.qualifyingName != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.sprintName != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.sprint != null);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.raceName != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r70.calendarData.f1Calendar.raceName != null);
} }
function F1CountdownComponent_div_20_div_1_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵtemplate */.YNc(0, F1CountdownComponent_div_20_div_1_ng_template_10_div_0_Template, 28, 16, "div", 42);
    core/* ɵɵelement */._UZ(1, "br");
    core/* ɵɵelement */._UZ(2, "br");
    core/* ɵɵelement */._UZ(3, "br");
} if (rf & 2) {
    const ctx_r28 = core/* ɵɵnextContext */.oxw(3);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r28.calendarData != null);
} }
function F1CountdownComponent_div_20_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r85 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 32);
    core/* ɵɵlistener */.NdJ("touchstart", function F1CountdownComponent_div_20_div_1_Template_div_touchstart_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r85); const ctx_r84 = core/* ɵɵnextContext */.oxw(2); return ctx_r84.touchstart($event); })("touchend", function F1CountdownComponent_div_20_div_1_Template_div_touchend_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r85); const ctx_r86 = core/* ɵɵnextContext */.oxw(2); return ctx_r86.touchend($event); });
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_img_1_Template, 1, 0, "img", 33);
    core/* ɵɵelementStart */.TgZ(2, "mat-tab-group", 34);
    core/* ɵɵlistener */.NdJ("selectedIndexChange", function F1CountdownComponent_div_20_div_1_Template_mat_tab_group_selectedIndexChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r85); const ctx_r87 = core/* ɵɵnextContext */.oxw(2); return ctx_r87.selectedTab = $event; })("selectedTabChange", function F1CountdownComponent_div_20_div_1_Template_mat_tab_group_selectedTabChange_2_listener($event) { core/* ɵɵrestoreView */.CHM(_r85); const ctx_r88 = core/* ɵɵnextContext */.oxw(2); return ctx_r88.tabChanged($event); });
    core/* ɵɵtemplate */.YNc(3, F1CountdownComponent_div_20_div_1_mat_tab_3_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_div_1_mat_tab_4_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_div_1_mat_tab_5_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵtemplate */.YNc(6, F1CountdownComponent_div_20_div_1_mat_tab_6_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵtemplate */.YNc(7, F1CountdownComponent_div_20_div_1_mat_tab_7_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵtemplate */.YNc(8, F1CountdownComponent_div_20_div_1_mat_tab_8_Template, 2, 1, "mat-tab", 35);
    core/* ɵɵelementStart */.TgZ(9, "mat-tab", 36);
    core/* ɵɵtemplate */.YNc(10, F1CountdownComponent_div_20_div_1_ng_template_10_Template, 4, 1, "ng-template", 37);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r8 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.overlays.includes("boat"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("selectedIndex", ctx_r8.selectedTab);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.practice1Name != undefined);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.practice2Name != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.practice3Name != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.qualifyingName != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.sprintName != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r8.calendarData.f1Calendar.raceName != undefined);
} }
function F1CountdownComponent_div_20_div_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 57);
    core/* ɵɵelementStart */.TgZ(1, "div", 58);
    core/* ɵɵelementStart */.TgZ(2, "h2");
    core/* ɵɵelementStart */.TgZ(3, "span", 41);
    core/* ɵɵtext */._uU(4, "February 23, 2023 ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵelementStart */.TgZ(7, "span", 45);
    core/* ɵɵtext */._uU(8);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r9 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵadvance */.xp6(8);
    core/* ɵɵtextInterpolate1 */.hij("", ctx_r9.preseasonDays, " days");
} }
function F1CountdownComponent_div_20_img_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 59);
} if (rf & 2) {
    const ctx_r10 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r10.getBottomLeftUrl(), core/* ɵɵsanitizeUrl */.LSH);
} }
function F1CountdownComponent_div_20_img_4_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 60);
} if (rf & 2) {
    const ctx_r11 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("src", ctx_r11.getBottomRightUrl(), core/* ɵɵsanitizeUrl */.LSH);
} }
function F1CountdownComponent_div_20_img_5_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "img", 61);
} if (rf & 2) {
    const ctx_r12 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵstyleMap */.Akn(ctx_r12.movingImageStyle);
    core/* ɵɵproperty */.Q6J("src", ctx_r12.getBottomCenterUrl(), core/* ɵɵsanitizeUrl */.LSH);
} }
function F1CountdownComponent_div_20_div_6_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 62);
} }
function F1CountdownComponent_div_20_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 63);
} }
function F1CountdownComponent_div_20_div_8_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 64);
} }
function F1CountdownComponent_div_20_div_9_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 65);
} }
function F1CountdownComponent_div_20_div_10_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 66);
} }
function F1CountdownComponent_div_20_div_11_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 67);
} }
function F1CountdownComponent_div_20_div_12_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 68);
} }
function F1CountdownComponent_div_20_div_13_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 69);
} }
function F1CountdownComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 18);
    core/* ɵɵtemplate */.YNc(1, F1CountdownComponent_div_20_div_1_Template, 11, 8, "div", 19);
    core/* ɵɵtemplate */.YNc(2, F1CountdownComponent_div_20_div_2_Template, 9, 1, "div", 20);
    core/* ɵɵtemplate */.YNc(3, F1CountdownComponent_div_20_img_3_Template, 1, 1, "img", 21);
    core/* ɵɵtemplate */.YNc(4, F1CountdownComponent_div_20_img_4_Template, 1, 1, "img", 22);
    core/* ɵɵtemplate */.YNc(5, F1CountdownComponent_div_20_img_5_Template, 1, 3, "img", 23);
    core/* ɵɵtemplate */.YNc(6, F1CountdownComponent_div_20_div_6_Template, 1, 0, "div", 24);
    core/* ɵɵtemplate */.YNc(7, F1CountdownComponent_div_20_div_7_Template, 1, 0, "div", 25);
    core/* ɵɵtemplate */.YNc(8, F1CountdownComponent_div_20_div_8_Template, 1, 0, "div", 26);
    core/* ɵɵtemplate */.YNc(9, F1CountdownComponent_div_20_div_9_Template, 1, 0, "div", 27);
    core/* ɵɵtemplate */.YNc(10, F1CountdownComponent_div_20_div_10_Template, 1, 0, "div", 28);
    core/* ɵɵtemplate */.YNc(11, F1CountdownComponent_div_20_div_11_Template, 1, 0, "div", 29);
    core/* ɵɵtemplate */.YNc(12, F1CountdownComponent_div_20_div_12_Template, 1, 0, "div", 30);
    core/* ɵɵtemplate */.YNc(13, F1CountdownComponent_div_20_div_13_Template, 1, 0, "div", 31);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.f1Calendar != null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.f1Calendar == null);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("bottom-left"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("bottom-right"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("bottom-center"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("chika1"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("boat"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("boat"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("winner-ferrari"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("winner-hamilton"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("winner-mercedes"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("winner-redbull-1-2"));
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r2.calendarData.overlays.includes("loser-ferrari"));
} }
function F1CountdownComponent_div_21_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 70);
} }
class F1CountdownComponent {
    constructor(restService, utilityService, toastr, router, route, sanitizer) {
        this.restService = restService;
        this.utilityService = utilityService;
        this.toastr = toastr;
        this.router = router;
        this.route = route;
        this.sanitizer = sanitizer;
        this.raceDays = 0;
        this.raceSeconds = 0;
        this.qualifyingDays = 0;
        this.qualifyingSeconds = 0;
        this.FP3Days = 0;
        this.FP3Seconds = 0;
        this.FP2Days = 0;
        this.FP2Seconds = 0;
        this.FP1Days = 0;
        this.FP1Seconds = 0;
        this.sprintDays = 0;
        this.sprintSeconds = 0;
        this.selectedTab = 4;
        this.unknown = false;
        this.isUtc = false;
        this.isPlayingMusic = false;
        this.itsTime = false;
        this.timezoneOffset = 0;
        this.relativeOffset = 0;
        this.preseasonDays = '?';
        this.utilityService.setTitleDefaultPage(1, 'F1Exposure');
        this.getCountdownData(0);
        this.getSelectedTab();
        this.preseasonCountdown();
        this.setMovingImageStyle(-1000);
    }
    setMovingImageStyle(position) {
        this.movingImageStyle = 'bottom: ' + position + 'px;';
        if (position < 0) {
            setTimeout(() => this.setMovingImageStyle(0), 1000);
        }
    }
    setRandomNumber() {
        this.random_image_number = Math.floor(Math.random() * 30) + 1;
    }
    preseasonCountdown() {
        const testingDate = new Date('2/23/2023');
        const today = new Date();
        const diffTime = Math.abs(testingDate - today);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        this.preseasonDays = diffDays + '';
    }
    getCountdownData(mode) {
        this.restService.getCountdownData(mode).subscribe({
            next: data => {
                if (this.calendarData == null) {
                    this.calendarData = data;
                    this.setupOverlays();
                    this.setTimezoneOffset();
                }
                this.calendarData = data;
                if (this.calendarData == null || this.calendarData.f1Calendar == null) {
                    this.unknown = true;
                    this.setupIframes();
                }
                else {
                    if (mode === 0 || mode === 1) {
                        this.FP1Days = this.calendarData.countdownData.FP1Days;
                        this.FP1Seconds = this.calendarData.countdownData.FP1Seconds;
                    }
                    if (mode === 0 || mode === 2) {
                        this.FP2Days = this.calendarData.countdownData.FP2Days;
                        this.FP2Seconds = this.calendarData.countdownData.FP2Seconds;
                    }
                    if (mode === 0 || mode === 3) {
                        this.FP3Days = this.calendarData.countdownData.FP3Days;
                        this.FP3Seconds = this.calendarData.countdownData.FP3Seconds;
                    }
                    if (mode === 0 || mode === 4) {
                        this.qualifyingDays = this.calendarData.countdownData.qualifyingDays;
                        this.qualifyingSeconds = this.calendarData.countdownData.qualifyingSeconds;
                    }
                    if (mode === 0 || mode === 5) {
                        this.raceDays = this.calendarData.countdownData.raceDays;
                        this.raceSeconds = this.calendarData.countdownData.raceSeconds;
                    }
                    if (mode === 0 || mode === 6) {
                        this.sprintDays = this.calendarData.countdownData.sprintDays;
                        this.sprintSeconds = this.calendarData.countdownData.sprintSeconds;
                    }
                    if (mode === 0) {
                        this.getSelectedTab();
                        this.utilityService.setTitleDefaultPage(1, this.calendarData.f1Calendar.summary);
                    }
                }
                return data;
            },
            'error': error => {
                console.error('There was an error!', error);
                this.calendarData = new CalendarData();
                this.calendarData.countdownData.raceDays = 0;
                this.calendarData.countdownData.raceSeconds = 0;
            }
        });
    }
    countdownWasClicked(tab) {
        let val;
        switch (tab) {
            case 1:
                val = this.calendarData.f1Calendar.practice1Name + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.FP1Seconds);
                break;
            case 2:
                val = this.calendarData.f1Calendar.practice2Name + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.FP2Seconds);
                break;
            case 3:
                val = this.calendarData.f1Calendar.practice3Name + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.FP3Seconds);
                break;
            case 4:
                val = this.calendarData.f1Calendar.qualifyingName + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.qualifyingSeconds);
                break;
            case 5:
                val = this.calendarData.f1Calendar.raceName + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.raceSeconds);
                break;
            case 6:
                val = this.calendarData.f1Calendar.sprintName + ' in: ' + this.getTimeFromSeconds(this.calendarData.countdownData.sprintSeconds);
                break;
            default:
                break;
        }
        const selBox = document.createElement('textarea');
        selBox.style.position = 'fixed';
        selBox.style.left = '0';
        selBox.style.top = '0';
        selBox.style.opacity = '0';
        selBox.value = val;
        document.body.appendChild(selBox);
        selBox.focus();
        selBox.select();
        document.execCommand('copy');
        document.body.removeChild(selBox);
        this.toastr.info('Countdown copied to clipboard', '', {
            timeOut: 4000,
            closeButton: false,
            enableHtml: false,
            toastClass: 'alert alert-info',
            positionClass: 'toast-top-center'
        });
    }
    getTimeFromSeconds(sec_num) {
        const days = Math.floor(sec_num / 86400);
        const hours = Math.floor(sec_num / 3600) % 24;
        const minutes = Math.floor(sec_num / 60) % 60;
        const seconds = sec_num % 60;
        let response = '';
        if (days > 0) {
            response = days + ' days, ';
        }
        response += hours + ' hours, ' + minutes + ' minutes, ' + seconds + ' seconds ';
        return response;
    }
    tabChanged(tabChangeEvent) {
        this.getCountdownData(0);
        //  this.getCountdownData(tabChangeEvent.index + 1);
        this.updateUrl();
    }
    touchstart(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        this.swipeCoord = coord;
        this.swipeTime = time;
    }
    touchend(e) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
        const duration = time - this.swipeTime;
        if (duration < 1000
            && Math.abs(direction[0]) > 30 // Long enough
            && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
            const swipe = direction[0] < 0 ? 'next' : 'previous';
            if (swipe === 'next') {
                const isFirst = this.selectedTab === 0;
                if (this.selectedTab <= 4) {
                    this.selectedTab = isFirst ? 1 : this.selectedTab + 1;
                }
            }
            else if (swipe === 'previous') {
                const isLast = this.selectedTab === 5;
                if (this.selectedTab >= 1) {
                    this.selectedTab = this.selectedTab - 1;
                }
            }
        }
    }
    checkTime(date) {
        if (this.isUtc) {
            return date;
        }
        else {
            const utcDate = new Date(date);
            return new Date(utcDate.getTime() - (this.relativeOffset * 1000 * 60));
        }
    }
    updateUrl() {
        const queryParams = { tab: this.selectedTab + 1 };
        this.router.navigate([], {
            relativeTo: this.route,
            queryParams: queryParams
        });
    }
    toggleMusic(event) {
        localStorage.setItem('f1-play-music', String(event.checked));
        this.runMusic(event.checked);
    }
    runMusicOnStart() {
        if (this.raceSeconds < 3600) {
            this.itsTime = true;
            if (localStorage.getItem('f1-play-music') == null) {
                localStorage.setItem('f1-play-music', String(false));
                this.isPlayingMusic = false;
            }
            else {
                this.isPlayingMusic = localStorage.getItem('f1-play-music') === 'true';
            }
            this.runMusic(this.isPlayingMusic);
        }
        else {
            this.itsTime = false;
            this.isPlayingMusic = false;
        }
    }
    runVerstappenMusicOnStart() {
        this.itsTime = true;
        if (localStorage.getItem('f1-play-music') == null) {
            localStorage.setItem('f1-play-music', String(true));
            this.isPlayingMusic = true;
        }
        else {
            this.isPlayingMusic = localStorage.getItem('f1-play-music') === 'true';
        }
        this.runMusic(this.isPlayingMusic);
    }
    runMusic(bool) {
        let element;
        if (bool) {
            element = document.getElementById('youtube1');
            if (element == null) {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.id = 'youtube1';
                // buildUp
                // iframe.src = 'https://www.youtube.com/embed/jKlL6wvGrbc?autoplay=1';
                // superMax
                iframe.src = 'https://www.youtube.com/embed/ZBJCgrrQhx4?start=10&autoplay=1';
                iframe.allow = 'autoplay; encrypted-media';
                document.body.appendChild(iframe);
            }
        }
        else {
            element = document.getElementById('youtube1');
            if (element != null) {
                const frame = document.getElementById('youtube1');
                frame.parentNode.removeChild(frame);
            }
        }
    }
    setupIframes() {
        const url = this.calendarData.iframeLink;
        if (url.includes('youtube')) {
            this.utilityService.setReferrerToOrigin();
        }
        this.iframeLink = this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    setupOverlays() {
        if (this.calendarData.overlays.includes('boat')) {
            let root = document.documentElement;
            root.style.setProperty('--f1-countdown-color', "#ffc107");
        }
    }
    setTimezoneOffset() {
        this.timezoneOffset = new Date().getTimezoneOffset();
        this.relativeOffset = this.timezoneOffset;
    }
    getSelectedTab() {
        const tab = this.route.snapshot.queryParamMap.get('tab');
        if (tab == null) {
            this.selectedTab = this.getSelectedTabByCalendarData();
        }
        else {
            this.selectedTab = Number(tab) - 1;
        }
    }
    getSelectedTabByCalendarData() {
        if (this.FP1Days > 0) {
            return 4;
        }
        else if (this.FP1Days == 0 && this.FP1Seconds > 0) {
            return 0;
        }
        else if (this.FP2Days == 0 && this.FP2Seconds > 0) {
            return 1;
        }
        else if (this.FP3Days == 0 && this.FP3Seconds > 0) {
            return 2;
        }
        else if (this.qualifyingDays == 0 && this.qualifyingSeconds > 0) {
            return 3;
        }
        else if (this.sprintSeconds > 0) {
            return 3;
        }
        else {
            return 4;
        }
    }
    getBottomRightUrl() {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/MD_bottomRight_wp';
    }
    getBottomLeftUrl() {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/MD_bottomLeft_wp';
    }
    getBottomCenterUrl() {
        return environment/* environment.f1exposureUrl */.N.f1exposureUrl + 'image/bottom-center-wp';
    }
}
F1CountdownComponent.ɵfac = function F1CountdownComponent_Factory(t) { return new (t || F1CountdownComponent)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(utility_service/* UtilityService */.t), core/* ɵɵdirectiveInject */.Y36(ngx_toastr/* ToastrService */._W), core/* ɵɵdirectiveInject */.Y36(router/* Router */.F0), core/* ɵɵdirectiveInject */.Y36(router/* ActivatedRoute */.gz), core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7)); };
F1CountdownComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: F1CountdownComponent, selectors: [["app-f1-countdown-cmp"]], viewQuery: function F1CountdownComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(f1_countdown_component_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.countdown = _t.first);
    } }, decls: 22, vars: 5, consts: [[1, "mat-drawer-no-overflow"], ["mode", "side", "position", "end", 1, "example-sidenav", 3, "opened", "openedChange"], ["drawer", ""], [1, "row"], [1, "col-md-12"], ["matInput", "", "placeholder", "Leave a comment", 1, "chat-text-area", 3, "ngModel", "ngModelChange"], [1, "post-comment"], ["mat-flat-button", "", 1, "active-color-button", 3, "click"], [4, "ngFor", "ngForOf"], [1, "fixed-button"], ["type", "fixed-plugin", "mat-button", "", 3, "click"], [1, "fa", "fa-commenting-o", "fa-2x"], ["class", "height-fill-screen", 4, "ngIf"], ["class", "max-on-top-div", 4, "ngIf"], [1, "basic-comment"], [1, "header-left", "hover-pointer", 3, "click"], [1, "header-right", "hover-pointer", 3, "click"], [1, "basic-comment-body"], [1, "height-fill-screen"], ["class", "mat-content", 3, "touchstart", "touchend", 4, "ngIf"], ["class", "\u201Dmat-content\u201D", 4, "ngIf"], ["class", "bottom-left-image", "alt", "bottom-left-image", 3, "src", 4, "ngIf"], ["class", "bottom-right-image", "alt", "bottom-right-image", 3, "src", 4, "ngIf"], ["class", "bottom-center-image max-height-40-vh", "alt", "bottom-center-image", 3, "style", "src", 4, "ngIf"], ["class", "chika-div overlay-bottom-div-fixed overlay-animation-1", 4, "ngIf"], ["class", "boat-div overlay-bottom-div-fixed overlay-animation-boat-1", 4, "ngIf"], ["class", "boat-div overlay-bottom-div-fixed overlay-animation-boat-2", 4, "ngIf"], ["class", "forza-ferrari-div overlay-top-right-div-fixed", 4, "ngIf"], ["class", "hamilton-div overlay-bottom-right-div-fixed", 4, "ngIf"], ["class", "toto-div overlay-bottom-right-div-fixed", 4, "ngIf"], ["class", "redbull-1-2-div overlay-bottom-right-div-fixed-2", 4, "ngIf"], ["class", "fail-ferrari-div overlay-bottom-left-div-fixed", 4, "ngIf"], [1, "mat-content", 3, "touchstart", "touchend"], ["class", "basic-bg-1", "src", "assets/img/overlays/miami_waters1.jpg", "alt", "transparent-bg", 4, "ngIf"], [3, "selectedIndex", "selectedIndexChange", "selectedTabChange"], [3, "label", 4, "ngIf"], ["label", "Start times"], ["matTabContent", ""], ["src", "assets/img/overlays/miami_waters1.jpg", "alt", "transparent-bg", 1, "basic-bg-1"], [3, "label"], [3, "click"], [1, "countdown-desc", "f1-glow"], [4, "ngIf"], [3, "config"], ["cd", ""], [1, "count-down"], [3, "ngModel", "change", "ngModelChange", 4, "ngIf"], [3, "click", 4, "ngIf"], [3, "ngModel", "change", "ngModelChange"], [1, "nc-icon", "nc-note-03"], [1, "div-padded-always-1rem"], [3, "ngModel", "ngModelChange"], ["class", "col-lg-5 countdown-desc-2 text-lg-right", 4, "ngIf"], [1, "col-lg-7", "countdown-desc-2", "text-lg-left"], [1, "col-12", "mobile-space"], ["class", "col-lg-7 countdown-desc-2 text-lg-left", 4, "ngIf"], [1, "col-lg-5", "countdown-desc-2", "text-lg-right"], [1, "\u201Dmat-content\u201D"], [1, "pt-5"], ["alt", "bottom-left-image", 1, "bottom-left-image", 3, "src"], ["alt", "bottom-right-image", 1, "bottom-right-image", 3, "src"], ["alt", "bottom-center-image", 1, "bottom-center-image", "max-height-40-vh", 3, "src"], [1, "chika-div", "overlay-bottom-div-fixed", "overlay-animation-1"], [1, "boat-div", "overlay-bottom-div-fixed", "overlay-animation-boat-1"], [1, "boat-div", "overlay-bottom-div-fixed", "overlay-animation-boat-2"], [1, "forza-ferrari-div", "overlay-top-right-div-fixed"], [1, "hamilton-div", "overlay-bottom-right-div-fixed"], [1, "toto-div", "overlay-bottom-right-div-fixed"], [1, "redbull-1-2-div", "overlay-bottom-right-div-fixed-2"], [1, "fail-ferrari-div", "overlay-bottom-left-div-fixed"], [1, "max-on-top-div"]], template: function F1CountdownComponent_Template(rf, ctx) { if (rf & 1) {
        const _r89 = core/* ɵɵgetCurrentView */.EpF();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵelementStart */.TgZ(1, "mat-drawer-container", 0);
        core/* ɵɵelementStart */.TgZ(2, "mat-drawer", 1, 2);
        core/* ɵɵlistener */.NdJ("openedChange", function F1CountdownComponent_Template_mat_drawer_openedChange_2_listener($event) { return ctx.utilityService.setSidebarStatus($event); });
        core/* ɵɵelementStart */.TgZ(4, "div", 3);
        core/* ɵɵelementStart */.TgZ(5, "div", 4);
        core/* ɵɵelementStart */.TgZ(6, "div");
        core/* ɵɵelementStart */.TgZ(7, "textarea", 5);
        core/* ɵɵlistener */.NdJ("ngModelChange", function F1CountdownComponent_Template_textarea_ngModelChange_7_listener($event) { return ctx.utilityService.postText = $event; });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(8, "div", 6);
        core/* ɵɵelementStart */.TgZ(9, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_Template_button_click_9_listener() { return ctx.utilityService.postComment(1); });
        core/* ɵɵtext */._uU(10, "Post ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(11, "button", 7);
        core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_Template_button_click_11_listener() { return ctx.utilityService.reloadPosts(1); });
        core/* ɵɵtext */._uU(12, "Reload ");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(13, F1CountdownComponent_div_13_Template, 8, 3, "div", 8);
        core/* ɵɵelementStart */.TgZ(14, "div", 9);
        core/* ɵɵelementStart */.TgZ(15, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_Template_button_click_15_listener() { core/* ɵɵrestoreView */.CHM(_r89); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(16, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementStart */.TgZ(17, "div", 9);
        core/* ɵɵelementStart */.TgZ(18, "button", 10);
        core/* ɵɵlistener */.NdJ("click", function F1CountdownComponent_Template_button_click_18_listener() { core/* ɵɵrestoreView */.CHM(_r89); const _r0 = core/* ɵɵreference */.MAs(3); return ctx.utilityService.drawerToggle(_r0); });
        core/* ɵɵelement */._UZ(19, "i", 11);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(20, F1CountdownComponent_div_20_Template, 14, 13, "div", 12);
        core/* ɵɵtemplate */.YNc(21, F1CountdownComponent_div_21_Template, 1, 0, "div", 13);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵpropertyInterpolate */.s9C("opened", ctx.utilityService.getSidebarStatus());
        core/* ɵɵadvance */.xp6(5);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.utilityService.postText);
        core/* ɵɵadvance */.xp6(6);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.utilityService.comments);
        core/* ɵɵadvance */.xp6(7);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.calendarData != null);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", ctx.calendarData != null && ctx.calendarData.overlays.includes("winner-verstappen") && ctx.selectedTab != 5);
    } }, directives: [sidenav/* MatDrawerContainer */.kh, sidenav/* MatDrawer */.jA, MatInput, fesm2015_forms/* DefaultValueAccessor */.Fj, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, fesm2015_button/* MatButton */.lW, common/* NgForOf */.sg, common/* NgIf */.O5, tabs/* MatTabGroup */.SP, tabs/* MatTab */.uX, tabs/* MatTabContent */.Vc, ngx_countdown/* CountdownComponent */.MR, slide_toggle/* MatSlideToggle */.Rr], pipes: [common/* DatePipe */.uU], styles: [""] });

;// CONCATENATED MODULE: ./src/app/layouts/admin-layout/admin-layout.routing.ts
























const AdminLayoutRoutes = [
    { path: 'countdown', component: F1CountdownComponent },
    { path: 'exposure/obsolete', component: ExposureComponent },
    { path: 'exposure', component: ExposedComponent },
    { path: 'championship', component: StandingsComponent },
    { path: 'database/drivers', component: DriversComponent },
    { path: 'database/seasons', component: SeasonsComponent },
    { path: 'database/circuit', component: CircuitComponent },
    { path: 'database/constructors', component: ConstructorsComponent },
    { path: 'database', component: DatabaseComponent },
    { path: 'contact-info', component: ContactInfoComponent },
    { path: 'videostreams', component: VideostreamsComponent },
    { path: 'posts', component: NewsSectionComponent },
    { path: 'posts/post', component: NewsComponent },
    { path: 'news', component: NewsSectionComponent },
    { path: 'news/post', component: NewsComponent },
    { path: 'aws-demo', component: AwsDemoComponent },
    { path: 'carousel', component: NgbdCarouselConfig },
    { path: 'art', component: ArtCarousel },
    { path: 'upcomingRaceAnalysis', component: UpcomingRaceAnalysisComponent },
    { path: 'raceAnalysis', component: RaceAnalysisComponent },
    { path: 'imageFeed', component: ImageFeedComponent },
    { path: 'moderator', component: ModeratorComponent },
    { path: 'radio', component: RadioComponent },
    { path: 'tifosi', component: TifosiComponent },
    { path: 'icons', component: IconsComponent },
    { path: 'social', component: SocialComponent }
];

;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/grid-list.js





/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
 * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
 * because the tiles can have a rowspan.
 *
 * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
 * large enough to accommodate it so that the tiles still render in the same order in which they
 * are given.
 *
 * The basis of the algorithm is the use of an array to track the already placed tiles. Each
 * element of the array corresponds to a column, and the value indicates how many cells in that
 * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
 * decrements each value in the tracking array (indicating that the column is one cell closer to
 * being free).
 *
 * @docs-private
 */



const grid_list_c0 = ["*"];
const grid_list_c1 = [[["", "mat-grid-avatar", ""], ["", "matGridAvatar", ""]], [["", "mat-line", ""], ["", "matLine", ""]], "*"];
const grid_list_c2 = ["[mat-grid-avatar], [matGridAvatar]", "[mat-line], [matLine]", "*"];
const grid_list_c3 = ".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n";
class TileCoordinator {
    constructor() {
        /** Index at which the search for the next gap will start. */
        this.columnIndex = 0;
        /** The current row index. */
        this.rowIndex = 0;
    }
    /** Gets the total number of rows occupied by tiles */
    get rowCount() { return this.rowIndex + 1; }
    /**
     * Gets the total span of rows occupied by tiles.
     * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
     */
    get rowspan() {
        const lastRowMax = Math.max(...this.tracker);
        // if any of the tiles has a rowspan that pushes it beyond the total row count,
        // add the difference to the rowcount
        return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
    }
    /**
     * Updates the tile positions.
     * @param numColumns Amount of columns in the grid.
     * @param tiles Tiles to be positioned.
     */
    update(numColumns, tiles) {
        this.columnIndex = 0;
        this.rowIndex = 0;
        this.tracker = new Array(numColumns);
        this.tracker.fill(0, 0, this.tracker.length);
        this.positions = tiles.map(tile => this._trackTile(tile));
    }
    /** Calculates the row and col position of a tile. */
    _trackTile(tile) {
        // Find a gap large enough for this tile.
        const gapStartIndex = this._findMatchingGap(tile.colspan);
        // Place tile in the resulting gap.
        this._markTilePosition(gapStartIndex, tile);
        // The next time we look for a gap, the search will start at columnIndex, which should be
        // immediately after the tile that has just been placed.
        this.columnIndex = gapStartIndex + tile.colspan;
        return new TilePosition(this.rowIndex, gapStartIndex);
    }
    /** Finds the next available space large enough to fit the tile. */
    _findMatchingGap(tileCols) {
        if (tileCols > this.tracker.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`mat-grid-list: tile with colspan ${tileCols} is wider than ` +
                `grid with cols="${this.tracker.length}".`);
        }
        // Start index is inclusive, end index is exclusive.
        let gapStartIndex = -1;
        let gapEndIndex = -1;
        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
        do {
            // If we've reached the end of the row, go to the next row.
            if (this.columnIndex + tileCols > this.tracker.length) {
                this._nextRow();
                gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                gapEndIndex = this._findGapEndIndex(gapStartIndex);
                continue;
            }
            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
            // If there are no more empty spaces in this row at all, move on to the next row.
            if (gapStartIndex == -1) {
                this._nextRow();
                gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                gapEndIndex = this._findGapEndIndex(gapStartIndex);
                continue;
            }
            gapEndIndex = this._findGapEndIndex(gapStartIndex);
            // If a gap large enough isn't found, we want to start looking immediately after the current
            // gap on the next iteration.
            this.columnIndex = gapStartIndex + 1;
            // Continue iterating until we find a gap wide enough for this tile. Since gapEndIndex is
            // exclusive, gapEndIndex is 0 means we didn't find a gap and should continue.
        } while ((gapEndIndex - gapStartIndex < tileCols) || (gapEndIndex == 0));
        // If we still didn't manage to find a gap, ensure that the index is
        // at least zero so the tile doesn't get pulled out of the grid.
        return Math.max(gapStartIndex, 0);
    }
    /** Move "down" to the next row. */
    _nextRow() {
        this.columnIndex = 0;
        this.rowIndex++;
        // Decrement all spaces by one to reflect moving down one row.
        for (let i = 0; i < this.tracker.length; i++) {
            this.tracker[i] = Math.max(0, this.tracker[i] - 1);
        }
    }
    /**
     * Finds the end index (exclusive) of a gap given the index from which to start looking.
     * The gap ends when a non-zero value is found.
     */
    _findGapEndIndex(gapStartIndex) {
        for (let i = gapStartIndex + 1; i < this.tracker.length; i++) {
            if (this.tracker[i] != 0) {
                return i;
            }
        }
        // The gap ends with the end of the row.
        return this.tracker.length;
    }
    /** Update the tile tracker to account for the given tile in the given space. */
    _markTilePosition(start, tile) {
        for (let i = 0; i < tile.colspan; i++) {
            this.tracker[start + i] = tile.rowspan;
        }
    }
}
/**
 * Simple data structure for tile position (row, col).
 * @docs-private
 */
class TilePosition {
    constructor(row, col) {
        this.row = row;
        this.col = col;
    }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection token used to provide a grid list to a tile and to avoid circular imports.
 * @docs-private
 */
const MAT_GRID_LIST = new core/* InjectionToken */.OlP('MAT_GRID_LIST');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatGridTile {
    constructor(_element, _gridList) {
        this._element = _element;
        this._gridList = _gridList;
        this._rowspan = 1;
        this._colspan = 1;
    }
    /** Amount of rows that the grid tile takes up. */
    get rowspan() { return this._rowspan; }
    set rowspan(value) { this._rowspan = Math.round((0,coercion/* coerceNumberProperty */.su)(value)); }
    /** Amount of columns that the grid tile takes up. */
    get colspan() { return this._colspan; }
    set colspan(value) { this._colspan = Math.round((0,coercion/* coerceNumberProperty */.su)(value)); }
    /**
     * Sets the style of the grid-tile element.  Needs to be set manually to avoid
     * "Changed after checked" errors that would occur with HostBinding.
     */
    _setStyle(property, value) {
        this._element.nativeElement.style[property] = value;
    }
}
MatGridTile.ɵfac = function MatGridTile_Factory(t) { return new (t || MatGridTile)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(MAT_GRID_LIST, 8)); };
MatGridTile.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatGridTile, selectors: [["mat-grid-tile"]], hostAttrs: [1, "mat-grid-tile"], hostVars: 2, hostBindings: function MatGridTile_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵattribute */.uIk("rowspan", ctx.rowspan)("colspan", ctx.colspan);
    } }, inputs: { rowspan: "rowspan", colspan: "colspan" }, exportAs: ["matGridTile"], ngContentSelectors: grid_list_c0, decls: 2, vars: 0, consts: [[1, "mat-grid-tile-content"]], template: function MatGridTile_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t();
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵprojection */.Hsn(1);
        core/* ɵɵelementEnd */.qZA();
    } }, styles: [grid_list_c3], encapsulation: 2, changeDetection: 0 });
MatGridTile.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_GRID_LIST,] }] }
];
MatGridTile.propDecorators = {
    rowspan: [{ type: core/* Input */.IIB }],
    colspan: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridTile, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-grid-tile',
                exportAs: 'matGridTile',
                host: {
                    'class': 'mat-grid-tile',
                    // Ensures that the "rowspan" and "colspan" input value is reflected in
                    // the DOM. This is needed for the grid-tile harness.
                    '[attr.rowspan]': 'rowspan',
                    '[attr.colspan]': 'colspan'
                },
                template: "<div class=\"mat-grid-tile-content\">\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_GRID_LIST]
            }] }]; }, { rowspan: [{
            type: core/* Input */.IIB
        }], colspan: [{
            type: core/* Input */.IIB
        }] }); })();
class MatGridTileText {
    constructor(_element) {
        this._element = _element;
    }
    ngAfterContentInit() {
        (0,fesm2015_core/* setLines */.E0)(this._lines, this._element);
    }
}
MatGridTileText.ɵfac = function MatGridTileText_Factory(t) { return new (t || MatGridTileText)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq)); };
MatGridTileText.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatGridTileText, selectors: [["mat-grid-tile-header"], ["mat-grid-tile-footer"]], contentQueries: function MatGridTileText_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, fesm2015_core/* MatLine */.X2, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._lines = _t);
    } }, ngContentSelectors: grid_list_c2, decls: 4, vars: 0, consts: [[1, "mat-grid-list-text"]], template: function MatGridTileText_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t(grid_list_c1);
        core/* ɵɵprojection */.Hsn(0);
        core/* ɵɵelementStart */.TgZ(1, "div", 0);
        core/* ɵɵprojection */.Hsn(2, 1);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵprojection */.Hsn(3, 2);
    } }, encapsulation: 2, changeDetection: 0 });
MatGridTileText.ctorParameters = () => [
    { type: core/* ElementRef */.SBq }
];
MatGridTileText.propDecorators = {
    _lines: [{ type: core/* ContentChildren */.AcB, args: [fesm2015_core/* MatLine */.X2, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridTileText, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-grid-tile-header, mat-grid-tile-footer',
                template: "<ng-content select=\"[mat-grid-avatar], [matGridAvatar]\"></ng-content>\n<div class=\"mat-grid-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div>\n<ng-content></ng-content>\n",
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                encapsulation: core/* ViewEncapsulation.None */.ifc.None
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }]; }, { _lines: [{
            type: core/* ContentChildren */.AcB,
            args: [fesm2015_core/* MatLine */.X2, { descendants: true }]
        }] }); })();
/**
 * Directive whose purpose is to add the mat- CSS styling to this selector.
 * @docs-private
 */
class MatGridAvatarCssMatStyler {
}
MatGridAvatarCssMatStyler.ɵfac = function MatGridAvatarCssMatStyler_Factory(t) { return new (t || MatGridAvatarCssMatStyler)(); };
MatGridAvatarCssMatStyler.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatGridAvatarCssMatStyler, selectors: [["", "mat-grid-avatar", ""], ["", "matGridAvatar", ""]], hostAttrs: [1, "mat-grid-avatar"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridAvatarCssMatStyler, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[mat-grid-avatar], [matGridAvatar]',
                host: { 'class': 'mat-grid-avatar' }
            }]
    }], null, null); })();
/**
 * Directive whose purpose is to add the mat- CSS styling to this selector.
 * @docs-private
 */
class MatGridTileHeaderCssMatStyler {
}
MatGridTileHeaderCssMatStyler.ɵfac = function MatGridTileHeaderCssMatStyler_Factory(t) { return new (t || MatGridTileHeaderCssMatStyler)(); };
MatGridTileHeaderCssMatStyler.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatGridTileHeaderCssMatStyler, selectors: [["mat-grid-tile-header"]], hostAttrs: [1, "mat-grid-tile-header"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridTileHeaderCssMatStyler, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-grid-tile-header',
                host: { 'class': 'mat-grid-tile-header' }
            }]
    }], null, null); })();
/**
 * Directive whose purpose is to add the mat- CSS styling to this selector.
 * @docs-private
 */
class MatGridTileFooterCssMatStyler {
}
MatGridTileFooterCssMatStyler.ɵfac = function MatGridTileFooterCssMatStyler_Factory(t) { return new (t || MatGridTileFooterCssMatStyler)(); };
MatGridTileFooterCssMatStyler.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatGridTileFooterCssMatStyler, selectors: [["mat-grid-tile-footer"]], hostAttrs: [1, "mat-grid-tile-footer"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridTileFooterCssMatStyler, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: 'mat-grid-tile-footer',
                host: { 'class': 'mat-grid-tile-footer' }
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * RegExp that can be used to check whether a value will
 * be allowed inside a CSS `calc()` expression.
 */
const cssCalcAllowedValue = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;
/**
 * Sets the style properties for an individual tile, given the position calculated by the
 * Tile Coordinator.
 * @docs-private
 */
class TileStyler {
    constructor() {
        this._rows = 0;
        this._rowspan = 0;
    }
    /**
     * Adds grid-list layout info once it is available. Cannot be processed in the constructor
     * because these properties haven't been calculated by that point.
     *
     * @param gutterSize Size of the grid's gutter.
     * @param tracker Instance of the TileCoordinator.
     * @param cols Amount of columns in the grid.
     * @param direction Layout direction of the grid.
     */
    init(gutterSize, tracker, cols, direction) {
        this._gutterSize = normalizeUnits(gutterSize);
        this._rows = tracker.rowCount;
        this._rowspan = tracker.rowspan;
        this._cols = cols;
        this._direction = direction;
    }
    /**
     * Computes the amount of space a single 1x1 tile would take up (width or height).
     * Used as a basis for other calculations.
     * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
     * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
     * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
     */
    getBaseTileSize(sizePercent, gutterFraction) {
        // Take the base size percent (as would be if evenly dividing the size between cells),
        // and then subtracting the size of one gutter. However, since there are no gutters on the
        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
        // edge evenly among the cells).
        return `(${sizePercent}% - (${this._gutterSize} * ${gutterFraction}))`;
    }
    /**
     * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
     * @param offset Number of tiles that have already been rendered in the row/column.
     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
     * @return Position of the tile as a CSS calc() expression.
     */
    getTilePosition(baseSize, offset) {
        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
        // row/column (offset).
        return offset === 0 ? '0' : calc(`(${baseSize} + ${this._gutterSize}) * ${offset}`);
    }
    /**
     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
     * @param span The tile's rowspan or colspan.
     * @return Size of the tile as a CSS calc() expression.
     */
    getTileSize(baseSize, span) {
        return `(${baseSize} * ${span}) + (${span - 1} * ${this._gutterSize})`;
    }
    /**
     * Sets the style properties to be applied to a tile for the given row and column index.
     * @param tile Tile to which to apply the styling.
     * @param rowIndex Index of the tile's row.
     * @param colIndex Index of the tile's column.
     */
    setStyle(tile, rowIndex, colIndex) {
        // Percent of the available horizontal space that one column takes up.
        let percentWidthPerTile = 100 / this._cols;
        // Fraction of the vertical gutter size that each column takes up.
        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
        let gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
    }
    /** Sets the horizontal placement of the tile in the list. */
    setColStyles(tile, colIndex, percentWidth, gutterWidth) {
        // Base horizontal size of a column.
        let baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
        // The width and horizontal position of each tile is always calculated the same way, but the
        // height and vertical position depends on the rowMode.
        let side = this._direction === 'rtl' ? 'right' : 'left';
        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
        tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
    }
    /**
     * Calculates the total size taken up by gutters across one axis of a list.
     */
    getGutterSpan() {
        return `${this._gutterSize} * (${this._rowspan} - 1)`;
    }
    /**
     * Calculates the total size taken up by tiles across one axis of a list.
     * @param tileHeight Height of the tile.
     */
    getTileSpan(tileHeight) {
        return `${this._rowspan} * ${this.getTileSize(tileHeight, 1)}`;
    }
    /**
     * Calculates the computed height and returns the correct style property to set.
     * This method can be implemented by each type of TileStyler.
     * @docs-private
     */
    getComputedHeight() { return null; }
}
/**
 * This type of styler is instantiated when the user passes in a fixed row height.
 * Example `<mat-grid-list cols="3" rowHeight="100px">`
 * @docs-private
 */
class FixedTileStyler extends TileStyler {
    constructor(fixedRowHeight) {
        super();
        this.fixedRowHeight = fixedRowHeight;
    }
    init(gutterSize, tracker, cols, direction) {
        super.init(gutterSize, tracker, cols, direction);
        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
        if (!cssCalcAllowedValue.test(this.fixedRowHeight) &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`Invalid value "${this.fixedRowHeight}" set as rowHeight.`);
        }
    }
    setRowStyles(tile, rowIndex) {
        tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
        tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
    }
    getComputedHeight() {
        return [
            'height', calc(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)
        ];
    }
    reset(list) {
        list._setListStyle(['height', null]);
        if (list._tiles) {
            list._tiles.forEach(tile => {
                tile._setStyle('top', null);
                tile._setStyle('height', null);
            });
        }
    }
}
/**
 * This type of styler is instantiated when the user passes in a width:height ratio
 * for the row height.  Example `<mat-grid-list cols="3" rowHeight="3:1">`
 * @docs-private
 */
class RatioTileStyler extends TileStyler {
    constructor(value) {
        super();
        this._parseRatio(value);
    }
    setRowStyles(tile, rowIndex, percentWidth, gutterWidth) {
        let percentHeightPerTile = percentWidth / this.rowHeightRatio;
        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
        // Use padding-top and margin-top to maintain the given aspect ratio, as
        // a percentage-based value for these properties is applied versus the *width* of the
        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
        tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
        tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
    }
    getComputedHeight() {
        return [
            'paddingBottom', calc(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)
        ];
    }
    reset(list) {
        list._setListStyle(['paddingBottom', null]);
        list._tiles.forEach(tile => {
            tile._setStyle('marginTop', null);
            tile._setStyle('paddingTop', null);
        });
    }
    _parseRatio(value) {
        const ratioParts = value.split(':');
        if (ratioParts.length !== 2 && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`mat-grid-list: invalid ratio given for row-height: "${value}"`);
        }
        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
    }
}
/**
 * This type of styler is instantiated when the user selects a "fit" row height mode.
 * In other words, the row height will reflect the total height of the container divided
 * by the number of rows.  Example `<mat-grid-list cols="3" rowHeight="fit">`
 *
 * @docs-private
 */
class FitTileStyler extends TileStyler {
    setRowStyles(tile, rowIndex) {
        // Percent of the available vertical space that one row takes up.
        let percentHeightPerTile = 100 / this._rowspan;
        // Fraction of the horizontal gutter size that each column takes up.
        let gutterHeightPerTile = (this._rows - 1) / this._rows;
        // Base vertical size of a column.
        let baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
        tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
        tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
    }
    reset(list) {
        if (list._tiles) {
            list._tiles.forEach(tile => {
                tile._setStyle('top', null);
                tile._setStyle('height', null);
            });
        }
    }
}
/** Wraps a CSS string in a calc function */
function calc(exp) {
    return `calc(${exp})`;
}
/** Appends pixels to a CSS string if no units are given. */
function normalizeUnits(value) {
    return value.match(/([A-Za-z%]+)$/) ? value : `${value}px`;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// TODO(kara): Conditional (responsive) column count / row size.
// TODO(kara): Re-layout on window resize / media change (debounced).
// TODO(kara): gridTileHeader and gridTileFooter.
const MAT_FIT_MODE = 'fit';
class MatGridList {
    constructor(_element, _dir) {
        this._element = _element;
        this._dir = _dir;
        /** The amount of space between tiles. This will be something like '5px' or '2em'. */
        this._gutter = '1px';
    }
    /** Amount of columns in the grid list. */
    get cols() { return this._cols; }
    set cols(value) {
        this._cols = Math.max(1, Math.round((0,coercion/* coerceNumberProperty */.su)(value)));
    }
    /** Size of the grid list's gutter in pixels. */
    get gutterSize() { return this._gutter; }
    set gutterSize(value) { this._gutter = `${value == null ? '' : value}`; }
    /** Set internal representation of row height from the user-provided value. */
    get rowHeight() { return this._rowHeight; }
    set rowHeight(value) {
        const newValue = `${value == null ? '' : value}`;
        if (newValue !== this._rowHeight) {
            this._rowHeight = newValue;
            this._setTileStyler(this._rowHeight);
        }
    }
    ngOnInit() {
        this._checkCols();
        this._checkRowHeight();
    }
    /**
     * The layout calculation is fairly cheap if nothing changes, so there's little cost
     * to run it frequently.
     */
    ngAfterContentChecked() {
        this._layoutTiles();
    }
    /** Throw a friendly error if cols property is missing */
    _checkCols() {
        if (!this.cols && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error(`mat-grid-list: must pass in number of columns. ` +
                `Example: <mat-grid-list cols="3">`);
        }
    }
    /** Default to equal width:height if rowHeight property is missing */
    _checkRowHeight() {
        if (!this._rowHeight) {
            this._setTileStyler('1:1');
        }
    }
    /** Creates correct Tile Styler subtype based on rowHeight passed in by user */
    _setTileStyler(rowHeight) {
        if (this._tileStyler) {
            this._tileStyler.reset(this);
        }
        if (rowHeight === MAT_FIT_MODE) {
            this._tileStyler = new FitTileStyler();
        }
        else if (rowHeight && rowHeight.indexOf(':') > -1) {
            this._tileStyler = new RatioTileStyler(rowHeight);
        }
        else {
            this._tileStyler = new FixedTileStyler(rowHeight);
        }
    }
    /** Computes and applies the size and position for all children grid tiles. */
    _layoutTiles() {
        if (!this._tileCoordinator) {
            this._tileCoordinator = new TileCoordinator();
        }
        const tracker = this._tileCoordinator;
        const tiles = this._tiles.filter(tile => !tile._gridList || tile._gridList === this);
        const direction = this._dir ? this._dir.value : 'ltr';
        this._tileCoordinator.update(this.cols, tiles);
        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
        tiles.forEach((tile, index) => {
            const pos = tracker.positions[index];
            this._tileStyler.setStyle(tile, pos.row, pos.col);
        });
        this._setListStyle(this._tileStyler.getComputedHeight());
    }
    /** Sets style on the main grid-list element, given the style name and value. */
    _setListStyle(style) {
        if (style) {
            this._element.nativeElement.style[style[0]] = style[1];
        }
    }
}
MatGridList.ɵfac = function MatGridList_Factory(t) { return new (t || MatGridList)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8)); };
MatGridList.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatGridList, selectors: [["mat-grid-list"]], contentQueries: function MatGridList_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatGridTile, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx._tiles = _t);
    } }, hostAttrs: [1, "mat-grid-list"], hostVars: 1, hostBindings: function MatGridList_HostBindings(rf, ctx) { if (rf & 2) {
        core/* ɵɵattribute */.uIk("cols", ctx.cols);
    } }, inputs: { cols: "cols", gutterSize: "gutterSize", rowHeight: "rowHeight" }, exportAs: ["matGridList"], features: [core/* ɵɵProvidersFeature */._Bn([{
                provide: MAT_GRID_LIST,
                useExisting: MatGridList
            }])], ngContentSelectors: grid_list_c0, decls: 2, vars: 0, template: function MatGridList_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t();
        core/* ɵɵelementStart */.TgZ(0, "div");
        core/* ɵɵprojection */.Hsn(1);
        core/* ɵɵelementEnd */.qZA();
    } }, styles: [grid_list_c3], encapsulation: 2, changeDetection: 0 });
MatGridList.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] }
];
MatGridList.propDecorators = {
    _tiles: [{ type: core/* ContentChildren */.AcB, args: [MatGridTile, { descendants: true },] }],
    cols: [{ type: core/* Input */.IIB }],
    gutterSize: [{ type: core/* Input */.IIB }],
    rowHeight: [{ type: core/* Input */.IIB }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridList, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-grid-list',
                exportAs: 'matGridList',
                template: "<div>\n  <ng-content></ng-content>\n</div>",
                host: {
                    'class': 'mat-grid-list',
                    // Ensures that the "cols" input value is reflected in the DOM. This is
                    // needed for the grid-list harness.
                    '[attr.cols]': 'cols'
                },
                providers: [{
                        provide: MAT_GRID_LIST,
                        useExisting: MatGridList
                    }],
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n"]
            }]
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }]; }, { cols: [{
            type: core/* Input */.IIB
        }], gutterSize: [{
            type: core/* Input */.IIB
        }], rowHeight: [{
            type: core/* Input */.IIB
        }], _tiles: [{
            type: core/* ContentChildren */.AcB,
            args: [MatGridTile, { descendants: true }]
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatGridListModule {
}
MatGridListModule.ɵfac = function MatGridListModule_Factory(t) { return new (t || MatGridListModule)(); };
MatGridListModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatGridListModule });
MatGridListModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[fesm2015_core/* MatLineModule */.uc, fesm2015_core/* MatCommonModule */.BQ], fesm2015_core/* MatLineModule */.uc,
        fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatGridListModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [fesm2015_core/* MatLineModule */.uc, fesm2015_core/* MatCommonModule */.BQ],
                exports: [
                    MatGridList,
                    MatGridTile,
                    MatGridTileText,
                    fesm2015_core/* MatLineModule */.uc,
                    fesm2015_core/* MatCommonModule */.BQ,
                    MatGridTileHeaderCssMatStyler,
                    MatGridTileFooterCssMatStyler,
                    MatGridAvatarCssMatStyler
                ],
                declarations: [
                    MatGridList,
                    MatGridTile,
                    MatGridTileText,
                    MatGridTileHeaderCssMatStyler,
                    MatGridTileFooterCssMatStyler,
                    MatGridAvatarCssMatStyler
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatGridListModule, { declarations: function () { return [MatGridList, MatGridTile, MatGridTileText, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler]; }, imports: function () { return [fesm2015_core/* MatLineModule */.uc, fesm2015_core/* MatCommonModule */.BQ]; }, exports: function () { return [MatGridList, MatGridTile, MatGridTileText, fesm2015_core/* MatLineModule */.uc,
        fesm2015_core/* MatCommonModule */.BQ, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Privately exported for the grid-list harness.
const ɵTileCoordinator = (/* unused pure expression or super */ null && (TileCoordinator));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=grid-list.js.map
// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/divider.js
var divider = __webpack_require__(1769);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules
var Observable = __webpack_require__(7574);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js
var isNumeric = __webpack_require__(6561);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/interval.js



function interval(period = 0, scheduler = scheduler_async/* async */.P) {
    if (!(0,isNumeric/* isNumeric */.k)(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = scheduler_async/* async */.P;
    }
    return new Observable/* Observable */.y(subscriber => {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));
        return subscriber;
    });
}
function dispatch(state) {
    const { subscriber, counter, period } = state;
    subscriber.next(counter);
    this.schedule({ subscriber, counter: counter + 1, period }, period);
}
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/@ngbmodule/material-carousel/__ivy_ngcc__/fesm2015/ngbmodule-material-carousel.js










/**
 * @fileoverview added by tsickle
 * Generated from: lib/carousel-slide/carousel-slide.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */







function MatCarouselSlideComponent_ng_template_0_div_3_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "div", 3);
} if (rf & 2) {
    const ctx_r1 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵstyleProp */.Udp("background-color", ctx_r1.overlayColor);
} }
function MatCarouselSlideComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 0);
    core/* ɵɵelementStart */.TgZ(1, "div", 1);
    core/* ɵɵprojection */.Hsn(2);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵtemplate */.YNc(3, MatCarouselSlideComponent_ng_template_0_div_3_Template, 1, 2, "div", 2);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("background-image", ctx_r0.image);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵproperty */.Q6J("ngIf", !ctx_r0.hideOverlay);
} }
const ngbmodule_material_carousel_c0 = ["*"];
const ngbmodule_material_carousel_c1 = ["carouselContainer"];
const ngbmodule_material_carousel_c2 = ["carouselList"];
function MatCarouselComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "li", 7, 8);
    core/* ɵɵlistener */.NdJ("panleft", function MatCarouselComponent_li_4_Template_li_panleft_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const _r7 = core/* ɵɵreference */.MAs(1); const ctx_r8 = core/* ɵɵnextContext */.oxw(); return ctx_r8.onPan($event, _r7); })("panright", function MatCarouselComponent_li_4_Template_li_panright_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const _r7 = core/* ɵɵreference */.MAs(1); const ctx_r10 = core/* ɵɵnextContext */.oxw(); return ctx_r10.onPan($event, _r7); })("panend", function MatCarouselComponent_li_4_Template_li_panend_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const _r7 = core/* ɵɵreference */.MAs(1); const ctx_r11 = core/* ɵɵnextContext */.oxw(); return ctx_r11.onPanEnd($event, _r7); })("pancancel", function MatCarouselComponent_li_4_Template_li_pancancel_0_listener($event) { core/* ɵɵrestoreView */.CHM(_r9); const _r7 = core/* ɵɵreference */.MAs(1); const ctx_r12 = core/* ɵɵnextContext */.oxw(); return ctx_r12.onPanEnd($event, _r7); });
    core/* ɵɵelementContainer */.GkF(2, 9);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const slide_r6 = ctx.$implicit;
    const ctx_r2 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("padding-bottom", ctx_r2.maintainAspectRatio && ctx_r2.proportion ? ctx_r2.proportion + "%" : "0px")("height", !ctx_r2.maintainAspectRatio && ctx_r2.slideHeight ? ctx_r2.slideHeight : "0px");
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵproperty */.Q6J("ngTemplateOutlet", slide_r6.templateRef);
} }
function MatCarouselComponent_button_5_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "mat-icon", 13);
} if (rf & 2) {
    const ctx_r13 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("svgIcon", ctx_r13.svgIconOverrides.arrowBack);
} }
function MatCarouselComponent_button_5_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-icon");
    core/* ɵɵtext */._uU(1, "arrow_back");
    core/* ɵɵelementEnd */.qZA();
} }
function MatCarouselComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r17 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 10);
    core/* ɵɵlistener */.NdJ("click", function MatCarouselComponent_button_5_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r17); const ctx_r16 = core/* ɵɵnextContext */.oxw(); return ctx_r16.previous(); });
    core/* ɵɵtemplate */.YNc(1, MatCarouselComponent_button_5_mat_icon_1_Template, 1, 1, "mat-icon", 11);
    core/* ɵɵtemplate */.YNc(2, MatCarouselComponent_button_5_ng_template_2_Template, 2, 0, "ng-template", null, 12, core/* ɵɵtemplateRefExtractor */.W1O);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const _r14 = core/* ɵɵreference */.MAs(3);
    const ctx_r3 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("color", ctx_r3.color)("disabled", !ctx_r3.loop && ctx_r3.currentIndex == 0);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r3.svgIconOverrides == null ? null : ctx_r3.svgIconOverrides.arrowBack)("ngIfElse", _r14);
} }
function MatCarouselComponent_button_6_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelement */._UZ(0, "mat-icon", 13);
} if (rf & 2) {
    const ctx_r18 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("svgIcon", ctx_r18.svgIconOverrides.arrowForward);
} }
function MatCarouselComponent_button_6_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "mat-icon");
    core/* ɵɵtext */._uU(1, "arrow_forward");
    core/* ɵɵelementEnd */.qZA();
} }
function MatCarouselComponent_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r22 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 10);
    core/* ɵɵlistener */.NdJ("click", function MatCarouselComponent_button_6_Template_button_click_0_listener() { core/* ɵɵrestoreView */.CHM(_r22); const ctx_r21 = core/* ɵɵnextContext */.oxw(); return ctx_r21.next(); });
    core/* ɵɵtemplate */.YNc(1, MatCarouselComponent_button_6_mat_icon_1_Template, 1, 1, "mat-icon", 11);
    core/* ɵɵtemplate */.YNc(2, MatCarouselComponent_button_6_ng_template_2_Template, 2, 0, "ng-template", null, 14, core/* ɵɵtemplateRefExtractor */.W1O);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const _r19 = core/* ɵɵreference */.MAs(3);
    const ctx_r4 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("color", ctx_r4.color)("disabled", !ctx_r4.loop && ctx_r4.currentIndex == ctx_r4.slidesList.length - 1);
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngIf", ctx_r4.svgIconOverrides == null ? null : ctx_r4.svgIconOverrides.arrowForward)("ngIfElse", _r19);
} }
function MatCarouselComponent_div_7_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r27 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "button", 17);
    core/* ɵɵlistener */.NdJ("click", function MatCarouselComponent_div_7_button_1_Template_button_click_0_listener() { const restoredCtx = core/* ɵɵrestoreView */.CHM(_r27); const i_r25 = restoredCtx.index; const ctx_r26 = core/* ɵɵnextContext */.oxw(2); return ctx_r26.slideTo(i_r25); })("focus", function MatCarouselComponent_div_7_button_1_Template_button_focus_0_listener() { core/* ɵɵrestoreView */.CHM(_r27); core/* ɵɵnextContext */.oxw(2); const _r0 = core/* ɵɵreference */.MAs(1); return _r0.focus(); });
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const i_r25 = ctx.index;
    const ctx_r23 = core/* ɵɵnextContext */.oxw(2);
    core/* ɵɵproperty */.Q6J("color", ctx_r23.color)("disabled", i_r25 == ctx_r23.currentIndex);
} }
function MatCarouselComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 15);
    core/* ɵɵtemplate */.YNc(1, MatCarouselComponent_div_7_button_1_Template, 1, 2, "button", 16);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r5 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵstyleProp */.Udp("flex-direction", ctx_r5.orientation === "rtl" ? "row-reverse" : "row");
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngForOf", ctx_r5.slidesList);
} }
class MatCarouselSlideComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.overlayColor = '#00000040';
        this.hideOverlay = false;
        this.disabled = false; // implements ListKeyManagerOption
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.image) {
            this.image = this.sanitizer.bypassSecurityTrustStyle(`url("${this.image}")`);
        }
    }
}
MatCarouselSlideComponent.ɵfac = function MatCarouselSlideComponent_Factory(t) { return new (t || MatCarouselSlideComponent)(core/* ɵɵdirectiveInject */.Y36(platform_browser/* DomSanitizer */.H7)); };
MatCarouselSlideComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatCarouselSlideComponent, selectors: [["mat-carousel-slide"]], viewQuery: function MatCarouselSlideComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(core/* TemplateRef */.Rgc, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.templateRef = _t.first);
    } }, inputs: { overlayColor: "overlayColor", hideOverlay: "hideOverlay", disabled: "disabled", image: "image" }, ngContentSelectors: ngbmodule_material_carousel_c0, decls: 1, vars: 0, consts: [[1, "carousel-slide"], [1, "carousel-slide-content"], ["class", "carousel-slide-overlay", 3, "background-color", 4, "ngIf"], [1, "carousel-slide-overlay"]], template: function MatCarouselSlideComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t();
        core/* ɵɵtemplate */.YNc(0, MatCarouselSlideComponent_ng_template_0_Template, 4, 3, "ng-template");
    } }, directives: [common/* NgIf */.O5], styles: [".carousel-slide[_ngcontent-%COMP%]{background-position:50%;background-repeat:no-repeat;background-size:cover}.carousel-slide[_ngcontent-%COMP%], .carousel-slide-overlay[_ngcontent-%COMP%]{height:100%;position:absolute;width:100%;z-index:auto}.carousel-slide-content[_ngcontent-%COMP%]{height:100%;position:absolute;width:100%;z-index:1}"] });
/** @nocollapse */
MatCarouselSlideComponent.ctorParameters = () => [
    { type: platform_browser/* DomSanitizer */.H7 }
];
MatCarouselSlideComponent.propDecorators = {
    image: [{ type: core/* Input */.IIB }],
    overlayColor: [{ type: core/* Input */.IIB }],
    hideOverlay: [{ type: core/* Input */.IIB }],
    disabled: [{ type: core/* Input */.IIB }],
    templateRef: [{ type: core/* ViewChild */.i9L, args: [core/* TemplateRef */.Rgc,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCarouselSlideComponent, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-carousel-slide',
                template: "<ng-template>\r\n  <div class=\"carousel-slide\" [style.background-image]=\"image\">\r\n    <div class=\"carousel-slide-content\"><ng-content></ng-content></div>\r\n    <div\r\n      *ngIf=\"!hideOverlay\"\r\n      class=\"carousel-slide-overlay\"\r\n      [style.background-color]=\"overlayColor\"\r\n    ></div>\r\n  </div>\r\n</ng-template>\r\n",
                styles: [".carousel-slide{background-position:50%;background-repeat:no-repeat;background-size:cover}.carousel-slide,.carousel-slide-overlay{height:100%;position:absolute;width:100%;z-index:auto}.carousel-slide-content{height:100%;position:absolute;width:100%;z-index:1}"]
            }]
    }], function () { return [{ type: platform_browser/* DomSanitizer */.H7 }]; }, { overlayColor: [{
            type: core/* Input */.IIB
        }], hideOverlay: [{
            type: core/* Input */.IIB
        }], disabled: [{
            type: core/* Input */.IIB
        }], image: [{
            type: core/* Input */.IIB
        }], templateRef: [{
            type: core/* ViewChild */.i9L,
            args: [core/* TemplateRef */.Rgc]
        }] }); })();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/carousel.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const Direction = {
    Left: 0,
    Right: 1,
    Index: 2,
};
Direction[Direction.Left] = 'Left';
Direction[Direction.Right] = 'Right';
Direction[Direction.Index] = 'Index';
class MatCarouselComponent {
    /**
     * @param {?} animationBuilder
     * @param {?} renderer
     * @param {?} platformId
     */
    constructor(animationBuilder, renderer, platformId) {
        this.animationBuilder = animationBuilder;
        this.renderer = renderer;
        this.platformId = platformId;
        this.timings = '250ms ease-in';
        this.hideArrows = true;
        this.hideIndicators = true;
        this.color = 'accent';
        this.maintainAspectRatio = true;
        this.proportion = 25;
        this.slideHeight = '100%';
        this.useKeyboard = false;
        this.useMouseWheel = false;
        this.change = new core/* EventEmitter */.vpe();
        this._autoplay = true;
        this.autoplay$ = new Subject/* Subject */.xQ();
        this.interval$ = new BehaviorSubject/* BehaviorSubject */.X(5000);
        this.slides$ = new BehaviorSubject/* BehaviorSubject */.X(null);
        this._maxWidth = 'auto';
        this.maxWidth$ = new Subject/* Subject */.xQ();
        this._loop = true;
        this.loop$ = new Subject/* Subject */.xQ();
        this._orientation = 'ltr';
        this.orientation$ = new Subject/* Subject */.xQ();
        this.timerStop$ = new Subject/* Subject */.xQ();
        this.destroy$ = new Subject/* Subject */.xQ();
        this.playing = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoplay(value) {
        this.autoplay$.next(value);
        this._autoplay = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set interval(value) {
        this.interval$.next(value);
    }
    /**
     * @return {?}
     */
    get loop() {
        return this._loop;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set loop(value) {
        this.loop$.next(value);
        this._loop = value;
    }
    /**
     * @return {?}
     */
    get maxWidth() {
        return this._maxWidth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxWidth(value) {
        this._maxWidth = value;
        this.maxWidth$.next();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set slides(value) {
        this.slides$.next(value);
    }
    /**
     * @return {?}
     */
    get orientation() {
        return this._orientation;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set orientation(value) {
        this.orientation$.next(value);
        this._orientation = value;
    }
    /**
     * @return {?}
     */
    get currentIndex() {
        if (this.listKeyManager) {
            return this.listKeyManager.activeItemIndex;
        }
        return 0;
    }
    /**
     * @return {?}
     */
    get currentSlide() {
        if (this.listKeyManager) {
            return this.listKeyManager.activeItem;
        }
        return null;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.listKeyManager = new a11y/* ListKeyManager */.cS(this.slidesList)
            .withVerticalOrientation(false)
            .withHorizontalOrientation(this._orientation)
            .withWrap(this._loop);
        this.listKeyManager.updateActiveItem(0);
        this.listKeyManager.change
            .pipe((0,takeUntil/* takeUntil */.R)(this.destroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.playAnimation()));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.autoplay$.pipe((0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.stopTimer();
            this.startTimer(value);
        }));
        this.interval$.pipe((0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.stopTimer();
            this.resetTimer(value);
            this.startTimer(this._autoplay);
        }));
        this.maxWidth$
            .pipe((0,takeUntil/* takeUntil */.R)(this.destroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.slideTo(0)));
        this.loop$
            .pipe((0,takeUntil/* takeUntil */.R)(this.destroy$))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => this.listKeyManager.withWrap(value)));
        this.orientation$
            .pipe((0,takeUntil/* takeUntil */.R)(this.destroy$))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => this.listKeyManager.withHorizontalOrientation(value)));
        this.slides$
            .pipe((0,takeUntil/* takeUntil */.R)(this.destroy$), (0,filter/* filter */.h)((/**
         * @param {?} value
         * @return {?}
         */
        value => value && value < this.slidesList.length)))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => this.resetSlides(value)));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    next() {
        this.goto(Direction.Right);
    }
    /**
     * @return {?}
     */
    previous() {
        this.goto(Direction.Left);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    slideTo(index) {
        this.goto(Direction.Index, index);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.useKeyboard && !this.playing) {
            this.listKeyManager.onKeydown(event);
        }
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        this.stopTimer();
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.startTimer(this._autoplay);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheel(event) {
        if (this.useMouseWheel) {
            event.preventDefault(); // prevent window to scroll
            // prevent window to scroll
            /** @type {?} */
            const Δ = Math.sign(event.deltaY);
            if (Δ > 0) {
                this.next();
            }
            else if (Δ < 0) {
                this.previous();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        // Reset carousel when window is resized
        // in order to avoid major glitches.
        this.slideTo(0);
    }
    /**
     * @param {?} event
     * @param {?} slideElem
     * @return {?}
     */
    onPan(event, slideElem) {
        // https://github.com/angular/angular/issues/10541#issuecomment-346539242
        // if y velocity is greater, it's a panup/pandown, so ignore.
        if (Math.abs(event.velocityY) > Math.abs(event.velocityX)) {
            return;
        }
        /** @type {?} */
        let Δx = event.deltaX;
        if (this.isOutOfBounds()) {
            Δx *= 0.2; // decelerate movement;
        }
        this.renderer.setStyle(slideElem, 'cursor', 'grabbing');
        this.renderer.setStyle(this.carouselList.nativeElement, 'transform', this.getTranslation(this.getOffset() + Δx));
    }
    /**
     * @param {?} event
     * @param {?} slideElem
     * @return {?}
     */
    onPanEnd(event, slideElem) {
        this.renderer.removeStyle(slideElem, 'cursor');
        if (!this.isOutOfBounds() &&
            Math.abs(event.deltaX) > this.getWidth() * 0.25) {
            if (event.deltaX <= 0) {
                this.next();
                return;
            }
            this.previous();
            return;
        }
        this.playAnimation(); // slide back, don't change current index
    }
    /**
     * @private
     * @return {?}
     */
    isOutOfBounds() {
        /** @type {?} */
        const sign = this.orientation === 'rtl' ? -1 : 1;
        /** @type {?} */
        const left = sign *
            (this.carouselList.nativeElement.getBoundingClientRect().left -
                this.carouselList.nativeElement.offsetParent.getBoundingClientRect()
                    .left);
        /** @type {?} */
        const lastIndex = this.slidesList.length - 1;
        /** @type {?} */
        const width = -this.getWidth() * lastIndex;
        return ((this.listKeyManager.activeItemIndex === 0 && left >= 0) ||
            (this.listKeyManager.activeItemIndex === lastIndex && left <= width));
    }
    /**
     * @private
     * @return {?}
     */
    isVisible() {
        if (!(0,common/* isPlatformBrowser */.NF)(this.platformId)) {
            return false;
        }
        /** @type {?} */
        const elem = this.carouselContainer.nativeElement;
        /** @type {?} */
        const docViewTop = window.pageYOffset;
        /** @type {?} */
        const docViewBottom = docViewTop + window.innerHeight;
        /** @type {?} */
        const elemOffset = elem.getBoundingClientRect();
        /** @type {?} */
        const elemTop = docViewTop + elemOffset.top;
        /** @type {?} */
        const elemBottom = elemTop + elemOffset.height;
        return elemBottom <= docViewBottom || elemTop >= docViewTop;
    }
    /**
     * @private
     * @return {?}
     */
    getOffset() {
        /** @type {?} */
        const offset = this.listKeyManager.activeItemIndex * this.getWidth();
        /** @type {?} */
        const sign = this.orientation === 'rtl' ? 1 : -1;
        return sign * offset;
    }
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    getTranslation(offset) {
        return `translateX(${offset}px)`;
    }
    /**
     * @private
     * @return {?}
     */
    getWidth() {
        return this.carouselContainer.nativeElement.clientWidth;
    }
    /**
     * @private
     * @param {?} direction
     * @param {?=} index
     * @return {?}
     */
    goto(direction, index) {
        if (!this.playing) {
            /** @type {?} */
            const rtl = this.orientation === 'rtl';
            switch (direction) {
                case Direction.Left:
                    return rtl
                        ? this.listKeyManager.setNextItemActive()
                        : this.listKeyManager.setPreviousItemActive();
                case Direction.Right:
                    return rtl
                        ? this.listKeyManager.setPreviousItemActive()
                        : this.listKeyManager.setNextItemActive();
                case Direction.Index:
                    return this.listKeyManager.setActiveItem(index);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    playAnimation() {
        /** @type {?} */
        const translation = this.getTranslation(this.getOffset());
        /** @type {?} */
        const factory = this.animationBuilder.build((0,animations/* animate */.jt)(this.timings, (0,animations/* style */.oB)({ transform: translation })));
        /** @type {?} */
        const animation = factory.create(this.carouselList.nativeElement);
        animation.onStart((/**
         * @return {?}
         */
        () => (this.playing = true)));
        animation.onDone((/**
         * @return {?}
         */
        () => {
            this.change.emit(this.currentIndex);
            this.playing = false;
            this.renderer.setStyle(this.carouselList.nativeElement, 'transform', translation);
            animation.destroy();
        }));
        animation.play();
    }
    /**
     * @private
     * @param {?} slides
     * @return {?}
     */
    resetSlides(slides) {
        this.slidesList.reset(this.slidesList.toArray().slice(0, slides));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    resetTimer(value) {
        this.timer$ = interval(value);
    }
    /**
     * @private
     * @param {?} autoplay
     * @return {?}
     */
    startTimer(autoplay) {
        if (!autoplay) {
            return;
        }
        this.timer$
            .pipe((0,takeUntil/* takeUntil */.R)(this.timerStop$), (0,takeUntil/* takeUntil */.R)(this.destroy$), (0,filter/* filter */.h)((/**
         * @return {?}
         */
        () => this.isVisible())))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.listKeyManager.withWrap(true).setNextItemActive();
            this.listKeyManager.withWrap(this.loop);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    stopTimer() {
        this.timerStop$.next();
    }
}
MatCarouselComponent.ɵfac = function MatCarouselComponent_Factory(t) { return new (t || MatCarouselComponent)(core/* ɵɵdirectiveInject */.Y36(animations/* AnimationBuilder */._j), core/* ɵɵdirectiveInject */.Y36(core/* Renderer2 */.Qsj), core/* ɵɵdirectiveInject */.Y36(core/* PLATFORM_ID */.Lbi)); };
MatCarouselComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatCarouselComponent, selectors: [["mat-carousel"]], contentQueries: function MatCarouselComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, MatCarouselSlideComponent, 4);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.slidesList = _t);
    } }, viewQuery: function MatCarouselComponent_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(ngbmodule_material_carousel_c1, 5);
        core/* ɵɵviewQuery */.Gf(ngbmodule_material_carousel_c2, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.carouselContainer = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.carouselList = _t.first);
    } }, hostBindings: function MatCarouselComponent_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("keyup", function MatCarouselComponent_keyup_HostBindingHandler($event) { return ctx.onKeyUp($event); })("mouseenter", function MatCarouselComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function MatCarouselComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("mousewheel", function MatCarouselComponent_mousewheel_HostBindingHandler($event) { return ctx.onMouseWheel($event); })("resize", function MatCarouselComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, core/* ɵɵresolveWindow */.Jf7);
    } }, inputs: { timings: "timings", hideArrows: "hideArrows", hideIndicators: "hideIndicators", color: "color", maintainAspectRatio: "maintainAspectRatio", proportion: "proportion", slideHeight: "slideHeight", useKeyboard: "useKeyboard", useMouseWheel: "useMouseWheel", autoplay: "autoplay", interval: "interval", loop: "loop", maxWidth: "maxWidth", slides: "slides", orientation: "orientation", svgIconOverrides: "svgIconOverrides" }, outputs: { change: "change" }, decls: 8, vars: 12, consts: [["tabindex", "0", 1, "carousel"], ["carouselContainer", ""], ["role", "listbox", 1, "carousel-list"], ["carouselList", ""], ["class", "carousel-slide", "role", "option", 3, "padding-bottom", "height", "panleft", "panright", "panend", "pancancel", 4, "ngFor", "ngForOf"], ["mat-icon-button", "", "type", "button", "tabindex", "-1", 3, "color", "disabled", "click", 4, "ngIf"], ["class", "carousel-indicators", "tabindex", "-1", 3, "flex-direction", 4, "ngIf"], ["role", "option", 1, "carousel-slide", 3, "panleft", "panright", "panend", "pancancel"], ["carouselSlide", ""], [3, "ngTemplateOutlet"], ["mat-icon-button", "", "type", "button", "tabindex", "-1", 3, "color", "disabled", "click"], [3, "svgIcon", 4, "ngIf", "ngIfElse"], ["defaultArrowBack", ""], [3, "svgIcon"], ["defaultArrowForward", ""], ["tabindex", "-1", 1, "carousel-indicators"], ["type", "button", "tabindex", "-1", "mat-mini-fab", "", 3, "color", "disabled", "click", "focus", 4, "ngFor", "ngForOf"], ["type", "button", "tabindex", "-1", "mat-mini-fab", "", 3, "color", "disabled", "click", "focus"]], template: function MatCarouselComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0, 1);
        core/* ɵɵelementStart */.TgZ(2, "ul", 2, 3);
        core/* ɵɵtemplate */.YNc(4, MatCarouselComponent_li_4_Template, 3, 5, "li", 4);
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(5, MatCarouselComponent_button_5_Template, 4, 4, "button", 5);
        core/* ɵɵtemplate */.YNc(6, MatCarouselComponent_button_6_Template, 4, 4, "button", 5);
        core/* ɵɵtemplate */.YNc(7, MatCarouselComponent_div_7_Template, 2, 3, "div", 6);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵstyleProp */.Udp("max-width", ctx.maxWidth)("height", !ctx.maintainAspectRatio ? "100%" : "auto");
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵstyleProp */.Udp("flex-direction", ctx.orientation === "rtl" ? "row-reverse" : "row")("height", !ctx.maintainAspectRatio ? "100%" : "auto");
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngForOf", ctx.slidesList);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.hideArrows);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.hideArrows);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.hideIndicators);
    } }, directives: [common/* NgForOf */.sg, common/* NgIf */.O5, common/* NgTemplateOutlet */.tP, fesm2015_button/* MatButton */.lW, icon/* MatIcon */.Hw], styles: [".carousel[_ngcontent-%COMP%]{outline:none;overflow:hidden;position:relative;width:100%}.carousel[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{position:absolute;top:50%;transform:translateY(-50%);z-index:1}.carousel[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]:first-of-type{left:30px}.carousel[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]:last-of-type{right:30px}.carousel-list[_ngcontent-%COMP%]{list-style:none;margin:0;padding:0}.carousel-list[_ngcontent-%COMP%], .carousel-slide[_ngcontent-%COMP%]{display:flex;position:relative;width:100%}.carousel-slide[_ngcontent-%COMP%]{flex-shrink:0;height:0}.carousel-slide[_ngcontent-%COMP%]:hover{cursor:-webkit-grab;cursor:grab}.carousel-indicators[_ngcontent-%COMP%]{bottom:15px;display:flex;left:50%;outline:none;position:absolute;transform:translateX(-50%);z-index:1}.carousel-indicators[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{height:10px;margin:7.5px;width:10px}"] });
/** @nocollapse */
MatCarouselComponent.ctorParameters = () => [
    { type: animations/* AnimationBuilder */._j },
    { type: core/* Renderer2 */.Qsj },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [core/* PLATFORM_ID */.Lbi,] }] }
];
MatCarouselComponent.propDecorators = {
    timings: [{ type: core/* Input */.IIB }],
    svgIconOverrides: [{ type: core/* Input */.IIB }],
    autoplay: [{ type: core/* Input */.IIB }],
    interval: [{ type: core/* Input */.IIB }],
    loop: [{ type: core/* Input */.IIB }],
    hideArrows: [{ type: core/* Input */.IIB }],
    hideIndicators: [{ type: core/* Input */.IIB }],
    color: [{ type: core/* Input */.IIB }],
    maxWidth: [{ type: core/* Input */.IIB }],
    maintainAspectRatio: [{ type: core/* Input */.IIB }],
    proportion: [{ type: core/* Input */.IIB }],
    slideHeight: [{ type: core/* Input */.IIB }],
    slides: [{ type: core/* Input */.IIB }],
    useKeyboard: [{ type: core/* Input */.IIB }],
    useMouseWheel: [{ type: core/* Input */.IIB }],
    orientation: [{ type: core/* Input */.IIB }],
    change: [{ type: core/* Output */.r_U }],
    slidesList: [{ type: core/* ContentChildren */.AcB, args: [MatCarouselSlideComponent,] }],
    carouselContainer: [{ type: core/* ViewChild */.i9L, args: ['carouselContainer',] }],
    carouselList: [{ type: core/* ViewChild */.i9L, args: ['carouselList',] }],
    onKeyUp: [{ type: core/* HostListener */.L6J, args: ['keyup', ['$event'],] }],
    onMouseEnter: [{ type: core/* HostListener */.L6J, args: ['mouseenter',] }],
    onMouseLeave: [{ type: core/* HostListener */.L6J, args: ['mouseleave',] }],
    onMouseWheel: [{ type: core/* HostListener */.L6J, args: ['mousewheel', ['$event'],] }],
    onResize: [{ type: core/* HostListener */.L6J, args: ['window:resize', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCarouselComponent, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-carousel',
                template: "<div\r\n  #carouselContainer\r\n  class=\"carousel\"\r\n  tabindex=\"0\"\r\n  [style.max-width]=\"maxWidth\"\r\n  [style.height]=\"!maintainAspectRatio ? '100%' : 'auto'\"\r\n>\r\n  <ul\r\n    #carouselList\r\n    class=\"carousel-list\"\r\n    role=\"listbox\"\r\n    [style.flex-direction]=\"orientation === 'rtl' ? 'row-reverse' : 'row'\"\r\n    [style.height]=\"!maintainAspectRatio ? '100%' : 'auto'\"\r\n  >\r\n    <li\r\n      #carouselSlide\r\n      *ngFor=\"let slide of slidesList\"\r\n      class=\"carousel-slide\"\r\n      role=\"option\"\r\n      [style.padding-bottom]=\"maintainAspectRatio && proportion ? proportion + '%': '0px'\"\r\n      [style.height]=\"!maintainAspectRatio && slideHeight ? slideHeight : '0px'\"\r\n      (panleft)=\"onPan($event, carouselSlide)\"\r\n      (panright)=\"onPan($event, carouselSlide)\"\r\n      (panend)=\"onPanEnd($event, carouselSlide)\"\r\n      (pancancel)=\"onPanEnd($event, carouselSlide)\"\r\n    >\r\n      <ng-container [ngTemplateOutlet]=\"slide.templateRef\"></ng-container>\r\n    </li>\r\n  </ul>\r\n\r\n  <button\r\n    *ngIf=\"!hideArrows\"\r\n    mat-icon-button\r\n    type=\"button\"\r\n    tabindex=\"-1\"\r\n    [color]=\"color\"\r\n    [disabled]=\"!loop && currentIndex == 0\"\r\n    (click)=\"previous()\"\r\n  >\r\n    <mat-icon\r\n      *ngIf=\"svgIconOverrides?.arrowBack; else: defaultArrowBack\"\r\n      [svgIcon]=\"svgIconOverrides.arrowBack\"\r\n    ></mat-icon>\r\n    <ng-template #defaultArrowBack>\r\n      <mat-icon>arrow_back</mat-icon>\r\n    </ng-template>\r\n  </button>\r\n  <button\r\n    *ngIf=\"!hideArrows\"\r\n    mat-icon-button\r\n    type=\"button\"\r\n    tabindex=\"-1\"\r\n    [color]=\"color\"\r\n    [disabled]=\"!loop && currentIndex == slidesList.length - 1\"\r\n    (click)=\"next()\"\r\n  >\r\n    <mat-icon\r\n      *ngIf=\"svgIconOverrides?.arrowForward; else: defaultArrowForward\"\r\n      [svgIcon]=\"svgIconOverrides.arrowForward\"\r\n    ></mat-icon>\r\n    <ng-template #defaultArrowForward>\r\n      <mat-icon>arrow_forward</mat-icon>\r\n    </ng-template>\r\n  </button>\r\n\r\n  <div\r\n    *ngIf=\"!hideIndicators\"\r\n    class=\"carousel-indicators\"\r\n    tabindex=\"-1\"\r\n    [style.flex-direction]=\"orientation === 'rtl' ? 'row-reverse' : 'row'\"\r\n  >\r\n    <button\r\n      *ngFor=\"let slide of slidesList; let i = index\"\r\n      type=\"button\"\r\n      tabindex=\"-1\"\r\n      mat-mini-fab\r\n      [color]=\"color\"\r\n      [disabled]=\"i == currentIndex\"\r\n      (click)=\"slideTo(i)\"\r\n      (focus)=\"carouselContainer.focus()\"\r\n    ></button>\r\n  </div>\r\n</div>\r\n",
                styles: [".carousel{outline:none;overflow:hidden;position:relative;width:100%}.carousel>button{position:absolute;top:50%;transform:translateY(-50%);z-index:1}.carousel>button:first-of-type{left:30px}.carousel>button:last-of-type{right:30px}.carousel-list{list-style:none;margin:0;padding:0}.carousel-list,.carousel-slide{display:flex;position:relative;width:100%}.carousel-slide{flex-shrink:0;height:0}.carousel-slide:hover{cursor:-webkit-grab;cursor:grab}.carousel-indicators{bottom:15px;display:flex;left:50%;outline:none;position:absolute;transform:translateX(-50%);z-index:1}.carousel-indicators>button{height:10px;margin:7.5px;width:10px}"]
            }]
    }], function () { return [{ type: animations/* AnimationBuilder */._j }, { type: core/* Renderer2 */.Qsj }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [core/* PLATFORM_ID */.Lbi]
            }] }]; }, { timings: [{
            type: core/* Input */.IIB
        }], hideArrows: [{
            type: core/* Input */.IIB
        }], hideIndicators: [{
            type: core/* Input */.IIB
        }], color: [{
            type: core/* Input */.IIB
        }], maintainAspectRatio: [{
            type: core/* Input */.IIB
        }], proportion: [{
            type: core/* Input */.IIB
        }], slideHeight: [{
            type: core/* Input */.IIB
        }], useKeyboard: [{
            type: core/* Input */.IIB
        }], useMouseWheel: [{
            type: core/* Input */.IIB
        }], change: [{
            type: core/* Output */.r_U
        }], autoplay: [{
            type: core/* Input */.IIB
        }], interval: [{
            type: core/* Input */.IIB
        }], loop: [{
            type: core/* Input */.IIB
        }], maxWidth: [{
            type: core/* Input */.IIB
        }], slides: [{
            type: core/* Input */.IIB
        }], orientation: [{
            type: core/* Input */.IIB
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp: [{
            type: core/* HostListener */.L6J,
            args: ['keyup', ['$event']]
        }], 
    /**
     * @return {?}
     */
    onMouseEnter: [{
            type: core/* HostListener */.L6J,
            args: ['mouseenter']
        }], 
    /**
     * @return {?}
     */
    onMouseLeave: [{
            type: core/* HostListener */.L6J,
            args: ['mouseleave']
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheel: [{
            type: core/* HostListener */.L6J,
            args: ['mousewheel', ['$event']]
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onResize: [{
            type: core/* HostListener */.L6J,
            args: ['window:resize', ['$event']]
        }], svgIconOverrides: [{
            type: core/* Input */.IIB
        }], slidesList: [{
            type: core/* ContentChildren */.AcB,
            args: [MatCarouselSlideComponent]
        }], carouselContainer: [{
            type: core/* ViewChild */.i9L,
            args: ['carouselContainer']
        }], carouselList: [{
            type: core/* ViewChild */.i9L,
            args: ['carouselList']
        }] }); })();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/carousel.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// https://github.com/angular/angular/issues/10541#issuecomment-300761387
class MatCarouselHammerConfig extends platform_browser/* HammerGestureConfig */.hm {
    constructor() {
        super(...arguments);
        this.overrides = {
            pinch: { enable: false },
            rotate: { enable: false }
        };
    }
}
MatCarouselHammerConfig.ɵfac = /*@__PURE__*/ function () { let ɵMatCarouselHammerConfig_BaseFactory; return function MatCarouselHammerConfig_Factory(t) { return (ɵMatCarouselHammerConfig_BaseFactory || (ɵMatCarouselHammerConfig_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatCarouselHammerConfig)))(t || MatCarouselHammerConfig); }; }();
MatCarouselHammerConfig.ɵprov = /*@__PURE__*/ core/* ɵɵdefineInjectable */.Yz7({ token: MatCarouselHammerConfig, factory: MatCarouselHammerConfig.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCarouselHammerConfig, [{
        type: core/* Injectable */.GSi
    }], null, null); })();
if (false) {}
class MatCarouselModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: MatCarouselModule,
            providers: [
                { provide: platform_browser/* HAMMER_GESTURE_CONFIG */.ok, useClass: MatCarouselHammerConfig }
            ]
        };
    }
}
MatCarouselModule.ɵfac = function MatCarouselModule_Factory(t) { return new (t || MatCarouselModule)(); };
MatCarouselModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatCarouselModule });
MatCarouselModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[common/* CommonModule */.ez, fesm2015_button/* MatButtonModule */.ot, icon/* MatIconModule */.Ps, platform_browser/* HammerModule */.t6]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatCarouselModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                declarations: [MatCarouselComponent, MatCarouselSlideComponent],
                imports: [common/* CommonModule */.ez, fesm2015_button/* MatButtonModule */.ot, icon/* MatIconModule */.Ps, platform_browser/* HammerModule */.t6],
                exports: [MatCarouselComponent, MatCarouselSlideComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatCarouselModule, { declarations: function () { return [MatCarouselComponent, MatCarouselSlideComponent]; }, imports: function () { return [common/* CommonModule */.ez, fesm2015_button/* MatButtonModule */.ot, icon/* MatIconModule */.Ps, platform_browser/* HammerModule */.t6]; }, exports: function () { return [MatCarouselComponent, MatCarouselSlideComponent]; } }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/carousel.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MatCarousel() { }
if (false) {}
/**
 * @record
 */
function SvgIconOverrides() { }
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/carousel-slide/carousel-slide.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MatCarouselSlide() { }
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngbmodule-material-carousel.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ngbmodule-material-carousel.js.map
;// CONCATENATED MODULE: ./src/app/shared/dialog/info-dialog.component.ts


class InfoDialog {
}
InfoDialog.ɵfac = function InfoDialog_Factory(t) { return new (t || InfoDialog)(); };
InfoDialog.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: InfoDialog, selectors: [["info-dialog"]], decls: 6, vars: 0, consts: [["mat-dialog-content", "", 1, "overflow-hidden"], [1, "teko-text"], ["href", "https://sportsurge.net/", "target", "_blank"]], template: function InfoDialog_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelementStart */.TgZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "span", 1);
        core/* ɵɵtext */._uU(2, "The livestream links are retrieved from ");
        core/* ɵɵelementStart */.TgZ(3, "a", 2);
        core/* ɵɵtext */._uU(4, "sportsurge.net");
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵelement */._UZ(5, "br");
        core/* ɵɵelementEnd */.qZA();
    } }, directives: [MatDialogContent], encapsulation: 2 });

// EXTERNAL MODULE: ./node_modules/ng2-adsense/__ivy_ngcc__/fesm2015/ng2-adsense.js
var ng2_adsense = __webpack_require__(5425);
;// CONCATENATED MODULE: ./src/app/shared/dialog/image-popup-dialog.component.ts








function ImagePopupDialog_div_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 1);
    core/* ɵɵelementStart */.TgZ(1, "div", 2);
    core/* ɵɵelementStart */.TgZ(2, "div", 3);
    core/* ɵɵelementStart */.TgZ(3, "button", 4);
    core/* ɵɵtext */._uU(4, "Buy ");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(5, "div");
    core/* ɵɵelementStart */.TgZ(6, "h1");
    core/* ɵɵtext */._uU(7);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(8, "div");
    core/* ɵɵelement */._UZ(9, "img", 5);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(10, "div");
    core/* ɵɵelementStart */.TgZ(11, "p");
    core/* ɵɵtext */._uU(12);
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(7);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.asset.name);
    core/* ɵɵadvance */.xp6(2);
    core/* ɵɵpropertyInterpolate */.s9C("src", ctx_r0.asset.image_preview_url, core/* ɵɵsanitizeUrl */.LSH);
    core/* ɵɵadvance */.xp6(3);
    core/* ɵɵtextInterpolate */.Oqu(ctx_r0.asset.id);
} }
class ImagePopupDialog {
    constructor(restService, dialogRef) {
        this.restService = restService;
        this.dialogRef = dialogRef;
        this.newContent = new NewsContent();
    }
    getData() {
        let observable;
        observable = this.restService.getOpenSeaAsset(this.contractAddress, this.tokenId);
        observable.subscribe({
            next: data => {
                this.asset = data;
            }
        });
    }
}
ImagePopupDialog.ɵfac = function ImagePopupDialog_Factory(t) { return new (t || ImagePopupDialog)(core/* ɵɵdirectiveInject */.Y36(rest_service/* RestService */.v), core/* ɵɵdirectiveInject */.Y36(MatDialogRef)); };
ImagePopupDialog.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: ImagePopupDialog, selectors: [["image-popup-dialog"]], decls: 1, vars: 1, consts: [["mat-dialog-content", "", "class", "1image-popup 1overflow-hidden", 4, "ngIf"], ["mat-dialog-content", "", 1, "1image-popup", "1overflow-hidden"], [1, "row"], [1, "col-12", "col-lg-12"], ["mat-flat-button", "", 1, "active-color-button", "width-100"], [1, "rounded", "mx-auto", "d-block", 3, "src"]], template: function ImagePopupDialog_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵtemplate */.YNc(0, ImagePopupDialog_div_0_Template, 13, 3, "div", 0);
    } if (rf & 2) {
        core/* ɵɵproperty */.Q6J("ngIf", ctx.tokenId !== undefined);
    } }, directives: [common/* NgIf */.O5, MatDialogContent, fesm2015_button/* MatButton */.lW], encapsulation: 2 });

;// CONCATENATED MODULE: ./src/app/shared/barChartRaceRaceAnalysis/am-chart-ra.component.ts










function AmChartRaComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r2 = core/* ɵɵgetCurrentView */.EpF();
    core/* ɵɵelementStart */.TgZ(0, "div", 4);
    core/* ɵɵelementStart */.TgZ(1, "mat-slider", 5);
    core/* ɵɵlistener */.NdJ("change", function AmChartRaComponent_div_3_Template_mat_slider_change_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r1 = core/* ɵɵnextContext */.oxw(); return ctx_r1.onStepDurationChange($event.value); })("ngModelChange", function AmChartRaComponent_div_3_Template_mat_slider_ngModelChange_1_listener($event) { core/* ɵɵrestoreView */.CHM(_r2); const ctx_r3 = core/* ɵɵnextContext */.oxw(); return ctx_r3.stepDurationSlider = $event; });
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementStart */.TgZ(2, "p");
    core/* ɵɵtext */._uU(3, "Speed");
    core/* ɵɵelementEnd */.qZA();
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵadvance */.xp6(1);
    core/* ɵɵproperty */.Q6J("ngModel", ctx_r0.stepDurationSlider);
} }
class AmChartRaComponent {
    constructor(platformId, zone) {
        this.platformId = platformId;
        this.zone = zone;
        this.dataMap = new Map();
        //vece=sporije
        this.stepDurationSlider = 2;
        this.stepDuration = 600;
        this.onOff = true;
    }
    // Run the function only in the browser
    browserOnly(f) {
        if ((0,common/* isPlatformBrowser */.NF)(this.platformId)) {
            this.zone.runOutsideAngular(() => {
                f();
            });
        }
    }
    ngAfterViewInit() {
        this.stepDuration = 1300 - (this.stepDurationSlider * 200);
        /* Chart code */
        // Data
        let dataMap = this.getDataFromDrivers();
        // Create root element
        // https://www.amcharts.com/docs/v5/getting-started/#Root_element
        let root = Root.new("chartdiv");
        this.root = root;
        //vece=sporije
        let stepDuration = this.stepDuration;
        // Set themes
        // https://www.amcharts.com/docs/v5/concepts/themes/
        root.setThemes([Animated.new(root)]);
        // Create chart
        // https://www.amcharts.com/docs/v5/charts/xy-chart/
        let chart = root.container.children.push(XYChart.new(root, {
            panX: true,
            panY: true,
            wheelX: "none",
            wheelY: "none"
        }));
        // We don't want zoom-out button to appear while animating, so we hide it at all
        // chart.zoomOutButton.set("forceHidden", true);
        // Create axes
        // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/
        let yRenderer = AxisRendererY.new(root, {
            minGridDistance: 20,
            inversed: true
        });
        // hide grid
        yRenderer.grid.template.set("visible", false);
        let yAxis = chart.yAxes.push(CategoryAxis.new(root, {
            maxDeviation: 0,
            categoryField: "network",
            renderer: yRenderer
        }));
        let xRenderer = AxisRendererX.new(root, {
            opacity: 0,
            visible: false,
            disabled: true
        });
        // hide grid axis.renderer.labels.template.disabled = true
        xRenderer.grid.template.set("visible", true);
        xRenderer.labels.template.set("visible", false);
        xRenderer.ticks.template.set("visible", true);
        let xAxis = chart.xAxes.push(ValueAxis.new(root, {
            maxDeviation: 0,
            min: 0,
            strictMinMax: true,
            extraMax: 0.1,
            renderer: xRenderer
        }));
        xAxis.set("interpolationDuration", stepDuration / 10);
        xAxis.set("interpolationEasing", linear);
        // Add series
        // https://www.amcharts.com/docs/v5/charts/xy-chart/series/
        let series = chart.series.push(ColumnSeries.new(root, {
            xAxis: xAxis,
            yAxis: yAxis,
            valueXField: "value",
            categoryYField: "network"
        }));
        // Rounded corners for columns
        series.columns.template.setAll({ cornerRadiusBR: 5, cornerRadiusTR: 5 });
        // Make each column to be of a different color
        series.columns.template.adapters.add("fill", function (fill, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        series.columns.template.adapters.add("stroke", function (stroke, target) {
            // @ts-ignore
            return chart.get("colors").getIndex(series.columns.indexOf(target));
        });
        // Add label bullet
        series.bullets.push(function () {
            return Bullet.new(root, {
                locationX: 1,
                sprite: Label.new(root, {
                    text: "{categoryY}",
                    fill: root.interfaceColors.get("alternativeText"),
                    centerX: p100,
                    centerY: p50,
                    populateText: true
                })
            });
        });
        let label = chart.plotContainer.children.push(Label.new(root, {
            text: "1",
            fontSize: "8em",
            opacity: 0.2,
            x: p100,
            y: p100,
            centerY: p100,
            centerX: p100
        }));
        // Get series item by category
        function getSeriesItem(category) {
            for (var i = 0; i < series.dataItems.length; i++) {
                let dataItem = series.dataItems[i];
                if (dataItem.get("categoryY") == category) {
                    return dataItem;
                }
            }
            return null;
        }
        // Axis sorting
        function sortCategoryAxis() {
            // sort by value
            series.dataItems.sort(function (x, y) {
                // @ts-ignore
                return y.get("valueX") - x.get("valueX"); // descending
                //return x.get("valueX") - y.get("valueX"); // ascending
            });
            // go through each axis item
            each(yAxis.dataItems, function (dataItem) {
                // get corresponding series item
                let seriesDataItem = getSeriesItem(dataItem.get("category"));
                if (seriesDataItem) {
                    // get index of series data item
                    let index = series.dataItems.indexOf(seriesDataItem);
                    // calculate delta position
                    let deltaPosition = (index - dataItem.get("index", 0)) / series.dataItems.length;
                    // set index to be the same as series data item index
                    if (dataItem.get("index") != index) {
                        dataItem.set("index", index);
                        // set deltaPosition instanlty
                        dataItem.set("deltaPosition", -deltaPosition);
                        // animate delta position to 0
                        dataItem.animate({
                            key: "deltaPosition",
                            to: 0,
                            duration: stepDuration / 2,
                            easing: out(cubic)
                        });
                    }
                }
            });
            // sort axis items by index.
            // This changes the order instantly, but as deltaPosition is set, they keep in the same places and then animate to true positions.
            yAxis.dataItems.sort(function (x, y) {
                // @ts-ignore
                return x.get("index") - y.get("index");
            });
        }
        let lap = 0;
        let total = this.total;
        // update data with values each 1.5 sec
        let interval = setInterval(function () {
            lap++;
            if (lap > dataMap.size) {
                clearInterval(interval);
                clearInterval(sortInterval);
            }
            updateData(dataMap);
        }, stepDuration);
        let sortInterval = setInterval(function () {
            sortCategoryAxis();
        }, 100);
        function setInitialData(dataMap) {
            let lapMap = dataMap.get(0);
            lapMap.forEach((value, key) => {
                series.data.push({ network: key, value: value, color: 'red' });
                yAxis.data.push({ network: key });
            });
        }
        function updateData(dataMap) {
            let itemsWithNonZero = 0;
            let newLastDriver = 0;
            if (dataMap.get(lap)) {
                label.set("text", lap.toString());
                const fastestDriver = dataMap.get(lap).get("LEADER");
                each(series.dataItems, function (dataItem) {
                    let category = dataItem.get("categoryY");
                    let value1 = dataMap.get(lap).get(category);
                    let value;
                    if (value1 == null) {
                        value = 0;
                    }
                    else {
                        value = fastestDriver - (value1 - fastestDriver);
                    }
                    dataItem.animate({
                        key: "valueX",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                    dataItem.animate({
                        key: "valueXWorking",
                        to: value,
                        duration: stepDuration,
                        easing: linear
                    });
                });
            }
        }
        setInitialData(dataMap);
        setTimeout(function () {
            lap++;
            updateData(dataMap);
        }, 50);
        // Make stuff animate on load
        // https://www.amcharts.com/docs/v5/concepts/animations/
        series.appear(1000);
        chart.appear(100, 100);
    }
    ngOnDestroy() {
        // Clean up chart when the component is removed
        this.browserOnly(() => {
            if (this.root) {
                this.root.dispose();
            }
            else {
                this.root.dispose();
            }
        });
    }
    getDataFromDrivers() {
        let dataMap = new Map();
        for (let i = 0; i <= this.total; i++) {
            dataMap.set(i, new Map());
        }
        this.drivers.forEach(driver => {
            dataMap.get(0).set(driver.LastName, 0);
            for (let i = 0; i < driver.lapByLapData.totalTimeByLapMs.length; i++) {
                dataMap.get(i + 1).set(driver.LastName, driver.lapByLapData.totalTimeByLapMs[i]);
                if (driver.lapByLapData.positions[i] == 1) {
                    dataMap.get(i + 1).set("LEADER", driver.lapByLapData.totalTimeByLapMs[i]);
                }
            }
        });
        this.dataMap = dataMap;
        return dataMap;
    }
    onStepDurationChange(value) {
    }
    onOffChart(event) {
        if (event.checked) {
            this.ngAfterViewInit();
        }
        else {
            this.ngOnDestroy();
        }
        this.onOff = event.checked;
    }
}
AmChartRaComponent.ɵfac = function AmChartRaComponent_Factory(t) { return new (t || AmChartRaComponent)(core/* ɵɵdirectiveInject */.Y36(core/* PLATFORM_ID */.Lbi), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b)); };
AmChartRaComponent.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: AmChartRaComponent, selectors: [["app-amchart-ra-cmp"]], inputs: { drivers: "drivers", total: "total" }, decls: 4, vars: 2, consts: [["id", "chartdiv", 2, "width", "100%", "height", "500px"], [1, "text-center", "wide-slider-container-2"], [3, "ngModel", "change"], ["class", "text-center mt-1", 4, "ngIf"], [1, "text-center", "mt-1"], ["aria-label", "units", "max", "5", "min", "1", "thumbLabel", "", 3, "ngModel", "change", "ngModelChange"]], template: function AmChartRaComponent_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵelement */._UZ(0, "div", 0);
        core/* ɵɵelementStart */.TgZ(1, "div", 1);
        core/* ɵɵelementStart */.TgZ(2, "mat-slide-toggle", 2);
        core/* ɵɵlistener */.NdJ("change", function AmChartRaComponent_Template_mat_slide_toggle_change_2_listener($event) { return ctx.onOffChart($event); });
        core/* ɵɵelementEnd */.qZA();
        core/* ɵɵtemplate */.YNc(3, AmChartRaComponent_div_3_Template, 4, 1, "div", 3);
        core/* ɵɵelementEnd */.qZA();
    } if (rf & 2) {
        core/* ɵɵadvance */.xp6(2);
        core/* ɵɵproperty */.Q6J("ngModel", ctx.onOff);
        core/* ɵɵadvance */.xp6(1);
        core/* ɵɵproperty */.Q6J("ngIf", !ctx.onOff);
    } }, directives: [slide_toggle/* MatSlideToggle */.Rr, fesm2015_forms/* NgControlStatus */.JJ, fesm2015_forms/* NgModel */.On, common/* NgIf */.O5, MatSlider], encapsulation: 2 });

;// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/autocomplete.js
















/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Autocomplete IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 */








const autocomplete_c0 = ["panel"];
function MatAutocomplete_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    core/* ɵɵelementStart */.TgZ(0, "div", 0, 1);
    core/* ɵɵprojection */.Hsn(2);
    core/* ɵɵelementEnd */.qZA();
} if (rf & 2) {
    const formFieldId_r1 = ctx.id;
    const ctx_r0 = core/* ɵɵnextContext */.oxw();
    core/* ɵɵproperty */.Q6J("id", ctx_r0.id)("ngClass", ctx_r0._classList);
    core/* ɵɵattribute */.uIk("aria-label", ctx_r0.ariaLabel || null)("aria-labelledby", ctx_r0._getPanelAriaLabelledby(formFieldId_r1));
} }
const autocomplete_c1 = ["*"];
let _uniqueAutocompleteIdCounter = 0;
/** Event object that is emitted when an autocomplete option is selected. */
class MatAutocompleteSelectedEvent {
    constructor(
    /** Reference to the autocomplete panel that emitted the event. */
    source, 
    /** Option that was selected. */
    option) {
        this.source = source;
        this.option = option;
    }
}
// Boilerplate for applying mixins to MatAutocomplete.
/** @docs-private */
const _MatAutocompleteMixinBase = (0,fesm2015_core/* mixinDisableRipple */.Kr)(class {
});
/** Injection token to be used to override the default options for `mat-autocomplete`. */
const MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core/* InjectionToken */.OlP('mat-autocomplete-default-options', {
    providedIn: 'root',
    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,
});
/** @docs-private */
function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
    return { autoActiveFirstOption: false };
}
/** Base class with all of the `MatAutocomplete` functionality. */
class _MatAutocompleteBase extends _MatAutocompleteMixinBase {
    constructor(_changeDetectorRef, _elementRef, defaults, platform) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._activeOptionChanges = Subscription/* Subscription.EMPTY */.w.EMPTY;
        /** Whether the autocomplete panel should be visible, depending on option length. */
        this.showPanel = false;
        this._isOpen = false;
        /** Function that maps an option's control value to its display value in the trigger. */
        this.displayWith = null;
        /** Event that is emitted whenever an option from the list is selected. */
        this.optionSelected = new core/* EventEmitter */.vpe();
        /** Event that is emitted when the autocomplete panel is opened. */
        this.opened = new core/* EventEmitter */.vpe();
        /** Event that is emitted when the autocomplete panel is closed. */
        this.closed = new core/* EventEmitter */.vpe();
        /** Emits whenever an option is activated using the keyboard. */
        this.optionActivated = new core/* EventEmitter */.vpe();
        this._classList = {};
        /** Unique ID to be used by autocomplete trigger's "aria-owns" property. */
        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;
        // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on
        // Safari using VoiceOver. We should occasionally check back to see whether the bug
        // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`
        // option altogether.
        this.inertGroups = (platform === null || platform === void 0 ? void 0 : platform.SAFARI) || false;
        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;
    }
    /** Whether the autocomplete panel is open. */
    get isOpen() { return this._isOpen && this.showPanel; }
    /**
     * Whether the first option should be highlighted when the autocomplete panel is opened.
     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
     */
    get autoActiveFirstOption() { return this._autoActiveFirstOption; }
    set autoActiveFirstOption(value) {
        this._autoActiveFirstOption = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    /**
     * Takes classes set on the host mat-autocomplete element and applies them to the panel
     * inside the overlay container to allow for easy styling.
     */
    set classList(value) {
        if (value && value.length) {
            this._classList = (0,coercion/* coerceStringArray */.du)(value).reduce((classList, className) => {
                classList[className] = true;
                return classList;
            }, {});
        }
        else {
            this._classList = {};
        }
        this._setVisibilityClasses(this._classList);
        this._elementRef.nativeElement.className = '';
    }
    ngAfterContentInit() {
        this._keyManager = new a11y/* ActiveDescendantKeyManager */.s1(this.options).withWrap();
        this._activeOptionChanges = this._keyManager.change.subscribe(index => {
            this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });
        });
        // Set the initial visibility state.
        this._setVisibility();
    }
    ngOnDestroy() {
        this._activeOptionChanges.unsubscribe();
    }
    /**
     * Sets the panel scrollTop. This allows us to manually scroll to display options
     * above or below the fold, as they are not actually being focused when active.
     */
    _setScrollTop(scrollTop) {
        if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
        }
    }
    /** Returns the panel's scrollTop. */
    _getScrollTop() {
        return this.panel ? this.panel.nativeElement.scrollTop : 0;
    }
    /** Panel should hide itself when the option list is empty. */
    _setVisibility() {
        this.showPanel = !!this.options.length;
        this._setVisibilityClasses(this._classList);
        this._changeDetectorRef.markForCheck();
    }
    /** Emits the `select` event. */
    _emitSelectEvent(option) {
        const event = new MatAutocompleteSelectedEvent(this, option);
        this.optionSelected.emit(event);
    }
    /** Gets the aria-labelledby for the autocomplete panel. */
    _getPanelAriaLabelledby(labelId) {
        if (this.ariaLabel) {
            return null;
        }
        const labelExpression = labelId ? labelId + ' ' : '';
        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;
    }
    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */
    _setVisibilityClasses(classList) {
        classList[this._visibleClass] = this.showPanel;
        classList[this._hiddenClass] = !this.showPanel;
    }
}
_MatAutocompleteBase.ɵfac = function _MatAutocompleteBase_Factory(t) { return new (t || _MatAutocompleteBase)(core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS), core/* ɵɵdirectiveInject */.Y36(platform/* Platform */.t4)); };
_MatAutocompleteBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatAutocompleteBase, viewQuery: function _MatAutocompleteBase_Query(rf, ctx) { if (rf & 1) {
        core/* ɵɵviewQuery */.Gf(core/* TemplateRef */.Rgc, 7);
        core/* ɵɵviewQuery */.Gf(autocomplete_c0, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.template = _t.first);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.panel = _t.first);
    } }, inputs: { displayWith: "displayWith", autoActiveFirstOption: "autoActiveFirstOption", classList: ["class", "classList"], ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], panelWidth: "panelWidth" }, outputs: { optionSelected: "optionSelected", opened: "opened", closed: "closed", optionActivated: "optionActivated" }, features: [core/* ɵɵInheritDefinitionFeature */.qOj] });
_MatAutocompleteBase.ctorParameters = () => [
    { type: core/* ChangeDetectorRef */.sBO },
    { type: core/* ElementRef */.SBq },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] },
    { type: platform/* Platform */.t4 }
];
_MatAutocompleteBase.propDecorators = {
    template: [{ type: core/* ViewChild */.i9L, args: [core/* TemplateRef */.Rgc, { static: true },] }],
    panel: [{ type: core/* ViewChild */.i9L, args: ['panel',] }],
    ariaLabel: [{ type: core/* Input */.IIB, args: ['aria-label',] }],
    ariaLabelledby: [{ type: core/* Input */.IIB, args: ['aria-labelledby',] }],
    displayWith: [{ type: core/* Input */.IIB }],
    autoActiveFirstOption: [{ type: core/* Input */.IIB }],
    panelWidth: [{ type: core/* Input */.IIB }],
    optionSelected: [{ type: core/* Output */.r_U }],
    opened: [{ type: core/* Output */.r_U }],
    closed: [{ type: core/* Output */.r_U }],
    optionActivated: [{ type: core/* Output */.r_U }],
    classList: [{ type: core/* Input */.IIB, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatAutocompleteBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: core/* ChangeDetectorRef */.sBO }, { type: core/* ElementRef */.SBq }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]
            }] }, { type: platform/* Platform */.t4 }]; }, { displayWith: [{
            type: core/* Input */.IIB
        }], optionSelected: [{
            type: core/* Output */.r_U
        }], opened: [{
            type: core/* Output */.r_U
        }], closed: [{
            type: core/* Output */.r_U
        }], optionActivated: [{
            type: core/* Output */.r_U
        }], autoActiveFirstOption: [{
            type: core/* Input */.IIB
        }], classList: [{
            type: core/* Input */.IIB,
            args: ['class']
        }], template: [{
            type: core/* ViewChild */.i9L,
            args: [core/* TemplateRef */.Rgc, { static: true }]
        }], panel: [{
            type: core/* ViewChild */.i9L,
            args: ['panel']
        }], ariaLabel: [{
            type: core/* Input */.IIB,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: core/* Input */.IIB,
            args: ['aria-labelledby']
        }], panelWidth: [{
            type: core/* Input */.IIB
        }] }); })();
class MatAutocomplete extends _MatAutocompleteBase {
    constructor() {
        super(...arguments);
        this._visibleClass = 'mat-autocomplete-visible';
        this._hiddenClass = 'mat-autocomplete-hidden';
    }
}
MatAutocomplete.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocomplete_BaseFactory; return function MatAutocomplete_Factory(t) { return (ɵMatAutocomplete_BaseFactory || (ɵMatAutocomplete_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatAutocomplete)))(t || MatAutocomplete); }; }();
MatAutocomplete.ɵcmp = /*@__PURE__*/ core/* ɵɵdefineComponent */.Xpm({ type: MatAutocomplete, selectors: [["mat-autocomplete"]], contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        core/* ɵɵcontentQuery */.Suo(dirIndex, fesm2015_core/* MAT_OPTGROUP */.K7, 5);
        core/* ɵɵcontentQuery */.Suo(dirIndex, fesm2015_core/* MatOption */.ey, 5);
    } if (rf & 2) {
        let _t;
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.optionGroups = _t);
        core/* ɵɵqueryRefresh */.iGM(_t = core/* ɵɵloadQuery */.CRH()) && (ctx.options = _t);
    } }, hostAttrs: [1, "mat-autocomplete"], inputs: { disableRipple: "disableRipple" }, exportAs: ["matAutocomplete"], features: [core/* ɵɵProvidersFeature */._Bn([
            { provide: fesm2015_core/* MAT_OPTION_PARENT_COMPONENT */.HF, useExisting: MatAutocomplete }
        ]), core/* ɵɵInheritDefinitionFeature */.qOj], ngContentSelectors: autocomplete_c1, decls: 1, vars: 0, consts: [["role", "listbox", 1, "mat-autocomplete-panel", 3, "id", "ngClass"], ["panel", ""]], template: function MatAutocomplete_Template(rf, ctx) { if (rf & 1) {
        core/* ɵɵprojectionDef */.F$t();
        core/* ɵɵtemplate */.YNc(0, MatAutocomplete_ng_template_0_Template, 3, 4, "ng-template");
    } }, directives: [common/* NgClass */.mk], styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}mat-autocomplete{display:none}\n"], encapsulation: 2, changeDetection: 0 });
MatAutocomplete.propDecorators = {
    optionGroups: [{ type: core/* ContentChildren */.AcB, args: [fesm2015_core/* MAT_OPTGROUP */.K7, { descendants: true },] }],
    options: [{ type: core/* ContentChildren */.AcB, args: [fesm2015_core/* MatOption */.ey, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatAutocomplete, [{
        type: core/* Component */.wA2,
        args: [{
                selector: 'mat-autocomplete',
                template: "<ng-template let-formFieldId=\"id\">\n  <div class=\"mat-autocomplete-panel\"\n       role=\"listbox\"\n       [id]=\"id\"\n       [attr.aria-label]=\"ariaLabel || null\"\n       [attr.aria-labelledby]=\"_getPanelAriaLabelledby(formFieldId)\"\n       [ngClass]=\"_classList\"\n       #panel>\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n",
                encapsulation: core/* ViewEncapsulation.None */.ifc.None,
                changeDetection: core/* ChangeDetectionStrategy.OnPush */.n4l.OnPush,
                exportAs: 'matAutocomplete',
                inputs: ['disableRipple'],
                host: {
                    'class': 'mat-autocomplete'
                },
                providers: [
                    { provide: fesm2015_core/* MAT_OPTION_PARENT_COMPONENT */.HF, useExisting: MatAutocomplete }
                ],
                styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}mat-autocomplete{display:none}\n"]
            }]
    }], null, { optionGroups: [{
            type: core/* ContentChildren */.AcB,
            args: [fesm2015_core/* MAT_OPTGROUP */.K7, { descendants: true }]
        }], options: [{
            type: core/* ContentChildren */.AcB,
            args: [fesm2015_core/* MatOption */.ey, { descendants: true }]
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Base class containing all of the functionality for `MatAutocompleteOrigin`. */
class _MatAutocompleteOriginBase {
    constructor(
    /** Reference to the element on which the directive is applied. */
    elementRef) {
        this.elementRef = elementRef;
    }
}
_MatAutocompleteOriginBase.ɵfac = function _MatAutocompleteOriginBase_Factory(t) { return new (t || _MatAutocompleteOriginBase)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq)); };
_MatAutocompleteOriginBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatAutocompleteOriginBase });
_MatAutocompleteOriginBase.ctorParameters = () => [
    { type: core/* ElementRef */.SBq }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatAutocompleteOriginBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: core/* ElementRef */.SBq }]; }, null); })();
/**
 * Directive applied to an element to make it usable
 * as a connection point for an autocomplete panel.
 */
class MatAutocompleteOrigin extends _MatAutocompleteOriginBase {
}
MatAutocompleteOrigin.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocompleteOrigin_BaseFactory; return function MatAutocompleteOrigin_Factory(t) { return (ɵMatAutocompleteOrigin_BaseFactory || (ɵMatAutocompleteOrigin_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatAutocompleteOrigin)))(t || MatAutocompleteOrigin); }; }();
MatAutocompleteOrigin.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatAutocompleteOrigin, selectors: [["", "matAutocompleteOrigin", ""]], exportAs: ["matAutocompleteOrigin"], features: [core/* ɵɵInheritDefinitionFeature */.qOj] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatAutocompleteOrigin, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: '[matAutocompleteOrigin]',
                exportAs: 'matAutocompleteOrigin'
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token that determines the scroll handling while the autocomplete panel is open. */
const MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core/* InjectionToken */.OlP('mat-autocomplete-scroll-strategy');
/** @docs-private */
function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {
    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,
    deps: [overlay/* Overlay */.aV],
    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,
};
/**
 * Provider that allows the autocomplete to register as a ControlValueAccessor.
 * @docs-private
 */
const MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: fesm2015_forms/* NG_VALUE_ACCESSOR */.JU,
    useExisting: (0,core/* forwardRef */.Gpc)(() => MatAutocompleteTrigger),
    multi: true
};
/**
 * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
 * @docs-private
 */
function getMatAutocompleteMissingPanelError() {
    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +
        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +
        'you\'re attempting to open it after the ngAfterContentInit hook.');
}
/** Base class with all of the `MatAutocompleteTrigger` functionality. */
class _MatAutocompleteTriggerBase {
    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {
        this._element = _element;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._formField = _formField;
        this._document = _document;
        this._viewportRuler = _viewportRuler;
        this._defaults = _defaults;
        this._componentDestroyed = false;
        this._autocompleteDisabled = false;
        /** Whether or not the label state is being overridden. */
        this._manuallyFloatingLabel = false;
        /** Subscription to viewport size changes. */
        this._viewportSubscription = Subscription/* Subscription.EMPTY */.w.EMPTY;
        /**
         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
         * closed autocomplete from being reopened if the user switches to another browser tab and then
         * comes back.
         */
        this._canOpenOnNextFocus = true;
        /** Stream of keyboard events that can close the panel. */
        this._closeKeyEventStream = new Subject/* Subject */.xQ();
        /**
         * Event handler for when the window is blurred. Needs to be an
         * arrow function in order to preserve the context.
         */
        this._windowBlurHandler = () => {
            // If the user blurred the window while the autocomplete is focused, it means that it'll be
            // refocused when they come back. In this case we want to skip the first focus event, if the
            // pane was closed, in order to avoid reopening it unintentionally.
            this._canOpenOnNextFocus =
                this._document.activeElement !== this._element.nativeElement || this.panelOpen;
        };
        /** `View -> model callback called when value changes` */
        this._onChange = () => { };
        /** `View -> model callback called when autocomplete has been touched` */
        this._onTouched = () => { };
        /**
         * Position of the autocomplete panel relative to the trigger element. A position of `auto`
         * will render the panel underneath the trigger if there is enough space for it to fit in
         * the viewport, otherwise the panel will be shown above it. If the position is set to
         * `above` or `below`, the panel will always be shown above or below the trigger. no matter
         * whether it fits completely in the viewport.
         */
        this.position = 'auto';
        /**
         * `autocomplete` attribute to be set on the input element.
         * @docs-private
         */
        this.autocompleteAttribute = 'off';
        this._overlayAttached = false;
        /** Stream of autocomplete option selections. */
        this.optionSelections = (0,defer/* defer */.P)(() => {
            if (this.autocomplete && this.autocomplete.options) {
                return (0,merge/* merge */.T)(...this.autocomplete.options.map(option => option.onSelectionChange));
            }
            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
            // Return a stream that we'll replace with the real one once everything is in place.
            return this._zone.onStable
                .pipe((0,take/* take */.q)(1), (0,switchMap/* switchMap */.w)(() => this.optionSelections));
        });
        this._scrollStrategy = scrollStrategy;
    }
    /**
     * Whether the autocomplete is disabled. When disabled, the element will
     * act as a regular input and the user won't be able to open the panel.
     */
    get autocompleteDisabled() { return this._autocompleteDisabled; }
    set autocompleteDisabled(value) {
        this._autocompleteDisabled = (0,coercion/* coerceBooleanProperty */.Ig)(value);
    }
    ngAfterViewInit() {
        const window = this._getWindow();
        if (typeof window !== 'undefined') {
            this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));
        }
    }
    ngOnChanges(changes) {
        if (changes['position'] && this._positionStrategy) {
            this._setStrategyPositions(this._positionStrategy);
            if (this.panelOpen) {
                this._overlayRef.updatePosition();
            }
        }
    }
    ngOnDestroy() {
        const window = this._getWindow();
        if (typeof window !== 'undefined') {
            window.removeEventListener('blur', this._windowBlurHandler);
        }
        this._viewportSubscription.unsubscribe();
        this._componentDestroyed = true;
        this._destroyPanel();
        this._closeKeyEventStream.complete();
    }
    /** Whether or not the autocomplete panel is open. */
    get panelOpen() {
        return this._overlayAttached && this.autocomplete.showPanel;
    }
    /** Opens the autocomplete suggestion panel. */
    openPanel() {
        this._attachOverlay();
        this._floatLabel();
    }
    /** Closes the autocomplete suggestion panel. */
    closePanel() {
        this._resetLabel();
        if (!this._overlayAttached) {
            return;
        }
        if (this.panelOpen) {
            // Only emit if the panel was visible.
            this.autocomplete.closed.emit();
        }
        this.autocomplete._isOpen = this._overlayAttached = false;
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
            this._closingActionsSubscription.unsubscribe();
        }
        // Note that in some cases this can end up being called after the component is destroyed.
        // Add a check to ensure that we don't try to run change detection on a destroyed view.
        if (!this._componentDestroyed) {
            // We need to trigger change detection manually, because
            // `fromEvent` doesn't seem to do it at the proper time.
            // This ensures that the label is reset when the
            // user clicks outside.
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
     * within the viewport.
     */
    updatePosition() {
        if (this._overlayAttached) {
            this._overlayRef.updatePosition();
        }
    }
    /**
     * A stream of actions that should close the autocomplete panel, including
     * when an option is selected, on blur, and when TAB is pressed.
     */
    get panelClosingActions() {
        return (0,merge/* merge */.T)(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe((0,filter/* filter */.h)(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?
            this._overlayRef.detachments().pipe((0,filter/* filter */.h)(() => this._overlayAttached)) :
            (0,of.of)()).pipe(
        // Normalize the output so we return a consistent type.
        (0,operators_map/* map */.U)(event => event instanceof fesm2015_core/* MatOptionSelectionChange */.rN ? event : null));
    }
    /** The currently active option, coerced to MatOption type. */
    get activeOption() {
        if (this.autocomplete && this.autocomplete._keyManager) {
            return this.autocomplete._keyManager.activeItem;
        }
        return null;
    }
    /** Stream of clicks outside of the autocomplete panel. */
    _getOutsideClickStream() {
        return (0,merge/* merge */.T)((0,fromEvent/* fromEvent */.R)(this._document, 'click'), (0,fromEvent/* fromEvent */.R)(this._document, 'auxclick'), (0,fromEvent/* fromEvent */.R)(this._document, 'touchend'))
            .pipe((0,filter/* filter */.h)(event => {
            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
            // fall back to check the first element in the path of the click event.
            const clickTarget = (0,platform/* _getEventTarget */.sA)(event);
            const formField = this._formField ? this._formField._elementRef.nativeElement : null;
            const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;
            return this._overlayAttached && clickTarget !== this._element.nativeElement &&
                (!formField || !formField.contains(clickTarget)) &&
                (!customOrigin || !customOrigin.contains(clickTarget)) &&
                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));
        }));
    }
    // Implemented as part of ControlValueAccessor.
    writeValue(value) {
        Promise.resolve(null).then(() => this._setTriggerValue(value));
    }
    // Implemented as part of ControlValueAccessor.
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // Implemented as part of ControlValueAccessor.
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    // Implemented as part of ControlValueAccessor.
    setDisabledState(isDisabled) {
        this._element.nativeElement.disabled = isDisabled;
    }
    _handleKeydown(event) {
        const keyCode = event.keyCode;
        // Prevent the default action on all escape key presses. This is here primarily to bring IE
        // in line with other browsers. By default, pressing escape on IE will cause it to revert
        // the input value to the one that it had on focus, however it won't dispatch any events
        // which means that the model value will be out of sync with the view.
        if (keyCode === keycodes/* ESCAPE */.hY && !(0,keycodes/* hasModifierKey */.Vb)(event)) {
            event.preventDefault();
        }
        if (this.activeOption && keyCode === keycodes/* ENTER */.K5 && this.panelOpen) {
            this.activeOption._selectViaInteraction();
            this._resetActiveItem();
            event.preventDefault();
        }
        else if (this.autocomplete) {
            const prevActiveItem = this.autocomplete._keyManager.activeItem;
            const isArrowKey = keyCode === keycodes/* UP_ARROW */.LH || keyCode === keycodes/* DOWN_ARROW */.JH;
            if (this.panelOpen || keyCode === keycodes/* TAB */.Mf) {
                this.autocomplete._keyManager.onKeydown(event);
            }
            else if (isArrowKey && this._canOpen()) {
                this.openPanel();
            }
            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);
            }
        }
    }
    _handleInput(event) {
        let target = event.target;
        let value = target.value;
        // Based on `NumberValueAccessor` from forms.
        if (target.type === 'number') {
            value = value == '' ? null : parseFloat(value);
        }
        // If the input has a placeholder, IE will fire the `input` event on page load,
        // focus and blur, in addition to when the user actually changed the value. To
        // filter out all of the extra events, we save the value on focus and between
        // `input` events, and we check whether it changed.
        // See: https://connect.microsoft.com/IE/feedback/details/885747/
        if (this._previousValue !== value) {
            this._previousValue = value;
            this._onChange(value);
            if (this._canOpen() && this._document.activeElement === event.target) {
                this.openPanel();
            }
        }
    }
    _handleFocus() {
        if (!this._canOpenOnNextFocus) {
            this._canOpenOnNextFocus = true;
        }
        else if (this._canOpen()) {
            this._previousValue = this._element.nativeElement.value;
            this._attachOverlay();
            this._floatLabel(true);
        }
    }
    /**
     * In "auto" mode, the label will animate down as soon as focus is lost.
     * This causes the value to jump when selecting an option with the mouse.
     * This method manually floats the label until the panel can be closed.
     * @param shouldAnimate Whether the label should be animated when it is floated.
     */
    _floatLabel(shouldAnimate = false) {
        if (this._formField && this._formField.floatLabel === 'auto') {
            if (shouldAnimate) {
                this._formField._animateAndLockLabel();
            }
            else {
                this._formField.floatLabel = 'always';
            }
            this._manuallyFloatingLabel = true;
        }
    }
    /** If the label has been manually elevated, return it to its normal state. */
    _resetLabel() {
        if (this._manuallyFloatingLabel) {
            this._formField.floatLabel = 'auto';
            this._manuallyFloatingLabel = false;
        }
    }
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    _subscribeToClosingActions() {
        const firstStable = this._zone.onStable.pipe((0,take/* take */.q)(1));
        const optionChanges = this.autocomplete.options.changes.pipe((0,tap/* tap */.b)(() => this._positionStrategy.reapplyLastPosition()), 
        // Defer emitting to the stream until the next tick, because changing
        // bindings in here will cause "changed after checked" errors.
        (0,delay/* delay */.g)(0));
        // When the zone is stable initially, and when the option list changes...
        return (0,merge/* merge */.T)(firstStable, optionChanges)
            .pipe(
        // create a new stream of panelClosingActions, replacing any previous streams
        // that were created, and flatten it so our stream only emits closing events...
        (0,switchMap/* switchMap */.w)(() => {
            const wasOpen = this.panelOpen;
            this._resetActiveItem();
            this.autocomplete._setVisibility();
            if (this.panelOpen) {
                this._overlayRef.updatePosition();
                // If the `panelOpen` state changed, we need to make sure to emit the `opened`
                // event, because we may not have emitted it when the panel was attached. This
                // can happen if the users opens the panel and there are no options, but the
                // options come in slightly later or as a result of the value changing.
                if (wasOpen !== this.panelOpen) {
                    this.autocomplete.opened.emit();
                }
            }
            return this.panelClosingActions;
        }), 
        // when the first closing event occurs...
        (0,take/* take */.q)(1))
            // set the value, close the panel, and complete.
            .subscribe(event => this._setValueAndClose(event));
    }
    /** Destroys the autocomplete suggestion panel. */
    _destroyPanel() {
        if (this._overlayRef) {
            this.closePanel();
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    _setTriggerValue(value) {
        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?
            this.autocomplete.displayWith(value) :
            value;
        // Simply falling back to an empty string if the display value is falsy does not work properly.
        // The display value can also be the number zero and shouldn't fall back to an empty string.
        const inputValue = toDisplay != null ? toDisplay : '';
        // If it's used within a `MatFormField`, we should set it through the property so it can go
        // through change detection.
        if (this._formField) {
            this._formField._control.value = inputValue;
        }
        else {
            this._element.nativeElement.value = inputValue;
        }
        this._previousValue = inputValue;
    }
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     */
    _setValueAndClose(event) {
        if (event && event.source) {
            this._clearPreviousSelectedOption(event.source);
            this._setTriggerValue(event.source.value);
            this._onChange(event.source.value);
            this._element.nativeElement.focus();
            this.autocomplete._emitSelectEvent(event.source);
        }
        this.closePanel();
    }
    /**
     * Clear any previous selected option and emit a selection change event for this option
     */
    _clearPreviousSelectedOption(skip) {
        this.autocomplete.options.forEach(option => {
            if (option !== skip && option.selected) {
                option.deselect();
            }
        });
    }
    _attachOverlay() {
        var _a;
        if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw getMatAutocompleteMissingPanelError();
        }
        let overlayRef = this._overlayRef;
        if (!overlayRef) {
            this._portal = new portal/* TemplatePortal */.UE(this.autocomplete.template, this._viewContainerRef, { id: (_a = this._formField) === null || _a === void 0 ? void 0 : _a.getLabelId() });
            overlayRef = this._overlay.create(this._getOverlayConfig());
            this._overlayRef = overlayRef;
            // Use the `keydownEvents` in order to take advantage of
            // the overlay event targeting provided by the CDK overlay.
            overlayRef.keydownEvents().subscribe(event => {
                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                if ((event.keyCode === keycodes/* ESCAPE */.hY && !(0,keycodes/* hasModifierKey */.Vb)(event)) ||
                    (event.keyCode === keycodes/* UP_ARROW */.LH && (0,keycodes/* hasModifierKey */.Vb)(event, 'altKey'))) {
                    this._resetActiveItem();
                    this._closeKeyEventStream.next();
                    // We need to stop propagation, otherwise the event will eventually
                    // reach the input itself and cause the overlay to be reopened.
                    event.stopPropagation();
                    event.preventDefault();
                }
            });
            this._viewportSubscription = this._viewportRuler.change().subscribe(() => {
                if (this.panelOpen && overlayRef) {
                    overlayRef.updateSize({ width: this._getPanelWidth() });
                }
            });
        }
        else {
            // Update the trigger, panel width and direction, in case anything has changed.
            this._positionStrategy.setOrigin(this._getConnectedElement());
            overlayRef.updateSize({ width: this._getPanelWidth() });
        }
        if (overlayRef && !overlayRef.hasAttached()) {
            overlayRef.attach(this._portal);
            this._closingActionsSubscription = this._subscribeToClosingActions();
        }
        const wasOpen = this.panelOpen;
        this.autocomplete._setVisibility();
        this.autocomplete._isOpen = this._overlayAttached = true;
        // We need to do an extra `panelOpen` check in here, because the
        // autocomplete won't be shown if there are no options.
        if (this.panelOpen && wasOpen !== this.panelOpen) {
            this.autocomplete.opened.emit();
        }
    }
    _getOverlayConfig() {
        var _a;
        return new overlay/* OverlayConfig */.X_({
            positionStrategy: this._getOverlayPosition(),
            scrollStrategy: this._scrollStrategy(),
            width: this._getPanelWidth(),
            direction: this._dir,
            panelClass: (_a = this._defaults) === null || _a === void 0 ? void 0 : _a.overlayPanelClass,
        });
    }
    _getOverlayPosition() {
        const strategy = this._overlay.position()
            .flexibleConnectedTo(this._getConnectedElement())
            .withFlexibleDimensions(false)
            .withPush(false);
        this._setStrategyPositions(strategy);
        this._positionStrategy = strategy;
        return strategy;
    }
    /** Sets the positions on a position strategy based on the directive's input state. */
    _setStrategyPositions(positionStrategy) {
        // Note that we provide horizontal fallback positions, even though by default the dropdown
        // width matches the input, because consumers can override the width. See #18854.
        const belowPositions = [
            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },
            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' }
        ];
        // The overlay edge connected to the trigger should have squared corners, while
        // the opposite end has rounded corners. We apply a CSS class to swap the
        // border-radius based on the overlay position.
        const panelClass = this._aboveClass;
        const abovePositions = [
            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },
            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass }
        ];
        let positions;
        if (this.position === 'above') {
            positions = abovePositions;
        }
        else if (this.position === 'below') {
            positions = belowPositions;
        }
        else {
            positions = [...belowPositions, ...abovePositions];
        }
        positionStrategy.withPositions(positions);
    }
    _getConnectedElement() {
        if (this.connectedTo) {
            return this.connectedTo.elementRef;
        }
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
    }
    _getPanelWidth() {
        return this.autocomplete.panelWidth || this._getHostWidth();
    }
    /** Returns the width of the input element, so the panel width can match it. */
    _getHostWidth() {
        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
    }
    /**
     * Resets the active item to -1 so arrow events will activate the
     * correct options, or to 0 if the consumer opted into it.
     */
    _resetActiveItem() {
        const autocomplete = this.autocomplete;
        if (autocomplete.autoActiveFirstOption) {
            // Note that we go through `setFirstItemActive`, rather than `setActiveItem(0)`, because
            // the former will find the next enabled option, if the first one is disabled.
            autocomplete._keyManager.setFirstItemActive();
        }
        else {
            autocomplete._keyManager.setActiveItem(-1);
        }
    }
    /** Determines whether the panel can be opened. */
    _canOpen() {
        const element = this._element.nativeElement;
        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;
    }
    /** Use defaultView of injected document if available or fallback to global window reference */
    _getWindow() {
        var _a;
        return ((_a = this._document) === null || _a === void 0 ? void 0 : _a.defaultView) || window;
    }
    /** Scrolls to a particular option in the list. */
    _scrollToOption(index) {
        // Given that we are not actually focusing active options, we must manually adjust scroll
        // to reveal options below the fold. First, we find the offset of the option from the top
        // of the panel. If that offset is below the fold, the new scrollTop will be the offset -
        // the panel height + the option height, so the active option will be just visible at the
        // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
        // will become the offset. If that offset is visible within the panel already, the scrollTop is
        // not adjusted.
        const autocomplete = this.autocomplete;
        const labelCount = (0,fesm2015_core/* _countGroupLabelsBeforeOption */.CB)(index, autocomplete.options, autocomplete.optionGroups);
        if (index === 0 && labelCount === 1) {
            // If we've got one group label before the option and we're at the top option,
            // scroll the list to the top. This is better UX than scrolling the list to the
            // top of the option, because it allows the user to read the top group's label.
            autocomplete._setScrollTop(0);
        }
        else if (autocomplete.panel) {
            const option = autocomplete.options.toArray()[index];
            if (option) {
                const element = option._getHostElement();
                const newScrollPosition = (0,fesm2015_core/* _getOptionScrollPosition */.jH)(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);
                autocomplete._setScrollTop(newScrollPosition);
            }
        }
    }
}
_MatAutocompleteTriggerBase.ɵfac = function _MatAutocompleteTriggerBase_Factory(t) { return new (t || _MatAutocompleteTriggerBase)(core/* ɵɵdirectiveInject */.Y36(core/* ElementRef */.SBq), core/* ɵɵdirectiveInject */.Y36(overlay/* Overlay */.aV), core/* ɵɵdirectiveInject */.Y36(core/* ViewContainerRef */.s_b), core/* ɵɵdirectiveInject */.Y36(core/* NgZone */.R0b), core/* ɵɵdirectiveInject */.Y36(core/* ChangeDetectorRef */.sBO), core/* ɵɵdirectiveInject */.Y36(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), core/* ɵɵdirectiveInject */.Y36(bidi/* Directionality */.Is, 8), core/* ɵɵdirectiveInject */.Y36(MAT_FORM_FIELD, 9), core/* ɵɵdirectiveInject */.Y36(common/* DOCUMENT */.K0, 8), core/* ɵɵdirectiveInject */.Y36(scrolling/* ViewportRuler */.rL), core/* ɵɵdirectiveInject */.Y36(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, 8)); };
_MatAutocompleteTriggerBase.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: _MatAutocompleteTriggerBase, inputs: { position: ["matAutocompletePosition", "position"], autocompleteAttribute: ["autocomplete", "autocompleteAttribute"], autocompleteDisabled: ["matAutocompleteDisabled", "autocompleteDisabled"], autocomplete: ["matAutocomplete", "autocomplete"], connectedTo: ["matAutocompleteConnectedTo", "connectedTo"] }, features: [core/* ɵɵNgOnChangesFeature */.TTD] });
_MatAutocompleteTriggerBase.ctorParameters = () => [
    { type: core/* ElementRef */.SBq },
    { type: overlay/* Overlay */.aV },
    { type: core/* ViewContainerRef */.s_b },
    { type: core/* NgZone */.R0b },
    { type: core/* ChangeDetectorRef */.sBO },
    { type: undefined, decorators: [{ type: core/* Inject */.tBr, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },
    { type: bidi/* Directionality */.Is, decorators: [{ type: core/* Optional */.FiY }] },
    { type: MatFormField, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_FORM_FIELD,] }, { type: core/* Host */.AA_ }] },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [common/* DOCUMENT */.K0,] }] },
    { type: scrolling/* ViewportRuler */.rL },
    { type: undefined, decorators: [{ type: core/* Optional */.FiY }, { type: core/* Inject */.tBr, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }
];
_MatAutocompleteTriggerBase.propDecorators = {
    autocomplete: [{ type: core/* Input */.IIB, args: ['matAutocomplete',] }],
    position: [{ type: core/* Input */.IIB, args: ['matAutocompletePosition',] }],
    connectedTo: [{ type: core/* Input */.IIB, args: ['matAutocompleteConnectedTo',] }],
    autocompleteAttribute: [{ type: core/* Input */.IIB, args: ['autocomplete',] }],
    autocompleteDisabled: [{ type: core/* Input */.IIB, args: ['matAutocompleteDisabled',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(_MatAutocompleteTriggerBase, [{
        type: core/* Directive */.Xek
    }], function () { return [{ type: core/* ElementRef */.SBq }, { type: overlay/* Overlay */.aV }, { type: core/* ViewContainerRef */.s_b }, { type: core/* NgZone */.R0b }, { type: core/* ChangeDetectorRef */.sBO }, { type: undefined, decorators: [{
                type: core/* Inject */.tBr,
                args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]
            }] }, { type: bidi/* Directionality */.Is, decorators: [{
                type: core/* Optional */.FiY
            }] }, { type: MatFormField, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_FORM_FIELD]
            }, {
                type: core/* Host */.AA_
            }] }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [common/* DOCUMENT */.K0]
            }] }, { type: scrolling/* ViewportRuler */.rL }, { type: undefined, decorators: [{
                type: core/* Optional */.FiY
            }, {
                type: core/* Inject */.tBr,
                args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]
            }] }]; }, { position: [{
            type: core/* Input */.IIB,
            args: ['matAutocompletePosition']
        }], autocompleteAttribute: [{
            type: core/* Input */.IIB,
            args: ['autocomplete']
        }], autocompleteDisabled: [{
            type: core/* Input */.IIB,
            args: ['matAutocompleteDisabled']
        }], autocomplete: [{
            type: core/* Input */.IIB,
            args: ['matAutocomplete']
        }], connectedTo: [{
            type: core/* Input */.IIB,
            args: ['matAutocompleteConnectedTo']
        }] }); })();
class MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {
    constructor() {
        super(...arguments);
        this._aboveClass = 'mat-autocomplete-panel-above';
    }
}
MatAutocompleteTrigger.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocompleteTrigger_BaseFactory; return function MatAutocompleteTrigger_Factory(t) { return (ɵMatAutocompleteTrigger_BaseFactory || (ɵMatAutocompleteTrigger_BaseFactory = core/* ɵɵgetInheritedFactory */.n5z(MatAutocompleteTrigger)))(t || MatAutocompleteTrigger); }; }();
MatAutocompleteTrigger.ɵdir = /*@__PURE__*/ core/* ɵɵdefineDirective */.lG2({ type: MatAutocompleteTrigger, selectors: [["input", "matAutocomplete", ""], ["textarea", "matAutocomplete", ""]], hostAttrs: [1, "mat-autocomplete-trigger"], hostVars: 7, hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) { if (rf & 1) {
        core/* ɵɵlistener */.NdJ("focusin", function MatAutocompleteTrigger_focusin_HostBindingHandler() { return ctx._handleFocus(); })("blur", function MatAutocompleteTrigger_blur_HostBindingHandler() { return ctx._onTouched(); })("input", function MatAutocompleteTrigger_input_HostBindingHandler($event) { return ctx._handleInput($event); })("keydown", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });
    } if (rf & 2) {
        core/* ɵɵattribute */.uIk("autocomplete", ctx.autocompleteAttribute)("role", ctx.autocompleteDisabled ? null : "combobox")("aria-autocomplete", ctx.autocompleteDisabled ? null : "list")("aria-activedescendant", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)("aria-expanded", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())("aria-owns", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)("aria-haspopup", !ctx.autocompleteDisabled);
    } }, exportAs: ["matAutocompleteTrigger"], features: [core/* ɵɵProvidersFeature */._Bn([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), core/* ɵɵInheritDefinitionFeature */.qOj] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatAutocompleteTrigger, [{
        type: core/* Directive */.Xek,
        args: [{
                selector: `input[matAutocomplete], textarea[matAutocomplete]`,
                host: {
                    'class': 'mat-autocomplete-trigger',
                    '[attr.autocomplete]': 'autocompleteAttribute',
                    '[attr.role]': 'autocompleteDisabled ? null : "combobox"',
                    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : "list"',
                    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',
                    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',
                    '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',
                    '[attr.aria-haspopup]': '!autocompleteDisabled',
                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                    // a little earlier. This avoids issues where IE delays the focusing of the input.
                    '(focusin)': '_handleFocus()',
                    '(blur)': '_onTouched()',
                    '(input)': '_handleInput($event)',
                    '(keydown)': '_handleKeydown($event)'
                },
                exportAs: 'matAutocompleteTrigger',
                providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class MatAutocompleteModule {
}
MatAutocompleteModule.ɵfac = function MatAutocompleteModule_Factory(t) { return new (t || MatAutocompleteModule)(); };
MatAutocompleteModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: MatAutocompleteModule });
MatAutocompleteModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[
            overlay/* OverlayModule */.U8,
            fesm2015_core/* MatOptionModule */.Ng,
            fesm2015_core/* MatCommonModule */.BQ,
            common/* CommonModule */.ez
        ], scrolling/* CdkScrollableModule */.ZD,
        fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && core/* ɵsetClassMetadata */.zlt(MatAutocompleteModule, [{
        type: core/* NgModule */.LVF,
        args: [{
                imports: [
                    overlay/* OverlayModule */.U8,
                    fesm2015_core/* MatOptionModule */.Ng,
                    fesm2015_core/* MatCommonModule */.BQ,
                    common/* CommonModule */.ez
                ],
                exports: [
                    MatAutocomplete,
                    MatAutocompleteTrigger,
                    MatAutocompleteOrigin,
                    scrolling/* CdkScrollableModule */.ZD,
                    fesm2015_core/* MatOptionModule */.Ng,
                    fesm2015_core/* MatCommonModule */.BQ,
                ],
                declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
                providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(MatAutocompleteModule, { declarations: function () { return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin]; }, imports: function () { return [overlay/* OverlayModule */.U8,
        fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ,
        common/* CommonModule */.ez]; }, exports: function () { return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin, scrolling/* CdkScrollableModule */.ZD,
        fesm2015_core/* MatOptionModule */.Ng,
        fesm2015_core/* MatCommonModule */.BQ]; } }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=autocomplete.js.map
;// CONCATENATED MODULE: ./src/app/layouts/admin-layout/admin-layout.module.ts






































































class AdminLayoutModule {
}
AdminLayoutModule.ɵfac = function AdminLayoutModule_Factory(t) { return new (t || AdminLayoutModule)(); };
AdminLayoutModule.ɵmod = /*@__PURE__*/ core/* ɵɵdefineNgModule */.oAB({ type: AdminLayoutModule, bootstrap: [NgbdCarouselConfig] });
AdminLayoutModule.ɵinj = /*@__PURE__*/ core/* ɵɵdefineInjector */.cJS({ imports: [[
            ng2_adsense/* AdsenseModule.forRoot */.ih.forRoot({
                adClient: 'ca-pub-1302230400221331',
                adSlot: 5686017586,
            }),
            common/* CommonModule */.ez,
            router/* RouterModule.forChild */.Bz.forChild(AdminLayoutRoutes),
            fesm2015_forms/* FormsModule */.u5,
            ng_bootstrap/* NgbModule */.IJ, GalleryModule,
            MatCardModule,
            button_toggle/* MatButtonToggleModule */.vV,
            MatGridListModule, divider/* MatDividerModule */.t, icon/* MatIconModule */.Ps, fesm2015_button/* MatButtonModule */.ot, fesm2015_radio/* MatRadioModule */.Fk,
            ng_apexcharts/* NgApexchartsModule */.X, ngx_countdown/* CountdownModule */.cD, tabs/* MatTabsModule */.Nh, table/* MatTableModule */.p0, sidenav/* MatSidenavModule */.SJ,
            MatFormFieldModule, MatInputModule, InfiniteScrollModule, MatCarouselModule, MatDialogModule, MatTooltipModule,
            MatSortModule, MatSelectModule, fesm2015_checkbox/* MatCheckboxModule */.p9, expansion/* MatExpansionModule */.To, slide_toggle/* MatSlideToggleModule */.rP,
            MatSliderModule, MatAutocompleteModule, fesm2015_forms/* ReactiveFormsModule */.UX, MatProgressSpinnerModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && core/* ɵɵsetNgModuleScope */.kYT(AdminLayoutModule, { declarations: [ContactInfoComponent,
        RadioComponent,
        IconsComponent,
        ExposureComponent,
        RaceAnalysisComponent,
        UpcomingRaceAnalysisComponent,
        ExposedComponent,
        F1CountdownComponent, AmChartComponent, AmChartRaComponent,
        SocialComponent, StandingsComponent, SeasonsComponent, DatabaseComponent, DriversComponent, CircuitComponent, ConstructorsComponent,
        VideostreamsComponent, ImageFeedComponent, NgbdCarouselConfig, ArtCarousel, InfoDialog, SubmitContentDialog, ImagePopupDialog,
        DriversPopupComponent, RacePopupComponent, CircuitsPopupComponent, NewsSectionComponent, NewsComponent, AwsDemoComponent,
        ModeratorComponent, ConstructorsPopupComponent, DriversComparatorComponent, SingleColumnTableDialogComponent, SingleColumnTableWithEventDialogComponent, SimpleInputDialog,
        TifosiComponent, RadioPopupComponent, ExposureResultComponent], imports: [ng2_adsense/* AdsenseModule */.ih, common/* CommonModule */.ez, router/* RouterModule */.Bz, fesm2015_forms/* FormsModule */.u5,
        ng_bootstrap/* NgbModule */.IJ, GalleryModule,
        MatCardModule,
        button_toggle/* MatButtonToggleModule */.vV,
        MatGridListModule, divider/* MatDividerModule */.t, icon/* MatIconModule */.Ps, fesm2015_button/* MatButtonModule */.ot, fesm2015_radio/* MatRadioModule */.Fk,
        ng_apexcharts/* NgApexchartsModule */.X, ngx_countdown/* CountdownModule */.cD, tabs/* MatTabsModule */.Nh, table/* MatTableModule */.p0, sidenav/* MatSidenavModule */.SJ,
        MatFormFieldModule, MatInputModule, InfiniteScrollModule, MatCarouselModule, MatDialogModule, MatTooltipModule,
        MatSortModule, MatSelectModule, fesm2015_checkbox/* MatCheckboxModule */.p9, expansion/* MatExpansionModule */.To, slide_toggle/* MatSlideToggleModule */.rP,
        MatSliderModule, MatAutocompleteModule, fesm2015_forms/* ReactiveFormsModule */.UX, MatProgressSpinnerModule], exports: [NgbdCarouselConfig] }); })();


/***/ })

}]);